# Lit Documentation
Scraped from https://lit.dev/docs/



# What is Lit?
Source: https://lit.dev/docs/

Lit is a simple library for building fast, lightweight web components.

At Lit's core is a boilerplate-killing component base class that provides reactive state, scoped styles, and a declarative template system that's tiny, fast and expressive.


## What can I build with Lit?
You can build just about any kind of web UI with Lit!

The first thing to know about Lit is thatevery Lit component is a standardweb component. Web components have the superpower of interoperability: natively supported by browsers, web components can be used in any HTML environment, with any framework or none at all.

This makes Lit an ideal choice for developingshareable components or design systems. Lit components can be used across multiple apps and sites, even if those apps and sites are built on a variety of front-end stacks. Site developers using Lit components don’t need to write or even see any Lit code; they can just use the components the same way they do built-in HTML elements.

Lit is also perfect forprogressively enhancing basic HTML sites. Browsers will recognize Lit components in your markup and initialize them automatically–whether your site is handcrafted, managed via a CMS, built with a server-side framework, or generated by a tool like Jekyll or eleventy.

Of course, you can also buildhighly interactive, feature-rich appsout of Lit components, just as you would with a framework like React or Vue. Lit’s capabilities and developer experience are comparable to these popular alternatives, but Lit minimizes lock-in, maximizes flexibility and promotes maintainability by embracing the browser’s native component model.

When you build an app with Lit, it’s easy to sprinkle in “vanilla” web components, or web components built with other libraries. You can even update to a major new version of Lit–or migrate to another library–one component at a time, without disrupting product development.


## What is it like to develop with Lit?
If you’ve done any modern, component-based web development, you should feel right at home with Lit. Even if you haven’t developed with components before, we think you’ll find Lit to be very approachable.

Each Lit component is a self-contained unit of UI, assembled from smaller building blocks: standard HTML elements and other web components. In turn, each Lit component is itself a building block that can be used–within an HTML document, another web component, or a framework component–to build larger and more complex interfaces.

Here’s a small but non-trivial component (a countdown timer) that illustrates what Lit code looks like and highlights several key features:

Some things to note:

- Lit's main feature is theLitElementbase class, a convenient and versatile extension of the nativeHTMLElement. You extend from it to define your own components.
- Lit’sexpressive, declarative templates(utilizing JavaScript tagged template literals) make it easy to describe how a component should be rendered.
- Reactive propertiesrepresent a component’s public API and/or internal state; your component automatically re-renders whenever a reactive property changes.
- Stylesare scoped by default, keeping your CSS selectors simple and ensuring that your component’s styling won’t pollute (or be polluted by) the surrounding context.
- Lit works great in vanilla JavaScript, or you can use TypeScript for even better ergonomics by using decorators and type declarations.
Lit doesn’t require compilation or building during development, so it can be used virtually tool-free if you prefer. First-classIDE support(code-completion, linting, etc.) andtooling for production(localization, template minification, etc.) are readily available.


## Why should I choose Lit?
As we’ve already noted, Lit is a great choice for building all sorts of web UI, pairing the interop-based advantages of web components with a modern, ergonomic developer experience.

Lit is also:

- Simple.Building on top of the Web Components standards, Lit adds just what you need to be happy and productive: reactivity, declarative templates and a handful of thoughtful features to reduce boilerplate and make your job easier.
- Fast.Updates are fast, because Lit keeps track of your UI’s dynamic parts and updates only those when the underlying state changes–no need to rebuild a whole virtual tree and diff it with the current state of the DOM.
- Lightweight.Weighing in at around 5 KB (minified and compressed), Lit helps keep bundle sizes small and loading times short.
The team behind Lit has been involved with Web Components from day one. We help Google maintain tens of thousands of components, offer a comprehensive set of web components polyfills, and engage deeply in standards and community work.

Every Lit feature is carefully designed with web platform evolution in mind; we aim to help you take full advantage of what the platform provides today while writing code that is ready to benefit from future enhancements.


## Next steps
- Getting started: Get set up to start developing with Lit.
- Components: Learn about the Lit component model.
- Templates: Write templates with lit-html syntax.
- Code organization: Write reusable, maintainable code.
Edit this page


--------------------------------------------------------------------------------


# Decorators
Source: https://lit.dev/docs/components/decorators/

Decorators are functions that can be used to declaratively annotate and modify the behavior of classes.

Lit provides a set of optional decorators that enable declarative APIs for things like registering elements, defining reactive properties and query properties, or adding event options to event handler methods.

For example, the@customElementand@property()decorators let you register a custom element and define a reactive property in a compact, declarative way:

``` ts
@customElement('my-element')export class MyElement extends LitElement {  @property()  greeting = 'Welcome';}
```

Lit supports two different versions of the JavaScript decorators proposal – an early version supported by TypeScript that we refer to asexperimental decoratorsand a new and final version we refer to asstandard decorators.

There are some small differences in usage between the two proposals (standard decorators often require theaccessorkeyword). Our code samples are written for experimental decorators because we recommend them for production at the moment.

SeeDecorator versionsfor more details.


## Built-in decorators

## Importing decorators
You can import all of the Lit decorators via thelit/decorators.jsmodule:

``` js
import {customElement, property, eventOptions, query} from 'lit/decorators.js';
```

To reduce the amount of code needed to run the component, decorators can be imported individually into component code. All decorators are available atlit/decorators/<decorator-name>.js. For example,

``` js
import {customElement} from 'lit/decorators/custom-element.js';import {eventOptions} from 'lit/decorators/event-options.js';
```


## Enabling decorators
To use decorators, you need to build your code with a compiler such asTypeScriptorBabel.

In the future when decorators are supported natively in browsers, this will no longer be necessary


## Using decorators with TypeScript
TypeScript supports both experimental decorators and standard decorators. We recommend that TypeScript developers use experimental decorators for now foroptimal compiler output. If your project requires using standard decorators or setting"useDefineForClassFields": true, skip down tomigrating to standard decorators.

To use experimental decorators you must enable theexperimentalDecoratorscompiler option.

You should also ensure that theuseDefineForClassFieldssetting isfalse. This is only required whentargetis set toES2022or greater, but it is recommended to explicitly set this tofalse. This is needed toavoid issues with class fields when declaring properties.

``` json
// tsconfig.json{  "compilerOptions": {    "experimentalDecorators": true,    "useDefineForClassFields": false,  }}
```

EnablingemitDecoratorMetadatais not required and not recommended.

Lit decorators are designed to supportstandard decorator syntax(usingaccessoron class field decorators) with TypeScript's experimental decorator mode.

This allows incremental migration off of experimental decorators starting with the addition of theaccessorkeyword to decorated properties without a change of behavior. Once all decorated class field use theaccessorkeyword, you can change your compiler options to complete the migration to standard decorators:

``` json
// tsconfig.json{  "compilerOptions": {    "experimentalDecorators": false, // default for TypeScript 5.0 and up    "useDefineForClassFields": true, // default when "target" is "ES2022" or higher  }}
```

Note: Theaccessorkeyword was introduced in TypeScript 4.9 and standard decorators with metadata require TypeScript ≥5.2.


## Using decorators with Babel
Babelsupports standard decorators with the@babel/plugin-proposal-decoratorsplugin as of version 7.23. Babel does not support TypeScript experimental decorators, so you must use Lit decorators withstandard decorator syntaxusing theaccessorkeyword on decorated class fields.

Enable decorators by adding@babel/plugin-proposal-decoratorswith these Babel configuration settings:

``` json
// babel.config.json{  "plugins": [    ["@babel/plugin-proposal-decorators", {"version": "2023-05"}]  ]}
```

Note: Lit decorators only work with"version": "2023-05". Other versions, including the formerly supported"2018-09", are not supported.


## Decorator versions
Decorators are astage 3 proposalfor addition to the ECMAScript standard. Compilers likeBabelandTypeScriptsupport decorators, though no browsers have implemented them yet. Lit decorators work with Babel and TypeScript, and will work in browsers when they implement them natively.

What does stage 3 mean?

It means that the specification text is complete, and ready for browsers to implement. Once the specification has been implemented in multiple browsers, it can move to the final stage, stage 4, and be added to the ECMAScript standard. A stage 3 proposal will only change if critical issues are discovered during implementation.


## Earlier decorator proposals
Before the TC39 proposal reached stage 3, compilers implemented earlier versions of the decorator specification.

Most notable of these isTypeScript'sexperimental decoratorswhich Lit has supported since its inception and is our current recommendation for use.

Babel has also supported different versions of the specification over time as can be seen from the"version"option of the decorator plugin. In the past, Lit 2 has supported the"2018-09"version for Babel users but that has now been dropped in favor of thestandard"2023-05"version described below.


## Standard decorators
Standard decoratorsis the version of decorators that has reached Stage 3 consensus at TC39, the body that defines ECMAScript/JavaScript.

Standard decorators are supported in TypeScript and Babel, with native browser coming in the near future.

The biggest difference between standard decorators and experimental decorators is that, for performance reasons, standard decorators cannot change thekindof a class member – fields, accessors, and methods – being decorated and replaced, and will only produce the same kind of member.

Since many Lit decorators generate accessors, this means that the decorators need to be applied to accessors, not class fields.

To make this convenient, the standard decorator specification adds theaccessorkeyword to declare "auto-accessors":

``` ts
class MyClass {  accessor foo = 42;}
```

Auto-accessors create a getter and setter pair that read and write from a private field. Decorators can then wrap these getters and setters.

Lit decorators that work on class fields with experimental decorators – such as@property(),@state(),@query(), etc. – must be applied to accessors or auto-accessors with standard decorators:

``` ts
@customElement('my-element')export class MyElement extends LitElement {  @property()  accessor greeting = 'Welcome';}
```


## Compiler output considerations
Compiler output for standard decorators is unfortunately large due to the need to generate the accessors, private storage, and other objects that are part of the decorators API.

So we recommend that users who wish to use decorators, if possible, use TypeScript experimental decorators for now.

In the future the Lit team plans on adding decorator transforms to our optional Lit Compiler in order to compile standard decorators to a more compact compiler output. Native browser support will also eliminate the need for any compiler transforms at all.

Edit this page


--------------------------------------------------------------------------------


# Defining a component
Source: https://lit.dev/docs/components/defining/

Define a Lit component by creating a class extendingLitElementand registering your class with the browser:

``` ts
@customElement('simple-greeting')export class SimpleGreeting extends LitElement { /* ... */ }
```

The@customElementdecorator is shorthand for callingcustomElements.define, which registers a custom element class with the browser and associates it with an element name (in this case,simple-greeting).

If you're using JavaScript, or if you're not using decorators, you can calldefine()directly:

``` js
export class SimpleGreeting extends LitElement { /* ... */  }customElements.define('simple-greeting', SimpleGreeting);
```


## A Lit component is an HTML element
When you define a Lit component, you're defining acustom HTML element. So you can use the new element like you'd use any built-in element:

``` html
<simple-greeting name="Markup"></simple-greeting>
```

``` js
const greeting = document.createElement('simple-greeting');
```

TheLitElementbase class is a subclass ofHTMLElement, so a Lit component inherits all of the standardHTMLElementproperties and methods.

Specifically,LitElementinherits fromReactiveElement, which implements reactive properties, and in turn inherits fromHTMLElement.


## Providing good TypeScript typings
TypeScript will infer the class of an HTML element returned from certain DOM APIs based on the tag name. For example,document.createElement('img')returns anHTMLImageElementinstance with asrc: stringproperty.

Custom elements can get this same treatment by adding to theHTMLElementTagNameMapas follows:

``` ts
@customElement('my-element')export class MyElement extends LitElement {  @property({type: Number})  aNumber: number = 5;  /* ... */}declare global {  interface HTMLElementTagNameMap {    "my-element": MyElement;  }}
```

By doing this, the following code properly type-checks:

``` ts
const myElement = document.createElement('my-element');myElement.aNumber = 10;
```

We recommend adding anHTMLElementTagNameMapentry for all elements authored in TypeScript, and ensuring you publish your.d.tstypings in your npm package.

Edit this page


--------------------------------------------------------------------------------


# Events
Source: https://lit.dev/docs/components/events/

Events are the standard way that elements communicate changes. These changes typically occur due to user interaction. For example, a button dispatches a click event when a user clicks on it; an input dispatches a change event when the user enters a value in it.

In addition to these standard events that are automatically dispatched, Lit elements can dispatch custom events. For example, a menu element might dispatch an event to indicate the selected item changed; a popup element might dispatch an event when the popup opens or closes.

Any Javascript code, including Lit elements themselves, can listen for and take action based on events. For example, a toolbar element might filter a list when a menu item is selected; a login element might process a login when it handles a click on the login button.


## Listening to events
In addition to the standardaddEventListenerAPI, Lit introduces a declarative way to add event listeners.


## Adding event listeners in the element template
You can use@expressions in your template to add event listeners to elements in your component's template. Declarative event listeners are added when the template is rendered.

If you need to customize the event options used for a declarative event listener (likepassiveorcapture), you can specify these on the listener using the@eventOptionsdecorator. The object passed to@eventOptionsis passed as theoptionsparameter toaddEventListener.

``` js
import {LitElement, html} from 'lit';import {eventOptions} from 'lit/decorators.js';//...@eventOptions({passive: true})private _handleTouchStart(e) { console.log(e.type) }
```

Using decorators.Decorators are a proposed JavaScript feature, so you’ll need to use a compiler like Babel or TypeScript to use decorators. SeeEnabling decoratorsfor details.

If you're not using decorators, you can customize event listener options by passing an object to the event listener expression. The object must have ahandleEvent()method and can include any the options that would normally appear in theoptionsargument toaddEventListener().

``` js
render() {  return html`<button @click=${{handleEvent: () => this.onClick(), once: true}}>click</button>`}
```


## Adding event listeners to the component or its shadow root
To be notified of an event dispatched from the component's slotted children as well as children rendered into shadow DOM via the component template, you can add a listener to the component itself using the standardaddEventListenerDOM method. SeeEventTarget.addEventListener()on MDN for full details.

The component constructor is a good place to add event listeners on the component.

``` js
constructor() {  super();  this.addEventListener('click', (e) => console.log(e.type, e.target.localName));}
```

Adding event listeners to the component itself is a form of event delegation and can be done to reduce code or improve performance. Seeevent delegationfor details. Typically when this is done, the event'stargetproperty is used to take action based on which element fired the event.

However, events fired from the component's shadow DOM are retargeted when heard by an event listener on the component. This means the event target is the component itself. SeeWorking with events in shadow DOMfor more information.

Retargeting can interfere with event delegation, and to avoid it, event listeners can be added to the component's shadow root itself. Since theshadowRootis not available in theconstructor, event listeners can be added in thecreateRenderRootmethod as follows. Please note that it's important to make sure to return the shadow root from thecreateRenderRootmethod.


## Adding event listeners to other elements
If your component adds an event listener to anything except itself or its templated DOM – for example, toWindow,Document, or some element in the main DOM – you should add the listener inconnectedCallbackand remove it indisconnectedCallback.

- Removing the event listener indisconnectedCallbackensures that any memory allocated by your component will be cleaned up when your component is destroyed or disconnected from the page.
Removing the event listener indisconnectedCallbackensures that any memory allocated by your component will be cleaned up when your component is destroyed or disconnected from the page.

- Adding the event listener inconnectedCallback(instead of, for example, the constructor orfirstUpdated) ensures that your component will re-create its event listener if it is disconnected and subsequently reconnected to DOM.
Adding the event listener inconnectedCallback(instead of, for example, the constructor orfirstUpdated) ensures that your component will re-create its event listener if it is disconnected and subsequently reconnected to DOM.

``` js
connectedCallback() {  super.connectedCallback();  window.addEventListener('resize', this._handleResize);}disconnectedCallback() {  window.removeEventListener('resize', this._handleResize);  super.disconnectedCallback();}
```

See the MDN documentation on using custom elementslifecycle callbacksfor more information onconnectedCallbackanddisconnectedCallback.


## Optimizing for performance
Adding event listeners is extremely fast and typically not a performance concern. However, for components that are used in high frequency and need a lot of event listeners, you can optimize first render performance by reducing the number of listeners used viaevent delegationand adding listenersasynchronouslyafter rendering.

Using event delegation can reduce the number of event listeners used and therefore improve performance. It is also sometimes convenient to centralize event handling to reduce code. Event delegation can only be use to handle events thatbubble. SeeDispatching eventsfor details on bubbling.

Bubbling events can be heard on any ancestor element in the DOM. You can take advantage of this by adding a single event listener on an ancestor component to be notified of a bubbling event dispatched by any of its descendants in the DOM. Use the event'stargetproperty to take specific action based on the element that dispatched the event.

To add an event listener after rendering, use thefirstUpdatedmethod. This is a Lit lifecycle callback which runs after the component first updates and renders its templated DOM.

ThefirstUpdatedcallback fires after the first time your component has been updated and called itsrendermethod, butbeforethe browser has had a chance to paint.

SeefirstUpdatedin the Lifecycle documentation for more information.

To ensure the listener is added after the user can see the component, you can await a Promise that resolves after the browser paints.

``` js
async firstUpdated() {  // Give the browser a chance to paint  await new Promise((r) => setTimeout(r, 0));  this.addEventListener('click', this._handleClick);}
```


## Understandingthisin event listeners
Event listeners added using the declarative@syntax in the template are automaticallyboundto the component.

Therefore, you can usethisto refer to your component instance inside any declarative event handler:

``` js
class MyElement extends LitElement {  render() {    return html`<button @click="${this._handleClick}">click</button>`;  }  _handleClick(e) {    console.log(this.prop);  }}
```

When adding listeners imperatively withaddEventListener, you'll want to use an arrow function so thatthisrefers to the component:

``` ts
export class MyElement extends LitElement {  private _handleResize = () => {    // `this` refers to the component    console.log(this.isConnected);  }  constructor() {    window.addEventListener('resize', this._handleResize);  }}
```

See thedocumentation forthison MDNfor more information.


## Listening to events fired from repeated templates
When listening to events on repeated items, it's often convenient to useevent delegationif the event bubbles. When an event does not bubble, a listener can be added on the repeated elements. Here's an example of both methods:


## Removing event listeners
Passingnull,undefinedornothingto an@expression will cause any existing listener to be removed.


## Dispatching events
All DOM nodes can dispatch events using thedispatchEventmethod. First, create an event instance, specifying the event type and options. Then pass it todispatchEventas follows:

``` js
const event = new Event('my-event', {bubbles: true, composed: true});myElement.dispatchEvent(event);
```

Thebubblesoption allows the event to flow up the DOM tree to ancestors of the dispatching element. It's important to set this flag if you want the event to be able to participate inevent delegation.

Thecomposedoption is useful to set to allow the event to be dispatched above the shadow DOM tree in which the element exists.

SeeWorking with events in shadow DOMfor more information.

SeeEventTarget.dispatchEvent()on MDN for a full description of dispatching events.


## When to dispatch an event
Events should be dispatched in response to user interaction or asynchronous changes in the component's state. They should generallynotbe dispatched in response to state changes made by the owner of the component via its property or attribute APIs. This is generally how native web platform elements work.

For example, when a user types a value into aninputelement achangeevent is dispatched, but if code sets theinput'svalueproperty, achangeevent isnotdispatched.

Similarly, a menu component should dispatch an event when the user selects a menu item, but it should not dispatch an event if, for example, the menu'sselectedItemproperty is set.

This typically means that a component should dispatch an event in response to another event to which it is listening.


## Dispatching events after an element updates
Often, an event should be fired only after an element updates and renders. This might be necessary if an event is intended to communicate a change in rendered state based on user interaction. In this case, the component'supdateCompletePromise can be awaited after changing state, but before dispatching the event.


## Using standard or custom events
Events can be dispatched either by constructing anEventor aCustomEvent. Either is a reasonable approach. When using aCustomEvent, any event data is passed in the event'sdetailproperty. When using anEvent, an event subclass can be made and custom API attached to it.

SeeEventon MDN for details about constructing events.

``` js
const event = new CustomEvent('my-event', {  detail: {    message: 'Something important happened'  }});this.dispatchEvent(event);
```

See theMDN documentation on custom eventsfor more information.

``` js
class MyEvent extends Event {  constructor(message) {    super();    this.type = 'my-event';    this.message = message;  }}const event = new MyEvent('Something important happened');this.dispatchEvent(event);
```


## Working with events in shadow DOM
When using shadow DOM there are a few modifications to the standard event system that are important to understand. Shadow DOM exists primarily to provide a scoping mechanism in the DOM that encapsulates details about these "shadow" elements. As such, events in shadow DOM encapsulate certain details from outside DOM elements.


## Understanding composed event dispatching
By default, an event dispatched inside a shadow root will not be visible outside that shadow root. To make an event pass through shadow DOM boundaries, you must set thecomposedpropertytotrue. It's common to paircomposedwithbubblesso that all nodes in the DOM tree can see the event:

``` js
_dispatchMyEvent() {  let myEvent = new CustomEvent('my-event', {    detail: { message: 'my-event happened.' },    bubbles: true,    composed: true });  this.dispatchEvent(myEvent);}
```

If an event iscomposedand doesbubble, it can be received by all ancestors of the element that dispatches the event—including ancestors in outer shadow roots. If an event iscomposedbut does notbubble, it can only be received on the element that dispatches the event and on the host element containing the shadow root.

Note that most standard user interface events, including all mouse, touch, and keyboard events, are both bubbling and composed. See theMDN documentation on composed eventsfor more information.


## Understanding event retargeting
Composedevents dispatched from within a shadow root are retargeted, meaning that to any listener on an element hosting a shadow root or any of its ancestors, they appear to come from the hosting element. Since Lit components render into shadow roots, all composed events dispatched from inside a Lit component appear to be dispatched by the Lit component itself. The event'stargetproperty is the Lit component.

``` html
<my-element onClick="(e) => console.log(e.target)"></my-element>
```

``` js
render() {  return html`    <button id="mybutton" @click="${(e) => console.log(e.target)}">      click me    </button>`;}
```

In advanced cases where it is required to determine the origin of an event, use theevent.composedPath()API. This method returns an array of all the nodes traversed by the event dispatch, including those within shadow roots. Because this breaks encapsulation, care should be taken to avoid relying on implementation details that may be exposed. Common use cases include determining if the element clicked was an anchor tag, for purposes of client-side routing.

``` js
handleMyEvent(event) {  console.log('Origin: ', event.composedPath()[0]);}
```

See theMDN documentation on composedPathfor more information.


## Communicating between the event dispatcher and listener
Events exist primarily to communicate changes from the event dispatcher to the event listener, but events can also be used to communicate information from the listener back to the dispatcher.

One way you can do this is to expose API on events which listeners can use to customize component behavior. For example, a listener can set a property on a custom event's detail property which the dispatching component then uses to customize behavior.

Another way to communicate between the dispatcher and listener is via thepreventDefault()method. It can be called to indicate the event's standard action should not occur. When the listener callspreventDefault(), the event'sdefaultPreventedproperty becomes true. This flag can then be used by the listener to customize behavior.

Both of these techniques are used in the following example:

Edit this page


--------------------------------------------------------------------------------


# Lifecycle
Source: https://lit.dev/docs/components/lifecycle/

Lit components use the standard custom element lifecycle methods. In addition Lit introduces a reactive update cycle that renders changes to DOM when reactive properties change.


## Standard custom element lifecycle
Lit components are standard custom elements and inherit the custom element lifecycle methods. For information about the custom element lifecycle, seeUsing the lifecycle callbackson MDN.

If you need to customize any of the standard custom element lifecycle methods, make sure to call thesuperimplementation (such assuper.connectedCallback()) so the standard Lit functionality is maintained.


## constructor()
Called when an element is created. Also, it’s invoked when an existing element is upgraded, which happens when the definition for a custom element is loaded after the element is already in the DOM.

Requests an asynchronous update using therequestUpdate()method, so when a Lit component gets upgraded, it performs an update immediately.

Saves any properties already set on the element. This ensures values set before upgrade are maintained and correctly override defaults set by the component.

Perform one time initialization tasks that must be done before the firstupdate. For example, when not using decorators, default values for properties can be set in the constructor, as shown inDeclaring properties in a static properties field.

``` js
constructor() {  super();  this.foo = 'foo';  this.bar = 'bar';}
```


## connectedCallback()
Invoked when a component is added to the document's DOM.

Lit initiates the first element update cycle after the element is connected. In preparation for rendering, Lit also ensures therenderRoot(typically, itsshadowRoot) is created.

Once an element has connected to the document at least once, component updates will proceed regardless of the connection state of the element.

InconnectedCallback()you should setup tasks that should only occur when the element is connected to the document. The most common of these is adding event listeners to nodes external to the element, like a keydown event handler added to the window. Typically, anything done inconnectedCallback()should be undone when the element is disconnected — for example, removing event listeners on window to prevent memory leaks.

``` js
connectedCallback() {  super.connectedCallback()  window.addEventListener('keydown', this._handleKeydown);}
```


## disconnectedCallback()
Invoked when a component is removed from the document's DOM.

Pauses thereactive update cycle. It is resumed when the element is connected.

This callback is the main signal to the element that it may no longer be used; as such,disconnectedCallback()should ensure that nothing is holding a reference to the element (such as event listeners added to nodes external to the element), so that it is free to be garbage collected. Because elements may be re-connected after being disconnected, as in the case of an element moving in the DOM or caching, any such references or listeners may need to be re-established viaconnectedCallback()so that the element continues functioning as expected in these scenarios. For example, remove event listeners to nodes external to the element, like a keydown event handler added to the window.

``` js
disconnectedCallback() {  super.disconnectedCallback()  window.removeEventListener('keydown', this._handleKeydown);}
```

No need to remove internal event listeners.You don't need to remove event listeners added on the component's own DOM—including those added declaratively in your template. Unlike external event listeners, these won't prevent the component from being garbage collected.


## attributeChangedCallback()
Invoked when one of the element’sobservedAttributeschanges.

Lit uses this callback to sync changes in attributes to reactive properties. Specifically, when an attribute is set, the corresponding property is set. Lit also automatically sets up the element’sobservedAttributesarray to match the component’s list of reactive properties.

You rarely need to implement this callback.


## adoptedCallback()
Invoked when a component is moved to a new document.

Be aware thatadoptedCallbackis not polyfilled.

Lit has no default behavior for this callback.

This callback should only be used for advanced use cases when the element behavior should change when it changes documents.


## Reactive update cycle
In addition to the standard custom element lifecycle, Lit components also implement a reactive update cycle.

The reactive update cycle is triggered when a reactive property changes or when therequestUpdate()method is explicitly called. Lit performs updates asynchronously so property changes are batched — if more properties change after an update is requested, but before the update starts, all of the changes are captured in the same update.

Updates happen at microtask timing, which means they occur before the browser paints the next frame to the screen. SeeJake Archibald's articleon microtasks for more information about browser timing.

At a high level, the reactive update cycle is:

- An update is scheduled when one or more properties change or whenrequestUpdate()is called.
- The update is performed prior to the next frame being painted.Reflecting attributes are set.The component’s render method is called to update its internal DOM.
- Reflecting attributes are set.
- The component’s render method is called to update its internal DOM.
- The update is completed and theupdateCompletepromise is resolved.
In more detail, it looks like this:

Pre-Update

Update

Post-Update


## The changedProperties map
Many reactive update methods receive aMapof changed properties. TheMapkeys are the property names and its values are thepreviousproperty values. You can always find the current property values usingthis.propertyorthis[property].

If you're using TypeScript and you want strong type checking for thechangedPropertiesmap, you can usePropertyValues<this>, which infers the correct type for each property name.

``` ts
import {LitElement, html, PropertyValues} from 'lit';...  shouldUpdate(changedProperties: PropertyValues<this>) {    ...  }
```

If you're less concerned with strong typing—or you're only checking the property names, not the previous values—you could use a less restrictive type likeMap<string, any>.

Note thatPropertyValues<this>doesn't recognizeprotectedorprivateproperties. If you're checking anyprotectedorprivateproperties, you'll need to use a less restrictive type.

Changing a propertyduringthe update (up to and including therender()method) updates thechangedPropertiesmap, butdoesn'ttrigger a new update. Changing a propertyafterrender()(for example, in theupdated()method) triggers a new update cycle, and the changed property is added to a newchangedPropertiesmap to be used for the next cycle.


## Triggering an update
An update is triggered when a reactive property changes or therequestUpdate()method is called. Since updates are performed asynchronously, any and all changes that occur before the update is performed result in only asingle update.

Called when a reactive property is set. By defaulthasChanged()does a strict equality check and if it returnstrue, an update is scheduled. SeeconfiguringhasChanged()for more information.

CallrequestUpdate()to schedule an explicit update. This can be useful if you need the element to update and render when something not related to a property changes. For example, a timer component might callrequestUpdate()every second.

``` js
connectedCallback() {  super.connectedCallback();  this._timerInterval = setInterval(() => this.requestUpdate(), 1000);}disconnectedCallback() {  super.disconnectedCallback();  clearInterval(this._timerInterval);}
```

The list of properties that have changed is stored in achangedPropertiesmap that’s passed to subsequent lifecycle methods. The map keys are the property names and its values are the previous property values.

Optionally, you can pass a property name and a previous value when callingrequestUpdate(), which will be stored in thechangedPropertiesmap. This can be useful if you implement a custom getter and setter for a property. SeeReactive propertiesfor more information about implementing custom getters and setters.

``` js
  this.requestUpdate('state', this._previousState);
```


## Performing an update
When an update is performed, theperformUpdate()method is called. This method calls a number of other lifecycle methods.

Any changes that would normally trigger an update which occurwhilea component is updating donot schedule a new update. This is done so that property values can be computed during the update process. Properties changed during the updateare reflected in thechangedPropertiesmap, so subsequent lifecycle methods can act on the changes.

Called to determine whether an update cycle is required.

IfshouldUpdate()returnstrue, which it does by default, then the update proceeds normally. If it returnsfalse, the rest of the update cycle will not be called but theupdateCompletePromise is still resolved.

You can implementshouldUpdate()to specify which property changes should cause updates. Use the map ofchangedPropertiesto compare current and previous values.

``` ts
shouldUpdate(changedProperties: Map<string, any>) {  // Only update element if prop1 changed.  return changedProperties.has('prop1'); }
```

``` js
shouldUpdate(changedProperties) {  // Only update element if prop1 changed.  return changedProperties.has('prop1');}
```

Called beforeupdate()to compute values needed during the update.

ImplementwillUpdate()to compute property values that depend on other properties and are used in the rest of the update process.

``` ts
willUpdate(changedProperties: PropertyValues<this>) {  // only need to check changed properties for an expensive computation.  if (changedProperties.has('firstName') || changedProperties.has('lastName')) {    this.sha = computeSHA(`${this.firstName} ${this.lastName}`);  }}render() {  return html`SHA: ${this.sha}`;}
```

``` js
willUpdate(changedProperties) {  // only need to check changed properties for an expensive computation.  if (changedProperties.has('firstName') || changedProperties.has('lastName')) {    this.sha = computeSHA(`${this.firstName} ${this.lastName}`);  }}render() {  return html`SHA: ${this.sha}`;}
```

Called to update the component's DOM.

Reflects property values to attributes and callsrender()to update the component’s internal DOM.

Generally, you should not need to implement this method.

Called byupdate()and should be implemented to return a renderable result (such as aTemplateResult) used to render the component's DOM.

Therender()method has no arguments, but typically it references component properties. SeeRenderingfor more information.

``` js
render() {  const header = `<header>${this.header}</header>`;  const content = `<section>${this.content}</section>`;  return html`${header}${content}`;}
```


## Completing an update
Afterupdate()is called to render changes to the component's DOM, you can perform actions on the component's DOM using these methods.

Called after the component's DOM has been updated the first time, immediately beforeupdated()is called.

ImplementfirstUpdated()to perform one-time work after the component's DOM has been created. Some examples might include focusing a particular rendered element or adding aResizeObserverorIntersectionObserverto an element.

``` js
firstUpdated() {  this.renderRoot.getElementById('my-text-area').focus();}
```

Called whenever the component’s update finishes and the element's DOM has been updated and rendered.

Implementupdated()to perform tasks that use element DOM after an update. For example, code that performs animation may need to measure the element DOM.

``` ts
updated(changedProperties: Map<string, any>) {  if (changedProperties.has('collapsed')) {    this._measureDOM();  }}
```

``` js
updated(changedProperties) {  if (changedProperties.has('collapsed')) {    this._measureDOM();  }}
```

TheupdateCompletepromise resolves when the element has finished updating. UseupdateCompleteto wait for an update. The resolved value is a boolean indicating if the element has finished updating. It will betrueif there are no pending updates after the update cycle has finished.

When an element updates, it may cause its children to update as well. By default, theupdateCompletepromise resolves when the element's update has completed, but does not wait for any children to have completed their updates. This behavior may be customized by overridinggetUpdateComplete.

There are several use cases for needing to know when an element's update has completed:

- TestsWhen writing tests you can await theupdateCompletepromise before making assertions about a component’s DOM. If the assertions depend on updates completing for the component's entire descendant tree, awaitingrequestAnimationFrameis often a better choice, since Lit's default scheduling uses the browser's microtask queue, which is emptied prior to animation frames. This ensures all pending Lit updates on the page have completed before therequestAnimationFramecallback.
TestsWhen writing tests you can await theupdateCompletepromise before making assertions about a component’s DOM. If the assertions depend on updates completing for the component's entire descendant tree, awaitingrequestAnimationFrameis often a better choice, since Lit's default scheduling uses the browser's microtask queue, which is emptied prior to animation frames. This ensures all pending Lit updates on the page have completed before therequestAnimationFramecallback.

- MeasurementSome components may need to measure DOM in order to implement certain layouts. While it is always better to implement layouts using pure CSS rather than JavaScript-based measurement, sometimes CSS limitations make this unavoidable. In very simple cases, and if you're measuring Lit or ReactiveElement components, it may be sufficient to awaitupdateCompleteafter state changes and before measuring. However, becauseupdateCompletedoes not await the update of all descendants, we recommend usingResizeObserveras a more robust way to trigger measurement code when layouts change.
MeasurementSome components may need to measure DOM in order to implement certain layouts. While it is always better to implement layouts using pure CSS rather than JavaScript-based measurement, sometimes CSS limitations make this unavoidable. In very simple cases, and if you're measuring Lit or ReactiveElement components, it may be sufficient to awaitupdateCompleteafter state changes and before measuring. However, becauseupdateCompletedoes not await the update of all descendants, we recommend usingResizeObserveras a more robust way to trigger measurement code when layouts change.

- EventsIt is a good practice to dispatch events from components after rendering has completed, so that the event's listeners see the fully rendered state of the component. To do so, you can await theupdateCompletepromise before firing the event.async_loginClickHandler(){this.loggedIn=true;// Wait for `loggedIn` state to be rendered to the DOMawaitthis.updateComplete;this.dispatchEvent(newEvent('login'));}
EventsIt is a good practice to dispatch events from components after rendering has completed, so that the event's listeners see the fully rendered state of the component. To do so, you can await theupdateCompletepromise before firing the event.

``` js
async _loginClickHandler() {  this.loggedIn = true;  // Wait for `loggedIn` state to be rendered to the DOM  await this.updateComplete;  this.dispatchEvent(new Event('login'));}
```

TheupdateCompletepromise rejects if there's an unhandled error during the update cycle. For more information, seeHandling errors in the update cycle.


## Handling errors in the update cycle
If you have an uncaught exception in a lifecycle method likerender()orupdate(), it causes theupdateCompletepromise to reject. If you have code in a lifecycle method that can throw an exception, it's good practice to put it inside atry/catchstatement.

You may also want to use atry/catchif you're awaiting theupdateCompletepromise:

``` js
try {  await this.updateComplete;} catch (e) {  /* handle error */}
```

In some cases, code may throw in unexpected places. As a fallback, you can add a handler forwindow.onunhandledrejectionto catch these issues. For example, you could use this report errors back to a backend service to help diagnose issues that are hard to reproduce.

``` js
window.onunhandledrejection = function(e) {  /* handle error */}
```


## Implementing additional customization
This section covers some less-common methods for customizing the update cycle.

OverridescheduleUpdate()to customize the timing of the update.scheduleUpdate()is called when an update is about to be performed, and by default it callsperformUpdate()immediately. Override it to defer the update—this technique can be used to unblock the main rendering/event thread.

For example, the following code schedules the update to occur after the next frame paints, which can reduce jank if the update is expensive:

``` ts
protected override async scheduleUpdate(): Promise<void> {  await new Promise((resolve) => setTimeout(resolve));  super.scheduleUpdate();}
```

``` js
async scheduleUpdate() {  await new Promise((resolve) => setTimeout(resolve));  super.scheduleUpdate();}
```

If you overridescheduleUpdate(), it's your responsibility to callsuper.scheduleUpdate()to perform the pending update.

Async function optional.

This example shows anasync functionwhichimplicitlyreturns a promise. You can also writescheduleUpdate()as a function thatexplictlyreturns aPromise. In either case, thenextupdate doesn't start until the promise returned byscheduleUpdate()resolves.

Implements the reactive update cycle, calling the other methods, likeshouldUpdate(),update(), andupdated().

CallperformUpdate()to immediately process a pending update. This should generally not be needed, but it can be done in rare cases when you need to update synchronously. (If there is no update pending, you can callrequestUpdate()followed byperformUpdate()to force a synchronous update.)

UsescheduleUpdate()to customize scheduling.

If you want to customize how updates are scheduled, overridescheduleUpdate(). Previously, we recommended overridingperformUpdate()for this purpose. That continues to work, but it makes it more difficult to callperformUpdate()to process a pending update synchronously.

ThehasUpdatedproperty returns true if the component has updated at least once. You can usehasUpdatedin any of the lifecycle methods to perform work only if the component has not yet updated.

To await additional conditions before fulfilling theupdateCompletepromise, override thegetUpdateComplete()method. For example, it may be useful to await the update of a child element. First awaitsuper.getUpdateComplete(), then any subsequent state.

It's recommended to override thegetUpdateComplete()method instead of theupdateCompletegetter to ensure compatibility with users who are using TypeScript's ES5 output (seeTypeScript#338).

``` js
class MyElement extends LitElement {  async getUpdateComplete() {    const result = await super.getUpdateComplete();    await this._myChild.updateComplete;    return result;  }}
```


## External lifecycle hooks: controllers and decorators
In addition to component classes implementing lifecycle callbacks, external code, such asdecoratorsmay need to hook into a component's lifecycle.

Lit offers two concepts for external code to integrate with the reactive update lifecycle:static addInitializer()andaddController():

addInitializer()allows code that has access to a Lit class definition to run code when instances of the class are constructed.

This is very useful when writing custom decorators. Decorators are run at class definition time, and can do things like replace field and method definitions. If they also need to do work when an instance is created, they must calladdInitializer(). It will be common to use this to add areactive controllerso decorators can hook into the component lifecycle:

``` ts
// A TypeScript decoratorconst myDecorator = (proto: ReactiveElement, key: string) => {  const ctor = proto.constructor as typeof ReactiveElement;  ctor.addInitializer((instance: ReactiveElement) => {    // This is run during construction of the element    new MyController(instance);  });};
```

``` js
// A Babel "Stage 2" decoratorconst myDecorator = (descriptor) => {  ...descriptor,  finisher(ctor) {    ctor.addInitializer((instance) => {      // This is run during construction of the element      new MyController(instance);    });  },};
```

Decorating a field will then cause each instance to run an initializer that adds a controller:

``` ts
class MyElement extends LitElement {  @myDecorator foo;}
```

Initializers are stored per-constructor. Adding an initializer to a subclass does not add it to a superclass. Since initializers are run in constructors, initializers will run in order of the class hierarchy, starting with superclasses and progressing to the instance's class.

addController()adds a reactive controller to a Lit component so that the component invokes the controller's lifecycle callbacks. See theReactive Controllerdocs for more information.

removeController()removes a reactive controller so it no longer receives lifecycle callbacks from this component.


## Server-side reactive update cycle
Lit'sserver-side rendering packageis currently under active development so the following information is subject to change.

Not all of the update cycle is called when rendering Lit on the server. The following methods are called on the server.

Edit this page


--------------------------------------------------------------------------------


# Components overview
Source: https://lit.dev/docs/components/overview/

A Lit component is a reusable piece of UI. You can think of a Lit component as a container that has some state and that displays a UI based on its state. It can also react to user input, fire events—anything you'd expect a UI component to do. And a Lit component is an HTML element, so it has all of the standard element APIs.

Creating a Lit component involves a number of concepts:

- Defining a component. A Lit component is implemented as acustom element, registered with the browser.
Defining a component. A Lit component is implemented as acustom element, registered with the browser.

- Rendering. A component hasrender methodthat's called to render the component's contents. In the render method, you define atemplatefor the component.
Rendering. A component hasrender methodthat's called to render the component's contents. In the render method, you define atemplatefor the component.

- Reactive properties. Properties hold the state of the component. Changing one or more of the components'reactive propertiestriggers an update cycle, re-rendering the component.
Reactive properties. Properties hold the state of the component. Changing one or more of the components'reactive propertiestriggers an update cycle, re-rendering the component.

- Styles. A component can defineencapsulated stylesto control its own appearance.
Styles. A component can defineencapsulated stylesto control its own appearance.

- Lifecycle. Lit defines a set of callbacks that you can override to hook into the component's lifecycle—for example, to run code when the element's added to a page, or whenever the component updates.
Lifecycle. Lit defines a set of callbacks that you can override to hook into the component's lifecycle—for example, to run code when the element's added to a page, or whenever the component updates.

Here's a sample component:

This example uses TypeScript decorators.

See theDecoratorsdocumentation for more information on configuring TypeScript for decorators.

Edit this page


--------------------------------------------------------------------------------


# Reactive properties
Source: https://lit.dev/docs/components/properties/

Lit components receive input and store their state as JavaScript class fields or properties.Reactive propertiesare properties that can trigger the reactive update cycle when changed, re-rendering the component, and optionally be read or written to attributes.

``` ts
class MyElement extends LitElement {  @property()  name?: string;}
```

``` js
class MyElement extends LitElement {  static properties = {    name: {},  };}
```

Lit manages your reactive properties and their corresponding attributes. In particular:

- Reactive updates. Lit generates a getter/setter pair for each reactive property. When a reactive property changes, the component schedules an update.
- Attribute handling. By default, Lit sets up an observed attribute corresponding to the property, and updates the property when the attribute changes. Property values can also, optionally, bereflectedback to the attribute.
- Superclass properties. Lit automatically applies property options declared by a superclass. You don't need to redeclare properties unless you want to change options.
- Element upgrade. If a Lit component is defined after the element is already in the DOM, Lit handles upgrade logic, ensuring that any properties set on an element before it was upgraded trigger the correct reactive side effects when the element upgrades.

## Public properties and internal state
Public properties are part of the component's public API. In general, public properties—especially public reactive properties—should be treated asinput.

The component shouldn't change its own public properties, except in response to user input. For example, a menu component might have a publicselectedproperty that can be initialized to a given value by the owner of the element, but that is updated by the component itself when the user selects an item. In these instances, the component should dispatch an event to indicate to the component's owner that theselectedproperty changed. SeeDispatching eventsfor more details.

Lit also supportsinternal reactive state. Internal reactive state refers to reactive properties thataren'tpart of the component's API. These properties don't have a corresponding attribute, and are typically marked protected or private in TypeScript.

``` ts
@state()private _counter = 0;
```

``` js
static properties = {  _counter: {state: true}};constructor() {  super();  this._counter = 0;}
```

The component manipulates its own internal reactive state. In some cases, internal reactive state may be initialized from public properties—for example, if there is an expensive transformation between the user-visible property and the internal state.

As with public reactive properties, updating internal reactive state triggers an update cycle. For more information, seeInternal reactive state.


## Public reactive properties
Declare your element's public reactive properties using decorators or the staticpropertiesfield.

In either case, you can pass an options object to configure features for the property.


## Declaring properties with decorators
Use the@propertydecorator with a class field declaration to declare a reactive property.

``` ts
class MyElement extends LitElement {  @property({type: String})  mode?: string;  @property({attribute: false})  data = {};}
```

The argument to the@propertydecorators is anoptions object. Omitting the argument is equivalent to specifying the default value for all options.

Using decorators.Decorators are a proposed JavaScript feature, so you'll need to use a compiler like Babel or the TypeScript compiler to use decorators. SeeEnabling decoratorsfor details.


## Declaring properties in a static properties class field
To declare properties in a staticpropertiesclass field:

``` js
class MyElement extends LitElement {  static properties = {    mode: {type: String},    data: {attribute: false},  };  constructor() {    super();    this.data = {};  }}
```

An empty option object is equivalent to specifying the default value for all options.


## Avoiding issues with class fields when declaring properties
Class fieldshave a problematic interaction with reactive properties. Class fields are defined on the element instance whereas reactive properties are defined as accessors on the element prototype. According to the rules of JavaScript, an instance property takes precedence over and effectively hides a prototype property. This means that reactive property accessors do not function when class fields are used such that setting the property won't trigger an element update.

``` js
class MyElement extends LitElement {  static properties = {foo: {type: String}}  foo = 'Default'; // ❌ this will make `foo` not reactive}
```

InJavaScript, youmust not use class fieldswhen declaring reactive properties. Instead, properties must be initialized in the element constructor:

``` js
class MyElement extends LitElement {  static properties = {    foo: {type: String}  }  constructor() {    super();    this.foo = 'Default';  }}
```

Alternatively, you may usestandard decorators with Babelto declare reactive properties.

``` ts
class MyElement extends LitElement {  @property()  accessor foo = 'Default';}
```

ForTypeScript, youmay use class fieldsfor declaring reactive properties as long as you use one of these patterns:

- Set theuseDefineForClassFieldscompiler option tofalse. This is already the recommendation whenusing decorators with TypeScript.
``` json
// tsconfig.json{  "compilerOptions": {    "experimentalDecorators": true, // If using decorators    "useDefineForClassFields": false,  }}
```

``` ts
class MyElement extends LitElement {  static properties = {foo: {type: String}}  foo = 'Default';  @property()  bar = 'Default';}
```

- Add thedeclarekeyword on the field, and put the field's initializer in the constructor.
``` ts
class MyElement extends LitElement {  declare foo: string;  static properties = {foo: {type: String}}  constructor() {    super();    this.foo = 'Default';  }}
```

- Add theaccessorkeyword on the field to useauto-accessors.
``` ts
class MyElement extends LitElement {  static properties = {foo: {type: String}}  accessor foo = 'Default';  @property()  accessor bar = 'Default';}
```


## Property options
The options object can have the following properties:

attribute

Whether the property is associated with an attribute, or a custom name for the associated attribute. Default: true. Ifattributeis false, theconverter,reflectandtypeoptions are ignored. For more information, seeSetting the attribute name.

converter

Acustom converterfor converting between properties and attributes. If unspecified, use thedefault attribute converter.

hasChanged

A function called whenever the property is set to determine if the property has changed, and should trigger an update. If unspecified, LitElement uses a strict inequality check (newValue !== oldValue) to determine whether the property value has changed. For more information, seeCustomizing change detection.

noAccessor

Set to true to avoid generating the default property accessors. This option is rarely necessary. Default: false. For more information, seePreventing Lit from generating a property accessor.

reflect

Whether property value is reflected back to the associated attribute. Default: false. For more information, seeEnabling attribute reflection.

state

Set to true to declare the property asinternal reactive state. Internal reactive state triggers updates like public reactive properties, but Lit doesn't generate an attribute for it, and users shouldn't access it from outside the component. Equivalent to using the@statedecorator. Default: false. For more information, seeInternal reactive state.

type

When converting a string-valued attribute into a property, Lit's default attribute converter will parse the string into the type given, and vice-versa when reflecting a property to an attribute. Ifconverteris set, this field is passed to the converter. Iftypeis unspecified, the default converter treats it astype: String. SeeUsing the default converter.

When using TypeScript, this field should generally match the TypeScript type declared for the field. However, thetypeoption is used by the Lit'sruntimefor string serialization/deserialization, and should not be confused with atype-checkingmechanism.

useDefault

Set to true to prevent initial attribute reflection for the default value whenreflectis set to true, and to reset the property to its default value when its corresponding attribute is removed.

The default value is the property's initial value set in the constructor or with anauto-accessor. This value is retained in memory so it's a good practice to avoid settinguseDefault: truefor non-primitive Object/Array properties. For more information, seeEnabling attribute reflectionandBest practices when reflecting attributes.

Omitting the options object or specifying an empty options object is equivalent to specifying the default value for all options.


## Internal reactive state
Internal reactive staterefers to reactive properties that are not part of the component's public API. These state properties don't have corresponding attributes, and aren't intended to be used from outside the component. Internal reactive state should be set by the component itself.

Use the@statedecorator to declare internal reactive state:

``` ts
@state()protected _active = false;
```

Using the staticpropertiesclass field, you can declare internal reactive state by using thestate: trueoption.

``` js
static properties = {  _active: {state: true}};constructor() {  this._active = false;}
```

Internal reactive state shouldn't be referenced from outside the component. In TypeScript, these properties should be marked as private or protected. We also recommend using a convention like a leading underscore (_) to identify private or protected properties for JavaScript users.

Internal reactive state works just like public reactive properties, except that there is no attribute associated with the property.The only option you can specify for internal reactive state is thehasChangedfunction.

The@statedecorator can also serve as a hint to a code minifier that the property name can be changed during minification.


## What happens when properties change
A property change can trigger a reactive update cycle, which causes the component to re-render its template.

When a property changes, the following sequence occurs:

- The property's setter is called.
- The setter calls the component'srequestUpdatemethod.
- The property's old and new values are compared.By default Lit uses a strict inequality test to determine if the value has changed (that isnewValue !== oldValue).If the property has ahasChangedfunction, it's called with the property's old and new values.
- By default Lit uses a strict inequality test to determine if the value has changed (that isnewValue !== oldValue).
- If the property has ahasChangedfunction, it's called with the property's old and new values.
- If the property change is detected, an update is scheduled asynchronously. If an update is already scheduled, only a single update is executed.
- The component'supdatemethod is called, reflecting changed properties to attributes and re-rendering the component's templates.
Note that if you mutate an object or array property, it won't trigger an update, because the object itself hasn't changed. For more information, seeMutating object and array properties.

There are many ways to hook into and modify the reactive update cycle. For more information, seeReactive update cycle.

For more information about property change detection, seeCustomizing change detection.


## Mutating object and array properties
Mutating an object or array doesn't change the object reference, so it won't trigger an update. You can handle object and array properties in one of two ways:

- Immutable data pattern.Treat objects and arrays as immutable. For example, to remove an item frommyArray, construct a new array:this.myArray=this.myArray.filter((_,i)=>i!==indexToRemove);While this example is simple, it's often helpful to use a library likeImmerto manage immutable data. This can help avoid tricky boilerplate code when setting deeply nested objects.
Immutable data pattern.Treat objects and arrays as immutable. For example, to remove an item frommyArray, construct a new array:

``` js
this.myArray = this.myArray.filter((_, i) => i !== indexToRemove);
```

While this example is simple, it's often helpful to use a library likeImmerto manage immutable data. This can help avoid tricky boilerplate code when setting deeply nested objects.

- Manually triggering an update.Mutate the data and callrequestUpdate()to trigger an update directly. For example:this.myArray.splice(indexToRemove,1);this.requestUpdate();When called with no arguments,requestUpdate()schedules an update, without calling ahasChanged()function. But note thatrequestUpdate()only causes thecurrentcomponent to update. That is, if a component uses the code shown above,andthe component passesthis.myArrayto a subcomponent, the subcomponent will detect that the array reference hasn't changed, so it won't update.
Manually triggering an update.Mutate the data and callrequestUpdate()to trigger an update directly. For example:

``` js
this.myArray.splice(indexToRemove, 1);this.requestUpdate();
```

When called with no arguments,requestUpdate()schedules an update, without calling ahasChanged()function. But note thatrequestUpdate()only causes thecurrentcomponent to update. That is, if a component uses the code shown above,andthe component passesthis.myArrayto a subcomponent, the subcomponent will detect that the array reference hasn't changed, so it won't update.

In general, using top-down data flow with immutable objects is best for most applications.It ensures that every component that needs to render a new value does (and does so as efficiently as possible, since parts of the data tree that didn't change won't cause components that rely on them to update).

Mutating data directly and callingrequestUpdate()should be considered an advanced use case. In this case, you (or some other system) need to identify all the components that use the mutated data and callrequestUpdate()on each one. When those components are spread across an application, this gets hard to manage. Not doing so robustly means that you might modify an object that's rendered in two parts of your application, but only have one part update.

In simple cases, when you know that a given piece of data is only used in a single component, it should be safe to mutate the data and callrequestUpdate(), if you prefer.


## Attributes
While properties are great for receiving JavaScript data as input, attributes are the standard way HTML allows configuring elements frommarkup, without needing to use JavaScript to set properties. Providing both a propertyandattribute interface for their reactive properties is a key way Lit components can be useful in a wide variety of environments, including those rendered without a client-side templating engine, such as static HTML pages served from CMSs.

By default, Lit sets up an observed attribute corresponding to each public reactive property, and updates the property when the attribute changes. Property values can also, optionally, bereflected(written back to the attribute).

While element properties can be of any type, attributes are always strings. This impacts theobserved attributesandreflected attributesof non-string properties:

- Toobservean attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type.
Toobservean attribute (set a property from an attribute), the attribute value must be converted from a string to match the property type.

- Toreflectan attribute (set an attribute from a property), the property value must be converted to a string.
Toreflectan attribute (set an attribute from a property), the property value must be converted to a string.

Boolean properties that expose an attribute should default to false. For more information, seeBoolean attributes.


## Setting the attribute name
By default, Lit creates a corresponding observed attribute for all public reactive properties. The name of the observed attribute is the property name, lowercased:

``` ts
// observed attribute name is "myvalue"@property({ type: Number })myValue = 0;
```

``` js
// observed attribute name is "myvalue"static properties = {  myValue: { type: Number },};constructor() {  super();  this.myValue = 0;}
```

To create an observed attribute with a different name, setattributeto a string:

``` ts
// Observed attribute will be called my-name@property({ attribute: 'my-name' })myName = 'Ogden';
```

``` js
// Observed attribute will be called my-namestatic properties = {  myName: { attribute: 'my-name' },};constructor() {  super();  this.myName = 'Ogden'}
```

To prevent an observed attribute from being created for a property, setattributetofalse. The property will not be initialized from attributes in markup, and attribute changes won't affect it.

``` ts
// No observed attribute for this property@property({ attribute: false })myData = {};
```

``` js
// No observed attribute for this propertystatic properties = {  myData: { attribute: false },};constructor() {  super();  this.myData = {};}
```

Internal reactive state never has an associated attribute.

An observed attribute can be used to provide an initial value for a property from markup. For example:

``` html
<my-element myvalue="99"></my-element>
```


## Using the default converter
Lit has a default converter that handlesString,Number,Boolean,Array, andObjectproperty types.

To use the default converter, specify thetypeoption in your property declaration:

``` ts
// Use the default converter@property({ type: Number })count = 0;
```

``` js
// Use the default converterstatic properties = {  count: { type: Number },};constructor() {  super();  this.count = 0;}
```

If you don't specify a typeora custom converter for a property, it behaves as if you'd specifiedtype: String.

The tables below shows how the default converter handles conversion for each type.

From attribute to property

For any case exceptBoolean, if the element doesn't have the corresponding attribute, the property keeps its default value, orundefinedif no default is set.

From property to attribute


## Providing a custom converter
You can specify a custom property converter in your property declaration with theconverteroption:

``` js
myProp: {  converter: // Custom property converter}
```

convertercan be an object or a function. If it is an object, it can have keys forfromAttributeandtoAttribute:

``` js
prop1: {  converter: {    fromAttribute: (value, type) => {      // `value` is a string      // Convert it to a value of type `type` and return it    },    toAttribute: (value, type) => {      // `value` is of type `type`      // Convert it to a string and return it    }  }}
```

Ifconverteris a function, it is used in place offromAttribute:

``` js
myProp: {  converter: (value, type) => {    // `value` is a string    // Convert it to a value of type `type` and return it  }}
```

If notoAttributefunction is supplied for a reflected attribute, the attribute is set to the property value using the default converter.

IftoAttributereturnsnullorundefined, the attribute is removed.


## Boolean attributes
For a boolean property to be configurable from an attribute,it must default to false. If it defaults to true, you cannot set it to false from markup, since the presence of the attribute, with or without a value, equates to true. This is the standard behavior for attributes in the web platform.

If this behavior doesn't fit your use case, there are a couple of options:

- Change the property name so it defaults to false. For example, the web platform uses thedisabledattribute (defaults to false), notenabled.
Change the property name so it defaults to false. For example, the web platform uses thedisabledattribute (defaults to false), notenabled.

- Use a string-valued or number-valued attribute instead.
Use a string-valued or number-valued attribute instead.


## Enabling attribute reflection
Settingreflectto true configures a property so that whenever it changes, its value is reflected to itscorresponding attribute. Reflected attributes are useful for serializing element state and because they are visible to CSS and DOM APIs likequerySelector.

SettinguseDefaultto true prevents the property's default value from initially reflecting to itscorresponding attribute. All subsequent changes are reflected; and if the attribute is removed, the property is reset to its default value.

This matches web platform behavior for attributes likeid. The default value of an element'sidproperty is''(an empty string) and initially it does not have anidattribute, but if theidproperty is set (even to an empty string), the appropirateidattribute is reflected. If theidattribute is removed, the element'sidproperty is set back to its initial value of''.

For example:

``` js
// Value of property "active" will reflect to attribute "active"active: {reflect: true}// Value of property "variant" will reflect except that the "variant"// attribute will not be iniitally set to the property's default value.variant: {reflect: true, useDefault: true}
```

When the property changes, Lit sets the corresponding attribute value as described inUsing the default converterorProviding a custom converter.

Lit tracks reflection state during updates.You may have realized that if property changes are reflected to an attribute and attribute changes update the property, it has the potential to create an infinite loop. However, Lit tracks when properties and attributes are set specifically to prevent this from happening


## Best practices when reflecting attributes
To ensure elements behave as expected and perform well, try to follow these best practices when reflecting attributes:

- Attributes should generally be considered input to the element from its owner, rather than under control of the element itself, so reflecting properties to attributes should be done sparingly. Consider instead using the:statepseudo selectorand theAccessibility Object Modelwhere possible.
Attributes should generally be considered input to the element from its owner, rather than under control of the element itself, so reflecting properties to attributes should be done sparingly. Consider instead using the:statepseudo selectorand theAccessibility Object Modelwhere possible.

- Reflecting properties should typically also setuseDefault: truesince this keeps the element from spontaneously spawning attributes that the user didn't set, and helps match expected platform behavior.
Reflecting properties should typically also setuseDefault: truesince this keeps the element from spontaneously spawning attributes that the user didn't set, and helps match expected platform behavior.

- Reflecting properties of type object or array is not recommended. This can cause large objects to serialize to the DOM which can result in poor performance and consume excess memory whenuseDefaultis used.
Reflecting properties of type object or array is not recommended. This can cause large objects to serialize to the DOM which can result in poor performance and consume excess memory whenuseDefaultis used.

- The property decorator does not alter any values assigned to the reactive property, which is considered a best practice for custom accessors. Sometimes native elements restrict properties to certain valid values, for instance, and if an invalid value is assigned to a property, the property will be set to a default instead.useDefault: truedoes not do this - it only restores the default when the attribute is removed. If you'd like to alter the property value on property assignments, define and decorate a custom property setter.
The property decorator does not alter any values assigned to the reactive property, which is considered a best practice for custom accessors. Sometimes native elements restrict properties to certain valid values, for instance, and if an invalid value is assigned to a property, the property will be set to a default instead.useDefault: truedoes not do this - it only restores the default when the attribute is removed. If you'd like to alter the property value on property assignments, define and decorate a custom property setter.


## Custom property accessors
By default, LitElement generates a getter/setter pair for all reactive properties. The setter is invoked whenever you set the property:

``` ts
// Declare a property@property()greeting: string = 'Hello';...// Later, set the propertythis.greeting = 'Hola'; // invokes greeting's generated property accessor
```

``` js
// Declare a propertystatic properties = {  greeting: {},}constructor() {  this.super();  this.greeting = 'Hello';}...// Later, set the propertythis.greeting = 'Hola'; // invokes greeting's generated property accessor
```

Generated accessors automatically callrequestUpdate(), initiating an update if one has not already begun.


## Creating custom property accessors
To specify how getting and setting works for a property, you can define your own getter/setter pair. For example:

``` ts
private _prop = 0;@property()set prop(val: number) {  this._prop = Math.floor(val);}get prop() { return this._prop; }
```

``` js
static properties = {  prop: {},};_prop = 0;set prop(val) {  this._prop = Math.floor(val);}get prop() { return this._prop; }
```

To use custom property accessors with the@propertyor@statedecorators, put the decorator on the setter, as shown above.@propertyor@statedecorated setters callrequestUpdate().

In most cases,you do not need to create custom property accessors.To compute values from existing properties, we recommend using thewillUpdatecallback, which allows you to set values during the update cycle without triggering an additional update. To perform a custom action after the element updates, we recommend using theupdatedcallback. A custom setter can be used in rare cases when it's important to synchronously validate any value the user sets.

If your class defines its own accessors for a property, Lit will not overwrite them with generated accessors. If your class does not define accessors for a property, Lit will generate them, even if a superclass has defined the property or accessors.


## Prevent Lit from generating a property accessor
In rare cases, a subclass may need to change or add property options for a property that exists on its superclass.

To prevent Lit from generating a property accessor that overwrites the superclass's defined accessor, setnoAccessortotruein the property declaration:

``` js
static properties = {  myProp: { type: Number, noAccessor: true }};
```

You don't need to setnoAccessorwhen defining your own accessors.


## Customizing change detection
All reactive properties have a function,hasChanged(), which is called when the property is set.

hasChangedcompares the property's old and new values, and evaluates whether or not the property has changed. IfhasChanged()returns true, Lit starts an element update if one is not already scheduled. For more information on updates, seeReactive update cycle.

The default implementation ofhasChanged()uses a strict inequality comparison:hasChanged()returnstrueifnewVal !== oldVal.

To customizehasChanged()for a property, specify it as a property option:

``` ts
@property({  hasChanged(newVal: string, oldVal: string) {    return newVal?.toLowerCase() !== oldVal?.toLowerCase();  }})myProp: string | undefined;
```

``` js
static properties = {  myProp: {    hasChanged(newVal, oldVal) {      return newVal?.toLowerCase() !== oldVal?.toLowerCase();    }  }};
```

In the following example,hasChanged()only returns true for odd values.

Edit this page


--------------------------------------------------------------------------------


# Rendering
Source: https://lit.dev/docs/components/rendering/

Add a template to your component to define what it should render. Templates can includeexpressions, which are placeholders for dynamic content.

To define a template for a Lit component, add arender()method:

Write your template in HTML inside a JavaScripttagged template literalusing Lit'shtmltag function.

Lit templates can include JavaScriptexpressions. You can use expressions to set text content, attributes, properties, and event listeners. Therender()method can also include any JavaScript—for example, you can create local variables for use in expressions.


## Renderable values
Typically, the component'srender()method returns a singleTemplateResultobject (the same type returned by thehtmltag function). However, it can return anything that Lit can render as the child of an HTML element:

- Primitive values like string, number, or boolean.
- TemplateResultobjects created by thehtmlfunction.
- DOM Nodes.
- The sentinel valuesnothingandnoChange.
- Arrays or iterables of any of the supported types.
This isalmost identicalto the set of values that can be rendered to a Litchild expression. The one difference is that a child expression can render anSVGTemplateResult, returned by thesvgfunction. This kind of template result can only be rendered as the descendant of an<svg>element.


## Writing a good render() method
To take best advantage of Lit's functional rendering model, yourrender()method should follow these guidelines:

- Avoid changing the component's state.
- Avoid producing any side effects.
- Use only the component's properties as input.
- Return the same result when given the same property values.
Following these guidelines keeps the template deterministic, and makes it easier to reason about the code.

In most cases you should avoid making DOM updates outside ofrender(). Instead, express the component's template as a function of its state, and capture its state in properties.

For example, if your component needs to update its UI when it receives an event, have the event listener set a reactive property that is used inrender(), rather than manipulate the DOM directly.

For more information, seeReactive properties.


## Composing templates
You can compose Lit templates from other templates. The following example composes a template for a component called<my-page>from smaller templates for the page's header, footer, and main content:

In this example, the individual templates are defined as instance methods, so a subclass could extend this component and override one or more templates.


## TO DO
Move example to composition section, add xref.

You can also compose templates by importing other elements and using them in your template:


## When templates render
A Lit component renders its template initially when it's added to the DOM on a page. After the initial render, any change to the component's reactive properties triggers an update cycle, re-rendering the component.

Lit batches updates to maximize performance and efficiency. Setting multiple properties at once triggers only one update, performed asynchronously at microtask timing.

During an update, only the parts of the DOM that change are re-rendered. Although Lit templates look like string interpolation, Lit parses and creates static HTML once, and then only updates changed values in expressions after that, making updates very efficient.

For more information about the update cycle, seeWhat happens when properties change.


## DOM encapsulation
Lit uses shadow DOM to encapsulate the DOM a component renders. Shadow DOM lets an element create its own, isolated DOM tree that's separate from the main document tree. It's a core feature of the web components specifications that enables interoperability, style encapsulation, and other benefits.

For more information about shadow DOM, seeShadow DOM v1: Self-Contained Web Componentson Web Fundamentals.

For more information about working with shadow DOM in your component, seeWorking with shadow DOM.


## See also
- Shadow DOM
- Templates overview
- Template expressions
Edit this page


--------------------------------------------------------------------------------


# Working with Shadow DOM
Source: https://lit.dev/docs/components/shadow-dom/

Lit components useshadow DOMto encapsulate their DOM. Shadow DOM provides a way to add a separate isolated and encapsulated DOM tree to an element. DOM encapsulation is the key to unlocking interoperability with any other code—including other web components or Lit components—functioning on the page.

Shadow DOM provides three benefits:

- DOM scoping. DOM APIs likedocument.querySelectorwon't find elements in the component's shadow DOM, so it's harder for global scripts to accidentally break your component.
- Style scoping. You can write encapsulated styles for your shadow DOM that don't affect the rest of the DOM tree.
- Composition. The component's shadow root, which contains its internal DOM, is separate from the component's children. You can choose how children are rendered in your component's internal DOM.
For more information on shadow DOM:

- Shadow DOM v1: Self-Contained Web Componentson Web Fundamentals.
- Using shadow DOMon MDN.
Older browsers.On older browsers where native shadow DOM isn't available, theweb components polyfillsmay be used. Please note that Lit'spolyfill-supportmodule must be loaded along with the web components polyfills. SeeRequirements for legacy browsersfor details.


## Accessing nodes in the shadow DOM
Lit renders components to itsrenderRoot, which is a shadow root by default. To find internal elements, you can use DOM query APIs, such asthis.renderRoot.querySelector().

TherenderRootshould always be either a shadow root or an element, which share APIs like.querySelectorAll()and.children.

You can query internal DOM after component initial render (for example, infirstUpdated), or use a getter pattern:

``` js
firstUpdated() {  this.staticNode = this.renderRoot.querySelector('#static-node');}get _closeButton() {  return this.renderRoot.querySelector('#close-button');}
```

LitElement supplies a set of decorators that provide a shorthand way of defining getters like this.


## @query, @queryAll, and @queryAsync decorators
The@query,@queryAll, and@queryAsyncdecorators all provide a convenient way to access nodes in the internal component DOM.

Using decorators.Decorators are a proposed JavaScript feature, so you’ll need to use a compiler like Babel or TypeScript to use decorators. SeeUsing decoratorsfor details.

Modifies a class property, turning it into a getter that returns a node from the render root. The optional second argument when true performs the DOM query only once and caches the result. This can be used as a performance optimization in cases when the node being queried will not change.

``` js
import {LitElement, html} from 'lit';import {query} from 'lit/decorators/query.js';class MyElement extends LitElement {  @query('#first')  _first;  render() {    return html`      <div id="first"></div>      <div id="second"></div>    `;  }}
```

This decorator is equivalent to:

``` js
get _first() {  return this.renderRoot?.querySelector('#first') ?? null;}
```

Identical toqueryexcept that it returns all matching nodes, instead of a single node. It's the equivalent of callingquerySelectorAll.

``` js
import {LitElement, html} from 'lit';import {queryAll} from 'lit/decorators/queryAll.js';class MyElement extends LitElement {  @queryAll('div')  _divs;  render() {    return html`      <div id="first"></div>      <div id="second"></div>    `;  }}
```

Here,_divswould return both<div>elements in the template. For TypeScript, the typing of a@queryAllproperty isNodeListOf<HTMLElement>. If you know exactly what kind of nodes you'll retrieve, the typing can be more specific:

``` js
@queryAll('button')_buttons!: NodeListOf<HTMLButtonElement>
```

The exclamation point (!) afterbuttonsis TypeScript'snon-null assertion operator. It tells the compiler to treatbuttonsas always being defined, nevernullorundefined.

Similar to@query, except that instead of returning a node directly, it returns aPromisethat resolves to that node after any pending element render is completed. Code can use this instead of waiting for theupdateCompletepromise.

This is useful, for example, if the node returned by@queryAsynccan change as a result of another property change.


## Rendering children with slots
Your component may accept children (like a<ul>element can have<li>children).

``` html
<my-element>  <p>A child</p></my-element>
```

By default, if an element has a shadow tree, its children don't render at all.

To render children, your template needs to include one or more<slot>elements, which act as placeholders for child nodes.


## Using the slot element
To render an element's children, create a<slot>for them in the element's template. The children aren'tmovedin the DOM tree, but they're renderedas ifthey were children of the<slot>. For example:


## Using named slots
To assign a child to a specific slot, ensure that the child'sslotattribute matches the slot'snameattribute:

- Named slots only accept children with a matchingslotattribute.For example,<slot name="one"></slot>only accepts children with the attributeslot="one".
Named slots only accept children with a matchingslotattribute.

For example,<slot name="one"></slot>only accepts children with the attributeslot="one".

- Children with aslotattribute will only be rendered in a slot with a matchingnameattribute.For example,<p slot="one">...</p>will only be placed in<slot name="one"></slot>.
Children with aslotattribute will only be rendered in a slot with a matchingnameattribute.

For example,<p slot="one">...</p>will only be placed in<slot name="one"></slot>.


## Specifying slot fallback content
You can specify fallback content for a slot. The fallback content is shown when no child is assigned to the slot.

``` html
<slot>I am fallback content</slot>
```

Rendering fallback content.If any child nodes are assigned to a slot, its fallback content doesn't render. A default slot with no name accepts any child nodes. It won't render fallback content even if the only assigned nodes are text nodes containing whitespace, for example<example-element> </example-element>. When using a Lit expression as a child of a custom element, make sure to use a non-rendering value when appropriate so that any slot fallback content is rendered. Seeremoving child contentfor more information.


## Accessing slotted children
To access children assigned to slots in your shadow root, you can use the standardslot.assignedNodesorslot.assignedElementsmethods with theslotchangeevent.

For example, you can create a getter to access assigned elements for a particular slot:

``` js
get _slottedChildren() {  const slot = this.shadowRoot.querySelector('slot');  return slot.assignedElements({flatten: true});}
```

The elements are assigned only after the slot is rendered.

If you need to access assigned elements at startup, you need to wait forfirstUpdatedorupdated. If you want to access assigned elements when your render changes, you can useslotchange.

You can use theslotchangeevent to take action when nodes are first assigned or change. The following example extracts the text content of all of the slotted children.

``` js
handleSlotchange(e) {  const childNodes = e.target.assignedNodes({flatten: true});  // ... do something with childNodes ...  this.allText = childNodes.map((node) => {    return node.textContent ? node.textContent : ''  }).join('');}render() {  return html`<slot @slotchange=${this.handleSlotchange}></slot>`;}
```

For more information, seeHTMLSlotElementon MDN.


## @queryAssignedElements and @queryAssignedNodes decorators
@queryAssignedElementsand@queryAssignedNodesconvert a class property into a getter that returns the result of callingslot.assignedElementsorslot.assignedNodesrespectively on a given slot in the component's shadow tree. Use these to query the elements or nodes assigned to a given slot.

Both accept an optional object with the following properties:

Deciding which decorator to use depends on whether you want to query for text nodes assigned to the slot, or only element nodes. This decision is specific to your use case.

Using decorators.Decorators are a proposed JavaScript feature, so you’ll need to use a compiler like Babel or TypeScript to use decorators. SeeUsing decoratorsfor details.

``` ts
@queryAssignedElements({slot: 'list', selector: '.item'})_listItems!: Array<HTMLElement>;@queryAssignedNodes({slot: 'header', flatten: true})_headerNodes!: Array<Node>;
```

The examples above are equivalent to the following code:

``` js
get _listItems() {  const slot = this.shadowRoot.querySelector('slot[name=list]');  return slot.assignedElements().filter((node) => node.matches('.item'));}get _headerNodes() {  const slot = this.shadowRoot.querySelector('slot[name=header]');  return slot.assignedNodes({flatten: true});}
```


## Customizing the render root
Each Lit component has arender root—a DOM node that serves as a container for its internal DOM.

By default, LitElement creates an openshadowRootand renders inside it, producing the following DOM structure:

``` html
<my-element>  #shadow-root    <p>child 1</p>    <p>child 2</p>
```

There are two ways to customize the render root used by LitElement:

- SettingshadowRootOptions.
- Implementing thecreateRenderRootmethod.

## SettingshadowRootOptions
The simplest way to customize the render root is to set theshadowRootOptionsstatic property. The default implementation ofcreateRenderRootpassesshadowRootOptionsas the options argument toattachShadowwhen creating the component's shadow root. It can be set to customize any options allowed in theShadowRootInitdictionary, for examplemodeanddelegatesFocus.

``` js
class DelegatesFocus extends LitElement {  static shadowRootOptions = {...LitElement.shadowRootOptions, delegatesFocus: true};}
```

SeeElement.attachShadow()on MDN for more information.


## ImplementingcreateRenderRoot
The default implementation ofcreateRenderRootcreates an open shadow root and adds to it any styles set in thestatic stylesclass field. For more information on styling seeStyles.

To customize a component's render root, implementcreateRenderRootand return the node you want the template to render into.

For example, to render the template into the main DOM tree as your element's children, implementcreateRenderRootand returnthis.

Rendering into children.Rendering into children and not shadow DOM is generally not recommended. Your element will not have access to DOM or style scoping, and it will not be able to compose elements into its internal DOM.

Edit this page


--------------------------------------------------------------------------------


# Styles
Source: https://lit.dev/docs/components/styles

Your component's template is rendered to its shadow root. The styles you add to your component are automaticallyscopedto the shadow root and only affect elements in the component's shadow root.

Shadow DOM provides strong encapsulation for styling. If Lit did not use Shadow DOM, you would have to be extremely careful not to accidentally style elements outside of your component, either ancestors or children of your component. This might involve writing long, cumbersome to use class names. By using Shadow DOM, Lit ensures whatever selector you write only apply to elements in your Lit component's shadow root.


## Adding styles to your component
You define scoped styles in the staticstylesclass field using the tagged template literalcssfunction. Defining styles this way results in the most optimal performance:

The styles you add to your component arescopedusing shadow DOM. For a quick overview, seeShadow DOM.

The value of the staticstylesclass field can be:

- A single tagged template literal.staticstyles=css`...`;
A single tagged template literal.

``` js
static styles = css`...`;
```

- An array of tagged template literals.staticstyles=[css`...`,css`...`];
An array of tagged template literals.

``` js
static styles = [ css`...`, css`...`];
```

The staticstylesclass field isalmost alwaysthe best way to add styles to your component, but there are some use cases you can't handle this way—for example, customizing styles per instance. For alternate ways to add styles, seeDefining scoped styles in the template.


## Using expressions in static styles
Static styles apply to all instances of a component. Any expressions in CSS are evaluatedonce, then reused for all instances.

For tree-based or per-instance style customization, use CSS custom properties to allow elements to bethemed.

To prevent Lit components from evaluating potentially malicious code, thecsstag only allows nested expressions that are themselvescsstagged strings or numbers.

``` js
const mainColor = css`red`;...static styles = css`  div { color: ${mainColor} }`;
```

This restriction exists to protect applications from security vulnerabilities whereby malicious styles, or even malicious code, can be injected from untrusted sources such as URL parameters or database values.

If you must use an expression in acssliteral that is not itself acssliteral,andyou are confident that the expression is from a fully trusted source such as a constant defined in your own code, then you can wrap the expression with theunsafeCSSfunction:

``` js
const mainColor = 'red';...static styles = css`  div { color: ${unsafeCSS(mainColor)} }`;
```

Only use theunsafeCSStag with trusted input.Injecting unsanitized CSS is a security risk. For example, malicious CSS can "phone home" by adding an image URL that points to a third-party server.


## Inheriting styles from a superclass
Using an array of tagged template literals, a component can inherit the styles from a superclass, and add its own styles:

You can also usesuper.stylesto reference the superclass's styles property in JavaScript. If you're using TypeScript, we recommend avoidingsuper.stylessince the compiler doesn't always convert it correctly. Explicitly referencing the superclass, as shown in the example, avoids this issue.

When writing components intended to be subclassed in TypeScript, thestatic stylesfield should be explicitly typed asCSSResultGroupto allow flexibility for users to overridestyleswith an array:

``` ts
// Prevent typescript from narrowing the type of `styles` to `CSSResult`// so that subclassers can assign e.g. `[SuperElement.styles, css`...`]`;static styles: CSSResultGroup = css`...`;
```


## Sharing styles
You can share styles between components by creating a module that exports tagged styles:

``` js
export const buttonStyles = css`  .blue-button {    color: white;    background-color: blue;  }  .blue-button:disabled {    background-color: grey;  }`;
```

Your element can then import the styles and add them to its staticstylesclass field:

``` js
import { buttonStyles } from './button-styles.js';class MyElement extends LitElement {  static styles = [    buttonStyles,    css`      :host { display: block;        border: 1px solid black;      }`  ];}
```


## Using unicode escapes in styles
CSS's unicode escape sequence is a backslash followed by four or six hex digits: for example,\2022for a bullet character. This similar to the format of JavaScript's deprecatedoctalescape sequences, so using these sequences in acsstagged template literal causes an error.

There are two work-arounds for adding a unicode escape to your styles:

- Add a second backslash (for example,\\2022).
- Use the JavaScript escape sequence, starting with\u(for example,\u2022).
``` js
static styles = css`  div::before {    content: '\u2022';  }
```


## Shadow DOM styling overview
This section gives a brief overview of shadow DOM styling.

Styles you add to a component can affect:

- The shadow tree(your component's rendered template).
- The component itself.
- The component's children.

## Styling the shadow tree
Lit templates are rendered into a shadow tree by default. Styles scoped to an element's shadow tree don't affect the main document or other shadow trees. Similarly, with the exception ofinherited CSS properties, document-level styles don't affect the contents of a shadow tree.

When you use standard CSS selectors, they only match elements in your component's shadow tree. This means you can often use very simple selectors since you don't have to worry about them accidentally styling other parts of the page; for example:input,*, or#my-element.


## Styling the component itself
You can style the component itself using special:hostselectors. (The element that owns, or "hosts" a shadow tree is called thehost element.)

To create default styles for the host element, use the:hostCSS pseudo-class and:host()CSS pseudo-class function.

- :hostselects the host element.
- :host(selector)selects the host element, but only if the host element matchesselector.
Note that the host element can be affected by styles from outside the shadow tree, as well, so you should consider the styles you set in:hostand:host()rules asdefault stylesthat can be overridden by the user. For example:

``` css
my-element {  display: inline-block;}
```


## Styling the component's children
Your component may accept children (like a<ul>element can have<li>children). To render children, your template needs to include one or more<slot>elements, as described inRender children with the slot element.

The<slot>element acts as a placeholder in a shadow tree where the host element's children are displayed.

Use the::slotted()CSS pseudo-element to select children that are included in your template via<slot>s.

- ::slotted(*)matches all slotted elements.
- ::slotted(p)matches slotted paragraphs.
- p ::slotted(*)matches slotted elements where the<slot>is a descendant of a paragraph element.
Note thatonly direct slotted childrencan be styled with::slotted().

``` html
<my-element>  <div>Stylable with ::slotted()</div></my-element><my-element>  <div><p>Not stylable with ::slotted()</p></div></my-element>
```

Also, children can be styled from outside the shadow tree, so you should regard your::slotted()styles as default styles that can be overridden.

``` css
my-element > div {  /* Outside style targetting a slotted child can override ::slotted() styles */}
```

Limitations in the ShadyCSS polyfill around slotted content.See theShadyCSS limitationsfor details on how to use the::slotted()syntax in a polyfill-friendly way.


## Defining scoped styles in the template
We recommend using thestaticstylesclass fieldfor optimal performance. However, sometimes you may want to define styles in the Lit template. There are two ways to add scoped styles in the template:

- Add styles using a<style>element.
- Add styles using anexternal style sheet(not recommended).
Each of these techniques has its own set of advantages and drawbacks.


## In a style element
Typically, styles are placed in thestaticstylesclass field; however, the element's staticstylesare evaluatedonce per class. Sometimes, you might need to customize stylesper instance. For this, we recommend using CSS properties to createthemable elements. Alternatively, you can also include<style>elements in a Lit template. These are updated per instance.

``` js
render() {  return html`    <style>      /* updated per instance */    </style>    <div>template content</div>  `;}
```

Limitations in the ShadyCSS polyfill around per instance styling.Per instance styling is not supported using the ShadyCSS polyfill. See theShadyCSS limitationsfor details.

Using expressions inside style elements has some important limitations and performance issues.

``` js
render() {  return html`    <style>      :host {        /* Warning: this approach has limitations & performance issues! */        color: ${myColor}      }    </style>    <div>template content</div>  `;}
```

Limitations in the ShadyCSS polyfill around expressions.Expressions in<style>elements won't update per instance in ShadyCSS, due to limitations of the ShadyCSS polyfill. In addition,<style>nodes may not be passed as expression values when using the ShadyCSS polyfill. See theShadyCSS limitationsfor more information.

Evaluating an expression inside a<style>element is extremely inefficient. When any text inside a<style>element changes, the browser must re-parse the whole<style>element, resulting in unnecessary work.

To mitigate this cost, separate styles that require per-instance evaluation from those that don't.

``` js
  static styles = css`/* ... */`;  render() {    const redStyle = html`<style> :host { color: red; } </style>`;    return html`${this.red ? redStyle : ''}`
```


## Import an external stylesheet (not recommended)
While you can include an external style sheet in your template with a<link>, we do not recommend this approach. Instead, styles should be placed in thestaticstylesclass field.

External stylesheet caveats.

- TheShadyCSS polyfilldoesn't support external style sheets.
- External styles can cause a flash-of-unstyled-content (FOUC) while they load.
- The URL in thehrefattribute is relative to themain document. This is okay if you're building an app and your asset URLs are well-known, but avoid using external style sheets when building a reusable element.

## Dynamic classes and styles
One way to make styles dynamic is to add expressions to theclassorstyleattributes in your template.

Lit offers two directives,classMapandstyleMap, to conveniently apply classes and styles in HTML templates.

For more information on these and other directives, see the documentation onbuilt-in directives.

To usestyleMapand/orclassMap:

- ImportclassMapand/orstyleMap:import{classMap}from'lit/directives/class-map.js';import{styleMap}from'lit/directives/style-map.js';
ImportclassMapand/orstyleMap:

``` js
import { classMap } from 'lit/directives/class-map.js';import { styleMap } from 'lit/directives/style-map.js';
```

- UseclassMapand/orstyleMapin your element template:
UseclassMapand/orstyleMapin your element template:

SeeclassMapandstyleMapfor more information.


## Theming
By usingCSS inheritanceandCSS variables and custom propertiestogether, it's easy to create themable elements. By applying css selectors to customize CSS custom properties, tree-based and per-instance theming is straightforward to apply. Here's an example:


## CSS inheritance
CSS inheritance lets parent and host elements propagate certain CSS properties to their descendants.

Not all CSS properties inherit. Inherited CSS properties include:

- color
- font-familyand otherfont-*properties
- All CSS custom properties (--*)
SeeCSS Inheritance on MDNfor more information.

You can use CSS inheritance to set styles on an ancestor element that are inherited by its descendants:

``` html
<style>html {  color: green;}</style><my-element>  #shadow-root    Will be green</my-element>
```


## CSS custom properties
All CSS custom properties (--custom-property-name) inherit. You can use this to make your component's styles configurable from outside.

The following component sets its background color to a CSS variable. The CSS variable uses the value of--my-backgroundif it's been set by a selector matching an ancestor in the DOM tree, and otherwise defaults toyellow:

``` js
class MyElement extends LitElement {  static styles = css`    :host {      background-color: var(--my-background, yellow);    }  `;  render() {    return html`<p>Hello world</p>`;  }}
```

Users of this component can set the value of--my-background, using themy-elementtag as a CSS selector:

``` html
<style>  my-element {    --my-background: rgb(67, 156, 144);  }</style><my-element></my-element>
```

--my-backgroundis configurable per instance ofmy-element:

``` html
<style>  my-element {    --my-background: rgb(67, 156, 144);  }  my-element.stuff {    --my-background: #111111;  }</style><my-element></my-element><my-element class="stuff"></my-element>
```

SeeCSS Custom Properties on MDNfor more information.

Edit this page


--------------------------------------------------------------------------------


# Styles
Source: https://lit.dev/docs/components/styles/

Your component's template is rendered to its shadow root. The styles you add to your component are automaticallyscopedto the shadow root and only affect elements in the component's shadow root.

Shadow DOM provides strong encapsulation for styling. If Lit did not use Shadow DOM, you would have to be extremely careful not to accidentally style elements outside of your component, either ancestors or children of your component. This might involve writing long, cumbersome to use class names. By using Shadow DOM, Lit ensures whatever selector you write only apply to elements in your Lit component's shadow root.


## Adding styles to your component
You define scoped styles in the staticstylesclass field using the tagged template literalcssfunction. Defining styles this way results in the most optimal performance:

The styles you add to your component arescopedusing shadow DOM. For a quick overview, seeShadow DOM.

The value of the staticstylesclass field can be:

- A single tagged template literal.staticstyles=css`...`;
A single tagged template literal.

``` js
static styles = css`...`;
```

- An array of tagged template literals.staticstyles=[css`...`,css`...`];
An array of tagged template literals.

``` js
static styles = [ css`...`, css`...`];
```

The staticstylesclass field isalmost alwaysthe best way to add styles to your component, but there are some use cases you can't handle this way—for example, customizing styles per instance. For alternate ways to add styles, seeDefining scoped styles in the template.


## Using expressions in static styles
Static styles apply to all instances of a component. Any expressions in CSS are evaluatedonce, then reused for all instances.

For tree-based or per-instance style customization, use CSS custom properties to allow elements to bethemed.

To prevent Lit components from evaluating potentially malicious code, thecsstag only allows nested expressions that are themselvescsstagged strings or numbers.

``` js
const mainColor = css`red`;...static styles = css`  div { color: ${mainColor} }`;
```

This restriction exists to protect applications from security vulnerabilities whereby malicious styles, or even malicious code, can be injected from untrusted sources such as URL parameters or database values.

If you must use an expression in acssliteral that is not itself acssliteral,andyou are confident that the expression is from a fully trusted source such as a constant defined in your own code, then you can wrap the expression with theunsafeCSSfunction:

``` js
const mainColor = 'red';...static styles = css`  div { color: ${unsafeCSS(mainColor)} }`;
```

Only use theunsafeCSStag with trusted input.Injecting unsanitized CSS is a security risk. For example, malicious CSS can "phone home" by adding an image URL that points to a third-party server.


## Inheriting styles from a superclass
Using an array of tagged template literals, a component can inherit the styles from a superclass, and add its own styles:

You can also usesuper.stylesto reference the superclass's styles property in JavaScript. If you're using TypeScript, we recommend avoidingsuper.stylessince the compiler doesn't always convert it correctly. Explicitly referencing the superclass, as shown in the example, avoids this issue.

When writing components intended to be subclassed in TypeScript, thestatic stylesfield should be explicitly typed asCSSResultGroupto allow flexibility for users to overridestyleswith an array:

``` ts
// Prevent typescript from narrowing the type of `styles` to `CSSResult`// so that subclassers can assign e.g. `[SuperElement.styles, css`...`]`;static styles: CSSResultGroup = css`...`;
```


## Sharing styles
You can share styles between components by creating a module that exports tagged styles:

``` js
export const buttonStyles = css`  .blue-button {    color: white;    background-color: blue;  }  .blue-button:disabled {    background-color: grey;  }`;
```

Your element can then import the styles and add them to its staticstylesclass field:

``` js
import { buttonStyles } from './button-styles.js';class MyElement extends LitElement {  static styles = [    buttonStyles,    css`      :host { display: block;        border: 1px solid black;      }`  ];}
```


## Using unicode escapes in styles
CSS's unicode escape sequence is a backslash followed by four or six hex digits: for example,\2022for a bullet character. This similar to the format of JavaScript's deprecatedoctalescape sequences, so using these sequences in acsstagged template literal causes an error.

There are two work-arounds for adding a unicode escape to your styles:

- Add a second backslash (for example,\\2022).
- Use the JavaScript escape sequence, starting with\u(for example,\u2022).
``` js
static styles = css`  div::before {    content: '\u2022';  }
```


## Shadow DOM styling overview
This section gives a brief overview of shadow DOM styling.

Styles you add to a component can affect:

- The shadow tree(your component's rendered template).
- The component itself.
- The component's children.

## Styling the shadow tree
Lit templates are rendered into a shadow tree by default. Styles scoped to an element's shadow tree don't affect the main document or other shadow trees. Similarly, with the exception ofinherited CSS properties, document-level styles don't affect the contents of a shadow tree.

When you use standard CSS selectors, they only match elements in your component's shadow tree. This means you can often use very simple selectors since you don't have to worry about them accidentally styling other parts of the page; for example:input,*, or#my-element.


## Styling the component itself
You can style the component itself using special:hostselectors. (The element that owns, or "hosts" a shadow tree is called thehost element.)

To create default styles for the host element, use the:hostCSS pseudo-class and:host()CSS pseudo-class function.

- :hostselects the host element.
- :host(selector)selects the host element, but only if the host element matchesselector.
Note that the host element can be affected by styles from outside the shadow tree, as well, so you should consider the styles you set in:hostand:host()rules asdefault stylesthat can be overridden by the user. For example:

``` css
my-element {  display: inline-block;}
```


## Styling the component's children
Your component may accept children (like a<ul>element can have<li>children). To render children, your template needs to include one or more<slot>elements, as described inRender children with the slot element.

The<slot>element acts as a placeholder in a shadow tree where the host element's children are displayed.

Use the::slotted()CSS pseudo-element to select children that are included in your template via<slot>s.

- ::slotted(*)matches all slotted elements.
- ::slotted(p)matches slotted paragraphs.
- p ::slotted(*)matches slotted elements where the<slot>is a descendant of a paragraph element.
Note thatonly direct slotted childrencan be styled with::slotted().

``` html
<my-element>  <div>Stylable with ::slotted()</div></my-element><my-element>  <div><p>Not stylable with ::slotted()</p></div></my-element>
```

Also, children can be styled from outside the shadow tree, so you should regard your::slotted()styles as default styles that can be overridden.

``` css
my-element > div {  /* Outside style targetting a slotted child can override ::slotted() styles */}
```

Limitations in the ShadyCSS polyfill around slotted content.See theShadyCSS limitationsfor details on how to use the::slotted()syntax in a polyfill-friendly way.


## Defining scoped styles in the template
We recommend using thestaticstylesclass fieldfor optimal performance. However, sometimes you may want to define styles in the Lit template. There are two ways to add scoped styles in the template:

- Add styles using a<style>element.
- Add styles using anexternal style sheet(not recommended).
Each of these techniques has its own set of advantages and drawbacks.


## In a style element
Typically, styles are placed in thestaticstylesclass field; however, the element's staticstylesare evaluatedonce per class. Sometimes, you might need to customize stylesper instance. For this, we recommend using CSS properties to createthemable elements. Alternatively, you can also include<style>elements in a Lit template. These are updated per instance.

``` js
render() {  return html`    <style>      /* updated per instance */    </style>    <div>template content</div>  `;}
```

Limitations in the ShadyCSS polyfill around per instance styling.Per instance styling is not supported using the ShadyCSS polyfill. See theShadyCSS limitationsfor details.

Using expressions inside style elements has some important limitations and performance issues.

``` js
render() {  return html`    <style>      :host {        /* Warning: this approach has limitations & performance issues! */        color: ${myColor}      }    </style>    <div>template content</div>  `;}
```

Limitations in the ShadyCSS polyfill around expressions.Expressions in<style>elements won't update per instance in ShadyCSS, due to limitations of the ShadyCSS polyfill. In addition,<style>nodes may not be passed as expression values when using the ShadyCSS polyfill. See theShadyCSS limitationsfor more information.

Evaluating an expression inside a<style>element is extremely inefficient. When any text inside a<style>element changes, the browser must re-parse the whole<style>element, resulting in unnecessary work.

To mitigate this cost, separate styles that require per-instance evaluation from those that don't.

``` js
  static styles = css`/* ... */`;  render() {    const redStyle = html`<style> :host { color: red; } </style>`;    return html`${this.red ? redStyle : ''}`
```


## Import an external stylesheet (not recommended)
While you can include an external style sheet in your template with a<link>, we do not recommend this approach. Instead, styles should be placed in thestaticstylesclass field.

External stylesheet caveats.

- TheShadyCSS polyfilldoesn't support external style sheets.
- External styles can cause a flash-of-unstyled-content (FOUC) while they load.
- The URL in thehrefattribute is relative to themain document. This is okay if you're building an app and your asset URLs are well-known, but avoid using external style sheets when building a reusable element.

## Dynamic classes and styles
One way to make styles dynamic is to add expressions to theclassorstyleattributes in your template.

Lit offers two directives,classMapandstyleMap, to conveniently apply classes and styles in HTML templates.

For more information on these and other directives, see the documentation onbuilt-in directives.

To usestyleMapand/orclassMap:

- ImportclassMapand/orstyleMap:import{classMap}from'lit/directives/class-map.js';import{styleMap}from'lit/directives/style-map.js';
ImportclassMapand/orstyleMap:

``` js
import { classMap } from 'lit/directives/class-map.js';import { styleMap } from 'lit/directives/style-map.js';
```

- UseclassMapand/orstyleMapin your element template:
UseclassMapand/orstyleMapin your element template:

SeeclassMapandstyleMapfor more information.


## Theming
By usingCSS inheritanceandCSS variables and custom propertiestogether, it's easy to create themable elements. By applying css selectors to customize CSS custom properties, tree-based and per-instance theming is straightforward to apply. Here's an example:


## CSS inheritance
CSS inheritance lets parent and host elements propagate certain CSS properties to their descendants.

Not all CSS properties inherit. Inherited CSS properties include:

- color
- font-familyand otherfont-*properties
- All CSS custom properties (--*)
SeeCSS Inheritance on MDNfor more information.

You can use CSS inheritance to set styles on an ancestor element that are inherited by its descendants:

``` html
<style>html {  color: green;}</style><my-element>  #shadow-root    Will be green</my-element>
```


## CSS custom properties
All CSS custom properties (--custom-property-name) inherit. You can use this to make your component's styles configurable from outside.

The following component sets its background color to a CSS variable. The CSS variable uses the value of--my-backgroundif it's been set by a selector matching an ancestor in the DOM tree, and otherwise defaults toyellow:

``` js
class MyElement extends LitElement {  static styles = css`    :host {      background-color: var(--my-background, yellow);    }  `;  render() {    return html`<p>Hello world</p>`;  }}
```

Users of this component can set the value of--my-background, using themy-elementtag as a CSS selector:

``` html
<style>  my-element {    --my-background: rgb(67, 156, 144);  }</style><my-element></my-element>
```

--my-backgroundis configurable per instance ofmy-element:

``` html
<style>  my-element {    --my-background: rgb(67, 156, 144);  }  my-element.stuff {    --my-background: #111111;  }</style><my-element></my-element><my-element class="stuff"></my-element>
```

SeeCSS Custom Properties on MDNfor more information.

Edit this page


--------------------------------------------------------------------------------


# Component composition
Source: https://lit.dev/docs/composition/component-composition/

The most common way to handle complexity and factor Lit code into separate units iscomponent composition: that is, the process of building a large, complex component out of smaller, simpler components. Imagine you've been tasked with implementing a screen of UI:

You can probably identify the areas which will involve some complexity to implement. Chances are, those could be components.

By isolating the complexity into specific components, you make the job much simpler, and you can then compose these components together to create the overall design.

For example, the fairly simple screenshot above involves a number of possible components: a top bar, a menu button, a drawer with menu items for navigating the current section; and a main content area. Each of these could be represented by a component. A complex component, like a drawer with a navigation menu, might be broken into many smaller components: the drawer itself, a button to open and close the drawer, the menu, individual menu items.

Lit lets you compose by adding elements to your template—whether those are built-in HTML elements or custom elements.

``` js
render() {  return html`    <top-bar>      <icon-button icon="menu" slot="nav-button"></icon-button>      <span slot="title">Fuzzy</span>    </top-bar>    `;}
```


## What makes a good component
When deciding how to break up functionality, there are several things that help identify when to make a new component. A piece of UI may be a good candidate for a component if one or more of the following applies:

- It has its own state.
- It has its own template.
- It's used in more than one place, either in this component or in multiple components.
- It focuses on doing one thing well.
- It has a well-defined API.
Reusable controls like buttons, checkboxes, and input fields can make great components. But more complex UI pieces like drawers and carousels are also great candidates for componentization.


## Passing data up and down the tree
When exchanging data with subcomponents, the general rule is to follow the model of the DOM:properties down,events up.

- Properties down. Setting properties on a subcomponent is usually preferable to calling methods on the subcomponent. It's easy to set properties in Lit templates and other declarative template systems.
Properties down. Setting properties on a subcomponent is usually preferable to calling methods on the subcomponent. It's easy to set properties in Lit templates and other declarative template systems.

- Events up. In the web platform, firing events is the default method for elements to send information up the tree, often in response to user interactions. This lets the host component respond to the event, or transform or re-fire the event for ancestors farther up the tree.
Events up. In the web platform, firing events is the default method for elements to send information up the tree, often in response to user interactions. This lets the host component respond to the event, or transform or re-fire the event for ancestors farther up the tree.

A few implications of this model:

- A component should be the source of truth for the subcomponents in its shadow DOM. Subcomponents shouldn't set properties or call methods on their host component.
A component should be the source of truth for the subcomponents in its shadow DOM. Subcomponents shouldn't set properties or call methods on their host component.

- If a component changes a public property on itself, it should fire an event to notify components higher in the tree. Generally these changes will be the result of user actions—like pressing a button or selecting a menu item. Think of the nativeinputelement, which fires an event when the user changes the value of the input.
If a component changes a public property on itself, it should fire an event to notify components higher in the tree. Generally these changes will be the result of user actions—like pressing a button or selecting a menu item. Think of the nativeinputelement, which fires an event when the user changes the value of the input.

Consider a menu component that includes a set of menu items and exposesitemsandselectedItemproperties as part of its public API. Its DOM structure might look like this:

When the user selects an item, themy-menuelement should update itsselectedItemproperty. It should also fire an event to notify any owning component that the selection has changed. The complete sequence would be something like this:

- The user interacts with an item, causing an event to fire (either a standard event likeclick, or some event specific to themy-itemcomponent).
- Themy-menuelement gets the event, and updates itsselectedItemproperty. It may also change some state so that the selected item is highlighted.
- Themy-menuelement fires a semantic event indicating that the selection has changed. This event might be calledselected-item-changed, for example. Since this event is part of the API formy-menu, it should be semantically meaningful in that context.
For more information on dispatching and listening for events, seeEvents.


## Passing data across the tree
Properties down and events up is a good rule to start with. But what if you need to exchange data between two components that don't have a direct descendant relationship? For example, two components that are siblings in the shadow tree?

One solution to this problem is to use themediator pattern. In the mediator pattern, peer components don't communicate with each other directly. Instead, interactions aremediatedby a third party.

A simple way to implement the mediator pattern is by having the owning component handle events from its children, and in turn update the state of its children as necessary by passing changed data back down the tree. By adding a mediator, you can pass data across the tree using the familiar events-up, properties-down principle.

In the following example, the mediator element listens for events from the input and button elements in its shadow DOM. It controls the enabled state of the button so the user can only clickSubmitwhen there's text in the input.

Other mediator patterns include flux/Redux-style patterns where a store mediates changes and updates components via subscriptions. Having components directly subscribe to changes can help avoid needing every parent to pass along all data required by its children.


## Light DOM children
In addition to the nodes in your shadow DOM, you can render child nodes provided by the component user, like the standard<select>element can take a set of<option>elements as children and render them as menu items.

Child nodes are sometimes referred to as "light DOM" to distinguish them from the component's shadow DOM. For example:

``` html
<top-bar>  <icon-button icon="menu" slot="nav-button"></icon-button>  <span slot="title">Fuzzy</span></top-bar>
```

Here thetop-barelement has two light DOM children supplied by the user: a navigation button, and a title.

Interacting with light DOM children is different from interacting with nodes in the shadow DOM. Nodes in a component's shadow DOM are managed by the component, and shouldn't be accessed from outside the component. Light DOM children are managed from outside the component, but can be accessed by the component as well. The component's user can add or remove light DOM children at any time, so the component can't assume a static set of child nodes.

The component has control over whether and where the child nodes are rendered, using the<slot>element in its shadow DOM. And it can receive notifications when child nodes are added and removed by listening for theslotchangeevent.

For more information, see the sections onrendering children with slotsandaccessing slotted children.

Meerkat photo byAnggit RizkiantoonUnsplash.

Edit this page


--------------------------------------------------------------------------------


# Reactive Controllers
Source: https://lit.dev/docs/composition/controllers/

A reactive controller is an object that can hook into a component'sreactive update cycle. Controllers can bundle state and behavior related to a feature, making it reusable across multiple component definitions.

You can use controllers to implement features that require their own state and access to the component's lifecycle, such as:

- Handling global events like mouse events
- Managing asynchronous tasks like fetching data over the network
- Running animations
Reactive controllers allow you to build components by composing smaller pieces that aren't themselves components. They can be thought of as reusable, partial component definitions, with their own identity and state.

Reactive controllers are similar in many ways to class mixins. The main difference is that they have their own identity and don't add to the component's prototype, which helps contain their APIs and lets you use multiple controller instances per host component. SeeControllers and mixinsfor more details.


## Using a controller
Each controller has its own creation API, but typically you will create an instance and store it with the component:

``` ts
class MyElement extends LitElement {  private clock = new ClockController(this, 1000);}
```

The component associated with a controller instance is called the host component.

The controller instance registers itself to receive lifecycle callbacks from the host component, and triggers a host update when the controller has new data to render. This is how theClockControllerexample periodically renders the current time.

A controller will typically expose some functionality to be used in the host'srender()method. For example, many controllers will have some state, like a current value:

``` ts
  render() {    return html`      <div>Current time: ${this.clock.value}</div>    `;  }
```

Since each controller has it's own API, refer to specific controller documentation on how to use them.


## Writing a controller
A reactive controller is an object associated with a host component, which implements one or more host lifecycle callbacks or interacts with its host. It can be implemented in a number of ways, but we'll focus on using JavaScript classes, with constructors for initialization and methods for lifecycles.


## Controller initialization
A controller registers itself with its host component by callinghost.addController(this). Usually a controller stores a reference to its host component so that it can interact with it later.

``` ts
class ClockController implements ReactiveController {  private host: ReactiveControllerHost;  constructor(host: ReactiveControllerHost) {    // Store a reference to the host    this.host = host;    // Register for lifecycle updates    host.addController(this);  }}
```

``` js
class ClockController {  constructor(host) {    // Store a reference to the host    this.host = host;    // Register for lifecycle updates    host.addController(this);  }}
```

You can add other constructor parameters for one-time configuration.

``` ts
class ClockController implements ReactiveController {  private host: ReactiveControllerHost;  timeout: number  constructor(host: ReactiveControllerHost, timeout: number) {    this.host = host;    this.timeout = timeout;    host.addController(this);  }
```

``` js
class ClockController {  constructor(host, timeout) {    this.host = host;    this.timeout = timeout;    host.addController(this);  }
```

Once your controller is registered with the host component, you can add lifecycle callbacks and other class fields and methods to the controller to implement the desired state and behavior.


## Lifecycle
The reactive controller lifecycle, defined in theReactiveControllerinterface, is a subset of the reactive update cycle. LitElement calls into any installed controllers during its lifecycle callbacks. These callbacks are optional.

- hostConnected():Called when the host is connected.Called after creating therenderRoot, so a shadow root will exist at this point.Useful for setting up event listeners, observers, etc.
- Called when the host is connected.
- Called after creating therenderRoot, so a shadow root will exist at this point.
- Useful for setting up event listeners, observers, etc.
- hostUpdate():Called before the host'supdate()andrender()methods.Useful for reading DOM before it's updated (for example, for animations).
- Called before the host'supdate()andrender()methods.
- Useful for reading DOM before it's updated (for example, for animations).
- hostUpdated():Called after updates, before the host'supdated()method.Useful for reading DOM after it's modified (for example, for animations).
- Called after updates, before the host'supdated()method.
- Useful for reading DOM after it's modified (for example, for animations).
- hostDisconnected():Called when the host is disconnected.Useful for cleaning up things added inhostConnected(), such as event listeners and observers.
- Called when the host is disconnected.
- Useful for cleaning up things added inhostConnected(), such as event listeners and observers.
For more information, seeReactive update cycle.


## Controller host API
A reactive controller host implements a small API for adding controllers and requesting updates, and is responsible for calling its controller's lifecycle methods.

This is the minimum API exposed on a controller host:

- addController(controller: ReactiveController)
- removeController(controller: ReactiveController)
- requestUpdate()
- updateComplete: Promise<boolean>
You can also create controllers that are specific toHTMLElement,ReactiveElement,LitElementand require more of those APIs; or even controllers that are tied to a specific element class or other interface.

LitElementandReactiveElementare controller hosts, but hosts can also be other objects like base classes from other web components libraries, components from frameworks, or other controllers.


## Building controllers from other controllers
Controllers can be composed of other controllers as well. To do this create a child controller and forward the host to it.

``` ts
class DualClockController implements ReactiveController {  private clock1: ClockController;  private clock2: ClockController;  constructor(host: ReactiveControllerHost, delay1: number, delay2: number) {    this.clock1 = new ClockController(host, delay1);    this.clock2 = new ClockController(host, delay2);  }  get time1() { return this.clock1.value; }  get time2() { return this.clock2.value; }}
```

``` js
class DualClockController {  constructor(host, delay1, delay2) {    this.clock1 = new ClockController(host, delay1);    this.clock2 = new ClockController(host, delay2);  }  get time1() { return this.clock1.value; }  get time2() { return this.clock2.value; }}
```


## Controllers and directives
Combining controllers with directives can be a very powerful technique, especially for directives that need to do work before or after rendering, like animation directives; or controllers that need references to specific elements in a template.

There are two main patterns of using controllers with directives:

- Controller directives. These are directives that themselves are controllers in order to hook into the host lifecycle.
- Controllers that own directives. These are controllers that create one or more directives for use in the host's template.
For more information about writing directives, seeCustom directives.

Reactive controllers do not need to be stored as instance fields on the host. Anything added to a host usingaddController()is a controller. In particular, a directive can also be a controller. This enables a directive to hook into the host lifecycle.

Directives do not need to be standalone functions, they can be methods on other objects as well, such as controllers. This can be useful in cases where a controller needs a specific reference to an element in a template.

For example, imagine a ResizeController that lets you observe an element's size with a ResizeObserver. To work we need both a ResizeController instance, and a directive that is placed on the element we want to observe:

``` ts
class MyElement extends LitElement {  private _textSize = new ResizeController(this);  render() {    return html`      <textarea ${this._textSize.observe()}></textarea>      <p>The width is ${this._textSize.contentRect?.width}</p>    `;  }}
```

``` js
class MyElement extends LitElement {  _textSize = new ResizeController(this);  render() {    return html`      <textarea ${this._textSize.observe()}></textarea>      <p>The width is ${this._textSize.contentRect?.width}</p>    `;  }}
```

To implement this, you create a directive and call it from a method:

``` ts
class ResizeDirective {  /* ... */}const resizeDirective = directive(ResizeDirective);export class ResizeController {  /* ... */  observe() {    // Pass a reference to the controller so the directive can    // notify the controller on size changes.    return resizeDirective(this);  }}
```


## TO DO
- Review and cleanup this example

## Use cases
Reactive controllers are very general and have a very broad set of possible use cases. They are particularly good for connecting a component to an external resource, like user input, state management, or remote APIs. Here are a few common use cases.


## External inputs
Reactive controllers can be used to connect to external inputs. For example, keyboard and mouse events, resize observers, or mutation observers. The controller can provide the current value of the input to use in rendering, and request a host update when the value changes.

This example shows how a controller can perform setup and cleanup work when its host is connected and disconnected, and request an update when an input changes:


## Asynchronous tasks
Asynchronous tasks, such as long running computations or network I/O, typically have state that changes over time, and will need to notify the host when the task state changes (completes, errors, etc.).

Controllers are a great way to bundle task execution and state to make it easy to use inside a component. A task written as a controller usually has inputs that a host can set, and outputs that a host can render.

@lit/taskcontains a genericTaskcontroller that can pull inputs from the host, execute a task function, and render different templates depending on the task state.

You can useTaskto create a custom controller with an API tailored for your specific task. Here we wrapTaskin aNamesControllerthat can fetch one of a specified list of names from a demo REST API.NameControllerexposes akindproperty as an input, and arender()method that can render one of four templates depending on the task state. The task logic, and how it updates the host, are abstracted from the host component.


## TO DO
- Animations

## See also
- Reactive update cycle
- @lit/task
Edit this page


--------------------------------------------------------------------------------


# Mixins
Source: https://lit.dev/docs/composition/mixins/

Class mixins are a pattern for sharing code between classes using standard JavaScript. As opposed to "has-a" composition patterns likereactive controllers, where a class canowna controller to add behavior, mixins implement "is-a" composition, where the mixin causes the class itself tobean instance of the behavior being shared.

You can use mixins to customize a Lit component by adding API or overriding its lifecycle callbacks.


## Mixin basics
Mixins can be thought of as "subclass factories" that override the class they are applied to and return a subclass, extended with the behavior in the mixin. Because mixins are implemented using standard JavaScript class expressions, they can use all of the idioms available to subclassing, such as adding new fields/methods, overriding existing superclass methods, and usingsuper.

For ease of reading, the samples on this page elide some of the TypeScript types for mixin functions. SeeMixins in TypeScriptfor details on proper typing of mixins in TypeScript.

To define a mixin, write a function that takes asuperClass, and returns a new class that extends it, adding fields and methods as needed:

``` ts
const MyMixin = (superClass) => class extends superClass {  /* class fields & methods to extend superClass with */};
```

To apply a mixin, simply pass a class to generate a subclass with the mixin applied. Most commonly, users will apply the mixin directly to a base class when defining a new class:

``` ts
class MyElement extends MyMixin(LitElement) {  /* user code */}
```

Mixins can also be used to create concrete subclasses that users can then extend like a normal class, where the mixin is an implementation detail:

``` ts
export const LitElementWithMixin = MyMixin(LitElement);
```

``` ts
import {LitElementWithMixin} from './lit-element-with-mixin.js';class MyElement extends LitElementWithMixin {  /* user code */}
```

Because class mixins are a standard JavaScript pattern and not Lit-specific, there is a good deal of information in the community on leveraging mixins for code reuse. For more reading on mixins, here are a few good references:

- Class mixinson MDN
- Real Mixins with JavaScript Classesby Justin Fagnani
- Mixinsin the TypeScript handbook.
- Dedupe mixin libraryby open-wc, including a discussion of when mixin usage may lead to duplication, and how to use a deduping library to avoid it.
- Mixin conventionsfollowed by Elix web component library. While not Lit-specific, contains thoughtful suggestions around applying conventions when defining mixins for web components.

## Creating mixins for LitElement
Mixins applied to LitElement can implement or override any of the standardcustom element lifecyclecallbacks like theconstructor()orconnectedCallback(), as well as any of thereactive update lifecyclecallbacks likerender()orupdated().

For example, the following mixin would log when the element is created, connected, and updated:

``` ts
const LoggingMixin = (superClass) => class extends superClass {  constructor() {    super();    console.log(`${this.localName} was created`);  }  connectedCallback() {    super.connectedCallback();    console.log(`${this.localName} was connected`);  }  updated(changedProperties) {    super.updated?.(changedProperties);    console.log(`${this.localName} was updated`);  }}
```

Note that a mixin should always make a super call to the standard custom element lifecycle methods implemented byLitElement. When overriding a reactive update lifecycle callback, it is good practice to call the super method if it already exists on the superclass (as shown above with the optional-chaining call tosuper.updated?.()).

Also note that mixins can choose to do work either before or after the base implementation of the standard lifecycle callbacks via its choice of when to make the super call.

Mixins can also addreactive properties,styles, and API to the subclassed element.

The mixin in the example below adds ahighlightreactive property to the element and arenderHighlight()method that the user can call to wrap some content. The wrapped content is styled yellow when thehighlightproperty/attribute is set.

Note in the example above, the user of the mixin is expected to call therenderHighlight()method from theirrender()method, as well as take care to add thestatic stylesdefined by the mixin to the subclass styles. The nature of this contract between mixin and user is up to the mixin definition and should be documented by the mixin author.


## Mixins in TypeScript
When writingLitElementmixins in TypeScript, there are a few details to be aware of.


## Typing the superclass
You should constrain thesuperClassargument to the type of class you expect users to extend, if any. This can be accomplished using a genericConstructorhelper type as shown below:

``` ts
import {LitElement} from 'lit';type Constructor<T = {}> = new (...args: any[]) => T;export const MyMixin = <T extends Constructor<LitElement>>(superClass: T) => {  class MyMixinClass extends superClass {    /* ... */  };  return MyMixinClass as /* see "typing the subclass" below */;}
```

The above example ensures that the class being passed to the mixin extends fromLitElement, so that your mixin can rely on callbacks and other API provided by Lit.


## Typing the subclass
Although TypeScript has basic support for inferring the return type for the subclass generated using the mixin pattern, it has a severe limitation in that the inferred class must not contain members withprivateorprotectedaccess modifiers.

BecauseLitElementitself does have private and protected members, by default TypeScript will error with"Property '...' of exported class expression may not be private or protected."when returning a class that extendsLitElement.

There are two workarounds that both involve casting the return type from the mixin function to avoid the error above.

If your mixin only overridesLitElementmethods or properties and does not add any new API of its own, you can simply cast the generated class to the super class typeTthat was passed in:

``` ts
export const MyMixin = <T extends Constructor<LitElement>>(superClass: T) => {  class MyMixinClass extends superClass {    connectedCallback() {      super.connectedCallback();      this.doSomethingPrivate();    }    private doSomethingPrivate() {      /* does not need to be part of the interface */    }  };  // Cast return type to the superClass type passed in  return MyMixinClass as T;}
```

If your mixin does add new protected or public API that you need users to be able to use on their class, you need to define the interface for the mixin separately from the implementation, and cast the return type as the intersection of your mixin interface and the super class type:

``` ts
// Define the interface for the mixinexport declare class MyMixinInterface {  highlight: boolean;  protected renderHighlight(): unknown;}export const MyMixin = <T extends Constructor<LitElement>>(superClass: T) => {  class MyMixinClass extends superClass {    @property() highlight = false;    protected renderHighlight() {      /* ... */    }  };  // Cast return type to your mixin's interface intersected with the superClass type  return MyMixinClass as Constructor<MyMixinInterface> & T;}
```


## Applying decorators in mixins
Due to limitations of TypeScript's type system, decorators (such as@property()) must be applied to a class declaration statement and not a class expression.

In practice this means mixins in TypeScript need to declare a class and then return it, rather than return a class expression directly from the arrow function.

Supported:

``` ts
export const MyMixin = <T extends LitElementConstructor>(superClass: T) => {  // ✅ Defining a class in a function body, and then returning it  class MyMixinClass extends superClass {    @property()    mode = 'on';    /* ... */  };  return MyMixinClass;}
```

Not supported:

``` ts
export const MyMixin = <T extends LitElementConstructor>(superClass: T) =>  // ❌ Returning class expression directly using arrow-function shorthand  class extends superClass {    @property()    mode = 'on';    /* ... */  }
```

Edit this page


--------------------------------------------------------------------------------


# Composition overview
Source: https://lit.dev/docs/composition/overview/

Composition is a strategy for managing complexity and organizing code into reusable pieces. Lit provides a few options for composition and code reuse:

- Component composition.
- Reactive controllers.
- Class mixins.
Component compositionis the process of assembling complex components from simpler components. A component can use subcomponents in its template. Components can use standard DOM mechanisms to communicate: setting properties on subcomponents, and listening for events from subcomponents.

Although component composition is the default way to think about breaking a complex Lit project down into smaller units, there are two other notable code patterns useful for factoring your Lit code:

Reactive controllersare objects that can hook into the update lifecycle of a Lit component, encapsulating state and behavior related to a feature into a separate unit of code.

Class mixinslet you write reusable partial component definitions and "mix them in" to a component's inheritance chain.

Both mixins and reactive controllers let you factor component logic related to a given feature into a reusable unit. See the next section for a comparison of controllers and mixins.


## Controllers and mixins
Controllers and class mixins are very similar in some ways. They both can hook into a host component's lifecycle, maintain state, and trigger host updates.

The primary difference between controllers and mixins is their relationship with the component. A component has a "has-a" relationship with a reactive controller, since it owns the controller. A component has an "is-a" relationship with a mixin, since the component is an instance of the mixin class.

A reactive controller is a separate object owned by a component. The controller can access methods and fields on the component, and the component can access methods and fields on the controller. But the controller can't (easily) be accessed by someone using the component, unless the component exposes a public API to it. The controller's lifecycle methods are calledbeforethe corresponding lifecycle method on the component.

A mixin, on the other hand, becomes part of the component's prototype chain. Any public fields or methods defined by the mixin are part of the component's API. And because a mixin is part of the prototype chain, your component has some control of when the mixin's lifecycle callbacks are called.

In general, if you're trying to decide whether to package a feature as a controller or a mixin, you should choose a controllerunlessthe feature requires one of the following:

- Adding public API to the component.
- Very granular access to the component lifecycle.
Edit this page


--------------------------------------------------------------------------------


# Context
Source: https://lit.dev/docs/data/context/

Context is a way of making data available to entire component subtrees without having to manually bind properties to every component. The data is "contextually" available, such that ancestor elements in between a provider of data and consumer of data aren't even aware of it.

Lit's context implementation is available in the@lit/contextpackage:

``` bash
npm i @lit/context
```

Context is useful for data that needs to be consumed by a wide variety and large number of components - things like an app's data store, the current user, a UI theme - or when data-binding isn't an option, such as when an element needs to provide data to its light DOM children.

Context is very similar to React's Context, or to dependency injection systems like Angular's, with some important differences that make Context work with the dynamic nature of the DOM, and enable interoperability across different web components libraries, frameworks and plain JavaScript.


## Example
Using context involves acontext object(sometimes called a key), aproviderand aconsumer, which communicate using the context object.

Context definition (logger-context.ts):

``` ts
import {createContext} from '@lit/context';import type {Logger} from 'my-logging-library';export type {Logger} from 'my-logging-library';export const loggerContext = createContext<Logger>('logger');
```

Provider:

``` ts
import {LitElement, property, html} from 'lit';import {provide} from '@lit/context';import {Logger} from 'my-logging-library';import {loggerContext} from './logger-context.js';@customElement('my-app')class MyApp extends LitElement {  @provide({context: loggerContext})  logger = new Logger();  render() {    return html`...`;  }}
```

Consumer:

``` ts
import {LitElement, property} from 'lit';import {consume} from '@lit/context';import {type Logger, loggerContext} from './logger-context.js';export class MyElement extends LitElement {  @consume({context: loggerContext})  @property({attribute: false})  public logger?: Logger;  private doThing() {    this.logger?.log('A thing was done');  }}
```


## Key Concepts

## Context Protocol
Lit's context is based on theContext Community Protocolby the W3C'sWeb Components Community Group.

This protocol enables interoperability between elements (or even non-element code) regardless of how they were built. Via the context protocol, a Lit-based element can provide data to a consumer not built with Lit, or vice versa.

The Context Protocol is based on DOM events. A consumer fires acontext-requestevent that carries the context key that it wants, and any element above it can listen for thecontext-requestevent and provide data for that context key.

@lit/contextimplements this event-based protocol and makes it available via a few reactive controllers and decorators.


## Context Objects
Contexts are identified bycontext objectsorcontext keys. They are objects that represent some potential data to be shared by the context object identity. You can think of them as similar to Map keys.


## Providers
Providers are usually elements (but can be any event handler code) that provide data for specific context keys.


## Consumers
Consumers request data for specific context keys.


## Subscriptions
When a consumer requests data for a context, it can tell the provider that it wants tosubscribeto changes in the context. If the provider has new data, the consumer will be notified and can automatically update.


## Usage

## Defining a context
Every usage of context must have a context object to coordinate the data request. This context object represents the identity and type of data that is provided.

Context objects are created with thecreateContext()function:

``` ts
export const myContext = createContext(Symbol('my-context'));
```

It is recommended to put context objects in their own module so that they're importable independent of specific providers and consumers.

createContext()takes any value and returns it directly. In TypeScript, the value is cast to a typedContextobject, which carries the type of the contextvaluewith it.

In case of a mistake like this:

``` ts
const myContext = createContext<Logger>(Symbol('logger'));class MyElement extends LitElement {  @provide({context: myContext})  name: string}
```

TypeScript will warn that the typestringis not assignable to the typeLogger. Note that this check is currently only for public fields.

Context objects are used by providers to match a context request event to a value. Contexts are compared with strict equality (===), so a provider will only handle a context request if its context key equals the context key of the request.

This means that there are two main ways to create a context object:

- With a value that is globally unique, like an object ({}) or symbol (Symbol())
- With a value that is not globally unique, so that it can be equal under strict equality, like a string ('logger') orglobalsymbol (Symbol.for('logger')).
If you want twoseparatecreateContext()calls to refer to the same context, then use a key that will be equal under strict equality like a string:

``` ts
// truecreateContext('my-context') === createContext('my-context')
```

Beware though that two modules in your app could use the same context key to refer to different objects. To avoid unintended collisions you may want to use a relatively unique string, e.g. like'console-logger'instead of'logger'.

Usually it's best to use a globally unique context object. Symbols are one of the easiest ways to do this.


## Providing a context
There are two ways in@lit/contextto provide a context value: the ContextProvider controller and the@provide()decorator.

The@provide()decorator is the easiest way to provide a value if you're using decorators. It creates a ContextProvider controller for you.

Decorate a property with@provide()and give it the context key:

``` ts
import {LitElement, html} from 'lit';import {property} from 'lit/decorators.js';import {provide} from '@lit/context';import {myContext, MyData} from './my-context.js';class MyApp extends LitElement {  @provide({context: myContext})  myData: MyData;}
```

You can make the property also a reactive property with@property()or@state()so that setting it will update the provider element as well as context consumers.

``` ts
  @provide({context: myContext})  @property({attribute: false})  myData: MyData;
```

Context properties are often intended to be private. You can make private properties reactive with@state():

``` ts
  @provide({context: myContext})  @state()  private _myData: MyData;
```

Making a context property public lets an element provide a public field to its child tree:

``` ts
  html`<my-provider-element .myData=${someData}>`
```

ContextProvideris a reactive controller that managescontext-requestevent handlers for you.

``` ts
import {LitElement, html} from 'lit';import {ContextProvider} from '@lit/context';import {myContext} from './my-context.js';export class MyApp extends LitElement {  private _provider = new ContextProvider(this, {context: myContext});}
```

ContextProvider can take an initial value as an option in the constructor:

``` ts
  private _provider = new ContextProvider(this, {context: myContext, initialValue: myData});
```

Or you can callsetValue():

``` ts
  this._provider.setValue(myData);
```


## Consuming a context
The@consume()decorator is the easiest way to consume a value if you're using decorators. It creates a ContextConsumer controller for you.

Decorate a property with@consume()and give it the context key:

``` ts
import {LitElement, html} from 'lit';import {consume} from '@lit/context';import {myContext, MyData} from './my-context.js';class MyElement extends LitElement {  @consume({context: myContext})  myData: MyData;}
```

When this element is connected to the document, it will automatically fire acontext-requestevent, get a provided value, assign it to the property, and trigger an update of the element.

ContextConsumer is a reactive controller that manages dispatching thecontext-requestevent for you. The controller will cause the host element to update when new values are provided. The provided value is then available at the.valueproperty of the controller.

``` ts
import {LitElement, property} from 'lit';import {ContextConsumer} from '@lit/context';import {myContext} from './my-context.js';export class MyElement extends LitElement {  private _myData = new ContextConsumer(this, {context: myContext});  render() {    const myData = this._myData.value;    return html`...`;  }}
```

Consumers can subscribe to context values so that if a provider has a new value, it can give it to all subscribed consumers, causing them to update.

You can subscribe with the@consume()decorator:

``` ts
  @consume({context: myContext, subscribe: true})  myData: MyData;
```

and the ContextConsumer controller:

``` ts
  private _myData = new ContextConsumer(this,    {      context: myContext,      subscribe: true,    }  );
```


## Example Use Cases

## Current user, locale, etc.
The most common context use cases involve data that is global to a page and possibly only sparsely needed in components throughout the page. Without context it's possible that most or all components would need to accept and propagate reactive properties for the data.


## Services
App-global services, like loggers, analytics, data stores, can be provided by context. An advantage of context over importing from a common module are the late coupling and tree-scoping that context provides. Tests can easily provide mock services, or different parts of the page can be given different service instances.


## Themes
Themes are sets of styles that apply to the entire page or entire subtrees within the page - exactly the kind of scope of data that context provides.

One way of building a theme system would be to define aThemetype that containers can provide that holds named styles. Elements that want to apply a theme can consume the theme object and look up styles by name. Custom theme reactive controllers can wrap ContextProvider and ContextConsumer to reduce boilerplate.


## HTML-based plugins
Context can be used to pass data from a parent to its light DOM children. Since the parent does usually not create the light DOM children, it cannot leverage template-based data-binding to pass data to them, but it can listen to and respond tocontext-requestevents.

For example, consider a code editor element with plugins for different language modes. You can make a plain HTML system for adding features using context:

``` html
<code-editor>  <code-editor-javascript-mode></code-editor-javascript-mode>  <code-editor-python-mode></code-editor-python-mode></code-editor>
```

In this case<code-editor>would provide an API for adding language modes via context, and plugin elements would consume that API and add themselves to the editor.


## Data formatters, link generators, etc.
Sometimes reusable components will need to format data or URLs in an application-specific way. For example, a documentation viewer that renders a link to another item. The component will not know the URL space of the application.

In these cases the component can depend on a context-provided function that will apply the application-specific formatting to the data or link.


## API
These API docs are a summary until generated API docs are available


## createContext()
Creates a typed Context object

Import:

``` ts
import {createContext} from '@lit/context';
```

Signature:

``` ts
function createContext<ValueType, K = unknown>(key: K): Context<K, ValueType>;
```

Contexts are compared with with strict equality.

If you want two separatecreateContext()calls to referrer to the same context, then use a key that will by equal under strict equality like a string forSymbol.for():

``` ts
// truecreateContext('my-context') === createContext('my-context')// truecreateContext(Symbol.for('my-context')) === createContext(Symbol.for('my-context'))
```

If you want a context to be unique so that it's guaranteed to not collide with other contexts, use a key that's unique under strict equality, like aSymbol()or object.:

``` ts
// falsecreateContext(Symbol('my-context')) === createContext(Symbol('my-context'))// falsecreateContext({}) === createContext({})
```

TheValueTypetype parameter is the type of value that can be provided by this context. It's uses to provide accurate types in the other context APIs.


## @provide()
A property decorator that adds a ContextProvider controller to the component making it respond to anycontext-requestevents from its children consumer.

Import:

``` ts
import {provide} from '@lit/context';
```

Signature:

``` ts
@provide({context: Context})
```


## @consume()
A property decorator that adds a ContextConsumer controller to the component which will retrieve a value for the property via the Context protocol.

Import:

``` ts
import {consume} from '@lit/context';
```

Signature:

``` ts
@consume({context: Context, subscribe?: boolean})
```

subscribeisfalseby default. Set it totrueto subscribe to updates to the context provided value.


## ContextProvider
A ReactiveController which adds context provider behavior to a custom element by listening tocontext-requestevents.

Import:

``` ts
import {ContextProvider} from '@lit/context';
```

Constructor:

``` ts
ContextProvider(  host: ReactiveElement,  options: {    context: T,    initialValue?: ContextType<T>  })
```

Members

- setValue(v: T, force = false): voidSets the value provided, and notifies any subscribed consumers of the new value if the value changed.forcecauses a notification even if the value didn't change, which can be useful if an object had a deep property change.
setValue(v: T, force = false): void

Sets the value provided, and notifies any subscribed consumers of the new value if the value changed.forcecauses a notification even if the value didn't change, which can be useful if an object had a deep property change.


## ContextConsumer
A ReactiveController which adds context consuming behavior to a custom element by dispatchingcontext-requestevents.

Import:

``` ts
import {ContextConsumer} from '@lit/context';
```

Constructor:

``` ts
ContextConsumer(  host: HostElement,  options: {    context: C,    callback?: (value: ContextType<C>, dispose?: () => void) => void,    subscribe?: boolean = false  })
```

Members

- value: ContextType<C>The current value for the context.
value: ContextType<C>

The current value for the context.

When the host element is connected to the document it will emit acontext-requestevent with its context key. When the context request is satisfied the controller will invoke the callback, if present, and trigger a host update so it can respond to the new value.

It will also call the dispose method given by the provider when the host element is disconnected.


## ContextRoot
A ContextRoot can be used to gather unsatisfied context requests and re-dispatch them when new providers which satisfy matching context keys are available. This allows providers to be added to a DOM tree, or upgraded, after the consumers.

Import:

``` ts
import {ContextRoot} from '@lit/context';
```

Constructor:

``` ts
ContextRoot()
```

Members

- attach(element: HTMLElement): voidAttaches the ContextRoot to this element and starts listening tocontext-requestevents.
attach(element: HTMLElement): void

Attaches the ContextRoot to this element and starts listening tocontext-requestevents.

- detach(element: HTMLElement): voidDetaches the ContextRoot from this element, stops listening tocontext-requestevents.
detach(element: HTMLElement): void

Detaches the ContextRoot from this element, stops listening tocontext-requestevents.


## ContextEvent
The event fired by consumers to request a context value. The API and behavior of this event is specified by theContext Protocol.

Import:

``` ts
import {ContextEvent} from '@lit/context';
```

Thecontext-requestbubbles and is composed.

Members

- readonly context: CThe context object this event is requesting a value for
readonly context: C

The context object this event is requesting a value for

- readonly contextTarget: ElementThe DOM element that initiated the context request
readonly contextTarget: Element

The DOM element that initiated the context request

- readonly callback: ContextCallback<ContextType<C>>The function to call to provide a context value
readonly callback: ContextCallback<ContextType<C>>

The function to call to provide a context value

- readonly subscribe?: booleanWhether the consumers wants to subscribe to new context values
readonly subscribe?: boolean

Whether the consumers wants to subscribe to new context values


## ContextCallback
A callback which is provided by a context requester and is called with the value satisfying the request.

This callback can be called multiple times by context providers as the requested value is changed.

Import:

``` ts
import {type ContextCallback} from '@lit/context';
```

Signature:

``` ts
type ContextCallback<ValueType> = (  value: ValueType,  unsubscribe?: () => void) => void;
```

Edit this page


--------------------------------------------------------------------------------


# Signals
Source: https://lit.dev/docs/data/signals/


## Overview

## What are Signals?
Signals are data structures for managing observable state.

A signal can hold either a single value or a computed value that depends on other signals. Signals are observable, so that a consumer can be notified when they change. Because they form a dependency graph, computed signals will re-compute and notify consumers when their dependencies change.

Signals are very useful for modeling and managingshared observable state—state that many different components may access and/or modify. When a signal is updated, every component that uses and watches that signal, or any signals that depend on it, will update.

Signals are a general concept, with many different implementations and variations found in JavaScript libraries and frameworks. There is also now aTC39 proposalto standardize signals as part of JavaScript.

Signal APIs typically have three main concepts:

- State signals, which hold a single value
- Computed signals, which wrap a computation that may depend on other signals
- Watchers or effects, which run side-effectful code when signal values change

## Example
Here is an example of signals with the proposed standard JavaScript signals API:

``` ts
//// Code developers might write to build their signals-based state...//// State signals hold values:const count = new Signal.State(0);// Computed signals wrap computations that use other signals:const doubleCount = new Signal.Computed(() => count.get() * 2);//// Lower-level code of the sort that will typically be inside frameworks and// signal-consuming libraries...//// Watchers are notified when signals that they watch change:const watcher = new Signal.subtle.Watcher(async () => {  // Notify callbacks are not allowed to access signals synchronously  await 0;  console.log('doubleCount is', doubleCount);  // Watchers have to be re-enabled after they run:  watcher.watch();});watcher.watch(doubleCount);// Computed signals are lazy, so we need to read it to run the computation and// potentially notify watchers:doubleCount.get();
```


## Signal Libraries
There are many signal implementations built in JavaScript. Many are tightly integrated into frameworks and only usable from within those frameworks, and some are standalone libraries that are usable from any other code.

While there are some differences in the specific signals APIs, they are quite similar.

Preact's signal library,@preact/signals, is a standalone library that is relatively fast and small, so we built our first Lit Labs signals integration package around it:@lit-labs/preact-signals.


## Signals Proposal for JavaScript
Because of the strong similarities between signal APIs, the increasing use of signals to implement reactivity in frameworks, and the desire for interoperability between signal-using systems, a proposal for standardizing signals is now underway in TC39 athttps://github.com/tc39/proposal-signals.

Lit provides the@lit-labs/signalspackage to integrate with the official polyfill for this proposal.

This proposal is very exciting for the web components ecosystem. Because all libraries and frameworks that adopt the standard will produce compatible signals, different web components won't have to use the same library to interoperably consume and produce signals.

What's more, signals have the potential to become the foundation for a wide range of state management systems and observability libraries, new or existing. Each of these libraries, like MobX or Redux, currently requires a specific adapter to ergonomically integrate with the Lit lifecycle. Signals standardization could mean we eventually need only one Lit adapter (or no adapter at all, when support for signals is built into the core Lit library).


## Signals and Lit
Lit currently provides two signals integration packages:@lit-labs/signalsfor integration with the TC39 Signals Proposal, and@lit-labs/preact-signalsfor integration with Preact Signals.

Because the TC39 Signals Proposal promises to be the one signal API that JavaScript systems converge on, we recommend using it, and will focus on its usage in this document.


## Installation
Install@lit-labs/signalsfrom npm:

``` sh
npm i @lit-labs/signals
```


## Usage
@lit-labs/signalsprovides three main exports:

- TheSignalWatchermixin to apply to all classes using signals
- Thewatch()template directive to watch individual signals with pinpoint updates
- Thehtmltemplate tag to apply the watch directive automatically to template bindings
Import these like so:

``` ts
import {SignalWatcher, watch, signal} from '@lit-labs/signals';
```

@lit-labs/signalsalso exports some of the polyfilled signals API for convenience, and awithWatch()template tag factory so that developers who need custom template tags can easily add signal-watching functionality.

This simplest way to use signals is to apply theSignalWatchermixin when defining your Custom Element class. With the mixin applied, you can read signals in Lit lifecycle methods (likerender()); any changes to the values of those signals will automatically initiate an update. You can write signals wherever it makes sense—for example, in event handlers.

In this example, theSharedCounterComponentreads and writes to a shared signal. Every instance of the component will show the same value, and they will all update when the value changes.

``` ts
import {LitElement, html, css} from 'lit';import {customElement} from 'lit/decorators.js';import {SignalWatcher, signal} from '@lit-labs/signals';const count = signal(0);@customElement('shared-counter')export class SharedCounterComponent extends SignalWatcher(LitElement) {  static styles = css`    :host {      display: block;    }  `;  render() {    return html`      <p>The count is ${count.get()}</p>      <button @click=${this.#onClick}>Increment</button>    `;  }  #onClick() {    count.set(count.get() + 1);  }}
```

``` html
<!-- Both of these elements will show the same counter value --><shared-counter></shared-counter><shared-counter></shared-counter>
```

Signals can also be used to achieve "pinpoint" DOM updates targeting individual bindings rather than an entire component. To do this, we need to watch signals individually with thewatch()directive.

For coordination purposes, updates triggered by thewatch()directive are batched and still participate in the Lit reactive update lifecycle. However, when a given Lit update has been triggered purely bywatch()directives, the only bindings updated are those with changed signals; the rest of the bindings in the template are skipped.

This example is the same as the previous, but only the${watch(count)}binding is updated when thecountsignal changes:

``` ts
import {LitElement, html} from 'lit';import {customElement} from 'lit/decorators.js';import {SignalWatcher, watch, signal} from '@lit-labs/signals';const count = signal(0);@customElement('shared-counter')export class SharedCounterComponent extends SignalWatcher(LitElement) {  static styles = css`    :host {      display: block;    }  `;  render() {    return html`      <p>The count is ${watch(count)}</p>      <button @click=${this.#onClick}>Increment</button>    `;  }  #onClick() {    count.set(count.get() + 1);  }}
```

Note that the work avoided by this pinpoint update is actually very little: the only things skipped are the identity check for the template returned byrender()and the value check for the@clickbinding, both of which are cheap.

In fact, in most caseswatch()willnotresult in a significant performance improvement over "plain" Lit template renders. This is because Lit already only updates the DOM for bindings that have changed values.

The performance savings ofwatch()will tend to scale with the amount of template logic and the number of bindings that can be skipped in an update, so savings will be more significant in templates with lots of logic and bindings.

@lit-labs/signalsdoes not yet contain a signal-awarerepeat()directive. Changes to the contents of arrays will perform full renders until then.

@lit-labs/signalsalso exports a special version of Lit'shtmltemplate tag that automatically applies thewatch()directive to any signal value passed to a binding.

This can be convenient to avoid the extra characters of thewatch()directive or thesignal.get()calls required withoutwatch().

If you importhtmlfrom@lit-labs/signalsinstead of fromlit, you will get the auto-watching feature:

``` ts
import {LitElement} from 'lit';import {SignalWatcher, html, signal} from '@lit-labs/signals';// SharedCounterComponent ...  render() {    return html`      <p>The count is ${count}</p>      <button @click=${this.#onClick}>Increment</button>    `;  }
```

The signalshtmltag doesn't yet work well with lit-analyzer. The analyzer will report type errors on bindings that use signals becuase it sees an assigment ofSignal<T>toT.


## Ensuring proper polyfill installation
@lit-labs/signalsincludes thesignal-polyfillpackage as a dependency, so you don't need to explicitly install anything else to start using signals.

But since signals rely on a shared global data structure (the signal dependency graph), it's critically important that the polyfill is installed properly: there can be only one copy of the polyfill package in any page or app.

If more than one copy of the polyfill is installed (either because of incompatible versions or other npm mishaps) then it's possible topartitionthe signal graph so that some watchers will not work with some signals, or some signals will not be tracked as dependencies of others.

To prevent this, be sure to check that there's only one installation ofsignal-polyfill, using thenpm lscommand:

``` sh
npm ls signal-polyfill
```

If you see more than one listing forsignal-polyfillwithoutdedupednext to the line, then you have duplicate copies of the polyfill.

You can usually fix this by running:

``` sh
npm dedupe
```

If that doesn't work, you may have to update dependencies until you get a single compatible version ofsignal-polyfillacross your package installation.


## Missing Features
@lit-labs/signalsis not feature-complete. There are a few envisioned features that will make working with signals in Lit more viable and performant:

- [ ] A signal-awarerepeat()directive. This will make incremental updates to arrays more efficient.
- [ ] A@property()decorator that uses signals for storage, to unify reactive properties and signals. This will make it easier to use generic signal utilities with Lit reactive properties.
- [ ] A@computed()decorator for marking methods as computed signals. Since computed signals are memoized, this can help with expensive computations.
- [ ] An@effect()decorator for marking methods as effects. This can be a more ergonomic way of running effects than using a separate utility.

## Useful Resources

## signal-utils
Thesignal-utilsnpm package contains a number of utilities for working with the TC39 Signals Proposal, including:

- Signal-backed, observable, collections likeArray,Map,Set,WeakMap,WeakSet, andObject
- Decorators for building classes with signal-backed fields
- Effects and reactions
These collections and decorators are useful for building observable data models from signals, where you will often need to manage values more complicated than a primitive.

For instance, you can make an observable array:

``` ts
import {SignalArray} from 'signal-utils/array';const numbers = new SignalArray([1, 2, 3]);
```

Reading from the array, like iterating over it or reading.lengthwill be tracked as signal access, and mutations of the array, like from.push()or.pop(), will notify any watchers.

The decorators let you model a class with observable fields, much like aLitElement:

``` ts
import {signal} from 'signal-utils';class GameState {  @signal  accessor playerOneTotal = 0;  @signal  accessor playerTwoTotal = 0;  @signal  accessor over = false;  readonly rounds = new SignalArray();  recordRound(playerOneScore, playerTwoScore) {    this.playerOneTotal += playerOneScore;    this.playerTwoTotal += playerTwoScore;    this.rounds.push([playerOneScore, playerTwoScore]);  }}
```

Instances of thisGameStateclass will be tracked by SignalWatcher classes that access it, and will update when the game state changes.


## Status and Feedback
This package is part of the Lit Labs family of experimental packages and under active development. There may be missing features, serious bugs in the implementation, and more frequent breaking changes than with the core Lit libraries.

This package also relies on a proposal and polyfill that themselves are not stable. As the signals proproposal progresses, breaking changes may be made to the proposed API, which will then be made to the polyfill.

We encourage cautious use in order for us to gain experience with and get feedback on the Lit integration layer, but please manage dependencies carefully and test judiciously so that unexpected breaking changes are kept to a minimum.

Please leave feedback on the@lit-labs/signals feedback discussion, andfile any issuesyou encounter.

Feedback on the Signals proposal can be left on theSignals proposal repository. Issues with the polyfill can be filedhere.

Edit this page


--------------------------------------------------------------------------------


# Async Tasks
Source: https://lit.dev/docs/data/task/


## Overview
Sometimes a component needs to render data that is only availableasynchronously. Such data might be fetched from a server, a database, or in general retrieved or computed from an async API.

While Lit's reactive update lifecycle is batched and asynchronous, Lit templates always rendersynchronously. The data used in a template must be readable at the time of rendering. To render async data in a Lit component, you must wait for the data to be ready, store it so that it's readable, then trigger a new render which can use the data synchronously. Considerations must often be made on what to render while the data is being fetched, or when the data fetch fails as well.

The@lit/taskpackage provides aTaskreactive controller to help manage this async data workflow.

Taskis a controller that takes an async task function and runs it either manually or automatically when its arguments change. Task stores the result of the task function and updates the host element when the task function completes so the result can be used in rendering.


## Example
This is an example of usingTaskto call an HTTP API viafetch(). The API is called whenever theproductIdparameter changes, and the component renders a loading message when the data is being fetched.

``` ts
import {Task} from '@lit/task';class MyElement extends LitElement {  @property() productId?: string;  private _productTask = new Task(this, {    task: async ([productId], {signal}) => {      const response = await fetch(`http://example.com/product/${productId}`, {signal});      if (!response.ok) { throw new Error(response.status); }      return response.json() as Product;    },    args: () => [this.productId]  });  render() {    return this._productTask.render({      pending: () => html`<p>Loading product...</p>`,      complete: (product) => html`          <h1>${product.name}</h1>          <p>${product.price}</p>        `,      error: (e) => html`<p>Error: ${e}</p>`    });  }}
```

``` js
import {Task} from '@lit/task';class MyElement extends LitElement {  static properties = {    productId: {},  };  _productTask = new Task(this, {    task: async ([productId], {signal}) => {      const response = await fetch(`http://example.com/product/${productId}`, {signal});      if (!response.ok) { throw new Error(response.status); }      return response.json();    },    args: () => [this.productId]  });  render() {    return this._productTask.render({      pending: () => html`<p>Loading product...</p>`,      complete: (product) => html`          <h1>${product.name}</h1>          <p>${product.price}</p>        `,      error: (e) => html`<p>Error: ${e}</p>`    });  }}
```


## Features
Task takes care of a number of things needed to properly manage async work:

- Gathers task arguments when the host updates
- Runs task functions when arguments change
- Tracks the task status (initial, pending, complete, or error)
- Saves the last completion value or error of the task function
- Triggers a host update when the task changes status
- Handles race conditions, ensuring that only the latest task invocation completes the task
- Renders the correct template for the current task status
- Allows aborting tasks with anAbortController
This removes most of the boilerplate for correctly using async data from your code, and ensures robust handling of race conditions and other edge-cases.


## What is async data?
Async data is data that's not available immediately, but may be available at some time in the future. For example, instead of a value like a string or an object that's usable synchronously, a promise provides a value in the future.

Async data is usually returned from an async API, which can come in a few forms:

- Promises or async functions, likefetch()
- Functions that accept callbacks
- Objects that emit events, such as DOM events
- Libraries like observables and signals
The Task controller deals in promises, so no matter the shape of your async API you can adapt it to promises to use with Task.


## What is a task?
At the core of the Task controller is the concept of a "task" itself.

A task is an async operation which does some work to produce data and return it in a Promise. A task can be in a few different states (initial, pending, complete, and error) and can take parameters.

A task is a generic concept and could represent any async operation. They apply best when there is a request/response structure, such as a network fetch, database query, or waiting for a single event in response to some action. They're less applicable to spontaneous or streaming operations like an open-ended stream of events, a streaming database response, etc.


## Installation
``` bash
npm install @lit/task
```


## Usage
Taskis areactive controller, so it can respond to and trigger updates to Lit's reactive update lifecycle.

You'll generally have one Task object for each logical task that your component needs to perform. Install tasks as fields on your class:

``` ts
class MyElement extends LitElement {  private _myTask = new Task(this, {/*...*/});}
```

``` js
class MyElement extends LitElement {  _myTask = new Task(this, {/*...*/});}
```

As a class field, the task status and value are easily available:

``` ts
this._task.status;this._task.value;
```


## The task function
The most critical part of a task declaration is thetask function. This is the function that does the actual work.

The task function is given in thetaskoption. The Task controller will automatically call the task function with arguments, which are supplied with a separateargscallback. Arguments are checked for changes and the task function is only called if the arguments have changed.

The task function takes the task arguments as anarraypassed as the first parameter, and an options argument as the second parameter:

``` ts
new Task(this, {  task: async ([arg1, arg2], {signal}) => {    // do async work here  },  args: () => [this.field1, this.field2]})
```

The task function's args array and the args callback should be the same length.

Write thetaskandargsfunctions as arrow functions so that thethisreference points to the host element.


## Task status
Tasks can be in one of four states:

- INITIAL: The task has not been run
- PENDING: The task is running and awaiting a new value
- COMPLETE: The task completed successfully
- ERROR: The task errored
The Task status is available at thestatusfield of the Task controller, and is represented by theTaskStatusenum-like object, which has propertiesINITIAL,PENDING,COMPLETE, andERROR.

``` ts
import {TaskStatus} from '@lit/task';// ...  if (this.task.status === TaskStatus.ERROR) {    // ...  }
```

Usually a Task will proceed fromINITIALtoPENDINGto one ofCOMPLETEorERROR, and then back toPENDINGif the task is re-run. When a task changes status it triggers a host update so the host element can handle the new task status and render if needed.

It's important to understand the status a task can be in, but it's not usually necessary to access it directly.

There are a few members on the Task controller that relate to the state of the task:

- status: the status of the task.
- value: the current value of the task, if it has completed.
- error: the current error of the task, if it has errored.
- render(): a method that chooses a callback to run based on the current status.

## Rendering Tasks
The simplest and most common API to use to render a task istask.render(), since it chooses the right code to run and provides it the relevant data.

render()takes a config object with an optional callback for each task status:

- initial()
- pending()
- complete(value)
- error(err)
You can usetask.render()inside a Litrender()method to render templates based on the task status:

``` ts
  render() {    return html`      ${this._myTask.render({        initial: () => html`<p>Waiting to start task</p>`,        pending: () => html`<p>Running task...</p>`,        complete: (value) => html`<p>The task completed with: ${value}</p>`,        error: (error) => html`<p>Oops, something went wrong: ${error}</p>`,      })}    `;  }
```


## Running tasks
By default, Tasks will run any time the arguments change. This is controlled by theautoRunoption, which defaults totrue.

Inauto-runmode, the task will call theargsfunction when the host has updated, compare the args to the previous args, and invoke the task function if they have changed. A task with an emptyargsarray runs once. A task withoutargsdefined is in manual mode.

IfautoRunis set to false, the task will be inmanualmode. In manual mode you can run the task by calling the.run()method, possibly from an event handler:

``` ts
class MyElement extends LitElement {  private _getDataTask = new Task(    this,    {      task: async () => {        const response = await fetch(`example.com/data/`);        return response.json();      },      args: () => []    }  );  render() {    return html`      <button @click=${this._onClick}>Get Data</button>    `;  }  private _onClick() {    this._getDataTask.run();  }}
```

``` js
class MyElement extends LitElement {  _getDataTask = new Task(    this,    {      task: async () => {        const response = await fetch(`example.com/data/`);        return response.json();      },      args: () => []    }  );  render() {    return html`      <button @click=${this._onClick}>Get Data</button>    `;  }  _onClick() {    this._getDataTask.run();  }}
```

In manual mode you can provide new arguments directly torun():

``` ts
this._task.run(['arg1', 'arg2']);
```

If arguments are not provided torun(), they are gathered from theargscallback.


## Aborting tasks
A task function can be called while previous task runs are still pending. In these cases the result of the pending task runs will be ignored, and you should try to cancel any outstanding work or network I/O in order to save resources.

You can do with with theAbortSignalthat is passed in thesignalproperty of the second argument to the task function. When a pending task run is superseded by a new run, theAbortSignalthat was passed to the pending run is aborted to signal the task run to cancel any pending work.

AbortSignaldoesn't cancel any work automatically - it is just a signal. To cancel some work you must either do it yourself by checking the signal, or forward the signal to another API that acceptsAbortSignals likefetch()oraddEventListener().

The easiest way to use theAbortSignalis to forward it to an API that accepts it, likefetch().

``` ts
  private _task = new Task(this, {    task: async (args, {signal}) => {      const response = await fetch(someUrl, {signal});      // ...    },  });
```

``` js
  _task = new Task(this, {    task: async (args, {signal}) => {      const response = await fetch(someUrl, {signal});      // ...    },  });
```

Forwarding the signal tofetch()will cause the browser to cancel the network request if the signal is aborted.

You can also check if a signal has been aborted in your task function. You should check the signal after returning to a task function from an async call.throwIfAborted()is a convenient way to do this:

``` ts
  private _task = new Task(this, {    task: async ([arg1], {signal}) => {      const firstResult = await doSomeWork(arg1);      signal.throwIfAborted();      const secondResult = await doMoreWork(firstResult);      signal.throwIfAborted();      return secondResult;    },  });
```

``` js
  _task = new Task(this, {    task: async ([arg1], {signal}) => {      const firstResult = await doSomeWork(arg1);      signal.throwIfAborted();      const secondResult = await doMoreWork(firstResult);      signal.throwIfAborted();      return secondResult;    },  });
```


## Task chaining
Sometimes you want to run one task when another task completes. This can be useful if the tasks have different arguments so that the chained task may run without the first task running again. In this case it'll use the first task like a cache. To do this you can use the value of a task as an argument to another task:

``` ts
class MyElement extends LitElement {  private _getDataTask = new Task(this, {    task: ([dataId]) => getData(dataId),    args: () => [this.dataId],  });  private _processDataTask = new Task(this, {    task: ([data, param]) => processData(data, param),    args: () => [this._getDataTask.value, this.param],  });}
```

``` js
class MyElement extends LitElement {  _getDataTask = new Task(this, {    task: ([dataId]) => getData(dataId),    args: () => [this.dataId],  });  _processDataTask = new Task(this, {    task: ([data, param]) => processData(data, param),    args: () => [this._getDataTask.value, this.param],  });}
```

You can also often use one task function and await intermediate results:

``` ts
class MyElement extends LitElement {  private _getDataTask = new Task(this, {    task: ([dataId, param]) => {      const data = await getData(dataId);      return processData(data, param);    },    args: () => [this.dataId, this.param],  });}
```

``` js
class MyElement extends LitElement {  _getDataTask = new Task(this, {    task: ([dataId, param]) => {      const data = await getData(dataId);      return processData(data, param);    },    args: () => [this.dataId, this.param],  });}
```


## More accurate argument types in TypeScript
Task argument types can sometimes be inferred too loosely by TypeScript. This can be fixed by casting argument arrays withas const. Consider the following task, with two arguments.

``` ts
class MyElement extends LitElement {  @property() myNumber = 10;  @property() myText = "Hello world";  _myTask = new Task(this, {    args: () => [this.myNumber, this.myText],    task: ([number, text]) => {      // implementation omitted    }  });}
```

As written, the type of the argument list to the task function is inferred asArray<number | string>.

But ideally this would be typed as a tuple[number, string]because the size and position of the args is fixed.

The return value ofargscan be written asargs: () => [this.myNumber, this.myText] as const, which will result in a tuple type for the args list to thetaskfunction.

``` ts
class MyElement extends LitElement {  @property() myNumber = 10;  @property() myText = "Hello world";  _myTask = new Task(this, {    args: () => [this.myNumber, this.myText] as const,    task: ([number, text]) => {      // implementation omitted    }  });}
```

Edit this page


--------------------------------------------------------------------------------


# React
Source: https://lit.dev/docs/frameworks/react/

The@lit/reactpackage provides utilities to create React wrapper components for web components, and custom hooks fromreactive controllers.

The React component wrapper enables setting properties on custom elements (instead of just attributes), mapping DOM events to React-style callbacks, and enables correct type-checking in JSX by TypeScript.

The wrappers are targeted at two different audiences:

- Users of web components can wrap components and controllers for their own use in their own React projects.
- Vendors of components can publish React wrappers so that their React users have idiomatic versions of their components.

## Why are wrappers needed?
React can already render web components, since custom elements are just HTML elements and React knows how to render HTML. But React makes some assumptions about HTML elements that don't always hold for custom elements, and it treats lower-case tag names differently from upper-case component names in ways that can make custom elements harder than necessary to use.

For instance, React assumes that all JSX properties map to HTML element attributes, and provides no way to set properties. This makes it difficult to pass complex data (like objects, arrays, or functions) to web components. React also assumes that all DOM events have corresponding "event properties" (onclick,onmousemove, etc), and uses those instead of callingaddEventListener(). This means that to properly use more complex web components you often have to useref()and imperative code. (For more information on the limitations of React's web component integration, seeCustom Elements Everywhere.)

React is working on fixes to these issues, but in the meantime, our wrappers take care of setting properties and listening to events for you.

The@lit/reactpackage provides two main exports:

- createComponent()creates a React component thatwrapsan existing web component. The wrapper allows you to set props on the component and add event listeners to the component like you would any other React component.
createComponent()creates a React component thatwrapsan existing web component. The wrapper allows you to set props on the component and add event listeners to the component like you would any other React component.

- useController()lets you use a Lit reactive controller as a React hook.
useController()lets you use a Lit reactive controller as a React hook.


## createComponent
ThecreateComponent()function makes a React component wrapper for a custom element class. The wrapper correctly passes Reactpropsto properties accepted by the custom element and listens for events dispatched by the custom element.


## Usage
ImportReact, a custom element class, andcreateComponent.

``` js
import React from 'react';import {createComponent} from '@lit/react';import {MyElement} from './my-element.js';export const MyElementComponent = createComponent({  tagName: 'my-element',  elementClass: MyElement,  react: React,  events: {    onactivate: 'activate',    onchange: 'change',  },});
```

After defining the React component, you can use it just as you would any other React component.

``` jsx
<MyElementComponent  active={isActive}  onactivate={(e) => setIsActive(e.active)}  onchange={handleChange}/>
```

See it in action in theReact playground examples.

createComponenttakes an options object with the following properties:

- tagName: The custom element's tag name.
- elementClass: The custom element class.
- react: The importedReactobject. This is used to create the wrapper component with the user suppliedReact. This can also be an import ofpreact-compat.
- events: An object that maps an event handler prop to an event name fired by the custom element.
Children of component created withcreateComponent()will render to the default slot of the custom element.

``` jsx
<MyElementComponent>  <p>This will render in the default slot.</p></MyElementComponent>
```

To render the child to a specific named slot, the standardslotattribute can be added.

``` jsx
<MyElementComponent>  <p slot="foo">This will render in the slot named "foo".</p></MyElementComponent>
```

Since React components are not themselves HTML elements, they usually cannot directly have aslotattribute. To render into a named slot, the component will need to be wrapped with a container element that has aslotattribute. If a wrapper element interferes with styling, like for grid and flexbox layouts, giving it adisplay: contents;style (See MDN for details) will remove the container from rendering, and only render its children.

``` jsx
<MyElementComponent>  <div slot="foo" style="display: contents;">    <ReactComponent />  </div></MyElementComponent>
```

Try it out in theReact slots playground example.

Theeventsoption takes an object that maps React prop names to event names. When a component user passes a callback prop with one of the event prop names, the wrapper will add it as an event handler for the corresponding event.

While the React prop name can be whatever you want, the recommended convention is to addonin front of the event name. This matches how React is planning to implement event support for custom elements. You should also make sure this prop name does not collide with any existing properties on the element.

In TypeScript, the event type can be specified by casting the event name to theEventNameutility type. This is a good practice to do so that React users will get the most accurate types for their event callbacks.

TheEventNametype is a string that takes an event interface as a type parameter. Here we cast the'my-event'name to anEventName<MyEvent>to provide the right event type:

``` ts
import React from 'react';import {createComponent, type EventName} from '@lit/react';import {MyElement, MyEvent} from './my-element.js';export const MyElementComponent = createComponent({  tagName: 'my-element',  elementClass: MyElement,  react: React,  events: {    'onmy-event': 'my-event' as EventName<MyEvent>,  },});
```

Casting the event name toEventName<MyEvent>causes the React component to have anonMyEventcallback prop that accepts aMyEventparameter instead of a plainEvent:

``` tsx
<MyElementComponent  onmy-event={(e: MyEvent) => {    console.log(e.myEventData);  }}/>
```


## How it works
During a render, the wrapper receives props from React and based on the options and the custom element class, changes the behavior of some of the props:

- If a prop name is a property on the custom element, as determined with anincheck, the wrapper sets that property on the element to the prop value
- If a prop name is an event name passed to theeventsoption, the prop value is passed toaddEventListener()with the name of the event.
- Otherwise the prop is passed to React'screateElement()to be rendered as an attribute.
Both properties and events are added incomponentDidMount()andcomponentDidUpdate()callbacks, because the element must have already been instantiated by React in order to access it.

For events,createComponent()accepts a mapping of React event prop names to events fired by the custom element. For example passing{onfoo: 'foo'}means a function passed via a prop namedonfoowill be called when the custom element fires thefooevent with the event as an argument.


## useController
Reactive controllers allow developers to hook in to a component's lifecycle to bundle together state and behavior related to a feature. They are similar to React hooks in the user cases and capabilities, but are plain JavaScript objects instead of functions with hidden state.

useController()lets you make React hooks out of reactive controllers allowing for the sharing of state and behaviors across web components and React.


## Usage
``` jsx
import React from 'react';import {useController} from '@lit/react/use-controller.js';import {MouseController} from '@example/mouse-controller';// Write a custom React hook function:const useMouse = () => {  // Use useController to create and store a controller instance:  const controller = useController(React, (host) => new MouseController(host));  // Return relevant data for consumption by the component:  return controller.pos;};// Now use the new hook in a React component:const Component = (props) => {  const mousePosition = useMouse();  return (    <pre>      x: {mousePosition.x}      y: {mousePosition.y}    </pre>  );};
```

See themouse controller examplein the reactive controller docs for its implementation.


## How it works
useController()creates a custom host object for the controller passed to it and drives the controller's lifecycle by using React hooks.

- useState()is used to store an instance of a controller and aReactControllerHost
- The hook body anduseLayoutEffect()callbacks emulate theReactiveElementlifecycle as closely as possible.
- ReactControllerHostimplementsaddController()so that controller composition works and nested controller lifecycles are called correctly.
- ReactControllerHostalso implementsrequestUpdate()by calling auseState()setter, so that a controller can cause its host component to re-render.
Edit this page


--------------------------------------------------------------------------------


# Getting Started
Source: https://lit.dev/docs/getting-started/

There are many ways to get started using Lit, from our Playground and interactive tutorial to installing into an existing project.


## Lit Playground
Get started right away with the interactive playground and examples. Start with "Hello World", then customize it or move on to more examples.


## Interactive tutorial
Take ourstep-by-step tutorialto learn how to build a Lit component in minutes.


## Lit starter kits
We provide TypeScript and JavaScript component starter kits for creating standalone reusable components. SeeStarter Kits.


## Install locally from npm
Lit is available as thelitpackage via npm.

``` sh
npm i lit
```

Then import into JavaScript or TypeScript files:

``` ts
import {LitElement, html} from 'lit';import {customElement, property} from 'lit/decorators.js';
```

``` js
import {LitElement, html} from 'lit';
```


## Use bundles
Lit is also available as pre-built, single-file bundles. These are provided for more flexibility around development workflows: for example, if you would prefer to download a single file rather than use npm and build tools. The bundles are standard JavaScript modules with no dependencies - any modern browser should be able to import and run the bundles from within a<script type="module">like this:

``` js
import {LitElement, html} from 'https://cdn.jsdelivr.net/gh/lit/dist@3/core/lit-core.min.js';
```

If you're using npm for client-side dependencies, you should usethelitpackage, not these bundles.The bundles intentionally combine most or all of Lit into a single file, which can cause your page to download more code than it needs.

To browse the bundles, go tohttps://cdn.jsdelivr.net/gh/lit/dist/and use the dropdown menu to go to the page for a particular version. On that page, there will be a directory for each type of bundle available for that version. There are two types of bundles:


## Add Lit to an existing project
SeeAdding Lit to an existing projectfor instructions on adding Lit to an existing project or application.


## Open WC project generator
The Open WC project has aproject generatorthat can scaffold out an application project using Lit.

Edit this page


--------------------------------------------------------------------------------


# Lit Labs
Source: https://lit.dev/docs/libraries/labs/

Lit Labs is an umbrella for Lit packages under development that we are actively seeking feedback on. While we encourage real-world use in order to help the feedback process, please note:

- Lit Labs projects are published under the@lit-labsnpm scope.
- Breaking changes are likely to occur more frequently than in non-labs packages, but they will still respect standard semantic versioning guildelines and all changes will be published to the CHANGELOG files.
- While we strive to address all bugs in a timely fashion, bugs in non-labs projects typically receive higher priority than bugs in labs projects.
- When a Lit Labs project is ready to graduate out of labs, we'll begin publishing it under the@litscope. (For example,@lit-labs/taskgraduated to@lit/task.) Once a package graduates, its first version under the@litscope will match that of the latest in@lit-labs—but only the@litversion will receive subsequent updates.
- We may decide to deprecate a Lit Labs project. In such cases, we will notify the community, and a deprecation warning will be added to the npm package. The deprecated package will receive bug fix support for at least 6 months. A record of historical labs packages will be kept on this page.
Feedback is currently being solicited on the following Labs packages:

scoped-registry-mixin

Mixin for Lit that integrates with the speculativeScoped CustomElementRegistry polyfill.

📄 Docs💬 Feedback🐞 Issues

eleventy-plugin-lit

A plugin forEleventythat pre-renders Lit components at build time, with optional hydration.

📄 Docs💬 Feedback🐞 Issues

motion

📄 Docs💬 Feedback🐞 Issues

observers

📄 Docs💬 Feedback🐞 Issues

signals

📄 Docs💬 Feedback🐞 Issues

ssr

📄 Docs💬 Feedback🐞 Issues

testing

📄 Docs💬 Feedback🐞 Issues

virtualizer

📄 Docs💬 Feedback🐞 Issues

analyzer

📄 Docs🐞 Issues

cli

📄 Docs🐞 Issues

compiler

📄 Docs💬 Feedback🐞 Issues

preact-signals

📄 Docs💬 Feedback🐞 Issues

router

📄 Docs💬 Feedback🐞 Issues

Edit this page


--------------------------------------------------------------------------------


# Using lit-html standalone
Source: https://lit.dev/docs/libraries/standalone-templates/

Lit combines the component model of LitElement with JavaScript template literal-based rendering into an easy-to-use package. However, the templating portion of Lit is factored into a standalone library calledlit-html, which can be used outside of the Lit component model anywhere you need to efficiently render and update HTML.


## lit-html standalone package
Thelit-htmlpackage can be installed separately fromlit:

``` sh
npm install lit-html
```

The main imports arehtmlandrender:

``` js
import {html, render} from 'lit-html';
```

The standalonelit-htmlpackage also includes modules for the following features described in the fullLitdeveloper guide:

- lit-html/directives/*-Built-in directives
- lit-html/directive.js-Custom directives
- lit-html/async-directive.js-Custom async directives
- lit-html/directive-helpers.js-Directive helpers for imperative updates
- lit-html/static.js-Static html tag
- lit-html/polyfill-support.js- Support for interfacing with the web components polyfills (seeStyles and lit-html templates)

## Rendering lit-html templates
Lit templates are written using JavaScript template literals tagged with thehtmltag. The contents of the literal are mostly plain, declarative HTML, and may include expressions to insert and update the dynamic parts of a template (seeTemplatesfor a full reference on Lit's templating syntax).

``` html
html`<h1>Hello ${name}</h1>`
```

A lit-html template expression does not cause any DOM to be created or updated. It's only a description of DOM, called aTemplateResult. To actually create or update DOM, you need to pass theTemplateResultto therender()function, along with a container to render to:

``` js
import {html, render} from 'lit-html';const name = 'world';const sayHi = html`<h1>Hello ${name}</h1>`;render(sayHi, document.body);
```


## Render dynamic data
To make your template dynamic, you can create atemplate function. Call the template function any time your data changes.

``` js
import {html, render} from 'lit-html';// Define a template functionconst myTemplate = (name) => html`<div>Hello ${name}</div>`;// Render the template with some datarender(myTemplate('earth'), document.body);// ... Later on ...// Render the template with different datarender(myTemplate('mars'), document.body);
```

When you call the template function, lit-html captures the current expression values. The template function doesn't create any DOM nodes, so it's fast and cheap.

The template function returns aTemplateResultthat contains the template and the input data. This is one of the main principles behind using lit-html:creating UI as afunctionof state.

When you callrender,lit-html only updates the parts of the template that have changed since the last render.This makes lit-html updates very fast.


## Render Options
Therendermethod also takes anoptionsargument that allows you to specify the following options:

- host: Thethisvalue to use when invoking event listeners registered with the@eventNamesyntax. This option only applies when you specify an event listener as a plain function. If you specify the event listener using an event listener object, the listener object is used as thethisvalue. SeeEvent listener expressionsfor more on event listeners.
host: Thethisvalue to use when invoking event listeners registered with the@eventNamesyntax. This option only applies when you specify an event listener as a plain function. If you specify the event listener using an event listener object, the listener object is used as thethisvalue. SeeEvent listener expressionsfor more on event listeners.

- renderBefore: An optional reference node within thecontainerbefore which lit-html will render. By default, lit-html will append to the end of the container. SettingrenderBeforeallows rendering to a specific spot within the container.
renderBefore: An optional reference node within thecontainerbefore which lit-html will render. By default, lit-html will append to the end of the container. SettingrenderBeforeallows rendering to a specific spot within the container.

- creationScope: The object lit-html will callimportNodeon when cloning templates (defaults todocument). This is provided for advanced use cases.
creationScope: The object lit-html will callimportNodeon when cloning templates (defaults todocument). This is provided for advanced use cases.

For example, if you're usinglit-htmlstandalone, you might use render options like this:

``` html
<div id="container">  <header>My Site</header>  <footer>Copyright 2021</footer></div>
```

``` ts
const template = () => html`...`;const container = document.getElementById('container');const renderBefore = container.querySelector('footer');render(template(), container, {renderBefore});
```

The above example would render the template between the<header>and<footer>elements.

Render options must be constant.Render options shouldnotchange between subsequentrendercalls.


## Styles and lit-html templates
lit-html focuses on one thing: rendering HTML. How you apply styles to the HTML lit-html creates depends on how you're using it—for example, if you're using lit-html inside a component system like LitElement, you can follow the patterns used by that component system.

In general, how you style HTML will depend on whether you're using shadow DOM:

- If you are not rendering into shadow DOM, you can style HTML using global style sheets.
- If are rendering into shadow DOM, then you can render<style>tags inside the shadow root.
Styling shadow roots on legacy browsers requires polyfills.Using theShadyCSSpolyfill with standalonelit-htmlrequires loadinglit-html/polyfill-support.jsand passing ascopeoption inRenderOptionswith the host tag name for scoping the rendered content. Although this approach is possible, we recommend usingLitElementif you want to support rendering lit-html templates to shadow DOM on legacy browsers.

To help with dynamic styling, lit-html provides two directives for manipulating an element'sclassandstyleattributes:

- classMapsets classes on an element based on the properties of an object.
- styleMapsets the styles on an element based on a map of style properties and values.
Edit this page


--------------------------------------------------------------------------------


# Localization best practices
Source: https://lit.dev/docs/localization/best-practices/


## Ensure re-evaluation on render
Each time themsgfunction is called, it returns a version of the given string or Lit template in the active locale. However, this result is just a normal string or template; it is notintrinsicallycapable of re-rendering itself when the locale changes.

For this reason, it is important to writemsgcalls in a way that ensures they will be re-evaluated each time the Litrendermethod runs. This way, when the locale changes, the correct string or template for the latest locale will be returned.

One situation where it is easy to make a mistake here is when localizing property default values. It may seem natural to write this:

``` js
// Don't do this!label = msg('Default label')render() {  return html`<button>${this.label}</button>`;}
```

However, the above pattern provides no opportunity for the default label to be updated when the locale changes. The default value will get stuck at the version from the locale that happened to be active when the element was instantiated.

A simple fix is to move the default value fallback directly into the render method:

``` js
render() {  return html`<button>${this.label ?? msg('Default label')}</button>`;}
```

Alternatively, a custom getter/setter can be used to create a more natural interface:

``` ts
private _label?: string;@property()get label() {  return this._label ?? msg('Default label');}set label(label: string) {  this._label = label;}render() {  return html`<button>${this.label}</button>`;}
```

``` js
static properties = {  label: {}};get label() {  return this._label ?? msg('Default label');}set label(label) {  this._label = label;}render() {  return html`<button>${this.label}</button>`;}
```


## Avoid unnecessary HTML markup
While@lit/localizehas full support for embedding HTML markup inside localized templates, it's best to avoid doing so whenever possible. This is because:

- It's easier for translators to deal with simple string phrases instead of phrases with embedded markup.
It's easier for translators to deal with simple string phrases instead of phrases with embedded markup.

- It avoids unnecessary re-translation work when markup changes, such as when adding a class that affects appearance without changing the meaning.
It avoids unnecessary re-translation work when markup changes, such as when adding a class that affects appearance without changing the meaning.

- It will typically be faster to swap locales, because fewer parts of the DOM will need to update. Also, less JavaScript will be included in your bundles, because common markup will not need to be duplicated into each translation.
It will typically be faster to swap locales, because fewer parts of the DOM will need to update. Also, less JavaScript will be included in your bundles, because common markup will not need to be duplicated into each translation.

Not ideal:

``` js
render() {  // Don't do this! There's no reason to include the <button> tag in this  // localized template.  return msg(html`<button>Launch rocket</button>`);}
```

Ideal:

``` js
render() {  // Much better! Now the phrase "Launch rocket" can be translated more easily  // in isolation.  return html`<button>${msg('Launch rocket')}</button>`;}
```

Breaking templates into smaller pieces can also be helpful:

``` js
render() {  // Don't do this!  return msg(html`  <p>The red button makes the rocket go up.</p>  <p>The green button makes the rocket do a flip.</p>  `);}
```

``` js
render() {  // Better! No markup needs to be processed by translators, and each sentence  // can be translated independently.  return html`  <p>${msg('The red button makes the rocket go up.')}</p>  <p>${msg('The green button makes the rocket do a flip.')}</p>  `;}
```

When using transform mode, templates will be automatically flattened to make them as small and efficient as possible. After transformation, the above example won't have any placeholders, because it knows that strings can be directly merged into HTML templates.

There are cases where HTMLshouldbe included in the localized template. For example where an HTML tag is needed in the middle of a phrase:

``` js
render() {  return msg(html`Lift off in <b>T-${this.countdown}</b> seconds`);}
```


## Safely re-exporting or re-assigning localize APIs
Static analysis is used to determine when you are calling the@lit/localizemsgfunction and other APIs, as opposed to a different function with the same name.

It is possible to re-export or re-assign themsgfunction and other APIs, and most of the time this will just work.

However, certain patterns may be too dynamic for static analysis to understand. If a message is failing to be extracted, and you have re-assigned or re-exported themsgfunction, this could be the cause.

To force a function to be analyzed as a@lit/localizeAPI, you can use a JSDoc@typecomment in JavaScript, or a type cast in TypeScript:

``` ts
const myMsg = ... as typeof import('@lit/localize').msg;
```

``` js
/** @type import('@lit/localize').msg */const myMsg = ...;
```

Edit this page


--------------------------------------------------------------------------------


# Localization CLI and config
Source: https://lit.dev/docs/localization/cli-and-config/


## CLI
``` sh
lit-localize command [--flags]
```


## Commands

## Flags

## Config file

## General settings
All file paths are relative to the location of the config file.

Required

Locale code that templates in the source code are written in.

Required (can be empty)

Locale codes that templates will be localized to.

Required unlesstsConfigis specified

Array of filenames orglobpatterns matching the JavaScript or TypeScript files to extract messages from.

If bothtsConfigandinputFilesare specified, theninputFilestakes precedence.

Required unlessinputFilesis specified

Path to atsconfig.jsonorjsconfig.jsonfile that describes the JavaScript or TypeScript files from which messages will be extracted, and also the compiler options that will be used when building for transform mode.

If bothtsConfigandinputFilesare specified, theninputFilestakes precedence.

Required

What kind of output should be produced. Seemodes.

Optional

Filepath for a generated JavaScript or TypeScript module that exportssourceLocale,targetLocales, andallLocalesusing the locale codes from your config file. Use to keep your config file and client config in sync.

This path should end with either".js"or".ts". If it ends with".js"it will be emitted as a JavaScript module. If it ends with".ts"it will be emitted as a TypeScript module.

Required

Data format to be consumed by your localization process. Options:

- "xliff":XLIFF 1.2XML format
- "xlb": Google-internal XML format

## Runtime mode settings
Required

Output directory for generated modules. A<locale>.[js|ts]file is generated for eachtargetLocale. Each file is a module that exports the translations for that locale, keyed by message ID.

Defaults to"js", or"ts"iftsConfigwas specified.

Language to generate modules in.


## Transform mode settings
Required unlesstsConfigis specified, in which case it defaults to that file'soutDir. If both are specified, this field takes precedence.

Output directory for generated modules. A subdirectory is created for each locale within this directory, each containing a full build of the project for that locale.


## XLIFF mode settings
Required with"mode": "xliff"

Directory on disk to read/write.xlfXML files. For each target locale, the path<xliffDir>/<locale>.xlfwill be used.

Defaults to"x"

How to represent placeholders containing HTML markup and dynamic expressions. Different localization tools and services have varying support for placeholder syntax.


## XLB mode settings
Required with"mode": "xlb"

Output path for XLB XML file that will be created containing all messages extracted from the source. E.g."data/localization/en.xlb".

Required with"mode": "xlb"

Globpattern of XLB XML files to read from disk containing translated messages. E.g."data/localization/*.xlb".

Edit this page


--------------------------------------------------------------------------------


# Localization
Source: https://lit.dev/docs/localization/overview/

Localization is the process of supporting multiple languages and regions in your apps and components. Lit has first-party support for localization through the@lit/localizelibrary, which has a number of advantages that can make it a good choice over third-party localization libraries:

- Native support for expressions and HTML markup inside localized templates. No need for a new syntax and interpolation runtime for variable substitution—just use the templates you already have.
Native support for expressions and HTML markup inside localized templates. No need for a new syntax and interpolation runtime for variable substitution—just use the templates you already have.

- Automatic re-rendering of Lit components when the locale switches.
Automatic re-rendering of Lit components when the locale switches.

- Only 1.27 KiB (minified + compressed) of extra JavaScript.
Only 1.27 KiB (minified + compressed) of extra JavaScript.

- Optionally compile for each locale, reducing extra JavaScript to 0 KiB.
Optionally compile for each locale, reducing extra JavaScript to 0 KiB.


## Installation
Install the@lit/localizeclient library and the@lit/localize-toolscommand-line interface.

``` sh
npm i @lit/localizenpm i -D @lit/localize-tools
```


## Quick start
- Wrap a string or template in themsgfunction (details).
- Create alit-localize.jsonconfig file (details).
- Runlit-localize extractto generate an XLIFF file (details).
- Edit the generated XLIFF file to add a<target>translation tag (details).
- Runlit-localize buildto output a localized version of your strings and templates (details).

## Making strings and templates localizable
To make a string or Lit template localizable, wrap it in themsgfunction. Themsgfunction returns a version of the given string or template in whichever locale is currently active.

Before you have any translations available,msgsimply returns the original string or template, so it's safe to use even if you're not yet ready to actually localize.

``` ts
import {html, LitElement} from 'lit';import {customElement, property} from 'lit/decorators.js';import {msg} from '@lit/localize';@customElement('my-greeter')class MyGreeter extends LitElement {  @property()  who = 'World';  render() {    return msg(html`Hello <b>${this.who}</b>`);  }}
```

``` js
import {html, LitElement} from 'lit';import {msg} from '@lit/localize';class MyGreeter extends LitElement {  static properties = {    who: {},  };  constructor() {    super();    this.who = 'World';  }  render() {    return msg(html`Hello <b>${this.who}</b>`);  }}customElements.define('my-greeter', MyGreeter);
```


## Message types
Any string or template that you would normally render with Lit can be localized, including ones with dynamic expressions and HTML markup.

Plain string:

``` js
msg('Hello World');
```

Plain string with expression (seestrings with expressionsfor details onstr):

``` js
msg(str`Hello ${name}`);
```

HTML template:

``` js
msg(html`Hello <b>World</b>`);
```

HTML template with expression:

``` js
msg(html`Hello <b>${name}</b>`);
```

Localized messages can also be nested inside HTML templates:

``` js
html`<button>${msg('Hello World')}</button>`;
```


## Strings with expressions
Strings that contain an expression must be tagged with eitherhtmlorstrin order to be localizable. You should preferstroverhtmlwhen your string doesn't contain any HTML markup, because it has slightly less performance overhead. An error will be raised when you run thelit-localizecommand if you forget thehtmlorstrtag on a string with an expression.

Incorrect:

``` js
import {msg} from '@lit/localize';msg(`Hello ${name}`);
```

Correct:

``` js
import {msg, str} from '@lit/localize';msg(str`Hello ${name}`);
```

Thestrtag is required in these cases because untagged template string literals are evaluated to regular strings before they are received by themsgfunction, which means dynamic expression values could not otherwise be captured and substituted into the localized versions of the string.


## Locale codes
A locale code is a string that identifies a human language, and sometimes also includes a region, script, or other variation.

Lit Localize does not mandate use any particular system of locale codes, though it is strongly recommended to use theBCP 47 language tag standard. Some examples of BCP 47 language tags are:

- en: English
- es-419: Spanish spoken in Latin America
- zh-Hans: Chinese written in Simplified script

## Terms
Lit Localize defines a few terms that refer to locale codes. These terms are used in this documentation, in the Lit Localize config file, and in the Lit Localize API:

The locale that is used to write strings and templates in your source code.

The locales that your strings and templates can be translated into.

The global locale that is currently being displayed.


## Output modes
Lit Localize supports two output modes:

- Runtimemode uses Lit Localize's APIs to load localized messages at runtime.
Runtimemode uses Lit Localize's APIs to load localized messages at runtime.

- Transformmode eliminates the Lit Localize runtime code by building a separate JavaScript bundle for each locale.
Transformmode eliminates the Lit Localize runtime code by building a separate JavaScript bundle for each locale.

Unsure which mode to use?Start with runtime mode. It's easy to switch modes later because the coremsgAPI is identical.


## Runtime mode
In runtime mode, one JavaScript or TypeScript module is generated for each of your locales. Each module contains the localized templates for that locale. When the active locale switches, the module for that locale is imported, and all localized components are re-rendered.

Runtime mode makes switching locales very fast because a page reload is not required. However, there is a slight performance cost to rendering performance compared to transform mode.

``` js
// locales/es-419.tsexport const templates = {  hf71d669027554f48: html`Hola <b>Mundo</b>`,};
```

See theruntime modepage for full details about runtime mode.


## Transform mode
In transform mode, a separate folder is generated for each locale. Each folder contains a complete standalone build of your application in that locale, withmsgwrappers and all other Lit Localize runtime code completely removed.

Transform mode requires 0 KiB of extra JavaScript and is extremely fast to render. However, switching locales requires re-loading the page so that a new JavaScript bundle can be loaded.

``` js
// locales/en/my-element.jsrender() {  return html`Hello <b>World</b>`;}
```

``` js
// locales/es-419/my-element.jsrender() {  return html`Hola <b>Mundo</b>`;}
```

See thetransform modepage for full details about transform mode.


## Differences
- Faster locale switching.
- Fewermarginalbytes when switching locale.
- Faster rendering.
- Fewer bytes for a single locale.

## Config file
Thelit-localizecommand-line tool looks for a config file calledlit-localize.jsonin the current directory. Copy-paste the example below for a quick start, and see theCLI and configpage for a full reference of all options.

If you're writing JavaScript, set theinputFilesproperty to the location of your.jssource files. If you're writing TypeScript, set thetsConfigproperty to the location of yourtsconfig.jsonfile, and leaveinputFilesblank.

``` ts
{  "$schema": "https://raw.githubusercontent.com/lit/lit/main/packages/localize-tools/config.schema.json",  "sourceLocale": "en",  "targetLocales": ["es-419", "zh-Hans"],  "tsConfig": "./tsconfig.json",  "output": {    "mode": "runtime",    "outputDir": "./src/generated/locales",    "localeCodesModule": "./src/generated/locale-codes.ts"  },  "interchange": {    "format": "xliff",    "xliffDir": "./xliff/"  }}
```

``` js
{  "$schema": "https://raw.githubusercontent.com/lit/lit/main/packages/localize-tools/config.schema.json",  "sourceLocale": "en",  "targetLocales": ["es-419", "zh-Hans"],  "inputFiles": [    "src/**/*.js"  ],  "output": {    "mode": "runtime",    "outputDir": "./src/generated/locales",    "localeCodesModule": "./src/generated/locale-codes.js"  },  "interchange": {    "format": "xliff",    "xliffDir": "./xliff/"  }}
```


## Extracting messages
Runlit-localize extractto generate anXLIFFfile for each target locale. XLIFF is an XML format supported by most localization tools and services. XLIFF files will be written to the directory specified by theinterchange.xliffDirconfig option.

``` sh
lit-localize extract
```

For example, given the source:

``` js
msg('Hello World');msg(str`Hello ${name}`);msg(html`Hello <b>World</b>`);
```

Then a<xliffDir>/<locale>.xlffile will be generated for each target locale:

``` xml
<!-- xliff/es-419.xlf --><trans-unit id="s3d58dee72d4e0c27">  <source>Hello World</source></trans-unit><trans-unit id="saed7d3734ce7f09d">  <source>Hello <x equiv-text="${name}"/></source></trans-unit><trans-unit id="hf71d669027554f48">  <source>Hello <x equiv-text="&lt;b&gt;"/>World<x equiv-text="&lt;/b&gt;"/></source></trans-unit>
```


## Translation with XLIFF
XLIFF files can be edited manually, but more typically they are sent to a third-party translation service where they are edited by language experts using specialized tools.

After uploading your XLIFF files to your chosen translation service, you will eventually receive new XLIFF files in response. The new XLIFF files will look just like the ones you uploaded, but with<target>tags inserted into each<trans-unit>.

When you receive new translation XLIFF files, save them to your configuredinterchange.xliffDirdirectory, overwriting the original versions.

``` xml
<!-- xliff/es-419.xlf --><trans-unit id="s3d58dee72d4e0c27">  <source>Hello World</source>  <target>Hola Mundo</target></trans-unit><trans-unit id="saed7d3734ce7f09d">  <source>Hello <x equiv-text="${name}"/></source>  <target>Hola <x equiv-text="${name}"/></target></trans-unit><trans-unit id="hf71d669027554f48">  <source>Hello <x equiv-text="&lt;b&gt;"/>World<x equiv-text="&lt;/b&gt;"/></source>  <target>Hola <x equiv-text="&lt;b&gt;"/>Mundo<x equiv-text="&lt;/b&gt;"/></target></trans-unit>
```


## Building localized templates
Use thelit-localize buildcommand to incorporate translations back into your application. The behavior of this command depends on theoutput modeyou have configured.

``` sh
lit-localize build
```

See theruntime modeandtransform modepages for details of how building in each mode works.


## Message descriptions
Use thedescoption to themsgfunction to provide human-readable descriptions for your strings and templates. These descriptions are shown to translators by most translation tools, and are highly recommended to help explain and contextualize the meaning of messages.

``` js
render() {  return html`<button>    ${msg("Launch", {      desc: "Button that begins rocket launch sequence.",    })}  </button>`;}
```

Descriptions are represented in XLIFF files using<note>elements.

``` xml
<trans-unit id="s512957aa09384646">  <source>Launch</source>  <note from="lit-localize">Button that begins rocket launch sequence.</note></trans-unit>
```


## Message IDs
Lit Localize automatically generates an ID for everymsgcall using a hash of the string.

If twomsgcalls share the same ID, then they are treated as the same message, meaning they will be translated as a single unit and the same translations will be substituted in both places.

For example, these twomsgcalls are in two different files, but since they have the same content they will be treated as one message:

``` js
// file1.jsmsg('Hello World');// file2.jsmsg('Hello World');
```


## ID generation
The following content affects ID generation:

- String content
- HTML markup
- The position of expressions
- Whether the string is tagged withhtml
The following contentdoes notaffect ID generation:

- The code inside an expression
- The computed value of an expression
- File location
For example, all of these messages share the same ID:

``` js
msg(html`Hello <b>${name}</b>`);msg(html`Hello <b>${this.name}</b>`);
```

But this message has a different ID:

``` js
msg(html`Hello <i>${name}</i>`);
```

Note, while providing adescriptiondoes not affect ID generation, multiple messages with the same ID but different description will produce an error during analysis to avoid ambiguity in the extracted translation unit. The following is consideredinvalid:

``` js
msg(html`Hello <b>${name}</b>`);msg(html`Hello <b>${name}</b>`, {desc: 'A friendly greeting'});
```

Make sure that all messages with the same ID also have the same description.


## Overriding IDs
Message IDs can be overridden by specifying theidoption to themsgfunction. In some cases this may be necessary, such as when an identical string has multiple meanings, because each might be written differently in another language:

``` js
msg('Buffalo', {id: 'buffalo-animal-singular'});msg('Buffalo', {id: 'buffalo-animal-plural'});msg('Buffalo', {id: 'buffalo-city'});msg('Buffalo', {id: 'buffalo-verb'});
```

Edit this page


--------------------------------------------------------------------------------


# Runtime localization mode
Source: https://lit.dev/docs/localization/runtime-mode/

In Lit Localize runtime mode, one JavaScript or TypeScript module is generated for each of your locales. Each generated module contains the localized templates for that locale. When your application switches locales, the module for that locale is imported, and all localized components are re-rendered.

Seeoutput modesfor a comparison of Lit Localize output modes.

``` js
// locales/es-419.tsexport const templates = {  h3c44aff2d5f5ef6b: html`Hola <b>Mundo!</b>`,};
```


## Example of using runtime mode
The following example demonstrates an application built with Lit Localize runtime mode:

The Lit GitHub repo includes full working examples (JavaScript,TypeScript) of Lit Localize runtime mode that you can use as templates.


## Configuring runtime mode
In yourlit-localize.jsonconfig, set theoutput.modeproperty toruntime, and set theoutput.outputDirproperty to the location where you would like your localized template modules to be generated. Seeruntime mode settingsfor more details.

Next, setoutput.localeCodesModuleto a filepath of your chosing. Lit Localize will generate a.jsor.tsmodule here which mirrors thesourceLocaleandtargetLocalessettings in your config file as exported variables. The generated module will look something like this:

``` js
export const sourceLocale = 'en';export const targetLocales = ['es-419', 'zh-Hans'];export const allLocales = ['en', 'es-419', 'zh-Hans'];
```

Finally, in your JavaScript or TypeScript project, callconfigureLocalization, passing an object with the following properties:

- sourceLocale: string: ThesourceLocalevariable exported by your generatedoutput.localeCodesModulemodule.
sourceLocale: string: ThesourceLocalevariable exported by your generatedoutput.localeCodesModulemodule.

- targetLocales: string[]: ThetargetLocalesvariable exported by your generatedoutput.localeCodesModulemodule.
targetLocales: string[]: ThetargetLocalesvariable exported by your generatedoutput.localeCodesModulemodule.

- loadLocale: (locale: string) => Promise<LocaleModule>: A function that loads a localized template. Returns a promise that resolves to the generated localized template module for the given locale code. SeeApproaches for loading locale modulesfor examples of functions you can use here.
loadLocale: (locale: string) => Promise<LocaleModule>: A function that loads a localized template. Returns a promise that resolves to the generated localized template module for the given locale code. SeeApproaches for loading locale modulesfor examples of functions you can use here.

configureLocalizationreturns an object with the following properties:

- getLocale: Function that returns the active locale code. If a new locale has started loading,getLocalewill continue to return the previous locale code until the new one has finished loading.
getLocale: Function that returns the active locale code. If a new locale has started loading,getLocalewill continue to return the previous locale code until the new one has finished loading.

- setLocale: Function that begins switching the active locale to the given code, and returns a promise that resolves when the new locale has loaded. Example usage:
setLocale: Function that begins switching the active locale to the given code, and returns a promise that resolves when the new locale has loaded. Example usage:

For example:

``` js
import {configureLocalization} from '@lit/localize';// Generated via output.localeCodesModuleimport {sourceLocale, targetLocales} from './generated/locale-codes.js';export const {getLocale, setLocale} = configureLocalization({  sourceLocale,  targetLocales,  loadLocale: (locale) => import(`/locales/${locale}.js`),});
```


## Automatically re-render
To automatically trigger a re-render of your component each time the active locale switches, apply theupdateWhenLocaleChangesfunction in yourconstructorwhen writing JavaScript, or apply the@localizeddecorator to your class when writing TypeScript.

``` ts
import {LitElement, html} from 'lit';import {customElement} from 'lit/decorators.js';import {msg, localized} from '@lit/localize';@customElement('my-element');@localized()class MyElement extends LitElement {  render() {    // Whenever setLocale() is called, and templates for that locale have    // finished loading, this render() function will be re-invoked.    return msg(html`Hello <b>World!</b>`);  }}
```

``` js
import {LitElement, html} from 'lit';import {msg, updateWhenLocaleChanges} from '@lit/localize';class MyElement extends LitElement {  constructor() {    super();    updateWhenLocaleChanges(this);  }  render() {    // Whenever setLocale() is called, and templates for that locale have    // finished loading, this render() function will be re-invoked.    return msg(html`Hello <b>World!</b>`);  }}customElements.define('my-element', MyElement);
```


## Status event
Thelit-localize-statusevent fires onwindowwhenever a locale switch starts, finishes, or fails. You can use this event to:

- Re-render when you can't use the@localizeddecorator (e.g. when using the Litrenderfunction directly).
Re-render when you can't use the@localizeddecorator (e.g. when using the Litrenderfunction directly).

- Render as soon as a locale switch begins, even before it finishes loading (e.g. a loading indicator).
Render as soon as a locale switch begins, even before it finishes loading (e.g. a loading indicator).

- Perform other localization related tasks (e.g. setting a locale preference cookie).
Perform other localization related tasks (e.g. setting a locale preference cookie).


## Event types
Thedetail.statusstring property tells you what kind of status change has occured, and can be eitherloading,ready, orerror:

A new locale has started to load.

Thedetailobject contains:

- loadingLocale: string: Code of the locale that has started loading.
In the case that a second locale is requested before the first one finishes loading, a newloadingevent is dispatched, and noreadyorerrorevent will be dispatched for the first request.

Aloadingstatus can be followed by aready,error, orloadingstatus.

A new locale has successfully loaded and is ready for rendering.

Thedetailobject contains:

- readyLocale: string: Code of the locale that has successfully loaded.
Areadystatus can be followed only by aloadingstatus.

A new locale failed to load.

Thedetailobject contains:

- errorLocale: string: Code of the locale that failed to load.
- errorMessage: string: Error message from locale load failure.
Anerrorstatus can be followed only by aloadingstatus.


## Example of using the status event
``` ts
// Show/hide a progress indicator whenever a new locale is loading,// and re-render the application every time a new locale successfully loads.window.addEventListener('lit-localize-status', (event) => {  const spinner = document.querySelector('#spinner');  if (event.detail.status === 'loading') {    console.log(`Loading new locale: ${event.detail.loadingLocale}`);    spinner.removeAttribute('hidden');  } else if (event.detail.status === 'ready') {    console.log(`Loaded new locale: ${event.detail.readyLocale}`);    spinner.setAttribute('hidden', '');    renderApplication();  } else if (event.detail.status === 'error') {    console.error(      `Error loading locale ${event.detail.errorLocale}: ` +        event.detail.errorMessage    );    spinner.setAttribute('hidden', '');  }});
```


## Approaches for loading locale modules
Lit Localize lets you load locale modules however you like, because you can pass any function as theloadLocaleoption. Here are a few common patterns:


## Lazy-load
Usedynamic importsto load each locale only when it becomes active. This is a good default because it minimizes the amount of code that your users will download and execute.

``` js
import {configureLocalization} from '@lit/localize';import {sourceLocale, targetLocales} from './generated/locale-codes.js';const {getLocale, setLocale} = configureLocalization({  sourceLocale,  targetLocales,  loadLocale: (locale) => import(`/locales/${locale}.js`),});
```


## Pre-load
Start pre-loading all locales when the page loads. Dynamic imports are still used to ensure that the remaining script on the page is not blocked while the locale modules are being fetched.

``` js
import {configureLocalization} from '@lit/localize';import {sourceLocale, targetLocales} from './generated/locale-codes.js';const localizedTemplates = new Map(  targetLocales.map((locale) => [locale, import(`/locales/${locale}.js`)]));const {getLocale, setLocale} = configureLocalization({  sourceLocale,  targetLocales,  loadLocale: async (locale) => localizedTemplates.get(locale),});
```


## Static imports
Usestatic importsto pre-load all locales in a way that blocks other script on the page.

This approach is not usually recommended because it will cause more code than necessary to be fetched and executed before the rest of the script on the page can execute, blocking interactivity. Use this approach only if your application is extremely small, must be distributed in a single JavaScript file, or you have some other restriction that prevents the use of dynamic imports.

``` js
import {configureLocalization} from '@lit/localize';import {sourceLocale, targetLocales} from './generated/locale-codes.js';import * as templates_es_419 from './locales/es-419.js';import * as templates_zh_hans from './locales/zh-Hans.js';...const localizedTemplates = new Map([  ['es-419', templates_es_419],  ['zh-Hans', templates_zh_hans],  ...]);const {getLocale, setLocale} = configureLocalization({  sourceLocale,  targetLocales,  loadLocale: async (locale) => localizedTemplates.get(locale),});
```

Edit this page


--------------------------------------------------------------------------------


# Transform localization mode
Source: https://lit.dev/docs/localization/transform-mode/

In Lit Localize transform mode, a separate folder is generated for each locale. Each folder contains a complete standalone build of your application in that locale, with all runtime@lit/localizecode removed:

- msgcalls are replaced with the static localized version of the string or template in each locale.
- strtags are removed.
- @lit/localizeimports are removed.
- Templates are optimized to remove unnecessary expressions by folding them into parent templates wherever possible.
For example, given the source:

``` js
// src/launch-button.jsimport {msg} from '@lit/localize';render() {  return html`<button>${msg('Launch rocket')}</button>`}
```

The following files will be generated:

``` js
// locales/en/launch-button.jsrender() {  return html`<button>Launch rocket</button>`}// locales/es-419/launch-button.jsrender() {  return html`<button>Lanza cohete</button>`}
```


## Configuring transform mode
In yourlit-localize.jsonconfig, set themodeproperty totransform, and set theoutput.outputDirproperty to the location where you would like your localized app folders to be generated. Seetransform mode settingsfor more details.

In your JavaScript or TypeScript project, optionally callconfigureTransformLocalization, passing an object with the following property:

- sourceLocale: string: Locale in which source templates are written. Specified as a locale code (for example:"en").
configureTransformLocalizationreturns an object with the following property:

- getLocale: Function that returns the active locale code.
For example:

``` js
import {configureTransformLocalization} from '@lit/localize';export const {getLocale} = configureTransformLocalization({  sourceLocale: 'en',});
```


## Setting the initial locale
In transform mode, the active locale is determined by the JavaScript bundle you load. How you determine which bundle to load when your page loads is up to you.

For example, if your application's locale is reflected in the URL path, you can include an inline script in your HTML file that checks the URL and inserts the appropriate<script>tag:

Always validate your locale codes when dynamically choosing a script name. The example below is safe because a script can only be loaded if it matches one of our known locale codes, but if our matching logic was less precise, it could result in bugs or attacks that inject insecure JavaScript.

``` js
import {allLocales} from './generated/locales.js';const url = new URL(window.location.href);const unsafeLocale = url.searchParams.get('locale');const locale = allLocales.includes(unsafeLocale) ? unsafeLocale : 'en';const script = document.createElement('script');script.type = 'module';script.src = `/${locale}.js`;document.head.appendChild(script);
```

For better performance, you can statically render the appropriate script tag into your HTML file on the server. This lets the browser start downloading your script as early as possible.


## Switching locales
In transform mode, thesetLocalefunction is not available. Instead, reload the page so that the next load will pick a different locale bundle.

For example, thislocale-pickercustom element loads a new URL whenever a new locale is selected from a drop-down list:

``` ts
import {LitElement, html} from 'lit';import {customElement} from 'lit/decorators.js';import {getLocale} from './localization.js';import {allLocales} from './generated/locales.js';@customElement('locale-picker');export class LocalePicker extends LitElement {  render() {    return html`      <select @change=${this.localeChanged}>        ${allLocales.map(          (locale) =>            html`<option value=${locale} selected=${locale === getLocale()}>              ${locale}            </option>`        )}      </select>    `;  }  localeChanged(event: Event) {    const newLocale = (event.target as HTMLSelectElement).value;    const url = new URL(window.location.href);    if (url.searchParams.get('locale') !== newLocale) {      url.searchParams.set('locale', newLocale);      window.location.assign(url.href);    }  }}
```

``` js
import {LitElement, html} from 'lit';import {getLocale} from './localization.js';import {allLocales} from './generated/locales.js';export class LocalePicker extends LitElement {  render() {    return html`      <select @change=${this.localeChanged}>        ${allLocales.map(          (locale) =>            html`<option value=${locale} selected=${locale === getLocale()}>              ${locale}            </option>`        )}      </select>    `;  }  localeChanged(event) {    const newLocale = event.target.value;    const url = new URL(window.location.href);    if (url.searchParams.get('locale') !== newLocale) {      url.searchParams.set('locale', newLocale);      window.location.assign(url.href);    }  }}customElements.define('locale-picker', LocalePicker);
```


## Rollup integration
If you useRollup, and would prefer an integrated solution instead of running thelit-localize buildcommand separately, import thelocaleTransformersfunction from@lit/localize-tools/lib/rollup.jsinto your Rollup config.

This function generates an array of{locale, transformer}objects, which you can use in conjunction with thetransformersoption of@rollup/plugin-typescriptto generate a separate bundle for each locale.

If you write JavaScript, don't worry about seeing the TypeScript compiler used here. Lit Localize depends on the TypeScript compiler to parse, analyze, and transform your source code, but it handles plain JavaScript files too!

The followingrollup.config.mjsgenerates a minified bundle for each of your locales into./bundled/<locale>/directories:

``` ts
import typescript from '@rollup/plugin-typescript';import {localeTransformers} from '@lit/localize-tools/lib/rollup.js';import resolve from '@rollup/plugin-node-resolve';import {terser} from 'rollup-plugin-terser';// Config is read from ./lit-localize.json by default.// Pass a path to read config from another location.const locales = localeTransformers();export default locales.map(({locale, localeTransformer}) => ({  input: `src/index.ts`,  plugins: [    typescript({      transformers: {        before: [localeTransformer],      },    }),    resolve(),    terser(),  ],  output: {    file: `bundled/${locale}/index.js`,    format: 'es',  },}));
```

``` js
import typescript from '@rollup/plugin-typescript';import resolve from '@rollup/plugin-node-resolve';import {terser} from 'rollup-plugin-terser';import summary from 'rollup-plugin-summary';import {localeTransformers} from '@lit/localize-tools/lib/rollup.js';// Config is read from ./lit-localize.json by default.// Pass a path to read config from another location.const locales = localeTransformers();export default locales.map(({locale, localeTransformer}) => ({  input: `src/index.js`,  plugins: [    typescript({      transformers: {        before: [localeTransformer],      },      // Specifies the ES version and module format to emit. See      // https://www.typescriptlang.org/docs/handbook/tsconfig-json.html      tsconfig: 'jsconfig.json',      // Temporary directory where transformed modules will be emitted before      // Rollup bundles them.      outDir: 'bundled/temp',      // @rollup/plugin-typescript always matches only ".ts" files, regardless      // of any settings in our jsconfig.json.      include: ['src/**/*.js'],    }),    resolve(),    terser(),    summary({      showMinifiedSize: false,    }),  ],  output: {    file: `bundled/${locale}/index.js`,    format: 'es',    sourcemap: true,  },}));
```

Edit this page


--------------------------------------------------------------------------------


# Lit 3 upgrade guide
Source: https://lit.dev/docs/releases/upgrade/

If you are looking to migrate from Lit 1.x to Lit 2.x, see theLit 2 upgrade guide.


## Overview
Lit 3.0 has very few breaking changes from Lit 2.x:

- IE11 is no longer supported.
- Lit's npm modules are now published as ES2021.
- APIs marked deprecated in Lit 2.x releases have been removed.
- SSR hydration support modules have moved to the@lit-labs/ssr-clientpackage.
- Type only: Type ofReactiveElement'srenderRootandcreateRenderRoot()have been updated.
- Support was removed for Babel decorators version "2018-09".
- Decorator behavior has been unified between TypeScript experimental decorators and standard decorators.As a consequence, if you use TypeScript you'll need to upgrade to at least TypeScript v5.2, to get the updated types for both kinds of decorators.
- As a consequence, if you use TypeScript you'll need to upgrade to at least TypeScript v5.2, to get the updated types for both kinds of decorators.
For the vast majority of users there should be no required code changes to upgrade from Lit 2 to Lit 3. Most apps and libraries should be able to extend their npm version ranges to include both 2.x and 3.x, like"^2.7.0 || ^3.0.0".

Lit 2.x and 3.0 areinteroperable– templates, base classes, and directives from one version of Lit will work with those from another.


## Lit is now published as ES2021
Lit 2 was published as ES2019, and Lit 3 is now published as ES2021 which has wide support in modern browsers and build tools. This may be a breaking change if you need to support older browser versions and your current tooling can't parse ES2021.


## Using Lit 3 with Webpack 4
Webpack 4's internal parser doesn't support nullish coalescing (??), logical assignment (??=), or optional chaining (?.), which are syntaxes introduced in ES2021 so will throw aModule parse failed: Unexpected tokenwhen encountering those.

The preferred solution is to upgrade to Webpack 5 which does support parsing these newer JS syntax. However if you are unable to do so, it is possible to usebabel-loaderto transform Lit 3 code to work with Webpack 4.

To transpile Lit 3 in Webpack 4, install the following required babel packages:

``` sh
> npm i -D babel-loader@8 \    @babel/plugin-transform-optional-chaining \    @babel/plugin-transform-nullish-coalescing-operator \    @babel/plugin-transform-logical-assignment-operators
```

And add a new rule that is similar to the following (you may need to modify it based on your specific project):

``` js
// In webpack.config.jsmodule.exports = {  // ...  module: {    rules: [      // ... your other rules      // Add a babel-loader rule to downlevel Lit's ES2021 syntax so Webpack 4 can parse it.      // TODO: Once on Webpack 5, this rule can be deleted.      {        test: /\.js$/,        include: ['@lit', 'lit-element', 'lit-html'].map((p) =>          path.resolve(__dirname, 'node_modules/' + p)        ),        use: {          loader: 'babel-loader',          options: {            plugins: [              '@babel/plugin-transform-optional-chaining',              '@babel/plugin-transform-nullish-coalescing-operator',              '@babel/plugin-transform-logical-assignment-operators'            ],          },        },      },    ],  }}
```


## Updates to Lit decorators
JavaScript decorators have recently been standardized by TC39 and are at Stage 3 of the four-stage standardization process. Stage 3 is when JavaScript implementations such as VMs and compilers start implementing the stable specification. TypeScript 5.2 and Babel 7.23 have implemented the standard recently.

This means that there is more than one version of the decorator API in existence: standard decorators, TypeScript's experimental decorators, and previous proposals that Babel has implemented, such as version "2018-09".

While Lit 2 supported TypeScript experimental decorators and Babel's "2018-09" decorators, Lit 3 now supports standard decorators and TypeScript experimental decorators.

The Lit 3 decorators are mostly backwards compatible with the Lit 2 TypeScript decorators -most likely no changes are needed.

Some minor breaking changes were necessary to make the Lit decorators behave consistently between both experimental and standard decorator modes.

Changes to Lit decorator behavior in Lit 3.0:

- requestUpdate()is called automatically for@property()and@state()decorated accessors where previously that was the setters responsibility.
- The value of an accessor is read on first render and used as the initial value forchangedPropertiesand attribute reflection.
- Lit 3 decorators no longer support theversion: "2018-09"option of@babel/plugin-proposal-decorators. Babel users shouldmigrate to standard decorators.
- [Optional]:We recommend migrating@property()and@state()to the setter for hand-written accessors to aid in migrating to standard decorators.

## List of removed APIs
If your Lit 2.x project does not have deprecation warnings you should not be impacted by this list.

- RemovedUpdatingElementalias forReactiveElement.
- Removed re-export of decorators from mainlit-elementmodule.
- Removed deprecated call signature for thequeryAssignedNodesdecorator.
- Moved experimental server side rendering hydration modules fromlit,lit-element, andlit-htmlto@lit-labs/ssr-client.

## Steps to upgrade

## RemovedUpdatingElementalias forReactiveElement
Replace Lit 2.x usage ofUpdatingElementwithReactiveElement. This is not a functional change asUpdatingElementwas aliasingReactiveElement.

``` ts
// Removedimport {UpdatingElement} from 'lit';// Updatedimport {ReactiveElement} from 'lit';
```


## Removed re-export of decorators fromlit-element
Lit 3.0built-in decoratorsare no longer exported bylit-element, and should instead be imported fromlit/decorators.js.

``` ts
// Removed decorator exports from lit-elementimport {customElement, property, state} from 'lit-element';// Updatedimport {customElement, property, state} from 'lit/decorators.js';
```


## DeprecatedqueryAssignedNodes(slot: string, flatten: bool, selector: string)decorator signature removed
Migrate any usage ofqueryAssignedNodestaking a selector to usequeryAssignedElements.

``` ts
// Removed@queryAssignedNodes('list', true, '.item')// Updated@queryAssignedElements({slot: 'list', flatten: true, selector: '.item'})
```

Usages without aselectornow must take an options object.

``` ts
// Removed@queryAssignedNodes('list', true)// Updated@queryAssignedNodes({slot: 'list', flatten: true})
```


## Server side rendering experimental hydration modules removed fromlit,lit-element, andlit-html
Experimental hydration support has been moved out of core libraries and into@lit-labs/ssr-client.

``` ts
// Removedimport 'lit/experimental-hydrate-support.js';import {hydrate} from 'lit/experimental-hydrate.js';// Updatedimport '@lit-labs/ssr-client/lit-element-hydrate-support.js';import {hydrate} from '@lit-labs/ssr-client';
```


## [Type only]: Type ofrenderRootandcreateRenderRoot()have been updated
This is a type only change with no runtime effect.

The type ofReactiveElement.renderRootwas changed fromElement | ShadowRoottoHTMLElement | DocumentFragmentand the return type ofReactiveElement.createRenderRoot()was changed fromHTMLElement | ShadowRoottoHTMLElement | DocumentFragment. This makes them congruent with each other, as well as lit-html'srender().

This change generally should not affect code that simply accessesthis.renderRoot. However, any code that had explicit type annotations for their former types should be updated.


## Optional: Upgrade to standard decorators
While Lit 3 adds support for standard decorators, we still recommend that TypeScript users stay with experimental decorators. This is because the emitted code for standard decorators from the TypeScript and Babel compilers is quite large at the moment.

We will recommend standard decorators for production when browsers support them, or when we release decorator transform support in our new Lit compiler.

But you can try standard decorators now, and they work in TypeScript 5.2 and above and Babel 7.23 with the@babel/plugin-proposal-decoratorsplugin.


## Configuration
Install TypeScript 5.2 or later, andremovethe"experimentalDecorators"setting from your tsconfig if it's present.

Install Babel 7.23 or later, and@babel/plugin-proposal-decorators. Be sure to pass the"version": "2023-05"option to the plugin.


## Code changes
Standard decorators are not allowed to change thekindof class member they decorate. Decorators that need to create getters and setters must be applied to existing getters and setters. To make this more ergonomic, the decorators standard adds theaccessorkeyword which creates "auto accessors" when applied to a class field. Auto accessors look and act much like class fields, but create accessors on the prototype backed by private storage.

The@property(),@state(),@query(),@queryAll(),@queryAssignedElements()and@queryAssignedNode()decorators require theaccessorkeyword.

Example:

``` ts
class MyElement extends LitElement {  @property()  accessor myProperty = "initial value"...}
```

Standard decorators can only replace the class member they're directly applied to. Lit decorators need to intercept property setting, so the decorators must be applied to setters. This is different from the Lit 2 recommendation of applying decorators to getters.

For@property()and@state()you can also remove anythis.requestUpdate()calls in the setter since this is done automatically now. If you need tonothaverequestUpdate()called, you'll have to use thenoAccessorproperty option.

Note that for@property()and@state()thegetterwill be called by the decorator when setting the property to retrieve the old value. This means that youmustdefine both a getter and a setter.

Before:

``` ts
class MyElement extends LitElement {  private _foo = 42;  set(v) {    const oldValue = this._foo;    this._foo = v;    this.requestUpdate('foo', oldValue);  }  @property()  get() {    return this._foo;  }}
```

After:

``` ts
class MyElement extends LitElement {  private _foo = 42;  @property()  set(v) {    this._foo = v;  }  get() {    return this._foo;  }}
```

Edit this page


--------------------------------------------------------------------------------


# Community
Source: https://lit.dev/docs/resources/community/

There are many great resources and locations to learn about Lit, share what you've built, and more. Participation in our community is subject to the LitCode of Conduct—be excellent to each other!

- Join us onDiscord!Chat about Lit, get help, or share your project in the Lit Discord server.
Join us onDiscord!Chat about Lit, get help, or share your project in the Lit Discord server.

- Follow us at@buildWithLit on X (formerly Twitter)for the latest on Lit and web components. Many of our team members can also be found tweeting about Lit, and the latest developments in the web platform.
Follow us at@buildWithLit on X (formerly Twitter)for the latest on Lit and web components. Many of our team members can also be found tweeting about Lit, and the latest developments in the web platform.

- Follow us onBlueskyfor updates and news from the Lit team.
Follow us onBlueskyfor updates and news from the Lit team.

- Talk about Lit onGitHub Discussions.For longer questions or ideas about Lit, or to see what others are talking about, GitHub discussions are a great way to connect with the team and community.
Talk about Lit onGitHub Discussions.For longer questions or ideas about Lit, or to see what others are talking about, GitHub discussions are a great way to connect with the team and community.

- Import theLit Community Calendarto keep up to date on official community events like the weekly Open Eng Meeting and Community Calls. Add it to your Google Calendar by pressing the "+ Google Calendar" button at the bottom right corner of the calendar page.
Import theLit Community Calendarto keep up to date on official community events like the weekly Open Eng Meeting and Community Calls. Add it to your Google Calendar by pressing the "+ Google Calendar" button at the bottom right corner of the calendar page.

- Find answers onStackOverflow.Search thelit,lit-element, andlit-htmltags when looking for answers. You can also find help on underlying web standards with tags likeweb-component, and try your hand at answering other people’s queries.
Find answers onStackOverflow.Search thelit,lit-element, andlit-htmltags when looking for answers. You can also find help on underlying web standards with tags likeweb-component, and try your hand at answering other people’s queries.

- Watch Lit videos onYouTube.The Lit team has a dedicated YouTube channel with tutorials and update streams.
Watch Lit videos onYouTube.The Lit team has a dedicated YouTube channel with tutorials and update streams.

Edit this page


--------------------------------------------------------------------------------


# Authoring components for Lit SSR
Source: https://lit.dev/docs/ssr/authoring/

Lit's approach to rendering web components in a server environment places some restrictions on component code to achieve efficient server rendering. When authoring components, keep in mind these considerations to ensure they are compatible with Lit SSR.

Note: The restrictions listed on this page are subject to change as we make improvements to Lit SSR. If you would like to see a certain use case supported, pleasefile an issueor start adiscussionthread.


## Browser-only code
Most browser DOM APIs are not available in the Node environment. Lit SSR utilizes a DOM shim that's the bare minimum required for rendering Lit templates and components. For a full list of what APIs are available, see theDOM Emulationpage.

When authoring components, perform imperative DOM operations from lifecycle methods that are calledonly on the client, and not on the server. For example, useupdated()if you need to measure the updated DOM. This callback is only run on the browser, so it is safe to access the DOM.

See thelifecyclesection below for a list of which specific methods are called on the server and which are browser-only.

Some modules that define Lit components may also have side effects that use browser APIs—for example to detect certain browser features—such that the module breaks when imported in a non-browser environment. In this case, you can move the side effect code into a browser-only lifecycle callback, or conditionalize so that it only runs on the browser.

For simple cases, adding conditionals or optional chaining to certain DOM accesses may be sufficient to guard against unavailable DOM APIs. For example:

``` js
const hasConstructableStylesheets = typeof globalThis.CSSStyleSheet?.prototype.replaceSync === 'function';
```

Thelitpackage also provides anisServerenvironment checker that can be used to write conditional blocks of code targeting different environments:

``` js
import {isServer} from 'lit';if (isServer) {  // only runs in server environments like Node} else {  // runs in the browser}
```


## Conditional exports
For more complex uses cases, consider utilizingconditional exportsthat specifically match for"node"environments so you could have different code depending on whether the module is being imported for use in Node or in the browser. Users would get the appropriate version of the package depending on whether it was imported from Node or the browser. Export conditions are also supported by popular bundling tools likerollupandwebpackso users can bring in the appropriate code for your bundle.

An example configuration might look like below:

``` json
// package.json{  "name": "my-awesome-lit-components",  "exports": {    "./button.js": {      "node": "./button-node.js",      "default": "./button.js"    }  }}
```

The Node entrypoint file can be made manually, or you might use a bundler to generate those.


## Bundlers
Avoid bundling Lit inline into published components if possible.

Because Lit packages use conditional exports to provide different modules to Node and browser environments, we strongly discourage bundlinglitinto your packages being published to NPM. If you do, your bundle will only includelitmodules meant for the environment you bundled, and won't automatically switch based on environment.

If you are using a bundler like ESBuild or Rollup to transform your code, you can mark packages asexternalso they will not be bundled into your component. ESBuild has apackagesoption to externalize all dependencies, or you can mark onlylitand related packages in theexternaloption. Similarly, Rollup also has an equivalent"external"configuration option.

If you must bundle Lit library code into your component (e.g. for distribution via a CDN), we recommended creating two entrypoints: one for the browser, and one for Node. Bundlers will have options to either select a target platform like browser or Node, or allow you to explicitly specify the export condition used for resolving modules.

For example, ESBuild has theplatformoption, and in Rollup you can provide"node"to@rollup/plugin-node-resolve'sexportConditionsoption.

These entrypoints for browser and Node targets must then be specified in your component library'spackage.jsonfile. SeeConditional exportsfor more details.


## Lifecycle
Only certain lifecycle callbacks are run during server-side rendering. These callback generate the initial styling and markup for the component. Additional lifecycle methods are called client-side during hydration and during runtime after the components are hydrated.

The tables below lists the standard custom element and Lit lifecycle methods and whether they are called during SSR. All of the lifecycle is available on the browser after element registration and hydration.

Methods called on the server should not contain references to browser/DOM APIs that have not been shimmed. Methods that are not called server-side may contain those references without causing breakages.

Whether a method is called on the server is subject to change while Lit SSR is part of Lit Labs.


## Standard custom element and LitElement

## ReactiveController

## Directive

## Asynchronicity
There currently isn't a mechanism to wait for asynchronous results before continuing to render (such as results from async directives or controllers), though we are considering options to allow this in the future. The current workaround for this is to do any asynchronous work before rendering the top level template on the server and providing the data to the template as some attribute or property.

For example:

- Async directives such asasyncAppend()orasyncReplace()will not produce any renderable results server-side.
- until()directive will only ever result in the highest-priority non-promise placeholder value.

## Testing
The@lit-labs/testingpackage contains utility functions that utilize aWeb Test Runnerplugin to create test fixtures that are rendered server-side using@lit-labs/ssr. It can help test whether your components are server-side renderable. See more in thereadme.

Edit this page


--------------------------------------------------------------------------------


# Lit SSR client usage
Source: https://lit.dev/docs/ssr/client-usage/

Lit SSR generates static HTML for the browser to parse and paint without any JavaScript. (Browsers that do not have support for Declarative Shadow DOM will require some JavaScript polyfill for Lit components authored to utilize the Shadow DOM.) For pages with static content, this is all that's needed. However, if the page content needs to be dynamic and respond to user interactions, it will need JavaScript to re-apply that reactivity.

How to re-apply that reactivity client-side depends on whether you are rendering standalone Lit templates or utilizing Lit components.


## Standalone Lit Templates
"Hydration" for Lit templates is the process of having Lit re-associate the expressions of Lit templates with the nodes they should update in the DOM as well as adding event listeners. In order to hydrate Lit templates, thehydrate()method is provided in the@lit-labs/ssr-clientpackage. Before you update a server-rendered container usingrender(), you must first callhydrate()on that container using the same template and data that was used to render on the server:

``` js
import {render} from 'lit';import {hydrate} from '@lit-labs/ssr-client';import {myTemplate} from './my-template.js';// Initial hydration required before render:// (must be same data used to render on the server)const initialData = getInitialAppData();hydrate(myTemplate(initialData), document.body);// After hydration, render will efficiently update the server-rendered DOM:const update = (data) => render(myTemplate(data), document.body);
```


## Lit components
To re-apply reactivity to Lit components, custom element definitions need to be loaded for them to upgrade, enabling their lifecycle callbacks, and the templates in the components' shadow roots needs to be hydrated.

Upgrading can be achieved simply by loading the component module that registers the custom element. This can be done by loading a bundle of all the component definitions for a page, or may be done based on more sophisticated heuristics where only a subset of definitions are loaded as needed. To ensure templates inLitElementshadow roots are hydrated, load the@lit-labs/ssr-client/lit-element-hydrate-support.jsmodule which installs support forLitElementto automatically hydrate itself when it detects it was server-rendered with declarative shadow DOM. This module must be loaded before thelitmodule is loaded (including any component modules that importlit) to ensure hydration support is properly installed.

When Lit components are server rendered, their shadow root contents are emitted inside a<template shadowroot>, also known as aDeclarative Shadow Root. Declarative shadow roots automatically attach their contents to a shadow root on the template's parent element when HTML is parsed without the need for JavaScript.

Until all browsers include declarative shadow DOM support, a very small polyfill is available that can be inlined into your page. This lets you use SSR now for any browsers with JavaScript enabled and incrementally address non-JavaScript use cases as the feature is rolled out to other browsers. The usage of thetemplate-shadowrootpolyfillis described below.


## Loading@lit-labs/ssr-client/lit-element-hydrate-support.js
This needs to be loaded before any component modules and thelitlibrary.

For example:

``` html
  <body>    <!-- App components rendered with declarative shadow DOM placed here. -->    <!-- ssr-client lit-element-hydrate-support should be loaded first. -->    <script type="module" src="/node_modules/@lit-labs/ssr-client/lit-element-hydrate-support.js"></script>    <!-- As component definition loads, your pre-rendered components will        come to life and become interactive. -->    <script src="/app-components.js"></script>  </body>
```

If you arebundlingyour code, make sure the@lit-labs/ssr-client/lit-element-hydrate-support.jsis imported first:

``` js
// index.jsimport '@lit-labs/ssr-client/lit-element-hydrate-support.js';import './app-components.js';
```


## Using thetemplate-shadowrootpolyfill
The HTML snippet below includes an optional strategy to hide the body until the polyfill is loaded to prevent layout shifts.

``` html
<!DOCTYPE html><html>  <head>    <!-- On browsers that don't yet support native declarative shadow DOM, a        paint can occur after some or all pre-rendered HTML has been parsed,        but before the declarative shadow DOM polyfill has taken effect. This        paint is undesirable because it won't include any component shadow DOM.        To prevent layout shifts that can result from this render, we use a        "dsd-pending" attribute to ensure we only paint after we know        shadow DOM is active. -->    <style>      body[dsd-pending] {        display: none;      }    </style>  </head>  <body dsd-pending>    <script>      if (HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {        // This browser has native declarative shadow DOM support, so we can        // allow painting immediately.        document.body.removeAttribute('dsd-pending');      }    </script>    <!-- App components rendered with declarative shadow DOM placed here. -->    <!-- Use a type=module script so that we can use dynamic module imports.        Note this pattern will not work in IE11. -->    <script type="module">      // Check if we require the template shadow root polyfill.      if (!HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {        // Fetch the template shadow root polyfill.        const {hydrateShadowRoots} = await import(          '/node_modules/@webcomponents/template-shadowroot/template-shadowroot.js'        );        // Apply the polyfill. This is a one-shot operation, so it is important        // it happens after all HTML has been parsed.        hydrateShadowRoots(document.body);        // At this point, browsers without native declarative shadow DOM        // support can paint the initial state of your components!        document.body.removeAttribute('dsd-pending');      }    </script>  </body></html>
```


## Combined example
This example shows a strategy that combines both the@lit-labs/ssr-client/lit-element-hydrate-support.jsand thetemplate-shadowrootpolyfill loading and serves a page with a SSRed component to hydrate client-side.

Lit SSR in a Koa server

Edit this page


--------------------------------------------------------------------------------


# Lit SSR DOM emulation
Source: https://lit.dev/docs/ssr/dom-emulation/

When running in Node, Lit automatically imports and uses a set of DOM shims, and defines thecustomElementsglobal. Only the minimal DOM interfaces needed to define and register components are implemented. These include a few key DOM classes and a roughly functioningCustomElementRegistry.

✅ signifies item is implemented to be functionally the same as in the browser.

Edit this page


--------------------------------------------------------------------------------


# Server-side rendering (SSR)
Source: https://lit.dev/docs/ssr/overview/

Server-side rendering (SSR) is a technique for generating and serving the HTML of your components, including shadow DOM and styles, before their JavaScript implementations have loaded and executed.

You can use SSR for a variety of reasons:

- Performance. Some sites can render faster if they render static HTML first without waiting for JavaScript to load, then (optionally) load the page's JavaScript and hydrate the components.
- SEO and web crawlers. While the major search-engine web crawlers render pages with full JavaScript-enabled browsers, not all web crawlers support JavaScript.
- Robustness. Static HTML renders even if the JavaScript fails to load or the user has JavaScript disabled.
For a deeper dive into server-side rendering concepts and techniques generally, seeRendering on the Webon web.dev.

Lit supports server-side rendering through theLit SSRpackage. Lit SSR renders Lit components and templates to static HTML markup in non-browser JavaScript environments like Node. It works without fully emulating the browser's DOM, and takes advantage of Lit's declarative template format to enable fast performance, achieve low time-to-first-byte, and support streaming.

Lit SSR is a low-level library that you can use directly in your Node-based server or site generator. Check outan example of Lit SSR used in a Koa server.

A number of integrations have also been published which make Lit SSR work out-of-the-box:

- Lit Eleventy Plugin
- Astro integration for Lit
- Rocket
- Next.js pages router with@lit-labs/nextjs
- Nuxt 3 withnuxt-ssr-lit
- ...and more under development!

## Library status
This library is under active development with some notable limitations we hope to resolve:

- Async component work is not supported. See issue#2469.
- Only Lit components using shadow DOM is supported. See issue#3080.
- Declarative shadow DOM is not implemented in all major browsers yet, though a polyfill is available. Read more about it inclient usage.
- There are also open discussions that need to happen regardingElementRendererRegistryfor interop with other custom elements.
Edit this page


--------------------------------------------------------------------------------


# Lit SSR server usage
Source: https://lit.dev/docs/ssr/server-usage/


## Rendering templates
Server rendering begins with rendering a Littemplatewith a server-specificrender()function provided in the@lit-labs/ssrpackage.

The signature of the render function is:

``` ts
render(value: unknown, renderInfo?: Partial<RenderInfo>): RenderResult
```

Typicallyvalueis aTemplateResultproduced by a Lit template expression, like:

``` ts
html`<h1>Hello</h1>`
```

The template can contain custom elements. If the custom elements are defined on the server, they'll be rendered in turn, along with their templates.

``` ts
import {render} from '@lit-labs/ssr';import {html} from 'lit';// Import `my-element` on the server to server render it.import './my-element.js';const result = render(html`  <h1>Hello SSR!</h1>  <my-element></my-element>`);
```

To render a single element, you render a template that only contains that element:

``` ts
import {html} from 'lit';import './my-element.js';const result = render(html`<my-element></my-element>`);
```


## Handling RenderResults
render()returns aRenderResult: an iterable of values that can be streamed or concatenated into a string.

ARenderResultcan contain strings, nested render results, or Promises of strings or render results. Not all render results contain Promises—those can occur when custom elements perform async tasks, like fetching data—but because aRenderResultcan contain Promises, processing it into a string or an HTTP response ispotentiallyan async operation.

Even though aRenderResultcan contain Promises, it is still a sync iterable, not an async iterable. This is because sync iterables are faster than async iterables and many server renders will not require async rendering, and so shouldn't pay the overhead of an async iterable.

Allowing Promises in a sync iterable creates a kind of hybrid sync / async iteration protocol. When consuming aRenderResult, you must check each value to see if it is a Promise or iterable and wait or recurse as needed.

@lit-labs/ssrcontains three utilities to do this for you:

- RenderResultReadable
- collectResult()
- collectResultSync()
RenderResultReadableis a NodeReadablestream implementation that provides values from aRenderResult. This can be piped into aWritablestream, or passed to web server frameworks like Koa.

This is the preferred way to handle SSR results when integrating with a streaming HTTP server or other stream-supporting API.

``` ts
import {render} from '@lit-labs/ssr';import {RenderResultReadable} from '@lit-labs/ssr/lib/render-result-readable.js';import {html} from 'lit';// Using Koa to streamapp.use(async (ctx) => {  const result = render(html`<my-element></my-element>`);  ctx.type = 'text/html';  ctx.body = new RenderResultReadable(result);});
```

collectResult(result: RenderResult): Promise<string>

collectResult()is an async function that takes aRenderResultand joins it into a string. It waits for Promises and recurses into nested iterables.

``` ts
import {render} from '@lit-labs/ssr';import {collectResult} from '@lit-labs/ssr/lib/render-result.js';import {html} from 'lit';const result = render(html`<my-element></my-element>`);const contents = await collectResult(result);
```

collectResultSync(result: RenderResult): Promise<string>

collectResultSync()is a sync function that takes aRenderResultand joins it into a string. It recurses into nested iterables, butthrowswhen it encounters a Promise.

Because this function doesn't support async rendering, it's recommended to only use it when you can't await async functions.

``` ts
import {render} from '@lit-labs/ssr';import {collectResultSync} from '@lit-labs/ssr/lib/render-result.js';import {html} from 'lit';const result = render(html`<my-element></my-element>`);// Throws if `result` contains a Promise!const contents = collectResultSync(result);
```


## Render options
The second argument torender()is aRenderInfoobject that is used to pass options and current render state to components and sub-templates.

The main options that can be set by callers are:

- deferHydration: controls whether the top-level custom elements have adefer-hydrationattribute added to signal that the elements should not automatically hydrate. This defaults tofalseso that top-level elementsdoautomatically hydrate.
- elementRenderers: An array ofElementRendererclasses to use for rendering custom elements. By default this containsLitElementRendererto render Lit elements. It can be set to include customElementRendererinstances (documentation forthcoming), or set to an empty array to disable custom element rendering altogether.

## Running SSR in a VM module or the global scope
In order to render custom elements in Node, they must first be defined and registered with the globalcustomElementsAPI, which is a browser-only feature. As such, when Lit runs in Node, it automatically uses a set of minimal DOM APIs necessary to render Lit on the server, and defines thecustomElementsglobal. (For a list of emulated APIs, seeDOM emulation.)

Lit SSR provides two different ways of rendering custom elements server-side: rendering in theglobal scopeor viaVM modules. VM modules utilizes Node'svm.ModuleAPI, which enables running code within V8 Virtual Machine contexts. The two methods differ primarily in how global state, such as the custom elements registry, are shared.

When rendering in the global scope, a single sharedcustomElementsregistry will be defined and shared across all render requests, along with any other global state that your component code might set.

Rendering with VM modules allows each render request to have its own context with a separate global from the main Node process. ThecustomElementsregistry will only be installed within that context, and other global state will also be isolated to that context. VM modules are an experimental Node feature.

- Easy to use. Can import component modules directly and callrender()with templates.
- Custom elements are registered in a shared registry across different render requests.
- Isolates contexts across different render requests.
- Less intuitive usage. Need to write and specify a module file with a function to call.
- Slower due the module graph needing to be re-evaluated per request.

## Global Scope
When using the global scope, you can just callrender()with a template to get aRenderResultand pass that to your server:

``` js
import {render} from '@lit-labs/ssr';import {RenderResultReadable} from '@lit-labs/ssr/lib/render-result-readable.js';import {myTemplate} from './my-template.js';// ...// within a Koa middleware, for exampleapp.use(async (ctx) => {  const ssrResult = render(myTemplate(data));  ctx.type = 'text/html';  ctx.body = new RenderResultReadable(ssrResult);});
```


## VM Module
Lit also provide a way to load application code into, and render from, a separate VM context with its own global object.

``` js
// render-template.jsimport {render} from '@lit-labs/ssr';import {myTemplate} from './my-template.js';export const renderTemplate = (someData) => {  return render(myTemplate(someData));};
```

``` ts
// server.jsimport {ModuleLoader} from '@lit-labs/ssr/lib/module-loader.js';import {RenderResultReadable} from '@lit-labs/ssr/lib/render-result-readable.js';// ...// within a Koa middleware, for exampleapp.use(async (ctx) => {  const moduleLoader = new ModuleLoader();  const importResult = await moduleLoader.importModule(    './render-template.js',  // Module to load in VM context    import.meta.url          // Referrer URL for module  );  const {renderTemplate} = importResult.module.namespace    as typeof import('./render-template.js')  const ssrResult = await renderTemplate({some: "data"});  ctx.type = 'text/html';  ctx.body = new RenderResultReadable(ssrResult);});
```

``` js
// server.jsimport {ModuleLoader} from '@lit-labs/ssr/lib/module-loader.js';import {RenderResultReadable} from '@lit-labs/ssr/lib/render-result-readable.js';// ...// within a Koa middleware, for exampleapp.use(async (ctx) => {  const moduleLoader = new ModuleLoader();  const importResult = await moduleLoader.importModule(    './render-template.js',  // Module to load in VM context    import.meta.url          // Referrer URL for module  );  const {renderTemplate} = importResult.module.namespace;  const ssrResult = await renderTemplate({some: "data"});  ctx.type = 'text/html';  ctx.body = new RenderResultReadable(ssrResult);});
```

Note: Using this feature requires Node 14+ and passing the--experimental-vm-modulesflag to Node because of its use of experimental VM modules for creating a module-compatible VM context.

Edit this page


--------------------------------------------------------------------------------


# Conditionals
Source: https://lit.dev/docs/templates/conditionals/

Since Lit leverages normal Javascript expressions, you can use standard Javascript control flow constructs likeconditional operators, function calls, andiforswitchstatements to render conditional content.

JavaScript conditionals also let you combine nested template expressions, and you can even store template results in variables to use elsewhere.


## Conditionals with the conditional (ternary) operator
Ternary expressions with the conditional operator,?, are a great way to add inline conditionals:

``` ts
render() {  return this.userName    ? html`Welcome ${this.userName}`    : html`Please log in <button>Login</button>`;}
```


## Conditionals with if statements
You can express conditional logic with if statements outside of a template to compute values to use inside of the template:

``` ts
render() {  let message;  if (this.userName) {    message = html`Welcome ${this.userName}`;  } else {    message = html`Please log in <button>Login</button>`;  }  return html`<p class="message">${message}</p>`;}
```

Alternately, you can factor logic into a separate function to simplify your template:

``` ts
getUserMessage() {  if (this.userName) {    return html`Welcome ${this.userName}`;  } else {    return html`Please log in <button>Login</button>`;  }}render() {  return html`<p>${this.getUserMessage()}</p>`;}
```


## Caching template results: the cache directive
In most cases, JavaScript conditionals are all you need for conditional templates. However, if you're switching between large, complicated templates, you might want to save the cost of recreating DOM on each switch.

In this case, you can use thecachedirective. The cache directive caches DOM for templates that aren't being rendered currently.

``` ts
render() {  return html`${cache(this.userName ?    html`Welcome ${this.userName}`:    html`Please log in <button>Login</button>`)  }`;}
```

See thecache directivefor more information.


## Conditionally rendering nothing
Sometimes, you may want to render nothing in one branch of a conditional operator. This is commonly needed for child expressions and also sometimes needed in attribute expressions.

For child expressions, the valuesundefined,null, the empty string (''), and Lit'snothingsentinel value all render no nodes. SeeRemoving child contentfor more information.

This example renders a value if it exists, and otherwise renders nothing:

``` ts
render() {  return html`<user-name>${this.userName ?? nothing}</user-name>`;}
```

For attribute expressions, Lit'snothingsentinel value removes the attribute. SeeRemoving an attributefor more information.

This example conditionally renders thearia-labelattribute:

``` ts
html`<button aria-label="${this.ariaLabel || nothing}"></button>`
```

Edit this page


--------------------------------------------------------------------------------


# Custom directives
Source: https://lit.dev/docs/templates/custom-directives/

Directives are functions that can extend Lit by customizing how a template expression renders. Directives are useful and powerful because they can be stateful, access the DOM, be notified when templates are disconnected and reconnected, and independently update expressions outside of a render call.

Using a directive in your template is as simple as calling a function in a template expression:

``` js
html`<div>       ${fancyDirective('some text')}     </div>`
```

Lit ships with a number ofbuilt-in directiveslikerepeat()andcache(). Users can also write their own custom directives.

There are two kinds of directives:

- Simple functions
- Class-based directives
A simple function returns a value to render. It can take any number of arguments, or no arguments at all.

``` js
export noVowels = (str) => str.replaceAll(/[aeiou]/ig,'x');
```

A class-based directive lets you do things that a simple function can't. Use a class based directive to:

- Access the rendered DOM directly (for example, add, remove, or reorder rendered DOM nodes).
- Persist state between renders.
- Update the DOM asynchronously, outside of a render call.
- Clean up resources when the directive is disconnected from the DOM
The rest of this page describes class-based directives.


## Creating class-based directives
To create a class-based directive:

- Implement the directive as a class that extends theDirectiveclass.
- Pass your class to thedirective()factory to create a directive function that can be used in Lit template expressions.
``` js
import {Directive, directive} from 'lit/directive.js';// Define directiveclass HelloDirective extends Directive {  render() {    return `Hello!`;  }}// Create the directive functionconst hello = directive(HelloDirective);// Use directiveconst template = html`<div>${hello()}</div>`;
```

When this template is evaluated, the directivefunction(hello()) returns aDirectiveResultobject, which instructs Lit to create or update an instance of the directiveclass(HelloDirective). Lit then calls methods on the directive instance to run its update logic.

Some directives need to update the DOM asynchronously, outside of the normal update cycle. To create anasync directive, extend theAsyncDirectivebase class instead ofDirective. SeeAsync directivesfor details.


## Lifecycle of a class-based directive
The directive class has a few built-in lifecycle methods:

- The class constructor, for one-time initialization.
- render(), for declarative rendering.
- update(), for imperative DOM access.
You must implement therender()callback for all directives. Implementingupdate()is optional. The default implementation ofupdate()calls and returns the value fromrender().

Async directives, which can update the DOM outside of the normal update cycle, use some additional lifecycle callbacks. SeeAsync directivesfor details.


## One-time setup: constructor()
When Lit encounters aDirectiveResultin an expression for the first time, it will construct an instance of the corresponding directive class (causing the directive's constructor and any class field initializers to run):

``` ts
class MyDirective extends Directive {  // Class fields will be initialized once and can be used to persist  // state between renders  value = 0;  // Constructor is only run the first time a given directive is used  // in an expression  constructor(partInfo: PartInfo) {    super(partInfo);    console.log('MyDirective created');  }  ...}
```

``` js
class MyDirective extends Directive {  // Class fields will be initialized once and can be used to persist  // state between renders  value = 0;  // Constructor is only run the first time a given directive is used  // in an expression  constructor(partInfo) {    super(partInfo);    console.log('MyDirective created');  }  ...}
```

As long as the same directive function is used in the same expression each render, the previous instance is reused, thus the state of the instance persists between renders.

The constructor receives a singlePartInfoobject, which provides metadata about the expression the directive was used in. This can be useful for providing error checking in the cases where a directive is designed to be used only in specific types of expressions (seeLimiting a directive to one expression type).


## Declarative rendering: render()
Therender()method should return the value to render into the DOM. It can return any renderable value, including anotherDirectiveResult.

In addition to referring to state on the directive instance, therender()method can also accept arbitrary arguments passed in to the directive function:

``` js
const template = html`<div>${myDirective(name, rank)}</div>`
```

The parameters defined for therender()method determine the signature of the directive function:

``` ts
class MaxDirective extends Directive {  maxValue = Number.MIN_VALUE;  // Define a render method, which may accept arguments:  render(value: number, minValue = Number.MIN_VALUE) {    this.maxValue = Math.max(value, this.maxValue, minValue);    return this.maxValue;  }}const max = directive(MaxDirective);// Call the directive with `value` and `minValue` arguments defined for `render()`:const template = html`<div>${max(someNumber, 0)}</div>`;
```

``` js
class MaxDirective extends Directive {  maxValue = Number.MIN_VALUE;  // Define a render method, which may accept arguments:  render(value, minValue = Number.MIN_VALUE) {    this.maxValue = Math.max(value, this.maxValue, minValue);    return this.maxValue;  }}const max = directive(MaxDirective);// Call the directive with `value` and `minValue` arguments defined for `render()`:const template = html`<div>${max(someNumber, 0)}</div>`;
```


## Imperative DOM access: update()
In more advanced use cases, your directive may need to access the underlying DOM and imperatively read from or mutate it. You can achieve this by overriding theupdate()callback.

Theupdate()callback receives two arguments:

- APartobject with an API for directly managing the DOM associated with the expression.
- An array containing therender()arguments.
Yourupdate()method should return something Lit can render, or the special valuenoChangeif no re-rendering is required. Theupdate()callback is quite flexible, but typical uses include:

- Reading data from the DOM, and using it to generate a value to render.
- Imperatively updating the DOM using theelementorparentNodereference on thePartobject. In this case,update()usually returnsnoChange, indicating that Lit doesn't need to take any further action to render the directive.
Each expression position has its own specificPartobject:

- ChildPartfor expressions in HTML child position.
- AttributePartfor expressions in HTML attribute value position.
- BooleanAttributePartfor expressions in a boolean attribute value (name prefixed with?).
- EventPartfor expressions in an event listener position (name prefixed with@).
- PropertyPartfor expressions in property value position (name prefixed with.).
- ElementPartfor expressions on the element tag.
In addition to the part-specific metadata contained inPartInfo, allParttypes provide access to the DOMelementassociated with the expression (orparentNode, in the case ofChildPart), which may be directly accessed inupdate(). For example:

``` ts
// Renders attribute names of parent element to textContentclass AttributeLogger extends Directive {  attributeNames = '';  update(part: ChildPart) {    this.attributeNames = (part.parentNode as Element).getAttributeNames?.().join(' ');    return this.render();  }  render() {    return this.attributeNames;  }}const attributeLogger = directive(AttributeLogger);const template = html`<div a b>${attributeLogger()}</div>`;// Renders: `<div a b>a b</div>`
```

``` js
// Renders attribute names of parent element to textContentclass AttributeLogger extends Directive {  attributeNames = '';  update(part) {    this.attributeNames = part.parentNode.getAttributeNames?.().join(' ');    return this.render();  }  render() {    return this.attributeNames;  }}const attributeLogger = directive(AttributeLogger);const template = html`<div a b>${attributeLogger()}</div>`;// Renders: `<div a b>a b</div>`
```

In addition, thedirective-helpers.jsmodule includes a number of helper functions which act onPartobjects, and can be used to dynamically create, insert, and move parts within a directive'sChildPart.

The default implementation ofupdate()simply calls and returns the value fromrender(). If you overrideupdate()and still want to callrender()to generate a value, you need to callrender()explicitly.

Therender()arguments are passed intoupdate()as an array. You can pass the arguments torender()like this:

``` ts
class MyDirective extends Directive {  update(part: Part, [fish, bananas]: DirectiveParameters<this>) {    // ...    return this.render(fish, bananas);  }  render(fish: number, bananas: number) { ... }}
```

``` js
class MyDirective extends Directive {  update(part, [fish, bananas]) {    // ...    return this.render(fish, bananas);  }  render(fish, bananas) { ... }}
```


## Differences between update() and render()
While theupdate()callback is more powerful than therender()callback, there is an important distinction: When using the@lit-labs/ssrpackage for server-side rendering (SSR),onlytherender()method is called on the server. To be compatible with SSR, directives should return values fromrender()and only useupdate()for logic that requires access to the DOM.


## Signaling no change
Sometimes a directive may have nothing new for Lit to render. You signal this by returningnoChangefrom theupdate()orrender()method. This is different from returningundefined, which causes Lit to clear thePartassociated with the directive. ReturningnoChangeleaves the previously rendered value in place.

There are several common reasons for returningnoChange:

- Based on the input values, there's nothing new to render.
- Theupdate()method updated the DOM imperatively.
- In an async directive, a call toupdate()orrender()may returnnoChangebecause there's nothing to renderyet.
For example, a directive can keep track of the previous values passed in to it, and perform its own dirty checking to determine whether the directive's output needs to be updated. Theupdate()orrender()method can returnnoChangeto signal that the directive's output doesn't need to be re-rendered.

``` ts
import {Directive} from 'lit/directive.js';import {noChange} from 'lit';class CalculateDiff extends Directive {  a?: string;  b?: string;  render(a: string, b: string) {    if (this.a !== a || this.b !== b) {      this.a = a;      this.b = b;      // Expensive & fancy text diffing algorithm      return calculateDiff(a, b);    }    return noChange;  }}
```

``` js
import {Directive} from 'lit/directive.js';import {noChange} from 'lit';class CalculateDiff extends Directive {  render(a, b) {    if (this.a !== a || this.b !== b) {      this.a = a;      this.b = b;      // Expensive & fancy text diffing algorithm      return calculateDiff(a, b);    }    return noChange;  }}
```


## Limiting a directive to one expression type
Some directives are only useful in one context, such as an attribute expression or a child expression. If placed in the wrong context, the directive should throw an appropriate error.

For example, theclassMapdirective validates that it is only used in anAttributePartand only for theclassattribute`:

``` ts
class ClassMap extends Directive {  constructor(partInfo: PartInfo) {    super(partInfo);    if (      partInfo.type !== PartType.ATTRIBUTE ||      partInfo.name !== 'class'    ) {      throw new Error('The `classMap` directive must be used in the `class` attribute');    }  }  ...}
```

``` js
class ClassMap extends Directive {  constructor(partInfo) {    super(partInfo);    if (      partInfo.type !== PartType.ATTRIBUTE ||      partInfo.name !== 'class'    ) {      throw new Error('The `classMap` directive must be used in the `class` attribute');    }  }  ...}
```


## Async directives
The previous example directives are synchronous: they return values synchronously from theirrender()/update()lifecycle callbacks, so their results are written to the DOM during the component'supdate()callback.

Sometimes, you want a directive to be able to update the DOM asynchronously—for example, if it depends on an asynchronous event like a network request.

To update a directive's result asynchronously, a directive needs to extend theAsyncDirectivebase class, which provides asetValue()API.setValue()allows a directive to "push" a new value into its template expression, outside of the template's normalupdate/rendercycle.

Here's an example of a simple async directive that renders a Promise value:

``` ts
class ResolvePromise extends AsyncDirective {  render(promise: Promise<unknown>) {    Promise.resolve(promise).then((resolvedValue) => {      // Rendered asynchronously:      this.setValue(resolvedValue);    });    // Rendered synchronously:    return `Waiting for promise to resolve`;  }}export const resolvePromise = directive(ResolvePromise);
```

``` js
class ResolvePromise extends AsyncDirective {  render(promise) {    Promise.resolve(promise).then((resolvedValue) => {      // Rendered asynchronously:      this.setValue(resolvedValue);    });    // Rendered synchronously:    return `Waiting for promise to resolve`;  }}export const resolvePromise = directive(ResolvePromise);
```

Here, the rendered template shows "Waiting for promise to resolve", followed by the resolved value of the promise, whenever it resolves.

Async directives often need to subscribe to external resources. To prevent memory leaks, async directives should unsubscribe or dispose of resources when the directive instance is no longer in use. For this purpose,AsyncDirectiveprovides the following extra lifecycle callbacks and API:

- disconnected(): Called when a directive is no longer in use. Directive instances are disconnected in three cases:When the DOM tree the directive is contained in is removed from the DOMWhen the directive's host element is disconnectedWhen the expression that produced the directive no longer resolves to the same directive.After a directive receives adisconnectedcallback, it should release all resources it may have subscribed to duringupdateorrenderto prevent memory leaks.
disconnected(): Called when a directive is no longer in use. Directive instances are disconnected in three cases:

- When the DOM tree the directive is contained in is removed from the DOM
- When the directive's host element is disconnected
- When the expression that produced the directive no longer resolves to the same directive.
After a directive receives adisconnectedcallback, it should release all resources it may have subscribed to duringupdateorrenderto prevent memory leaks.

- reconnected(): Called when a previously disconnected directive is being returned to use. Because DOM subtrees can be temporarily disconnected and then reconnected again later, a disconnected directive may need to react to being reconnected. Examples of this include when DOM is removed and cached for later use, or when a host element is moved causing a disconnection and reconnection. Thereconnected()callback should always be implemented alongsidedisconnected(), in order to restore a disconnected directive back to its working state.
reconnected(): Called when a previously disconnected directive is being returned to use. Because DOM subtrees can be temporarily disconnected and then reconnected again later, a disconnected directive may need to react to being reconnected. Examples of this include when DOM is removed and cached for later use, or when a host element is moved causing a disconnection and reconnection. Thereconnected()callback should always be implemented alongsidedisconnected(), in order to restore a disconnected directive back to its working state.

- isConnected: Reflects the current connection state of the directive.
isConnected: Reflects the current connection state of the directive.

Note that it is possible for anAsyncDirectiveto continue receiving updates while it is disconnected if its containing tree is re-rendered. Because of this,updateand/orrendershould always check thethis.isConnectedflag before subscribing to any long-held resources to prevent memory leaks.

Below is an example of a directive that subscribes to anObservableand handles disconnection and reconnection appropriately:

``` ts
class ObserveDirective extends AsyncDirective {  observable: Observable<unknown> | undefined;  unsubscribe: (() => void) | undefined;  // When the observable changes, unsubscribe to the old one and  // subscribe to the new one  render(observable: Observable<unknown>) {    if (this.observable !== observable) {      this.unsubscribe?.();      this.observable = observable      if (this.isConnected)  {        this.subscribe(observable);      }    }    return noChange;  }  // Subscribes to the observable, calling the directive's asynchronous  // setValue API each time the value changes  subscribe(observable: Observable<unknown>) {    this.unsubscribe = observable.subscribe((v: unknown) => {      this.setValue(v);    });  }  // When the directive is disconnected from the DOM, unsubscribe to ensure  // the directive instance can be garbage collected  disconnected() {    this.unsubscribe!();  }  // If the subtree the directive is in was disconnected and subsequently  // re-connected, re-subscribe to make the directive operable again  reconnected() {    this.subscribe(this.observable!);  }}export const observe = directive(ObserveDirective);
```

``` js
class ObserveDirective extends AsyncDirective {  // When the observable changes, unsubscribe to the old one and  // subscribe to the new one  render(observable) {    if (this.observable !== observable) {      this.unsubscribe?.();      this.observable = observable      if (this.isConnected)  {        this.subscribe(observable);      }    }    return noChange;  }  // Subscribes to the observable, calling the directive's asynchronous  // setValue API each time the value changes  subscribe(observable) {    this.unsubscribe = observable.subscribe((v) => {      this.setValue(v);    });  }  // When the directive is disconnected from the DOM, unsubscribe to ensure  // the directive instance can be garbage collected  disconnected() {    this.unsubscribe();  }  // If the subtree the directive is in was disconneted and subsequently  // re-connected, re-subscribe to make the directive operable again  reconnected() {    this.subscribe(this.observable);  }}export const observe = directive(ObserveDirective);
```

Edit this page


--------------------------------------------------------------------------------


# Built-in directives
Source: https://lit.dev/docs/templates/directives/

Directives are functions that can extend Lit by customizing the way an expression renders. Lit includes a number of built-in directives to help with a variety of rendering needs:

Styling

classMap

Assigns a list of classes to an element based on an object.

styleMap

Sets a list of style properties to an element based on an object.

Loops and Conditionals

when

choose

map

repeat

join

range

ifDefined

Caching and change detection

cache

keyed

guard

live

Referencing rendered DOM

ref

Rendering special values

templateContent

Renders the content of a<template>element.

unsafeHTML

unsafeSVG

Asynchronous rendering

until

asyncAppend

Appends values from anAsyncIterableinto the DOM as they are yielded.

asyncReplace

Renders the latest value from anAsyncIterableinto the DOM as it is yielded.

Only bundle what you use.These are called "built-in" directives because they're part of the Lit package. But each directive is a separate module, so your app only bundles the directives you import.

You can also build your own directives. For more information, seeCustom directives.


## Styling

## classMap
Sets a list of classes to an element based on an object.

``` js
import {classMap} from 'lit/directives/class-map.js';
```

``` ts
classMap(classInfo: {[name: string]: string | boolean | number})
```

classattribute expression (must be the only expression in theclassattribute)

TheclassMapdirective uses theelement.classListAPI to efficiently add and remove classes to an element based on an object passed by the user. Each key in the object is treated as a class name, and if the value associated with the key is truthy, that class is added to the element. On subsequent renders, any previously set classes that are falsy or no longer in the object are removed.

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property({type: Boolean})  enabled = false;  render() {    const classes = { enabled: this.enabled, hidden: false };    return html`<div class=${classMap(classes)}>Classy text</div>`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    enabled: {type: Boolean},  };  constructor() {    super();    this.enabled = false;  }  render() {    const classes = { enabled: this.enabled, hidden: false };    return html`<div class=${classMap(classes)}>Classy text</div>`;  }}customElements.define('my-element', MyElement);
```

TheclassMapmust be the only expression in theclassattribute, but it can be combined with static values:

``` ts
html`<div class="my-widget ${classMap(dynamicClasses)}">Static and dynamic</div>`;
```

ExploreclassMapmore in theplayground.


## styleMap
Sets a list of style properties to an element based on an object.

``` js
import {styleMap} from 'lit/directives/style-map.js';
```

``` ts
styleMap(styleInfo: {[name: string]: string | undefined | null})
```

styleattribute expression (must be the only expression in thestyleattribute)

ThestyleMapdirective uses theelement.styleAPI to efficiently add and remove inline styles to an element based on an object passed by the user. Each key in the object is treated as a style property name, the value is treated as the value for that property. On subsequent renders, any previously set style properties that are undefined ornullare removed (set tonull).

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property({type: Boolean})  enabled = false;  render() {    const styles = { backgroundColor: this.enabled ? 'blue' : 'gray', color: 'white' };    return html`<p style=${styleMap(styles)}>Hello style!</p>`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    enabled: {type: Boolean},  };  constructor() {    super();    this.enabled = false;  }  render() {    const styles = { backgroundColor: this.enabled ? 'blue' : 'gray', color: 'white' };    return html`<p style=${styleMap(styles)}>Hello style!</p>`;  }}customElements.define('my-element', MyElement);
```

For CSS properties that contain dashes, you can either use the camel-case equivalent, or put the property name in quotes. For example, you can write the CSS propertyfont-familyas eitherfontFamilyor'font-family':

``` js
{ fontFamily: 'roboto' }{ 'font-family': 'roboto' }
```

Refer to CSS custom properties such as--custom-color, by placing the whole property name in quotes:

``` js
{ '--custom-color': 'steelblue' }
```

ThestyleMapmust be the only expression in thestyleattribute, but it can be combined with static values:

``` js
html`<p style="color: white; ${styleMap(moreStyles)}">More styles!</p>`;
```

ExplorestyleMapmore in theplayground.


## Loops and conditionals

## when
Renders one of two templates based on a condition.

``` js
import {when} from 'lit/directives/when.js';
```

``` ts
when<T, F>(  condition: boolean,  trueCase: () => T,  falseCase?: () => F)
```

Any

Whenconditionis true, returns the result of callingtrueCase(), else returns the result of callingfalseCase()iffalseCaseis defined.

This is a convenience wrapper around a ternary expression that makes it a little nicer to write an inline conditional without an else.

``` ts
class MyElement extends LitElement {  render() {    return html`      ${when(this.user, () => html`User: ${this.user.username}`, () => html`Sign In...`)}    `;  }}
```


## choose
Chooses and evaluates a template function from a list of cases based on matching the givenvalueto a case.

``` js
import {choose} from 'lit/directives/choose.js';
```

``` ts
choose<T, V>(  value: T,  cases: Array<[T, () => V]>,  defaultCase?: () => V)
```

Any

Cases are structured as[caseValue, func].valueis matched tocaseValueby strict equality. The first match is selected. Case values can be of any type including primitives, objects, and symbols.

This is similar to a switch statement, but as an expression and without fallthrough.

``` ts
class MyElement extends LitElement {  render() {    return html`      ${choose(this.section, [        ['home', () => html`<h1>Home</h1>`],        ['about', () => html`<h1>About</h1>`]      ],      () => html`<h1>Error</h1>`)}    `;  }}
```


## map
Returns an iterable containing the result of callingf(value)on each value initems.

``` js
import {map} from 'lit/directives/map.js';
```

``` ts
map<T>(  items: Iterable<T> | undefined,  f: (value: T, index: number) => unknown)
```

Any

map()is a simple wrapper around afor/of loopthat makes working with iterables in expressions a bit easier.map()always updates any DOM created in place - it does not do any diffing or DOM movement. If you need that seerepeat.map()is smaller and faster thanrepeat(), so if you don't need diffing and DOM stability, prefermap().

``` ts
class MyElement extends LitElement {  render() {    return html`      <ul>        ${map(items, (i) => html`<li>${i}</li>`)}      </ul>    `;  }}
```


## repeat
Renders values from an iterable into the DOM, with optional keying to enable data diffing and DOM stability.

``` js
import {repeat} from 'lit/directives/repeat.js';
```

``` ts
repeat(items: Iterable<T>, keyfn: KeyFn<T>, template: ItemTemplate<T>)repeat(items: Iterable<T>, template: ItemTemplate<T>)type KeyFn<T> = (item: T, index: number) => unknown;type ItemTemplate<T> = (item: T, index: number) => unknown;
```

Child expression

Repeats a series of values (usuallyTemplateResults) generated from an iterable, and updates those items efficiently when the iterable changes. When thekeyFnis provided, key-to-DOM association is maintained between updates by moving generated DOM when required, and is generally the most efficient way to userepeatsince it performs minimum unnecessary work for insertions and removals.

If you're not using a key function, you should consider usingmap().

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property()  items: Array<{id: number, name: string}> = [];  render() {    return html`      <ul>        ${repeat(this.items, (item) => item.id, (item, index) => html`          <li>${index}: ${item.name}</li>`)}      </ul>    `;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    items: {},  };  constructor() {    super();    this.items = [];  }  render() {    return html`      <ul>        ${repeat(this.items, (item) => item.id, (item, index) => html`          <li>${index}: ${item.name}</li>`)}      </ul>    `;  }}customElements.define('my-element', MyElement);
```

If nokeyFnis provided,repeatwill perform similar to a simple map of items to values, and DOM will be reused against potentially different items.

SeeWhen to use map or repeatfor a discussion of when to userepeatand when to use standard JavaScript flow control.

Explorerepeatmore in theplayground.


## join
Returns an iterable containing the values initemsinterleaved with thejoinervalue.

``` js
import {join} from 'lit/directives/join.js';
```

``` ts
join<I, J>(  items: Iterable<I> | undefined,  joiner: J): Iterable<I | J>;join<I, J>(  items: Iterable<I> | undefined,  joiner: (index: number) => J): Iterable<I | J>;
```

Any

``` ts
class MyElement extends LitElement {  render() {    return html`      ${join(        map(menuItems, (i) => html`<a href=${i.href}>${i.label}</a>`),        html`<span class="separator">|</span>`      )}    `;  }}
```


## range
Returns an iterable of integers fromstarttoend(exclusive) incrementing bystep.

``` js
import {range} from 'lit/directives/range.js';
```

``` ts
range(end: number): Iterable<number>;range(  start: number,  end: number,  step?: number): Iterable<number>;
```

Any

``` ts
class MyElement extends LitElement {  render() {    return html`      ${map(range(8), (i) => html`${i + 1}`)}    `;  }}
```


## ifDefined
Sets an attribute if the value is defined and removes the attribute if undefined.

``` js
import {ifDefined} from 'lit/directives/if-defined.js';
```

``` ts
ifDefined(value: unknown)
```

Attribute expression

For AttributeParts, sets the attribute if the value is defined and removes the attribute if the value is undefined (undefinedornull). For other part types, this directive is a no-op.

When more than one expression exists in a single attribute value, the attribute will be removed ifanyexpression usesifDefinedand evaluates toundefined/null. This is especially useful for setting URL attributes, when the attribute should not be set if required parts of the URL are not defined, to prevent 404's.

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property()  filename: string | undefined = undefined;  @property()  size: string | undefined = undefined;  render() {    // src attribute not rendered if either size or filename are undefined    return html`<img src="/images/${ifDefined(this.size)}/${ifDefined(this.filename)}">`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    filename: {},    size: {},  };  constructor() {    super();    this.filename = undefined;    this.size = undefined;  }  render() {    // src attribute not rendered if either size or filename are undefined    return html`<img src="/images/${ifDefined(this.size)}/${ifDefined(this.filename)}">`;  }}customElements.define('my-element', MyEleent);
```

ExploreifDefinedmore in theplayground.


## Caching and change detection

## cache
Caches rendered DOM when changing templates rather than discarding the DOM. You can use this directive to optimize rendering performance when frequently switching between large templates.

``` js
import {cache} from 'lit/directives/cache.js';
```

``` ts
cache(value: TemplateResult|unknown)
```

Child expression

When the value passed tocachechanges between one or moreTemplateResults, the rendered DOM nodes for a given template are cached when they're not in use. When the template changes, the directive caches thecurrentDOM nodes before switching to the new value, and restores them from the cache when switching back to a previously-rendered value, rather than creating the DOM nodes anew.

``` ts
const detailView = (data) => html`<div>...</div>`;const summaryView = (data) => html`<div>...</div>`;@customElement('my-element')class MyElement extends LitElement {  @property()  data = {showDetails: true, /*...*/ };  render() {    return html`${cache(this.data.showDetails      ? detailView(this.data)      : summaryView(this.data)    )}`;  }}
```

``` js
const detailView = (data) => html`<div>...</div>`;const summaryView = (data) => html`<div>...</div>`;class MyElement extends LitElement {  static properties = {    data: {},  };  constructor() {    super();    this.data = {showDetails: true, /*...*/ };  }  render() {    return html`${cache(this.data.showDetails      ? detailView(this.data)      : summaryView(this.data)    )}`;  }}customElements.define('my-element', MyElement);
```

When Lit re-renders a template, it only updates the modified portions: it doesn't create or remove any more DOM than needed. But when you switch from one template to another, Lit removes the old DOM and renders a new DOM tree.

Thecachedirective caches the generated DOM for a given expression and input template. In the example above, it caches the DOM for both thesummaryViewanddetailViewtemplates. When you switch from one view to another, Lit swaps in the cached version of the new view and updates it with the latest data. This can improve rendering performance when these views are frequently switched.

Explorecachemore in theplayground.


## keyed
Associates a renderable value with a unique key. When the key changes, the previous DOM is removed and disposed before rendering the next value, even if the value—such as a template—is the same.

``` js
import {keyed} from 'lit/directives/keyed.js';
```

``` ts
keyed(key: unknown, value: unknown)
```

Any expression

keyedis useful when you're rendering stateful elements and you need to ensure that all state of the element is cleared when some critical data changes. It essentially opts-out of Lit's default DOM reuse strategy.

keyedis also useful in some animation scenarios if you need to force a new element for "enter" or "exit" animations.

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property()  userId: string = '';  render() {    return html`      <div>        ${keyed(this.userId, html`<user-card .userId=${this.userId}></user-card>`)}      </div>`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    userId: {},  };  constructor() {    super();    this.userId = '';  }  render() {    return html`      <div>        ${keyed(this.userId, html`<user-card .userId=${this.userId}></user-card>`)}      </div>`;  }}customElements.define('my-element', MyElement);
```


## guard
Only re-evaluates the template when one of its dependencies changes, to optimize rendering performance by preventing unnecessary work.

``` js
import {guard} from 'lit/directives/guard.js';
```

``` ts
guard(dependencies: unknown[], valueFn: () => unknown)
```

Any expression

Renders the value returned byvalueFn, and only re-evaluatesvalueFnwhen one of the dependencies changes identity.

Where:

- dependenciesis an array of values to monitor for changes.
- valueFnis a function that returns a renderable value.
guardis useful with immutable data patterns, by preventing expensive work until data updates.

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property()  value: string = '';  render() {    return html`      <div>        ${guard([this.value], () => calculateSHA(this.value))}      </div>`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    value: {},  };  constructor() {    super();    this.value = '';  }  render() {    return html`      <div>        ${guard([this.value], () => calculateSHA(this.value))}      </div>`;  }}customElements.define('my-element', MyElement);
```

In this case, the expensivecalculateSHAfunction is only run when thevalueproperty changes.

Exploreguardmore in theplayground.


## live
Sets an attribute or property if it differs from the live DOM value rather than the last-rendered value.

``` js
import {live} from 'lit/directives/live.js';
```

``` ts
live(value: unknown)
```

Attribute or property expression

When determining whether to update the value, checks the expression value against theliveDOM value, instead of Lit's default behavior of checking against the last set value.

This is useful for cases where the DOM value may change from outside of Lit. For example, when using an expression to set an<input>element'svalueproperty, a content editable element's text, or to a custom element that changes its own properties or attributes.

In these cases if the DOM value changes, but the value set through Lit expression hasn't, Lit won't know to update the DOM value and will leave it alone. If this is not what you want—if you want to overwrite the DOM value with the bound value no matter what—use thelive()directive.

``` ts
@customElement('my-element')class MyElement extends LitElement {  @property()  data = {value: 'test'};  render() {    return html`<input .value=${live(this.data.value)}>`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    data: {},  };  constructor() {    super();    this.data = {value: 'test'};  }  render() {    return html`<input .value=${live(this.data.value)}>`;  }}customElements.define('my-element', MyElement);
```

live()performs a strict equality check against the live DOM value, and if the new value is equal to the live value, does nothing. This means thatlive()should not be used when the expression will cause a type conversion. If you uselive()with an attribute expression, make sure that only strings are passed in, or the expression will update every render.

Explorelivemore in theplayground.


## Rendering special values

## templateContent
Renders the content of a<template>element.

``` js
import {templateContent} from 'lit/directives/template-content.js';
```

``` ts
templateContent(templateElement: HTMLTemplateElement)
```

Child expression

Lit templates are encoded in Javascript, so that they can embed Javascript expressions that make them dynamic. If you have a static HTML<template>that you need to include in your Lit template, you can use thetemplateContentdirective to clone the template content and include it in your Lit template. As long as the template element reference does not change between renders, subsequent renders will no-op.

Note, the template content should be developer-controlled and must not be created using an untrusted string. Examples of untrusted content include query string parameters and values from user inputs. Untrusted templates rendered with this directive could lead tocross-site scripting (XSS)vulnerabilities.

``` ts
const templateEl = document.querySelector('template#myContent') as HTMLTemplateElement;@customElement('my-element')class MyElement extends LitElement {  render() {    return  html`      Here's some content from a template element:      ${templateContent(templateEl)}`;  }}
```

``` js
const templateEl = document.querySelector('template#myContent');class MyElement extends LitElement {  render() {    return  html`      Here's some content from a template element:      ${templateContent(templateEl)}`;  }}customElements.define('my-element', MyElement);
```

ExploretemplateContentmore in theplayground.


## unsafeHTML
Renders a string as HTML rather than text.

``` js
import {unsafeHTML} from 'lit/directives/unsafe-html.js';
```

``` ts
unsafeHTML(value: string | typeof nothing | typeof noChange)
```

Child expression

A key feature of Lit's templating syntax is that only strings originating in template literals are parsed as HTML. Because template literals can only be authored in trusted script files, this acts as a natural safeguard against XSS attacks injecting untrusted HTML. However, there may be cases when HTML not originating in script files needs to be rendered in a Lit template, for example trusted HTML content fetched from a database. TheunsafeHTMLdirective will parse such a string as HTML and render it in a Lit template.

Note, the string passed tounsafeHTMLmust be developer-controlled and not include untrusted content. Examples of untrusted content include query string parameters and values from user inputs.

Untrusted content rendered with this directive could lead tocross-site scripting (XSS), CSS injection, data exfiltration, etc. vulnerabilities.unsafeHTMLusesinnerHTMLto parse the HTML string, so the security implications are the same asinnerHTML,as documented on MDN.

``` ts
const markup = '<h3>Some HTML to render.</h3>';@customElement('my-element')class MyElement extends LitElement {  render() {    return html`      Look out, potentially unsafe HTML ahead:      ${unsafeHTML(markup)}    `;  }}
```

``` js
const markup = '<h3>Some HTML to render.</h3>';class MyElement extends LitElement {  render() {    return html`      Look out, potentially unsafe HTML ahead:      ${unsafeHTML(markup)}    `;  }}customElements.define('my-element', MyElement);
```

ExploreunsafeHTMLmore in theplayground.


## unsafeSVG
Renders a string as SVG rather than text.

``` js
import {unsafeSVG} from 'lit/directives/unsafe-svg.js';
```

``` ts
unsafeSVG(value: string | typeof nothing | typeof noChange)
```

Child expression

Similar to withunsafeHTML, there may be cases when SVG content not originating in script files needs to be rendered in a Lit template, for example trusted SVG content fetched from a database. TheunsafeSVGdirective will parse such a string as SVG and render it in a Lit template.

Note, the string passed tounsafeSVGmust be developer-controlled and not include untrusted content. Examples of untrusted content include query string parameters and values from user inputs. Untrusted content rendered with this directive could lead tocross-site scripting (XSS)vulnerabilities.

``` ts
const svg = '<circle cx="50" cy="50" r="40" fill="red" />';@customElement('my-element')class MyElement extends LitElement {  render() {    return html`      Look out, potentially unsafe SVG ahead:      <svg width="40" height="40" viewBox="0 0 100 100"        xmlns="http://www.w3.org/2000/svg" version="1.1">        ${unsafeSVG(svg)}      </svg> `;  }}
```

``` js
const svg = '<circle cx="50" cy="50" r="40" fill="red" />';class MyElement extends LitElement {  render() {    return html`      Look out, potentially unsafe SVG ahead:      <svg width="40" height="40" viewBox="0 0 100 100"        xmlns="http://www.w3.org/2000/svg" version="1.1">        ${unsafeSVG(svg)}      </svg> `;  }}customElements.define('my-element', MyElement);
```

ExploreunsafeSVGmore in theplayground.


## Referencing rendered DOM

## ref
Retrieves a reference to an element rendered into the DOM.

``` js
import {ref} from 'lit/directives/ref.js';
```

``` ts
ref(refOrCallback: RefOrCallback)
```

Element expression

Although most DOM manipulation in Lit can be achieved declaratively using templates, advanced situations may required getting a reference to an element rendered in the template and manipulating it imperatively. Common examples of when this may be useful include focusing a form control or calling an imperative DOM manipulation library on a container element.

When placed on an element in the template, therefdirective will retrieve a reference to that element once rendered. The element reference may be retrieved in one of two ways: either by passing aRefobject or by passing a callback.

ARefobject acts as a container for a reference to the element, and can be created using thecreateRefhelper method found in therefmodule. After rendering, theRef'svalueproperty will be set to the element, where it can be accessed in post-render lifecycle likeupdated.

``` ts
@customElement('my-element')class MyElement extends LitElement {  inputRef: Ref<HTMLInputElement> = createRef();  render() {    // Passing ref directive a Ref object that will hold the element in .value    return html`<input ${ref(this.inputRef)}>`;  }  firstUpdated() {    const input = this.inputRef.value!;    input.focus();  }}
```

``` js
class MyElement extends LitElement {  inputRef = createRef();  render() {    // Passing ref directive a Ref object that will hold the element in .value    return html`<input ${ref(this.inputRef)}>`;  }  firstUpdated() {    const input = this.inputRef.value!;    input.focus();  }}customElements.define('my-element', MyElement);
```

A ref callback can also be passed to therefdirective. The callback will be called each time the referenced element changes. If a ref callback is rendered to a different element position or is removed in a subsequent render, it will first be called withundefined, followed by another call with the new element it was rendered to (if any). Note that in aLitElement, the callback will be called bound to the host element automatically.

``` ts
@customElement('my-element')class MyElement extends LitElement {  render() {    // Passing ref directive a change callback    return html`<input ${ref(this.inputChanged)}>`;  }  inputChanged(input?: HTMLInputElement) {    input?.focus();  }}
```

``` js
class MyElement extends LitElement {  render() {    // Passing ref directive a change callback    return html`<input ${ref(this.inputChanged)}>`;  }  inputChanged(input) {    input?.focus();  }}customElements.define('my-element', MyElement);
```

Explorerefmore in theplayground.


## Asynchronous rendering

## until
Renders placeholder content until one or more promises resolve.

``` js
import {until} from 'lit/directives/until.js';
```

``` ts
until(...values: unknown[])
```

Any expression

Takes a series of values, including Promises. Values are rendered in priority order, with the first argument having the highest priority and the last argument having the lowest priority. If a value is a Promise, a lower-priority value will be rendered until it resolves.

The priority of values can be used to create placeholder content for async data. For example, a Promise with pending content can be the first (highest-priority) argument, and a non-promise loading indicator template can be used as the second (lower-priority) argument. The loading indicator renders immediately, and the primary content will render when the Promise resolves.

``` ts
@customElement('my-element')class MyElement extends LitElement {  @state()  private content = fetch('./content.txt').then(r => r.text());  render() {    return html`${until(this.content, html`<span>Loading...</span>`)}`;  }}
```

``` js
class MyElement extends LitElement {  static properties = {    content: {state: true},  };  constructor() {    super();    this.content = fetch('./content.txt').then(r => r.text());  }  render() {    return html`${until(this.content, html`<span>Loading...</span>`)}`;  }}customElements.define('my-element', MyElement);
```

Exploreuntilmore in theplayground.


## asyncAppend
Appends values from anAsyncIterableinto the DOM as they are yielded.

``` js
import {asyncAppend} from 'lit/directives/async-append.js';
```

``` ts
asyncAppend(  iterable: AsyncIterable<I>,  mapper?: (item: I, index?: number) => unknown)
```

Child expression

asyncAppendrenders the values of anasync iterable, appending each new value after the previous. Note that async generators also implement the async iterable protocol, and thus can be consumed byasyncAppend.

``` ts
async function *tossCoins(count: number) {  for (let i=0; i<count; i++) {    yield Math.random() > 0.5 ? 'Heads' : 'Tails';    await new Promise((r) => setTimeout(r, 1000));  }}@customElement('my-element')class MyElement extends LitElement {  @state()  private tosses = tossCoins(10);  render() {    return html`      <ul>${asyncAppend(this.tosses, (v: string) => html`<li>${v}</li>`)}</ul>`;  }}
```

``` js
async function *tossCoins(count) {  for (let i=0; i<count; i++) {    yield Math.random() > 0.5 ? 'Heads' : 'Tails';    await new Promise((r) => setTimeout(r, 1000));  }}class MyElement extends LitElement {  static properties = {    tosses: {state: true},  };  constructor() {    super();    this.tosses = tossCoins(10);  }  render() {    return html`      <ul>${asyncAppend(this.tosses, (v) => html`<li>${v}</li>`)}</ul>`;  }}customElements.define('my-element', MyElement);
```

ExploreasyncAppendmore in theplayground.


## asyncReplace
Renders the latest value from anAsyncIterableinto the DOM as it is yielded.

``` js
import {asyncReplace} from 'lit/directives/async-replace.js';
```

``` ts
asyncReplace(  iterable: AsyncIterable<I>,  mapper?: (item: I, index?: number) => unknown)
```

Any expression

Similar toasyncAppend,asyncReplacerenders the values of anasync iterable, replacing the previous value with each new value.

``` ts
async function *countDown(count: number) {  while (count > 0) {    yield count--;    await new Promise((r) => setTimeout(r, 1000));  }}@customElement('my-element')class MyElement extends LitElement {  @state()  private timer = countDown(10);  render() {    return html`Timer: <span>${asyncReplace(this.timer)}</span>.`;  }}
```

``` js
async function *countDown(count) {  while (count > 0) {    yield count--;    await new Promise((r) => setTimeout(r, 1000));  }}class MyElement extends LitElement {  static properties = {    timer: {state: true},  };  constructor() {    super();    this.timer = countDown(10);  }  render() {    return html`Timer: <span>${asyncReplace(this.timer)}</span>.`;  }}customElements.define('my-element', MyElement);
```

ExploreasyncReplacemore in theplayground.

Edit this page


--------------------------------------------------------------------------------


# Expressions
Source: https://lit.dev/docs/templates/expressions/

Lit templates can include dynamic values called expressions. An expression can be any JavaScript expression. The expression is evaluated when the template is evaluated, and the result of the expression is included when the template renders. In a Lit component, this means whenever therendermethod is called.

Expressions can only be placed in specific locations in the template, and how an expression is interpreted depends on where it appears. Expressions inside the element tag itself affect the element. Expressions inside the element's content, where child nodes go, render child nodes or text.

Valid values for expressions differ based on where the expression occurs. Generally all expressions accept primitive values like strings and numbers, and some expressions support additional value types. In addition, all expressions can acceptdirectives, which are special functions that customize the way an expression is processed and rendered. SeeCustom directivesfor more information.

Here's a quick reference followed by more detailed information about each expression type.

Child nodes

``` js
html`<h1>Hello ${name}</h1><ul>  ${listItems}</ul>`
```

Attributes

``` js
html`<div class=${highlightClass}></div>`
```

Boolean Attributes

``` js
html`<div ?hidden=${!show}></div>`
```

Properties

``` js
html`<input .value=${value}>`
```

Event listeners

``` js
html`<button @click=${this._clickHandler}>Go</button>`
```

Element directives

``` js
html`<input ${ref(inputRef)}>`
```

This basic example shows a variety of different kinds of expressions.

The following sections describe each kind of expression in more detail. For more information about the structure of templates, seeWell-formed HTMLandValid expression locations.


## Child expressions
An expression that occurs between the start and end tags of an element can add child nodes to the element. For example:

``` js
html`<p>Hello, ${name}</p>`
```

Or:

``` js
html`<main>${bodyText}</main>`
```

Expressions in the child position can take many kinds of values:

- Primitive values likes strings, numbers, and booleans.
- TemplateResultobjects created with thehtmlfunction (or thesvgfunction, if the expression is inside an<svg>element).
- DOM nodes.
- The sentinel valuesnothingandnoChange.
- Arrays or iterables of any of the supported types.

## Primitive values
Lit can render almost allprimitive valuesand converts them to strings when interpolated into text content.

Numbers values like5will render the string'5'. Bigints are treated similarly.

A boolean valuetruewill render'true', andfalsewill render'false', but rendering a boolean like this is uncommon. Instead booleans are typically used in conditionals to render other appropriate values. For more on conditionals, seeConditionals.

The empty string'',null, andundefinedare specially treated and render nothing. SeeRemoving child contentfor more information.

Symbol values cannot be converted to strings and throw when placed in child expressions.


## Sentinel values
Lit supplies a couple of special sentinel values that can be used in child expressions.

ThenoChangesentinel value does not change the expression's existing value. It is typically used in custom directives. SeeSignaling no changefor more information.

Thenothingsentinel renders nothing. SeeRemoving child contentfor more information.


## Templates
Since an expression in the child position can return aTemplateResult, you can nest and compose templates:

``` js
const nav = html`<nav>...</nav>`;const page = html`  ${nav}  <main>...</main>`;
```

This means you can use plain JavaScript to create conditional templates, repeating templates, and more.

``` js
html`  ${this.user.isloggedIn      ? html`Welcome ${this.user.name}`      : html`Please log in`  }`;
```

For more on conditionals, seeConditionals.

For more on using JavaScript to create repeating templates, seeLists.


## DOM nodes
Any DOM node can be passed to a child expression. Typically DOM nodes should be rendered by specifying a template usinghtml, but a DOM node can be directly rendered like this when needed. The node is attached to the DOM tree at that point, and so removed from any current parent:

``` js
const div = document.createElement('div');const page = html`  ${div}  <p>This is some text</p>`;
```


## Arrays or iterables of any of the supported types
An expression can also return an array or iterable of any of the supported types, in any combination. You can use this feature along with standard JavaScript like the Arraymapmethod to create repeating templates and lists. For examples, seeLists.


## Removing child content
The valuesnull,undefined, the empty string'', and Lit'snothingsentinel value remove any previously rendered content and render no node.

Setting or removing child content is often done based on a condition. SeeConditionally rendering nothingfor more information.

Rendering no node can be important when an expression is a child of an element with Shadow DOM that includes aslotwith fallback content. Rendering no node ensures the fallback content is rendered. Seefallback contentfor more information.


## Attribute expressions
In addition to using expressions to add child nodes, you can use them to set an elements's attributes and properties, too.

By default, an expression in the value of an attribute sets the attribute:

``` js
html`<div class=${this.textClass}>Stylish text.</div>`;
```

Since attribute values are always strings, the expression should return a value that can be converted into a string.

If the expression makes up the entire attribute value, you can leave off the quotes. If the expression makes up only part of the attribute value, you need to quote the entire value:

``` js
html`<img src="/images/${this.image}">`;
```

Note, some primitive values are handled specially in attributes. Boolean values are converted to strings so, for example,falserenders'false'. Bothundefinedandnullrender to an attribute as an empty string.


## Boolean attributes
To set a boolean attribute, use the?prefix with the attribute name. The attribute is added if the expression evaluates to a truthy value, removed if it evaluates to a falsy value:

``` js
html`<div ?hidden=${!this.showAdditional}>This text may be hidden.</div>`;
```


## Removing an attribute
Sometimes you want to set an attribute only under certain conditions, and otherwise remove the attribute. For common "boolean attributes" likedisabledandhiddenwhere you want to set the attribute to an empty string for a truthy value and remove it otherwise, use aboolean attribute. Sometimes, however, you might require a different condition for adding or removing an attribute.

For example, consider:

``` js
html`<img src="/images/${this.imagePath}/${this.imageFile}">`;
```

Ifthis.imagePathorthis.imageFileis not defined, thesrcattribute should not be set or an invalid network request will occur.

Lit'snothingsentinel value addresses this by removing the attribute when any expression in the attribute value evaluates tonothing.

``` js
html`<img src="/images/${this.imagePath ?? nothing}/${this.imageFile ?? nothing}">`;
```

In this exampleboththethis.imagePathandthis.imageFileproperties must be defined for thesrcattribute to be set. The??nullish coalescing operatorreturns the right-hand value if the left-hand value isnullorundefined.

Lit also provides anifDefineddirective which is sugar forvalue ?? nothing.

``` js
html`<img src="/images/${ifDefined(this.imagePath)}/${ifDefined(this.imageFile)}">`;
```

You might also want to remove the attribute if the value is not truthy so that values offalseor empty string''remove the attribute. For example, consider an element that has default value forthis.ariaLabelof empty string'':

``` js
html`<button aria-label="${this.ariaLabel || nothing}"></button>`
```

In this example thearia-labelattribute is rendered only ifthis.ariaLabelis not an empty string.

Setting or removing an attribute is often done based on a condition. SeeConditionally rendering nothingfor more information.


## Property expressions
You can set a JavaScript property on an element using the.prefix and the property name:

``` js
html`<input .value=${this.itemCount}>`;
```

The behavior of the code above is the same as directly setting thevalueproperty on theinputelement, e.g.:

``` js
inputEl.value = this.itemCount;
```

You can use the property expression syntax to pass complex data down the tree to subcomponents. For example, if you have amy-listcomponent with alistItemsproperty, you could pass it an array of objects:

``` js
html`<my-list .listItems=${this.items}></my-list>`;
```

Note that the property name in this example—listItems—is mixed case. Although HTMLattributesare case-insensitive, Lit preserves the case for property names when it processes the template.

For more information about component properties, seeReactive properties.


## Event listener expressions
Templates can also include declarative event listeners. Use the prefix@followed by the event name. The expression should evaluate to an event listener.

``` js
html`<button @click=${this.clickHandler}>Click Me!</button>`;
```

This is similar to callingaddEventListener('click', this.clickHandler)on the button element.

The event listener can be either a plain function, or an object with ahandleEventmethod — the same as thelistenerargument to the standardaddEventListenermethod.

In a Lit component, the event listener is automatically bound to the component, so you can use thethisvalue inside the handler to refer to the component instance.

``` js
clickHandler() {  this.clickCount++;}
```

For more information about component events, seeEvents.


## Element expressions
You can also add an expression that accesses an element instance, instead of a single property or attribute on an element:

``` js
html`<div ${myDirective()}></div>`
```

Element expressions only work withdirectives. Any other value type in an element expression is ignored.

One built-in directive that can be used in an element expression is therefdirective. It provides a reference to the rendered element.

``` js
html`<button ${ref(this.myRef)}></button>`;
```

Seereffor more information.


## Well-formed HTML
Lit templates must be well-formed HTML. The templates are parsed by the browser's built-in HTML parser before any values are interpolated. Follow these rules for well-formed templates:

- Templates must be well-formed HTML when all expressions are replaced by empty values.
Templates must be well-formed HTML when all expressions are replaced by empty values.

- Templates can have multiple top-level elements and text.
Templates can have multiple top-level elements and text.

- Templatesshould not containunclosed elements—they will be closed by the HTML parser.// HTML parser closes this div after "Some text"consttemplate1=html`<divclass="broken-div">Some text`;// When joined, "more text" does not end up in .broken-divconsttemplate2=html`${template1}more text.</div>`;
Templatesshould not containunclosed elements—they will be closed by the HTML parser.

``` js
// HTML parser closes this div after "Some text"const template1 = html`<div class="broken-div">Some text`;// When joined, "more text" does not end up in .broken-divconst template2 = html`${template1} more text. </div>`;
```

Because the browser's built-in parser is very lenient, most cases of malformed templates are not detectable at runtime, so you won't see warnings—just templates that don't behave as you expect. We recommend usinglinting toolsandIDE pluginsto find issues in your templates during development.


## Valid expression locations
Expressionscan only occurwhere you can place attribute values and child elements in HTML.

``` html
<!-- attribute values --><div label=${label}></div><button ?disabled=${isDisabled}>Click me!</button><input .value=${currentValue}><button @click=${this.handleClick()}><!-- child content --><div>${textContent}</div>
```

Element expressions can occur inside the opening tag after the tag name:

``` html
<div ${ref(elementReference)}></div>
```


## Invalid locations
Expressions should generally not appear in the following locations:

- Where tag or attribute names would appear. Lit does not support dynamically changing values in this position and will error in development mode.<!-- ERROR --><${tagName}></${tagName}><!-- ERROR --><div${attrName}=true></div>
Where tag or attribute names would appear. Lit does not support dynamically changing values in this position and will error in development mode.

``` html
<!-- ERROR --><${tagName}></${tagName}><!-- ERROR --><div ${attrName}=true></div>
```

- Inside<template>element content (attribute expressions on the template element itself are allowed). Lit does not recurse into template content to dynamically update expressions and will error in development mode.<!-- ERROR --><template>${content}</template><!-- OK --><templateid="${attrValue}">static content ok</template>
Inside<template>element content (attribute expressions on the template element itself are allowed). Lit does not recurse into template content to dynamically update expressions and will error in development mode.

``` html
<!-- ERROR --><template>${content}</template><!-- OK --><template id="${attrValue}">static content ok</template>
```

- Inside<textarea>element content (attribute expressions on the textarea element itself are allowed). Note that Lit can render content into textarea, however editing the textarea will break references to the DOM that Lit uses to dynamically update, and Lit will warn in development mode. Instead, bind to the.valueproperty of textarea.<!-- BEWARE --><textarea>${content}</textarea><!-- OK --><textarea.value=${content}></textarea><!-- OK --><textareaid="${attrValue}">static content ok</textarea>
Inside<textarea>element content (attribute expressions on the textarea element itself are allowed). Note that Lit can render content into textarea, however editing the textarea will break references to the DOM that Lit uses to dynamically update, and Lit will warn in development mode. Instead, bind to the.valueproperty of textarea.

``` html
<!-- BEWARE --><textarea>${content}</textarea><!-- OK --><textarea .value=${content}></textarea><!-- OK --><textarea id="${attrValue}">static content ok</textarea>
```

- Similarly, inside elements with thecontenteditableattribute. Instead, bind to the.innerTextproperty of the element.<!-- BEWARE --><divcontenteditable>${content}</div><!-- OK --><divcontenteditable.innerText=${content}></div><!-- OK --><divcontenteditableid="${attrValue}">static content ok</div>
Similarly, inside elements with thecontenteditableattribute. Instead, bind to the.innerTextproperty of the element.

``` html
<!-- BEWARE --><div contenteditable>${content}</div><!-- OK --><div contenteditable .innerText=${content}></div><!-- OK --><div contenteditable id="${attrValue}">static content ok</div>
```

- Inside HTML comments. Lit will not update expressions in comments, and the expressions will instead be rendered with a Lit token string. However, this will not break subsequent expressions, so commenting out blocks of HTML during development that may contain expressions is safe.<!-- will not update: ${value} -->
Inside HTML comments. Lit will not update expressions in comments, and the expressions will instead be rendered with a Lit token string. However, this will not break subsequent expressions, so commenting out blocks of HTML during development that may contain expressions is safe.

``` html
<!-- will not update: ${value} -->
```

- Inside<style>elements when using the ShadyCSS polyfill. SeeExpressions and style elementsfor more details.
Inside<style>elements when using the ShadyCSS polyfill. SeeExpressions and style elementsfor more details.

Note that expressions in all the invalid cases above are valid when usingstatic expressions, although these should not be used for performance-sensitive updates due to the inefficiencies involved (see below).


## Static expressions
Static expressions return special values that are interpolated into the templatebeforethe template is processed as HTML by Lit. Because they become part of the template's static HTML, they can be placed anywhere in the template - even where expressions would normally be disallowed, such as in attribute and tag names.

To use static expressions, you must import a special version of thehtmlorsvgtemplate tags from Lit'sstatic-htmlmodule:

``` ts
import {html, literal} from 'lit/static-html.js';
```

Thestatic-htmlmodule containshtmlandsvgtag functions which support static expressions and should be used instead of the standard versions provided in thelitmodule. Use theliteraltag function to create static expressions.

You can use static expressions for configuration options that are unlikely to change or for customizing parts of the template you cannot with normal expressions - see the section onValid expression locationsfor details. For example, amy-buttoncomponent might render a<button>tag, but a subclass might render an<a>tag, instead. This is a good place to use a static expression because the setting does not change frequently and customizing an HTML tag cannot be done with a normal expression.

``` ts
import {LitElement} from 'lit';import {customElement, property} from 'lit/decorators.js';import {html, literal} from 'lit/static-html.js';@customElement('my-button')class MyButton extends LitElement {  tag = literal`button`;  activeAttribute = literal`active`;  @property() caption = 'Hello static';  @property({type: Boolean}) active = false;  render() {    return html`      <${this.tag} ${this.activeAttribute}=${this.active}>        <p>${this.caption}</p>      </${this.tag}>`;  }}
```

``` js
import {LitElement} from 'lit';import {html, literal} from 'lit/static-html.js';class MyButton extends LitElement {  static properties = {    caption: {},    active: {type: Boolean},  };  tag = literal`button`;  activeAttribute = literal`active`;  constructor() {    super();    this.caption = 'Hello static';    this.active = false;  }  render() {    return html`      <${this.tag} ${this.activeAttribute}=${this.active}>        <p>${this.caption}</p>      </${this.tag}>`;  }}customElements.define('my-button', MyButton);
```

``` ts
@customElement('my-anchor')class MyAnchor extends MyButton {  tag = literal`a`;}
```

``` js
class MyAnchor extends MyButton {  tag = literal`a`;}customElements.define('my-anchor', MyAnchor);
```

Changing the value of static expressions is expensive.Expressions usingliteralvalues should not change frequently, as they cause a new template to be re-parsed and each variation is held in memory.

In the example above, if the template re-renders andthis.captionorthis.activechange, Lit updates the template efficiently, only changing the affected expressions. However, ifthis.tagorthis.activeAttributechange, since they are static values tagged withliteral, an entirely new template is created; the update is inefficient since the DOM is completely re-rendered. In addition, changingliteralvalues passed to expressions increases memory use since each unique template is cached in memory to improve re-render performance.

For these reasons, it's a good idea keep changes to expressions usingliteralto a minimum and avoid using reactive properties to changeliteralvalues, since reactive properties are intended to change.


## Template structure
After static values have been interpolated, the template must be well-formed like normal Lit templates, otherwise the dynamic expressions in the template might not function properly. See theWell-formed HTMLsection for more information.


## Non-literal statics
In rare cases, you may need to interpolate static HTML into a template that is not defined in your script, and thus cannot be tagged with theliteralfunction. For these cases, theunsafeStatic()function can be used to create static HTML based on strings from non-script sources.

``` ts
import {html, unsafeStatic} from 'lit/static-html.js';
```

Only for trusted content.Note the use ofunsafeinunsafeStatic(). The string passed tounsafeStatic()must be developer-controlled and not include untrusted content, because it will be parsed directly as HTML with no sanitization. Examples of untrusted content include query string parameters and values from user inputs. Untrusted content rendered with this directive could lead tocross-site scripting (XSS)vulnerabilities.

``` ts
@customElement('my-button')class MyButton extends LitElement {  @property() caption = 'Hello static';  @property({type: Boolean}) active = false;  render() {    // These strings MUST be trusted, otherwise this is an XSS vulnerability    const tag = getTagName();    const activeAttribute = getActiveAttribute();    // html should be imported from `lit/static-html.js`    return html`      <${unsafeStatic(tag)} ${unsafeStatic(activeAttribute)}=${this.active}>        <p>${this.caption}</p>      </${unsafeStatic(tag)}>`;  }}
```

``` js
class MyButton extends LitElement {  static properties = {    caption: {},    active: {type: Boolean},  };  constructor() {    super();    this.caption = 'Hello static';    this.active = false;  }  render() {    // These strings MUST be trusted, otherwise this is an XSS vulnerability    const tag = getTagName();    const activeAttribute = getActiveAttribute();    // html should be imported from `lit/static-html.js`    return html`      <${unsafeStatic(tag)} ${unsafeStatic(activeAttribute)}=${this.active}>        <p>${this.caption}</p>      </${unsafeStatic(tag)}>`;  }}customElements.define('my-button', MyButton);
```

Note that the behavior of usingunsafeStaticcarries the same caveats asliteral: because changing values causes a new template to be parsed and cached in memory, they should not change frequently.

Edit this page


--------------------------------------------------------------------------------


# Lists
Source: https://lit.dev/docs/templates/lists/

You can use standard JavaScript constructs to create repeating templates.

Lit also provides arepeatdirective to build certain kinds of dynamic lists more efficiently.


## Rendering arrays
When an expression in the child position returns an array or iterable, Lit renders all of the items in the array:

In most cases, you'll want to transform the array items into a more useful form.


## Repeating templates with map
To render lists, you can usemapto transform a list of data into a list of templates:

Note that this expression returns an array ofTemplateResultobjects. Lit will render an array or iterable of sub-templates and other values.


## Repeating templates with looping statements
You can also build an array of templates and pass it into a template expression.

``` ts
render() {  const itemTemplates = [];  for (const i of this.items) {    itemTemplates.push(html`<li>${i}</li>`);  }  return html`    <ul>      ${itemTemplates}    </ul>  `;}
```


## The repeat directive
In most cases, using loops ormapis an efficient way to build repeating templates. However, if you want to reorder a large list, or mutate it by adding and removing individual entries, this approach can involve updating a large number of DOM nodes.

Therepeatdirective can help here.

The repeat directive performs efficient updates of lists based on user-supplied keys:

``` ts
repeat(items, keyFunction, itemTemplate)
```

Where:

- itemsis an array or iterable.
- keyFunctionis a function that takes a single item as an argument and returns a guaranteed unique key for that item.
- itemTemplateis a template function that takes the item and its current index as arguments, and returns aTemplateResult.
For example:

If you re-sort theemployeesarray, therepeatdirective reorders the existing DOM nodes.

To compare this to Lit's default handling for lists, consider reversing a large list of names:

- For a list created usingmap, Lit maintains the DOM nodes for the list items, but reassigns the values.
- For a list created usingrepeat, therepeatdirective reorders theexistingDOM nodes, so the nodes representing the first list item move to the last position.

## When to use map or repeat
Which repeat is more efficient depends on your use case:

- If updating the DOM nodes is more expensive than moving them, use therepeatdirective.
If updating the DOM nodes is more expensive than moving them, use therepeatdirective.

- If the DOM nodes have state thatisn'tcontrolled by a template expression, use therepeatdirective.For example, consider this list:html`${this.users.map((user)=>html`<div><inputtype="checkbox">${user.name}</div>`)}`The checkbox has a checked or unchecked state, but it isn't controlled by a template expression.If you reorder the list after the user has checked one or more checkboxes, Lit would update the names associated with the checkboxes, but not the state of the checkboxes.
If the DOM nodes have state thatisn'tcontrolled by a template expression, use therepeatdirective.

For example, consider this list:

``` js
html`${this.users.map((user) =>  html`    <div><input type="checkbox"> ${user.name}</div>  `)}`
```

The checkbox has a checked or unchecked state, but it isn't controlled by a template expression.

If you reorder the list after the user has checked one or more checkboxes, Lit would update the names associated with the checkboxes, but not the state of the checkboxes.

If neither of these situations apply, usemapor looping statements.

Edit this page


--------------------------------------------------------------------------------


# Templates overview
Source: https://lit.dev/docs/templates/overview/


## TO DO
If time permits, add new page on working with inputs, per outline.

Lit templates are written using JavaScript template literals tagged with thehtmltag. The contents of the literal are mostly plain, declarative, HTML:

``` js
html`<h1>Hello ${name}</h1>`
```

The template syntax might look like you're just doing string interpolation. But with tagged template literals, the browser passes the tag function an array of strings (the static portions of the template) and an array of expressions (the dynamic portions). Lit uses this to build an efficient representation of your template, so it can re-render only the parts of template that have changed.

Lit templates are extremely expressive and allow you to render dynamic content in a variety of ways:

- Expressions: Templates can include dynamic values calledexpressionsthat can be used to render attributes, text, properties, event handlers, and even other templates.
- Conditionals: Expressions can render conditional content using standard JavaScript flow control.
- Lists: Render lists by transforming data into arrays of templates using standard JavaScript looping and array techniques.
- Built-in directives: Directives are functions that can extend Lit's templating functionality. The library includes a set of built-in directives to help with a variety of rendering needs.
- Custom directives: You can also write your own directives to customize Lit's rendering as needed.

## Standalone templating
You can also use Lit's templating library for standalone templating, outside of a Lit component. For details, seeStandalone lit-html templates.

Edit this page


--------------------------------------------------------------------------------


# Adding Lit to an existing project
Source: https://lit.dev/docs/tools/adding-lit/

Lit doesn't require any specialized tools, and Lit components work in any JavaScript framework or with any server templating system or CMS, so Lit is ideal for adding to existing projects and applications.


## Install from npm
First, install thelitpackage from npm:

``` sh
npm i lit
```

If you are not already using npm to manage JavaScript dependencies, you will have to set up your project first. We recommend thenpm CLI.


## Add a component
You can create a new element anywhere in your project's sources:

lib/components/my-element.ts

``` ts
import {LitElement, html} from 'lit';import {customElement} from 'lit/decorators.js';@customElement('my-element')class MyElement extends LitElement {  render() {    return html`      <div>Hello from MyElement!</div>    `;  }}
```

``` js
import {LitElement, html} from 'lit';class MyElement extends LitElement {  render() {    return html`      <div>Hello from MyElement!</div>    `;  }}customElements.define('my-element', MyElement);
```


## Use your component
How you use a component depends on your project and the libraries or frameworks it uses. You can use your component in HTML, with DOM APIs, or in template languages:


## Plain HTML
``` html
<script type="module" src="/lib/components/my-element.js"><my-element></my-element>
```


## JSX
JSX is a very common templating language. In JSX, lower-case element names create HTML elements, which is what Lit components are. Use the tag name you specified in the@customElement()decorator:

``` tsx
import './components/my-element.js';export const App = () => (  <h1>My App</h1>  <my-element></my-element>)
```


## Framework templates
Most JavaScript frameworks havegreat support for web componentsand Lit. Just import your element definition and use the element tag names in your templates.


## Next steps
At this point, you should be able to build and run your project and see the "Hello from MyElement!" message.

If you're ready to add features to your component, head over toComponentsto learn about building your first Lit component, orTemplatesfor details on writing templates.

For details on building projects, including some sample Rollup configurations, seeBuilding for production.

Edit this page


--------------------------------------------------------------------------------


# Development
Source: https://lit.dev/docs/tools/development/

During the development phase of your projects, when you're writing Lit components, the following tools can help boost your productivity:

- A dev server, for previewing code without a build step.
- TypeScript, for writing type-checked code.
- A linter, for catching Javascript errors.
- A code formatter, for consistently formatting code.
- Lit-specific IDE plugins, for linting and syntax-highlighting Lit templates.
Check out theStarter Kitsdocumentation to easily setup a development environment with all of these features pre-configured.


## Development and production builds
All the Lit packages are published with development and production builds, using Node's support forexport conditions.

The production build is optimized with very aggressive minification settings. The development build is unminified for easier debugging and includes extra checks and warnings. The default build is the production build, so that projects don't accidentally deploy the larger development build.

You must opt into the development build by specifying the"development"export condition in tools that support export conditions, such as Rollup, Webpack, and Web Dev Server. This is done differently for each tool.

For example, in Rollup, using the@rollup/node-resolveplugin, you can select the development build withexportConditionsoption:

``` js
import { nodeResolve } from '@rollup/plugin-node-resolve';export default {  // ...  plugins: [nodeResolve({    exportConditions: ['development']  })]};
```


## Development build runtime warnings
The development builds ofReactiveElementandLitElementsupport extra runtime warnings that can help identify issues that would be costly to check for in production builds.

Some warnings are always displayed. There are also two categories ofoptional warningsthat can be turned on or off:

- 'migration'. Warnings related to migration from LitElement 2.x. Off by default.
- 'change-in-update'. Warnings related to changing reactive state during an update. On by default.
You can control the optional warnings using theReactiveElement.disableWarning()andReactiveElement.enableWarning()methods. You can call them on any subclass ofReactiveElement, includingLitElementand your own classes. Calling the methods on a given class turns warnings on or off for and the warnings for that class and any subclasses. For instance, you can turn off a category of warnings on allReactiveElementclasses, on allLitElementclasses, or on a specificLitElementsubclass.

These methods are only available in development builds, so be sure to guard their access. We recommend using optional chaining.

Examples:

``` ts
import {LitElement, ReactiveElement} from 'lit';// Turn off migration warnings on all ReactiveElements,// including LitElementsReactiveElement.disableWarning?.('migration');// Turn off update warnings on all LitElementsLitElement.disableWarning?.('change-in-update');// Turn off update warnings on one elementMyElement.disableWarning?.('change-in-update');
```

You can also control warnings within a single class by defining astatic enabledWarningsproperty:

``` ts
class MyElement extends LitElement {  static enabledWarnings = ['migration'];}
```

It's best for code size if the code to control warnings is eliminated in your own production builds.

A dev mode only warning is triggered when multiple versions, or even multiple copies of the same version, of any of the Lit core packages –lit-html,lit-element,@lit/reactive-element– are detected.

If Lit is being used as an internal dependency of elements, elements can use different versions of Lit and are completely interoperable. We also take care to ensure that Lit 2 and Lit 3 are mostly compatible with each other. For example, you can pass a Lit 2 template into a Lit 3 render function and vice-versa.

So, why the warning? Lit is sometimes compared to frameworks which often break if components using different framework versions are mixed together. Thus, it's easier to accidentally install multiple duplicated versions of Lit without realizing.

Loading multiple compatible versions of Lit is non-optimal because extra duplicated bytes must be sent to the user.

If you’re publishing a library that uses Lit, follow ourpublishing best practicesso consumers of your library are able to de-duplicate Lit in their projects.

It is possible to follow the steps below, and not be able to de-duplicate Lit, e.g., a library you depend on is bundling a specific version of Lit. In these cases the warning can be ignored.

If you’re seeing aMultiple versions of Lit loadeddevelopment mode warning, there are a couple things you can try:

- Find out which Lit libraries have multiple versions loaded by checking the following variables in your browser console:window.litElementVersions,window.reactiveElementVersions, andwindow.litHtmlVersions.
Find out which Lit libraries have multiple versions loaded by checking the following variables in your browser console:window.litElementVersions,window.reactiveElementVersions, andwindow.litHtmlVersions.

- Usenpm ls(note, you can specify exact libraries to look for, e.g.npm ls @lit/reactive-element) to narrow down which dependencies are loading multiple different versions of Lit.
Usenpm ls(note, you can specify exact libraries to look for, e.g.npm ls @lit/reactive-element) to narrow down which dependencies are loading multiple different versions of Lit.

- Try to usenpm dedupeto de-duplicate Lit. Usenpm lsto verify if the duplicated Lit package was successfully de-duped.
Try to usenpm dedupeto de-duplicate Lit. Usenpm lsto verify if the duplicated Lit package was successfully de-duped.

- It is possible to nudgenpmto hoist particular versions of the core Lit packages by installing them as direct dependencies of your project withnpm i @lit/reactive-element@latest lit-element@latest lit-html@latest. Replacelatestwith the version you want to de-dupe to.
It is possible to nudgenpmto hoist particular versions of the core Lit packages by installing them as direct dependencies of your project withnpm i @lit/reactive-element@latest lit-element@latest lit-html@latest. Replacelatestwith the version you want to de-dupe to.

- If there is still duplication, you may need to delete your package lock andnode_modules. Then install the version oflityou want explicitly, followed by your dependencies.
If there is still duplication, you may need to delete your package lock andnode_modules. Then install the version oflityou want explicitly, followed by your dependencies.


## Local dev servers
Lit is packaged as JavaScript modules, and it uses bare module specifiers that are not yet natively supported in most browsers. Bare specifiers are commonly used, and you may want to use them in your own code as well. For example:

``` js
import {LitElement, html, css} from 'lit';
```

To run this code in the browser, the bare specifier ('lit') needs to be transformed to a URL that the browser can load (such as'/node_modules/lit/lit.js').

There are many development servers that can deal with module specifiers. If you already have a dev server that does this and integrates with your build process, that should be sufficient.

If you need a dev server, we recommendWeb Dev Server.


## Web Dev Server
Web Dev Serveris an open-source dev server that enables a build-free development process.

It handles rewriting bare module specifiers to valid URLs, as required by browsers.

Install Web Dev Server:

``` bash
npm i @web/dev-server --save-dev
```

Add a command to yourpackage.jsonfile:

``` json
"scripts": {  "start": "web-dev-server"}
```

And aweb-dev-server.config.jsfile:

``` js
export default {  open: true,  watch: true,  appIndex: 'index.html',  nodeResolve: {    exportConditions: ['development'],  },};
```

Run the dev server:

``` bash
npm run start
```

For older browsers like IE11, Web Dev Server can transform JavaScript modules to use the backwards-compatible SystemJS module loader, and automatically serve the web components polyfills. You'll need to configure the@web/dev-server-legacypackage to support older browsers.

Install the Web Dev Server legacy package:

``` bash
npm i @web/dev-server-legacy --save-dev
```

Configureweb-dev-server.config.js:

``` js
import { legacyPlugin } from '@web/dev-server-legacy';export default {  // ...  plugins: [    // Make sure this plugin is always last    legacyPlugin({      polyfills: {        webcomponents: true,        // Inject lit's polyfill-support module into test files, which is required        // for interfacing with the webcomponents polyfills        custom: [          {            name: 'lit-polyfill-support',            path: 'node_modules/lit/polyfill-support.js',            test: "!('attachShadow' in Element.prototype)",            module: false,          },        ],      },    }),  ],};
```

For full installation and usage instructions, see theWeb Dev Server documentation.


## TypeScript
Lit support developing components in TypeScript, including full type declarations for the Lit APIs, standard and experimental decorators, and community tools for template type-checking and linting.

Because Lit is just a library, and doesn't require a compiler or use non-standard language syntax, there are no specific TypeScript tools that are required. Lit works with the official TypeScript compiler,tsc, with TypeScript wrappers such as those for Rollup, Vite, or Webpack, and alternate compilers likeesbuild.

The main requirements of a TypeScript project are:

- Enabling a modern JavaScript language level, like with the"ES2021"lib.
- Enabling the DOM types with the"DOM"lib.
- Optionallyenabling experimental decoratorsanddisabling "define" semantics for class fields, if you choose to use TypeScript's experimental decorators.
These options are generally set in your project's tsconfig.


## Installation
To install TypeScript in your project:

``` bash
npm i -D typescript
```

To build the code:

``` bash
npx tsc --watch
```

For full installation and usage instructions, see theTypeScript site. To get started, the sections oninstalling TypeScriptandusing its featuresare particularly helpful.


## Decorators
TypeScript supports two versions of decorators: experimental and standard. See ourDecoratorsdocumentation for more information.


## JavaScript and TypeScript linting
Linting can help catch errors in your code. We recommend usingESLintfor linting Lit code.

To install ESLint in your project:

``` bash
npm install eslint --save-devnpx eslint --init
```

To run it:

``` bash
npx eslint yourfile.js
```

Or add it to your npm scripts:

``` json
{  "scripts": {    "lint": "eslint \"**/*.{js,ts}\"",  }}
```

For full installation and usage instructions, see theESLint documentation.

We also recommend theeslint-plugin-litfor ESLintwhich provides linting for Lit's HTML templates, inlcluding common HTML linting checks plus Lit-specific rules.

Integrating linting into your IDE workflow can help catch errors as early as possible. SeeLit-specific IDE pluginsto configure your IDE for Lit.


## Source formatting
Using a code formatter can help ensure code is consistent and readable. Integrating your formatter of choice with your IDE ensures your code is always clean and tidy.

A few popular options include:

- Prettier:VS Code plugin
- Beautifier:VS Code plugin
- Clang:VS Code plugin

## Lit-specific IDE plugins
There are a number of IDE plugins that may be useful when developing with Lit. In particular, we recommend using a syntax highlighter that works with Lit templates.


## lit-plugin
lit-pluginprovides syntax highlighting, type checking, and more for Lit templates. It'savailable for VS Code, or you can use thets-lit-pluginTypeScript compiler pluginwhich works with Sublime Text and Atom.

lit-pluginandts-lit-pluginprovide:

- Syntax highlighting
- Type-checking
- Code completion
- Hover-over docs
- Jump to definition
- Linting
- Quick Fixes

## ESLint
ESLint hasintegrationsfor a number of code editors. If you haveeslint-plugin-litfor ESLintinstalled in your ESLint configuration, your IDE will show the Lit specific errors and warnings.


## Other plugins
See theawesome-lit-htmlrepo for other IDE plugins, as well as additional tools and information.

Edit this page


--------------------------------------------------------------------------------


# Tools and workflows overview
Source: https://lit.dev/docs/tools/overview/

Lit components are written using plain JavaScript or TypeScript and run out-of-the box on modern browsers with minimal tooling, so you don'tneedany Lit-specific compilers, tools, or workflows.

However, Lit uses verymodernweb platform features, so it does require some tooling and polyfills to run on older browsers. Some tools also require configuration options to handle modern JavaScript. And, while Lit is "just JavaScript" there are some tools that make working with web components much nicer.

The tools and workflows docs cover the different phases of development:

- Requirements: Common requirements for tools and browsers to work with Lit out of the box, as well as compiler options and polyfills required for legacy browsers.
- Development: Setting up your local development environment, including dev server, linting, formatting, syntax highlighting and type-checking.
- Testing: Recommendations for testing Lit projects in modern and legacy browsers.
- Publishing: Guidelines for publishing your component packages to npm.
- Building for production: Building applications for production, including bundling, optimizations, and differential serving for modern and legacy browsers.
- Starter Kits: Instructions on using our Lit component starter kits for JavaScript and TypeScript.
- Adding Lit: Installing and adding Lit to an existing project.
Edit this page


--------------------------------------------------------------------------------


# Building for production
Source: https://lit.dev/docs/tools/production/

This page focuses on recommendations for building anapplicationthat uses Lit components for production. For recommendations on build steps to perform on source code prior to publishing a reusable Litcomponentto npm, seePublishing.

When building an application that includes Lit components, you can use common JavaScript build tools likeRolluporwebpackto prepare your source code and dependencies for serving in a production environment.

SeeRequirementsfor a full list of requirements for building Lit code, which apply to both development and production.

In addition to those minimum requirements, this page describes optimizations you should consider when preparing code for production, as well as a concrete Rollup configuration that implements them.


## Preparing code for production
Lit projects benefit from the same build-time optimizations as other web projects. The following optimizations are recommended when serving Lit applications in production:

- Bundling Javascript modules to reduce network requests (for example, usingRolluporwebpack).
- Minifying Javascript code for smaller payload sizes (Terserworks well for Lit, because it supports modern JavaScript).
- Serving modern code to modern browsersas it is generally smaller and faster, and falling back to compiled code on older browsers.
- Hashing static assets including bundled JavaScriptfor easier cache invalidation.
- Enabling serve-time compression(such as gzip or brotli) for fewer bytes over the wire.
In addition, note that because Lit templates are defined inside JavaScript template string literals, they don't get processed by standard HTML minifiers. Adding a plugin that minifies the HTML in template string literals can result in a modest decrease in code size. Several packages are available to perform this optimization:

- Rollup:rollup-plugin-minify-html-literals
- Webpack:minify-html-literals-loader

## Building with Rollup
There are many tools you can use to perform the required and optional build steps necessary to serve Lit code, and Lit does not require any one specific tool. However, we recommend Rollup because it's designed to work with the standard ES module format and output optimal code that leverages native modules on the client.

There are many ways to set up Rollup to bundle your project. TheModern Webproject maintains an excellent Rollup plugin@web/rollup-plugin-htmlthat helps tie a number of best-practices for building applications together into an easy-to-use package. Example configurations using this plugin are described below.


## Modern-only build
The annotatedrollup.config.jsfile below will build an application that meets themodern browser build requirementsandproduction optimizationsdescribed on this page. This configuration is suitable for serving to modern browsers that can run ES2021 JS without polyfills.

Required node modules:

``` sh
npm i --save-dev rollup \  @web/rollup-plugin-html \  @web/rollup-plugin-copy \  @rollup/plugin-node-resolve \  @rollup/plugin-terser \  rollup-plugin-minify-html-literals \  rollup-plugin-summary
```

rollup.config.js:

``` js
// Import rollup pluginsimport html from '@web/rollup-plugin-html';import {copy} from '@web/rollup-plugin-copy';import resolve from '@rollup/plugin-node-resolve';import {terser} from '@rollup/plugin-terser';import minifyHTML from 'rollup-plugin-minify-html-literals';import summary from 'rollup-plugin-summary';export default {  plugins: [    // Entry point for application build; can specify a glob to build multiple    // HTML files for non-SPA app    html({      input: 'index.html',    }),    // Resolve bare module specifiers to relative paths    resolve(),    // Minify HTML template literals    minifyHTML(),    // Minify JS    terser({      ecma: 2021,      module: true,      warnings: true,    }),    // Print bundle summary    summary(),    // Optional: copy any static assets to build directory    copy({      patterns: ['images/**/*'],    }),  ],  output: {    dir: 'build',  },  preserveEntrySignatures: 'strict',};
```

Running the rollup build:

``` sh
rollup -c
```

Edit this page


--------------------------------------------------------------------------------


# Publishing
Source: https://lit.dev/docs/tools/publishing/

This page provides guidelines for publishing a Lit component tonpm, the package manager used by the vast majority of JavaScript libraries and developers. SeeStarter Kitsfor reusable component templates set up for publishing to npm.


## Publishing to npm
To publish your component to npm,see the instructions on contributing npm packages.

Your package.json configuration should have thetype,main, andmodulefields:

package.json

``` json
{  "type": "module",  "main": "my-element.js",  "module": "my-element.js"}
```

You should also create a README describing how to consume your component.


## Publishing modern JavaScript
We recommend publishing JavaScript modules in standardES2021syntax, as this is supported on all evergreen browsers and results in the fastest and smallest JavaScript. Users of your package can always use a compiler to support older browsers, but they can't transform legacy JavaScript to modern syntax if you pre-compile your code before publishing.

However, it is important that if you are using newly proposed or non-standard JavaScript features such as TypeScript, decorators, and class fields, youshouldcompile those features to standard ES2021 supported natively in browsers before publishing to npm.


## Compiling with TypeScript
The following JSON sample is a partialtsconfig.jsonthat uses recommended options for targeting ES2021, enables compilation of decorators, and outputs.d.tstypes for users:

tsconfig.json

``` json
"compilerOptions": {  "target": "es2021",  "module": "es2015",  "moduleResolution": "node",  "lib": ["es2021", "dom"],  "declaration": true,  "declarationMap": true,  "experimentalDecorators": true,  "useDefineForClassFields": false}
```

Note, settinguseDefineForClassFieldstofalseshould only be required when thetargetis set toes2022or greater includingesnext, but it's recommended to explicitly ensure this setting isfalse.

When compiling from TypeScript, you should include declaration files (generated based ondeclaration: trueabove) for your component's types in thetypesfield ofpackage.json, and ensure the.d.tsand.d.ts.mapfiles are published as well:

package.json

``` json
{  ...  "types": "my-element.d.ts"}
```

See thetsconfig.json documentationfor more information.


## Compiling with Babel
To compile a Lit component that uses proposed JavaScript features not yet included in ES2021, use Babel.

Install Babel and the Babel plugins you need. For example:

``` sh
npm install --save-dev \  @babel/core \  @babel/cli \  @babel/preset-env \  @babel/plugin-proposal-decorators
```

Configure Babel. For example:

babel.config.json

``` json
{  "presets": [    ["@babel/preset-env", {"targets": "defaults"}]  ],  "plugins": [    ["@babel/plugin-proposal-decorators", {"version": "2023-05"}]  ]}
```

You can adjust the"targets"option to target browsers you wish to support. See@babel/preset-envfor available options.

You can run Babel via a bundler plugin such as@rollup/plugin-babel, or from the command line. See theBabel documentationfor more information.


## Publishing best practices
The following are other good practices to follow when publishing reusable Web Components.


## Don't import polyfills into modules
Polyfills are an application concern, so the application should depend directly on them, not individual packages. The exact polyfills needed often depends on the browsers the application needs to support, and that choice is best left to the application developer using your component. Your component's documentationshouldclearly identify any APIs it uses that may require polyfills.

Packages may need to depend on polyfills for tests and demos, so if they're needed, they should only go indevDependencies.


## Don't bundle, minify, or optimize modules
Bundling and other optimizations are application concerns. Bundling a reusable component before publishing to npm can also introduce multiple versions of Lit (and other packages) into a user's application since npm can't deduplicate the packages. This causes bloat and may cause bugs.

Optimizing modules before publication may also prevent application-level optimizations.

Bundling and other optimizations can be valuable when serving a module from a CDN, but since users may need to use multiple packages that depend on Lit, serving from a CDN can result in users loading more code than necessary. For these reasons we recommend performance-sensitive applications always build from npm where packages can be deduplicated, rather than loading bundled packages off of a CDN.

If you want to support usage from a CDN, we recommend making a clear separation between the CDN modules and the modules intended for production use. For example, placing them in a separate folder, or only adding them as part of a GitHub release and not adding them to the published npm module.


## Include file extensions in import specifiers
Node module resolution doesn't require file extensions because it does a search of the file system looking for one of several file extensions if one isn't given. When you importsome-package/foo, Node will importsome-package/foo.jsif it exists. Likewise, build tools that resolve package specifiers to URLs can also do this file system search at build time.

However, theimport mapsspecification that isstarting to shipin browsers will allow the browser to load modules with bare package specifiers from sourceuntransformed, by providing a mapping of import specifiers to URLs in an import map manifest (that will likely be tool generated based on your e.g. npm installation).

Import maps will allow mapping imports to URLs, but they only have two type of mappings: exact and prefix. That means it is easy to aliasallmodules under a given package by mapping the package name to a single URL prefix. However, if you write imports without file extensions, it means thateach filein your package would need an entry in the import map. This could greatly bloat the import map.

Thus, to prepare your source now to be optimally compatible with import maps, we recommend authoring with file extensions on imports.


## Publish TypeScript typings
To make your element easy to use from TypeScript, we recommend that you:

- Add anHTMLElementTagNameMapentry for all elements authored in TypeScript.@customElement('my-element')exportclassMyElementextendsLitElement{/* ... */}declareglobal{interfaceHTMLElementTagNameMap{"my-element":MyElement;}}
Add anHTMLElementTagNameMapentry for all elements authored in TypeScript.

``` ts
@customElement('my-element')export class MyElement extends LitElement { /* ... */ }declare global {  interface HTMLElementTagNameMap {    "my-element": MyElement;  }}
```

- Publish your.d.tstypings in your npm package.
Publish your.d.tstypings in your npm package.

For more information aboutHTMLElementTagNameMap, seeProviding good TypeScript typings.


## Self-define elements
The module that declares the web component class should always include a call tocustomElements.define()(or the@customElementdecorator) to define the element.

Currently, web components are always defined in a global registry. Each custom element definition needs to use a unique tag nameanda unique JavaScript class. Attempting to register the same tag name twice, or the same class twice will fail with an error. Simply exporting a class and expecting the user to calldefine()is brittle. If two different components both depend on a shared third component, and both try to define it, one will fail. This isn't a problem if an element is always defined in the same module where its class is declared.

One downside of this approach is that if two different elements use the same tag name, they can't both be imported to the same project.

Work is progressing on addingScoped Custom Element Registriesto the platform. Scoped registries allow a custom element's tag name to be chosen by the user of the component for a given shadow root scope. Once browsers start shipping this feature, it will become practical to publish two modules for each component: one that exports the custom element class with no side effects, and one that registers it globally with a tag name.

Until then, we recommend continuing to register elements in the global registry.


## Export element classes
In order to support subclassing, export your element class from the module that defines it. This allows subclassing for extension purposes, as well as for registering inScoped Custom Element Registriesin the future.


## For more reading
For a more general guide for creating high-quality reusable web components, see theGold Standard Checklist for Web Components.

Edit this page


--------------------------------------------------------------------------------


# Requirements
Source: https://lit.dev/docs/tools/requirements/

The most important things to know about Lit in order to work with various browsers and tools are that:

- Lit is published as ES2021.
- Lit uses "bare module specifiers" to import modules.
- Lit uses modern web APIs such as<template>, custom elements, shadow DOM, andParentNode.
These features are supported by the latest versions of major browsers (including Chrome, Edge, Safari, and Firefox) and most popular tools (such as Rollup, Webpack, Babel, and Terser)—with the exception of bare module specifier support in browsers.

When developing an app using Lit, either your target browsers need to support those features natively, or your tools will need to handle them. While there are a large number of browsers with various support for modern web features, for simplicity we recommend grouping browsers into one of two categories:

- Modern browserssupport ES2021 and web components. Tools must resolve bare module specifiers.
- Legacy browserssupport ES5 and don't support web components or newer DOM APIs. Tools must compile JavaScript and load polyfills.
This page gives a general overview for how to meet these requirements in your development and productions environments.

SeeDevelopment,Testing, andBuilding for Productionfor recommendations on tools and configurations that meet these requirements.


## Requirements for modern browsers
The only transformation required to use Lit on modern browsers is to convert bare module specifiers to browser-compatible URLs.

Lit uses bare module specifiers to import modules between its sub-packages, like this:

``` js
import {html} from 'lit-html';
```

Modern browsers currently only support loading modules from URLs or relative paths, not bare names that refer to an npm package, so the build system needs to handle them. This should be done either by transforming the specifier to one that works for ES modules in the browser, or by producing a different type of module as output.

Webpack automatically handles bare module specifiers; for Rollup, you'll need a plugin (@rollup/plugin-node-resolve).

Why bare module specifiers?Bare module specifiers let you import modules without knowing exactly where the package manager has installed them. A standards proposal calledImport mapsisstarting to ship, which will let browsers support bare module specifiers. In the meantime, bare import specifiers can easily be transformed as a build step. There are also some polyfills and module loaders that support import maps.


## Modern browser breakdown
All modern browsers update automatically and users are highly likely to have a recent version. Lit and related libraries are tested on the current versions of Chromium, Safari, and Firefox as well as two major versions prior for Chromium and Safari, and the Extended Support Release (ESR) for Firefox. Older versions may still work but will be at best efforts without guarantee.


## Note on legacy browsers
Lit 3 is not tested on legacy browsers, specifically Internet Explorer 11 and Classic Edge are not supported due to non-standard DOM behavior. If you must support legacy browsers, consider using Lit 2 with additional compilation and/or polyfills as described inBuilding for legacy browsers.

Edit this page


--------------------------------------------------------------------------------


# Starter kits
Source: https://lit.dev/docs/tools/starter-kits/

The Lit Starter Kits are project templates for reusable Lit components that can be published for others to use.

To get started working on a component locally, you can use one of these starter projects:

- Lit JavaScript starter project
- Lit TypeScript starter project
Both projects define a Lit component. They also add a set of optional tools for developing, linting, and testing the component:

- Node.js and npm for managing dependencies.Requires Node.js 10 or greater.
- A local dev server,Web Dev Server.
- Linting withESLintandlit-analyzer.
- Testing withWeb Test Runner.
- A static doc site built withweb-component-analyzerandeleventy.
None of these tools isrequiredto work with Lit. They represent one possible set of tools for a good developer experience.

Alternative starting point.As an alternative to the official Lit starter projects, the Open WC project has aproject generatorfor web components using Lit. The Open WC script asks a series of questions and scaffolds out a project for you.


## Download the starter project
The quickest way to try out a project locally is to download one of the starter projects as a zip file.

- Download the starter project from GitHub as a zip file:JavaScript starter projectTypeScript starter project
Download the starter project from GitHub as a zip file:

- JavaScript starter project
- TypeScript starter project
- Uncompress the zip file.
Uncompress the zip file.

- Install dependencies.cd <project folder>npm i
Install dependencies.

``` bash
cd <project folder>npm i
```

Want it on GitHub?If you're familiar with git you may want to create a GitHub repository for your starter project, instead of just downloading the zip file. You can use theGitHub template repositoryfeature to create your own repository from theJavaScript starter projector theTypeScript starter project. Then clone your new repository and install dependencies, as above.


## Try out your project
- If you're using the TypeScript version of the starter, build the JavaScript version of your project:npm run buildTo watch files and rebuild when the files are modified, run the following command in a separate shell:npm run build:watchNo build step is required if you're using the JavaScript version of the starter project.
If you're using the TypeScript version of the starter, build the JavaScript version of your project:

``` bash
npm run build
```

To watch files and rebuild when the files are modified, run the following command in a separate shell:

``` bash
npm run build:watch
```

No build step is required if you're using the JavaScript version of the starter project.

- Run the dev server:npm run serve
Run the dev server:

``` bash
npm run serve
```

- Open the project demo page in a browser tab. For example:http://localhost:8000/dev/Your server may use a different port number. Check the URL in the terminal output for the correct port number.
Open the project demo page in a browser tab. For example:

http://localhost:8000/dev/

Your server may use a different port number. Check the URL in the terminal output for the correct port number.


## Edit your component
Edit your component definition. The file you edit depends on which language you're using:

- JavaScript. Edit themy-element.jsfile in the project root.
- TypeScript. Edit themy-element.tsfile in thesrcdirectory.
A couple of things to look for in the code:

- The code defines a class for the component (MyElement) and registers it with the browser as a custom element named<my-element>.@customElement('my-element')exportclassMyElementextendsLitElement{/* ... */}exportclassMyElementextendsLitElement{/* ... */}customElements.define('my-element',MyElement);
The code defines a class for the component (MyElement) and registers it with the browser as a custom element named<my-element>.

``` ts
@customElement('my-element')export class MyElement extends LitElement { /* ... */ }
```

``` js
export class MyElement extends LitElement { /* ... */ }customElements.define('my-element', MyElement);
```

- The component'srendermethod defines atemplatethat will be rendered as a part of the component. In this case, it includes some text, some data bindings, and a button. For more information, seeTemplates.exportclassMyElementextendsLitElement{// ...render(){returnhtml`<h1>Hello,${this.name}!</h1><button@click=${this._onClick}>Click Count:${this.count}</button><slot></slot>`;}}
The component'srendermethod defines atemplatethat will be rendered as a part of the component. In this case, it includes some text, some data bindings, and a button. For more information, seeTemplates.

``` js
export class MyElement extends LitElement {  // ...  render() {    return html`      <h1>Hello, ${this.name}!</h1>      <button @click=${this._onClick}>        Click Count: ${this.count}      </button>      <slot></slot>    `;  }}
```

- The component defines some properties. The component responds to changes in these properties (for example, by re-rendering the template when necessary). For more information, seeProperties.exportclassMyElementextendsLitElement{// ...@property({type:String})name='World';//...}exportclassMyElementextendsLitElement{// ...staticproperties={name:{type:String}};constructor(){super();this.name='World';}// ...}
The component defines some properties. The component responds to changes in these properties (for example, by re-rendering the template when necessary). For more information, seeProperties.

``` ts
export class MyElement extends LitElement {  // ...  @property({type: String})  name = 'World';  //...}
```

``` js
export class MyElement extends LitElement {  // ...  static properties = {    name: {type: String}  };  constructor() {    super();    this.name = 'World';  }  // ...}
```


## Rename your component
You'll probably want to change the component name from "my-element" to something more appropriate. This is easiest to do using an IDE or other text editor that lets you do a global search and replace through an entire project.

- If you're using the TypeScript version, remove generated files:npm run clean
If you're using the TypeScript version, remove generated files:

``` bash
npm run clean
```

- Search and replace "my-element" with your new component name in all files in your project (except in thenode_modulesfolder).
Search and replace "my-element" with your new component name in all files in your project (except in thenode_modulesfolder).

- Search and replace "MyElement" with your new class name in all files in your project (except in thenode_modulesfolder).
Search and replace "MyElement" with your new class name in all files in your project (except in thenode_modulesfolder).

- Rename the source and test files to match the new component name:JavaScript:src/my-element.jssrc/test/my-element_test.jsTypeScript:src/my-element.tssrc/test/my-element_test.ts
Rename the source and test files to match the new component name:

JavaScript:

- src/my-element.js
- src/test/my-element_test.js
TypeScript:

- src/my-element.ts
- src/test/my-element_test.ts
- If you're using the TypeScript version, rebuild the project:npm run build
If you're using the TypeScript version, rebuild the project:

``` bash
npm run build
```

- Test and make sure your component is still working:npm run serve
Test and make sure your component is still working:

``` bash
npm run serve
```


## Next steps
Ready to add features to your component? Head over toComponentsto learn about building your first Lit component, orTemplatesfor details on writing templates.

For details on running tests and using other tools, see the starter project README:

- TypeScript project README
- JavaScript project README
For a guide on publishing your component tonpm, seePublishing.

Edit this page


--------------------------------------------------------------------------------


# Testing
Source: https://lit.dev/docs/tools/testing/

Testing ensures your code functions as you intend and saves you from tedious debugging.

See theStarter Kitsdocumentation for an easy to use setup with a fully pre-configured testing environment that works great for testing Lit components.


## Selecting a test framework
Lit is a standard modern Javascript library, and you can use virtually any Javascript testing framework to test your Lit code. There are many popular options, includingJest,Karma,Mocha,Jasmine,WebdriverIOandWeb Test Runner.

There are a few things you'll want to make sure your testing environment supports to effectively test your Lit code.


## Testing in the browser
Lit components are designed to run in the browser so testing should be conducted in a browser environment. Tools specifically focusing on testingnodecode may not be a good fit.


## Supporting modern Javascript
The test environment you use must have support for using modern Javascript, including using modules with bare module specifiers, or else down-leveling modern Javascript appropriately. See theRequirements for legacy browsersdocumentation for more details.


## Using polyfills
To test on older browsers, your test environment will need to load some polyfills, including theweb components polyfillsand Lit'spolyfill-supportmodule. See thePolyfillsdocumentation for more details.


## Using Web Test Runner
Web Test Runneris specifically designed to test modern web libraries like Lit using modern web features like custom elements and shadow DOM. See theGetting Starteddocumentation for Web Test Runner.

In order to support older browsers, you need to configure Web Test Runner as follows:

Install@web/dev-server-legacy:

``` bash
npm i @web/dev-server-legacy --save-dev
```

Setupweb-test-runner.config.js:

``` js
import { legacyPlugin } from '@web/dev-server-legacy';export default {  /* ... */  plugins: [    // make sure this plugin is always last    legacyPlugin({      polyfills: {        webcomponents: true,        // Inject lit's polyfill-support module into test files, which is required        // for interfacing with the webcomponents polyfills        custom: [          {            name: 'lit-polyfill-support',            path: 'node_modules/lit/polyfill-support.js',            test: "!('attachShadow' in Element.prototype)",            module: false,          },        ],      },    }),  ],};
```


## Using WebdriverIO
WebdriverIOis a good option for your component or end-to-end tests. It has very compelling advantages like support formockingandcode coveragereporting.

You can set up WebdriverIO in your project via:

``` bash
npm init wdio@latest ./
```

It will start a configuration wizard that will guide you through some questions. Make sure select the following:

- What type of testing would you like to do?Component or Unit Testing - in the browser
- Which framework do you use for building components?Lit
The remaining questions can be answered as desired.

In order test the component you have to render it into the test page before the test starts and ensure it gets cleaned up afterwards:

``` ts
import { expect, $ } from '@wdio/globals'// Component.ts contains the <simple-greeting> component implemented the same as:// https://lit.dev/docs/components/overview/import './components/Component.ts'describe('Lit Component testing', () => {    let elem: HTMLElement    beforeEach(() => {        elem = document.createElement('simple-greeting')    })    it('should render component', async () => {        elem.setAttribute('name', 'WebdriverIO')        document.body.appendChild(elem)        await expect($(elem)).toHaveText('Hello, WebdriverIO!')    })    afterEach(() => {        elem.remove()    })})
```

Find more information onelement assertions,finding elementswithin the Shadow DOM andmorein the WebdriverIO documentation.

Edit this page


--------------------------------------------------------------------------------
