# React Learning Curriculum
Scraped from https://react.dev/learn



# Quick Start
Source: https://react.dev/learn

Welcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.


### You will learn
- How to create and nest components
- How to add markup and styles
- How to display data
- How to render conditions and lists
- How to respond to events and update the screen
- How to share data between components

## Creating and nesting components
React apps are made out ofcomponents. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.

React components are JavaScript functions that return markup:

```jsx
function MyButton() {  return (    <button>I'm a button</button>  );}
```

Now that you’ve declaredMyButton, you can nest it into another component:

```jsx
export default function MyApp() {  return (    <div>      <h1>Welcome to my app</h1>      <MyButton />    </div>  );}
```

Notice that<MyButton />starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase.

Have a look at the result:

```jsx
function MyButton() {
  return (
    <button>
      I'm a button
    </button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton />
    </div>
  );
}


```

Theexport defaultkeywords specify the main component in the file. If you’re not familiar with some piece of JavaScript syntax,MDNandjavascript.infohave great references.


## Writing markup with JSX
The markup syntax you’ve seen above is calledJSX. It is optional, but most React projects use JSX for its convenience. All of thetools we recommend for local developmentsupport JSX out of the box.

JSX is stricter than HTML. You have to close tags like<br />. Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a<div>...</div>or an empty<>...</>wrapper:

```jsx
function AboutPage() {  return (    <>      <h1>About</h1>      <p>Hello there.<br />How do you do?</p>    </>  );}
```

If you have a lot of HTML to port to JSX, you can use anonline converter.


## Adding styles
In React, you specify a CSS class withclassName. It works the same way as the HTMLclassattribute:

```jsx
<img className="avatar" />
```

Then you write the CSS rules for it in a separate CSS file:

```jsx
/* In your CSS */.avatar {  border-radius: 50%;}
```

React does not prescribe how you add CSS files. In the simplest case, you’ll add a<link>tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.


## Displaying data
JSX lets you put markup into JavaScript. Curly braces let you “escape back” into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will displayuser.name:

```jsx
return (  <h1>    {user.name}  </h1>);
```

You can also “escape into JavaScript” from JSX attributes, but you have to use curly bracesinstead ofquotes. For example,className="avatar"passes the"avatar"string as the CSS class, butsrc={user.imageUrl}reads the JavaScriptuser.imageUrlvariable value, and then passes that value as thesrcattribute:

```jsx
return (  <img    className="avatar"    src={user.imageUrl}  />);
```

You can put more complex expressions inside the JSX curly braces too, for example,string concatenation:

```jsx
const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

export default function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={'Photo of ' + user.name}
        style={{
          width: user.imageSize,
          height: user.imageSize
        }}
      />
    </>
  );
}


```

In the above example,style={{}}is not a special syntax, but a regular{}object inside thestyle={ }JSX curly braces. You can use thestyleattribute when your styles depend on JavaScript variables.


## Conditional rendering
In React, there is no special syntax for writing conditions. Instead, you’ll use the same techniques as you use when writing regular JavaScript code. For example, you can use anifstatement to conditionally include JSX:

```jsx
let content;if (isLoggedIn) {  content = <AdminPanel />;} else {  content = <LoginForm />;}return (  <div>    {content}  </div>);
```

If you prefer more compact code, you can use theconditional?operator.Unlikeif, it works inside JSX:

```jsx
<div>  {isLoggedIn ? (    <AdminPanel />  ) : (    <LoginForm />  )}</div>
```

When you don’t need theelsebranch, you can also use a shorterlogical&&syntax:

```jsx
<div>  {isLoggedIn && <AdminPanel />}</div>
```

All of these approaches also work for conditionally specifying attributes. If you’re unfamiliar with some of this JavaScript syntax, you can start by always usingif...else.


## Rendering lists
You will rely on JavaScript features likeforloopand thearraymap()functionto render lists of components.

For example, let’s say you have an array of products:

```jsx
const products = [  { title: 'Cabbage', id: 1 },  { title: 'Garlic', id: 2 },  { title: 'Apple', id: 3 },];
```

Inside your component, use themap()function to transform an array of products into an array of<li>items:

```jsx
const listItems = products.map(product =>  <li key={product.id}>    {product.title}  </li>);return (  <ul>{listItems}</ul>);
```

Notice how<li>has akeyattribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.

```jsx
const products = [
  { title: 'Cabbage', isFruit: false, id: 1 },
  { title: 'Garlic', isFruit: false, id: 2 },
  { title: 'Apple', isFruit: true, id: 3 },
];

export default function ShoppingList() {
  const listItems = products.map(product =>
    <li
      key={product.id}
      style={{
        color: product.isFruit ? 'magenta' : 'darkgreen'
      }}
    >
      {product.title}
    </li>
  );

  return (
    <ul>{listItems}</ul>
  );
}


```


## Responding to events
You can respond to events by declaringevent handlerfunctions inside your components:

```jsx
function MyButton() {  function handleClick() {    alert('You clicked me!');  }  return (    <button onClick={handleClick}>      Click me    </button>  );}
```

Notice howonClick={handleClick}has no parentheses at the end! Do notcallthe event handler function: you only need topass it down. React will call your event handler when the user clicks the button.


## Updating the screen
Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, addstateto your component.

First, importuseStatefrom React:

```jsx
import { useState } from 'react';
```

Now you can declare astate variableinside your component:

```jsx
function MyButton() {  const [count, setCount] = useState(0);  // ...
```

You’ll get two things fromuseState: the current state (count), and the function that lets you update it (setCount). You can give them any names, but the convention is to write[something, setSomething].

The first time the button is displayed,countwill be0because you passed0touseState(). When you want to change state, callsetCount()and pass the new value to it. Clicking this button will increment the counter:

```jsx
function MyButton() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <button onClick={handleClick}>      Clicked {count} times    </button>  );}
```

React will call your component function again. This time,countwill be1. Then it will be2. And so on.

If you render the same component multiple times, each will get its own state. Click each button separately:

```jsx
import { useState } from 'react';

export default function MyApp() {
  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}


```

Notice how each button “remembers” its owncountstate and doesn’t affect other buttons.


## Using Hooks
Functions starting withuseare calledHooks.useStateis a built-in Hook provided by React. You can find other built-in Hooks in theAPI reference.You can also write your own Hooks by combining the existing ones.

Hooks are more restrictive than other functions. You can only call Hooksat the topof your components (or other Hooks). If you want to useuseStatein a condition or a loop, extract a new component and put it there.


## Sharing data between components
In the previous example, eachMyButtonhad its own independentcount, and when each button was clicked, only thecountfor the button clicked changed:

Initially, eachMyButton’scountstate is0

The firstMyButtonupdates itscountto1

However, often you’ll need components toshare data and always update together.

To make bothMyButtoncomponents display the samecountand update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them.

In this example, it isMyApp:

Initially,MyApp’scountstate is0and is passed down to both children

On click,MyAppupdates itscountstate to1and passes it down to both children

Now when you click either button, thecountinMyAppwill change, which will change both of the counts inMyButton. Here’s how you can express this in code.

First,move the state upfromMyButtonintoMyApp:

```jsx
export default function MyApp() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <div>      <h1>Counters that update separately</h1>      <MyButton />      <MyButton />    </div>  );}function MyButton() {  // ... we're moving code from here ...}
```

Then,pass the state downfromMyAppto eachMyButton, together with the shared click handler. You can pass information toMyButtonusing the JSX curly braces, just like you previously did with built-in tags like<img>:

```jsx
export default function MyApp() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1);  }  return (    <div>      <h1>Counters that update together</h1>      <MyButton count={count} onClick={handleClick} />      <MyButton count={count} onClick={handleClick} />    </div>  );}
```

The information you pass down like this is calledprops. Now theMyAppcomponent contains thecountstate and thehandleClickevent handler, andpasses both of them down as propsto each of the buttons.

Finally, changeMyButtontoreadthe props you have passed from its parent component:

```jsx
function MyButton({ count, onClick }) {  return (    <button onClick={onClick}>      Clicked {count} times    </button>  );}
```

When you click the button, theonClickhandler fires. Each button’sonClickprop was set to thehandleClickfunction insideMyApp, so the code inside of it runs. That code callssetCount(count + 1), incrementing thecountstate variable. The newcountvalue is passed as a prop to each button, so they all show the new value. This is called “lifting state up”. By moving state up, you’ve shared it between components.

```jsx
import { useState } from 'react';

export default function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>Counters that update together</h1>
      <MyButton count={count} onClick={handleClick} />
      <MyButton count={count} onClick={handleClick} />
    </div>
  );
}

function MyButton({ count, onClick }) {
  return (
    <button onClick={onClick}>
      Clicked {count} times
    </button>
  );
}


```


## Next Steps
By now, you know the basics of how to write React code!

Check out theTutorialto put them into practice and build your first mini-app with React.


--------------------------------------------------------------------------------


# Tutorial: Tic-Tac-Toe
Source: https://react.dev/learn/tutorial-tic-tac-toe

You will build a small tic-tac-toe game during this tutorial. This tutorial does not assume any existing React knowledge. The techniques you’ll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React.


### Note
This tutorial is designed for people who prefer tolearn by doingand want to quickly try making something tangible. If you prefer learning each concept step by step, start withDescribing the UI.

The tutorial is divided into several sections:

- Setup for the tutorialwill give youa starting pointto follow the tutorial.
- Overviewwill teach youthe fundamentalsof React: components, props, and state.
- Completing the gamewill teach youthe most common techniquesin React development.
- Adding time travelwill give youa deeper insightinto the unique strengths of React.

### What are you building?
In this tutorial, you’ll build an interactive tic-tac-toe game with React.

You can see what it will look like when you’re finished here:

```jsx
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const xIsNext = currentMove % 2 === 0;
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```

If the code doesn’t make sense to you yet, or if you are unfamiliar with the code’s syntax, don’t worry! The goal of this tutorial is to help you understand React and its syntax.

We recommend that you check out the tic-tac-toe game above before continuing with the tutorial. One of the features that you’ll notice is that there is a numbered list to the right of the game’s board. This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses.

Once you’ve played around with the finished tic-tac-toe game, keep scrolling. You’ll start with a simpler template in this tutorial. Our next step is to set you up so that you can start building the game.


## Setup for the tutorial
In the live code editor below, clickForkin the top-right corner to open the editor in a new tab using the website CodeSandbox. CodeSandbox lets you write code in your browser and preview how your users will see the app you’ve created. The new tab should display an empty square and the starter code for this tutorial.

```jsx
export default function Square() {
  return <button className="square">X</button>;
}


```


### Note
You can also follow this tutorial using your local development environment. To do this, you need to:

- InstallNode.js
- In the CodeSandbox tab you opened earlier, press the top-left corner button to open the menu, and then chooseDownload Sandboxin that menu to download an archive of the files locally
- Unzip the archive, then open a terminal andcdto the directory you unzipped
- Install the dependencies withnpm install
- Runnpm startto start a local server and follow the prompts to view the code running in a browser
If you get stuck, don’t let this stop you! Follow along online instead and try a local setup again later.


## Overview
Now that you’re set up, let’s get an overview of React!


### Inspecting the starter code
In CodeSandbox you’ll see three main sections:

- TheFilessection with a list of files likeApp.js,index.js,styles.cssinsrcfolder and a folder calledpublic
- Thecode editorwhere you’ll see the source code of your selected file
- Thebrowsersection where you’ll see how the code you’ve written will be displayed
TheApp.jsfile should be selected in theFilessection. The contents of that file in thecode editorshould be:

```jsx
export default function Square() {  return <button className="square">X</button>;}
```

Thebrowsersection should be displaying a square with an X in it like this:

Now let’s have a look at the files in the starter code.


#### App.js
The code inApp.jscreates acomponent. In React, a component is a piece of reusable code that represents a part of a user interface. Components are used to render, manage, and update the UI elements in your application. Let’s look at the component line by line to see what’s going on:

```jsx
export default function Square() {  return <button className="square">X</button>;}
```

The first line defines a function calledSquare. TheexportJavaScript keyword makes this function accessible outside of this file. Thedefaultkeyword tells other files using your code that it’s the main function in your file.

```jsx
export default function Square() {  return <button className="square">X</button>;}
```

The second line returns a button. ThereturnJavaScript keyword means whatever comes after is returned as a value to the caller of the function.<button>is aJSX element. A JSX element is a combination of JavaScript code and HTML tags that describes what you’d like to display.className="square"is a button property orpropthat tells CSS how to style the button.Xis the text displayed inside of the button and</button>closes the JSX element to indicate that any following content shouldn’t be placed inside the button.


#### styles.css
Click on the file labeledstyles.cssin theFilessection of CodeSandbox. This file defines the styles for your React app. The first twoCSS selectors(*andbody) define the style of large parts of your app while the.squareselector defines the style of any component where theclassNameproperty is set tosquare. In your code, that would match the button from your Square component in theApp.jsfile.


#### index.js
Click on the file labeledindex.jsin theFilessection of CodeSandbox. You won’t be editing this file during the tutorial but it is the bridge between the component you created in theApp.jsfile and the web browser.

```jsx
import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';import './styles.css';import App from './App';
```

Lines 1-5 bring all the necessary pieces together:

- React
- React’s library to talk to web browsers (React DOM)
- the styles for your components
- the component you created inApp.js.
The remainder of the file brings all the pieces together and injects the final product intoindex.htmlin thepublicfolder.


### Building the board
Let’s get back toApp.js. This is where you’ll spend the rest of the tutorial.

Currently the board is only a single square, but you need nine! If you just try and copy paste your square to make two squares like this:

```jsx
export default function Square() {  return <button className="square">X</button><button className="square">X</button>;}
```

You’ll get this error:

React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons. To fix this you can useFragments(<>and</>) to wrap multiple adjacent JSX elements like this:

```jsx
export default function Square() {  return (    <>      <button className="square">X</button>      <button className="square">X</button>    </>  );}
```

Now you should see:

Great! Now you just need to copy-paste a few times to add nine squares and…

Oh no! The squares are all in a single line, not in a grid like you need for our board. To fix this you’ll need to group your squares into rows withdivs and add some CSS classes. While you’re at it, you’ll give each square a number to make sure you know where each square is displayed.

In theApp.jsfile, update theSquarecomponent to look like this:

```jsx
export default function Square() {  return (    <>      <div className="board-row">        <button className="square">1</button>        <button className="square">2</button>        <button className="square">3</button>      </div>      <div className="board-row">        <button className="square">4</button>        <button className="square">5</button>        <button className="square">6</button>      </div>      <div className="board-row">        <button className="square">7</button>        <button className="square">8</button>        <button className="square">9</button>      </div>    </>  );}
```

The CSS defined instyles.cssstyles the divs with theclassNameofboard-row. Now that you’ve grouped your components into rows with the styleddivs you have your tic-tac-toe board:

But you now have a problem. Your component namedSquare, really isn’t a square anymore. Let’s fix that by changing the name toBoard:

```jsx
export default function Board() {  //...}
```

At this point your code should look something like this:

```jsx
export default function Board() {
  return (
    <>
      <div className="board-row">
        <button className="square">1</button>
        <button className="square">2</button>
        <button className="square">3</button>
      </div>
      <div className="board-row">
        <button className="square">4</button>
        <button className="square">5</button>
        <button className="square">6</button>
      </div>
      <div className="board-row">
        <button className="square">7</button>
        <button className="square">8</button>
        <button className="square">9</button>
      </div>
    </>
  );
}


```


### Note
Psssst… That’s a lot to type! It’s okay to copy and paste code from this page. However, if you’re up for a little challenge, we recommend only copying code that you’ve manually typed at least once yourself.


### Passing data through props
Next, you’ll want to change the value of a square from empty to “X” when the user clicks on the square. With how you’ve built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)! Instead of copy-pasting, React’s component architecture allows you to create a reusable component to avoid messy, duplicated code.

First, you are going to copy the line defining your first square (<button className="square">1</button>) from yourBoardcomponent into a newSquarecomponent:

```jsx
function Square() {  return <button className="square">1</button>;}export default function Board() {  // ...}
```

Then you’ll update the Board component to render thatSquarecomponent using JSX syntax:

```jsx
// ...export default function Board() {  return (    <>      <div className="board-row">        <Square />        <Square />        <Square />      </div>      <div className="board-row">        <Square />        <Square />        <Square />      </div>      <div className="board-row">        <Square />        <Square />        <Square />      </div>    </>  );}
```

Note how unlike the browserdivs, your own componentsBoardandSquaremust start with a capital letter.

Let’s take a look:

Oh no! You lost the numbered squares you had before. Now each square says “1”. To fix this, you will usepropsto pass the value each square should have from the parent component (Board) to its child (Square).

Update theSquarecomponent to read thevalueprop that you’ll pass from theBoard:

```jsx
function Square({ value }) {  return <button className="square">1</button>;}
```

function Square({ value })indicates the Square component can be passed a prop calledvalue.

Now you want to display thatvalueinstead of1inside every square. Try doing it like this:

```jsx
function Square({ value }) {  return <button className="square">value</button>;}
```

Oops, this is not what you wanted:

You wanted to render the JavaScript variable calledvaluefrom your component, not the word “value”. To “escape into JavaScript” from JSX, you need curly braces. Add curly braces aroundvaluein JSX like so:

```jsx
function Square({ value }) {  return <button className="square">{value}</button>;}
```

For now, you should see an empty board:

This is because theBoardcomponent hasn’t passed thevalueprop to eachSquarecomponent it renders yet. To fix it you’ll add thevalueprop to eachSquarecomponent rendered by theBoardcomponent:

```jsx
export default function Board() {  return (    <>      <div className="board-row">        <Square value="1" />        <Square value="2" />        <Square value="3" />      </div>      <div className="board-row">        <Square value="4" />        <Square value="5" />        <Square value="6" />      </div>      <div className="board-row">        <Square value="7" />        <Square value="8" />        <Square value="9" />      </div>    </>  );}
```

Now you should see a grid of numbers again:

Your updated code should look like this:

```jsx
function Square({ value }) {
  return <button className="square">{value}</button>;
}

export default function Board() {
  return (
    <>
      <div className="board-row">
        <Square value="1" />
        <Square value="2" />
        <Square value="3" />
      </div>
      <div className="board-row">
        <Square value="4" />
        <Square value="5" />
        <Square value="6" />
      </div>
      <div className="board-row">
        <Square value="7" />
        <Square value="8" />
        <Square value="9" />
      </div>
    </>
  );
}


```


### Making an interactive component
Let’s fill theSquarecomponent with anXwhen you click it. Declare a function calledhandleClickinside of theSquare. Then, addonClickto the props of the button JSX element returned from theSquare:

```jsx
function Square({ value }) {  function handleClick() {    console.log('clicked!');  }  return (    <button      className="square"      onClick={handleClick}    >      {value}    </button>  );}
```

If you click on a square now, you should see a log saying"clicked!"in theConsoletab at the bottom of theBrowsersection in CodeSandbox. Clicking the square more than once will log"clicked!"again. Repeated console logs with the same message will not create more lines in the console. Instead, you will see an incrementing counter next to your first"clicked!"log.


### Note
If you are following this tutorial using your local development environment, you need to open your browser’s Console. For example, if you use the Chrome browser, you can view the Console with the keyboard shortcutShift + Ctrl + J(on Windows/Linux) orOption + ⌘ + J(on macOS).

As a next step, you want the Square component to “remember” that it got clicked, and fill it with an “X” mark. To “remember” things, components usestate.

React provides a special function calleduseStatethat you can call from your component to let it “remember” things. Let’s store the current value of theSquarein state, and change it when theSquareis clicked.

ImportuseStateat the top of the file. Remove thevalueprop from theSquarecomponent. Instead, add a new line at the start of theSquarethat callsuseState. Have it return a state variable calledvalue:

```jsx
import { useState } from 'react';function Square() {  const [value, setValue] = useState(null);  function handleClick() {    //...
```

valuestores the value andsetValueis a function that can be used to change the value. Thenullpassed touseStateis used as the initial value for this state variable, sovaluehere starts off equal tonull.

Since theSquarecomponent no longer accepts props anymore, you’ll remove thevalueprop from all nine of the Square components created by the Board component:

```jsx
// ...export default function Board() {  return (    <>      <div className="board-row">        <Square />        <Square />        <Square />      </div>      <div className="board-row">        <Square />        <Square />        <Square />      </div>      <div className="board-row">        <Square />        <Square />        <Square />      </div>    </>  );}
```

Now you’ll changeSquareto display an “X” when clicked. Replace theconsole.log("clicked!");event handler withsetValue('X');. Now yourSquarecomponent looks like this:

```jsx
function Square() {  const [value, setValue] = useState(null);  function handleClick() {    setValue('X');  }  return (    <button      className="square"      onClick={handleClick}    >      {value}    </button>  );}
```

By calling thissetfunction from anonClickhandler, you’re telling React to re-render thatSquarewhenever its<button>is clicked. After the update, theSquare’svaluewill be'X', so you’ll see the “X” on the game board. Click on any Square, and “X” should show up:

Each Square has its own state: thevaluestored in each Square is completely independent of the others. When you call asetfunction in a component, React automatically updates the child components inside too.

After you’ve made the above changes, your code will look like this:

```jsx
import { useState } from 'react';

function Square() {
  const [value, setValue] = useState(null);

  function handleClick() {
    setValue('X');
  }

  return (
    <button
      className="square"
      onClick={handleClick}
    >
      {value}
    </button>
  );
}

export default function Board() {
  return (
    <>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
    </>
  );
}


```


### React Developer Tools
React DevTools let you check the props and the state of your React components. You can find the React DevTools tab at the bottom of thebrowsersection in CodeSandbox:

To inspect a particular component on the screen, use the button in the top left corner of React DevTools:


### Note
For local development, React DevTools is available as aChrome,Firefox, andEdgebrowser extension. Install it, and theComponentstab will appear in your browser Developer Tools for sites using React.


## Completing the game
By this point, you have all the basic building blocks for your tic-tac-toe game. To have a complete game, you now need to alternate placing “X”s and “O”s on the board, and you need a way to determine a winner.


### Lifting state up
Currently, eachSquarecomponent maintains a part of the game’s state. To check for a winner in a tic-tac-toe game, theBoardwould need to somehow know the state of each of the 9Squarecomponents.

How would you approach that? At first, you might guess that theBoardneeds to “ask” eachSquarefor thatSquare’s state. Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game’s state in the parentBoardcomponent instead of in eachSquare. TheBoardcomponent can tell eachSquarewhat to display by passing a prop, like you did when you passed a number to each Square.

To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent.

Lifting state into a parent component is common when React components are refactored.

Let’s take this opportunity to try it out. Edit theBoardcomponent so that it declares a state variable namedsquaresthat defaults to an array of 9 nulls corresponding to the 9 squares:

```jsx
// ...export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    // ...  );}
```

Array(9).fill(null)creates an array with nine elements and sets each of them tonull. TheuseState()call around it declares asquaresstate variable that’s initially set to that array. Each entry in the array corresponds to the value of a square. When you fill the board in later, thesquaresarray will look like this:

```jsx
['O', null, 'X', 'X', 'X', 'O', 'O', null, null]
```

Now yourBoardcomponent needs to pass thevalueprop down to eachSquarethat it renders:

```jsx
export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    <>      <div className="board-row">        <Square value={squares[0]} />        <Square value={squares[1]} />        <Square value={squares[2]} />      </div>      <div className="board-row">        <Square value={squares[3]} />        <Square value={squares[4]} />        <Square value={squares[5]} />      </div>      <div className="board-row">        <Square value={squares[6]} />        <Square value={squares[7]} />        <Square value={squares[8]} />      </div>    </>  );}
```

Next, you’ll edit theSquarecomponent to receive thevalueprop from the Board component. This will require removing the Square component’s own stateful tracking ofvalueand the button’sonClickprop:

```jsx
function Square({value}) {  return <button className="square">{value}</button>;}
```

At this point you should see an empty tic-tac-toe board:

And your code should look like this:

```jsx
import { useState } from 'react';

function Square({ value }) {
  return <button className="square">{value}</button>;
}

export default function Board() {
  const [squares, setSquares] = useState(Array(9).fill(null));
  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} />
        <Square value={squares[1]} />
        <Square value={squares[2]} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} />
        <Square value={squares[4]} />
        <Square value={squares[5]} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} />
        <Square value={squares[7]} />
        <Square value={squares[8]} />
      </div>
    </>
  );
}


```

Each Square will now receive avalueprop that will either be'X','O', ornullfor empty squares.

Next, you need to change what happens when aSquareis clicked. TheBoardcomponent now maintains which squares are filled. You’ll need to create a way for theSquareto update theBoard’s state. Since state is private to a component that defines it, you cannot update theBoard’s state directly fromSquare.

Instead, you’ll pass down a function from theBoardcomponent to theSquarecomponent, and you’ll haveSquarecall that function when a square is clicked. You’ll start with the function that theSquarecomponent will call when it is clicked. You’ll call that functiononSquareClick:

```jsx
function Square({ value }) {  return (    <button className="square" onClick={onSquareClick}>      {value}    </button>  );}
```

Next, you’ll add theonSquareClickfunction to theSquarecomponent’s props:

```jsx
function Square({ value, onSquareClick }) {  return (    <button className="square" onClick={onSquareClick}>      {value}    </button>  );}
```

Now you’ll connect theonSquareClickprop to a function in theBoardcomponent that you’ll namehandleClick. To connectonSquareClicktohandleClickyou’ll pass a function to theonSquareClickprop of the firstSquarecomponent:

```jsx
export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  return (    <>      <div className="board-row">        <Square value={squares[0]} onSquareClick={handleClick} />        //...  );}
```

Lastly, you will define thehandleClickfunction inside the Board component to update thesquaresarray holding your board’s state:

```jsx
export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick() {    const nextSquares = squares.slice();    nextSquares[0] = "X";    setSquares(nextSquares);  }  return (    // ...  )}
```

ThehandleClickfunction creates a copy of thesquaresarray (nextSquares) with the JavaScriptslice()Array method. Then,handleClickupdates thenextSquaresarray to addXto the first ([0]index) square.

Calling thesetSquaresfunction lets React know the state of the component has changed. This will trigger a re-render of the components that use thesquaresstate (Board) as well as its child components (theSquarecomponents that make up the board).


### Note
JavaScript supportsclosureswhich means an inner function (e.g.handleClick) has access to variables and functions defined in an outer function (e.g.Board). ThehandleClickfunction can read thesquaresstate and call thesetSquaresmethod because they are both defined inside of theBoardfunction.

Now you can add X’s to the board…  but only to the upper left square. YourhandleClickfunction is hardcoded to update the index for the upper left square (0). Let’s updatehandleClickto be able to update any square. Add an argumentito thehandleClickfunction that takes the index of the square to update:

```jsx
export default function Board() {  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick(i) {    const nextSquares = squares.slice();    nextSquares[i] = "X";    setSquares(nextSquares);  }  return (    // ...  )}
```

Next, you will need to pass thatitohandleClick. You could try to set theonSquareClickprop of square to behandleClick(0)directly in the JSX like this, but it won’t work:

```jsx
<Square value={squares[0]} onSquareClick={handleClick(0)} />
```

Here is why this doesn’t work. ThehandleClick(0)call will be a part of rendering the board component. BecausehandleClick(0)alters the state of the board component by callingsetSquares, your entire board component will be re-rendered again. But this runshandleClick(0)again, leading to an infinite loop:

Why didn’t this problem happen earlier?

When you were passingonSquareClick={handleClick}, you were passing thehandleClickfunction down as a prop. You were not calling it! But now you arecallingthat function right away—notice the parentheses inhandleClick(0)—and that’s why it runs too early. You don’twantto callhandleClickuntil the user clicks!

You could fix this by creating a function likehandleFirstSquareClickthat callshandleClick(0), a function likehandleSecondSquareClickthat callshandleClick(1), and so on. You would pass (rather than call) these functions down as props likeonSquareClick={handleFirstSquareClick}. This would solve the infinite loop.

However, defining nine different functions and giving each of them a name is too verbose. Instead, let’s do this:

```jsx
export default function Board() {  // ...  return (    <>      <div className="board-row">        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />        // ...  );}
```

Notice the new() =>syntax. Here,() => handleClick(0)is anarrow function,which is a shorter way to define functions. When the square is clicked, the code after the=>“arrow” will run, callinghandleClick(0).

Now you need to update the other eight squares to callhandleClickfrom the arrow functions you pass. Make sure that the argument for each call of thehandleClickcorresponds to the index of the correct square:

```jsx
export default function Board() {  // ...  return (    <>      <div className="board-row">        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />      </div>      <div className="board-row">        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />      </div>      <div className="board-row">        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />      </div>    </>  );};
```

Now you can again add X’s to any square on the board by clicking on them:

But this time all the state management is handled by theBoardcomponent!

This is what your code should look like:

```jsx
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

export default function Board() {
  const [squares, setSquares] = useState(Array(9).fill(null));

  function handleClick(i) {
    const nextSquares = squares.slice();
    nextSquares[i] = 'X';
    setSquares(nextSquares);
  }

  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}


```

Now that your state handling is in theBoardcomponent, the parentBoardcomponent passes props to the childSquarecomponents so that they can be displayed correctly. When clicking on aSquare, the childSquarecomponent now asks the parentBoardcomponent to update the state of the board. When theBoard’s state changes, both theBoardcomponent and every childSquarere-renders automatically. Keeping the state of all squares in theBoardcomponent will allow it to determine the winner in the future.

Let’s recap what happens when a user clicks the top left square on your board to add anXto it:

- Clicking on the upper left square runs the function that thebuttonreceived as itsonClickprop from theSquare. TheSquarecomponent received that function as itsonSquareClickprop from theBoard. TheBoardcomponent defined that function directly in the JSX. It callshandleClickwith an argument of0.
- handleClickuses the argument (0) to update the first element of thesquaresarray fromnulltoX.
- Thesquaresstate of theBoardcomponent was updated, so theBoardand all of its children re-render. This causes thevalueprop of theSquarecomponent with index0to change fromnulltoX.
In the end the user sees that the upper left square has changed from empty to having anXafter clicking it.


### Note
The DOM<button>element’sonClickattribute has a special meaning to React because it is a built-in component. For custom components like Square, the naming is up to you. You could give any name to theSquare’sonSquareClickprop orBoard’shandleClickfunction, and the code would work the same. In React, it’s conventional to useonSomethingnames for props which represent events andhandleSomethingfor the function definitions which handle those events.


### Why immutability is important
Note how inhandleClick, you call.slice()to create a copy of thesquaresarray instead of modifying the existing array. To explain why, we need to discuss immutability and why immutability is important to learn.

There are generally two approaches to changing data. The first approach is tomutatethe data by directly changing the data’s values. The second approach is to replace the data with a new copy which has the desired changes. Here is what it would look like if you mutated thesquaresarray:

```jsx
const squares = [null, null, null, null, null, null, null, null, null];squares[0] = 'X';// Now `squares` is ["X", null, null, null, null, null, null, null, null];
```

And here is what it would look like if you changed data without mutating thesquaresarray:

```jsx
const squares = [null, null, null, null, null, null, null, null, null];const nextSquares = ['X', null, null, null, null, null, null, null, null];// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null`
```

The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits.

Immutability makes complex features much easier to implement. Later in this tutorial, you will implement a “time travel” feature that lets you review the game’s history and “jump back” to past moves. This functionality isn’t specific to games—an ability to undo and redo certain actions is a common requirement for apps. Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later.

There is also another benefit of immutability. By default, all child components re-render automatically when the state of a parent component changes. This includes even the child components that weren’t affected by the change. Although re-rendering is not by itself noticeable to the user (you shouldn’t actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons. Immutability makes it very cheap for components to compare whether their data has changed or not. You can learn more about how React chooses when to re-render a component inthememoAPI reference.


### Taking turns
It’s now time to fix a major defect in this tic-tac-toe game: the “O”s cannot be marked on the board.

You’ll set the first move to be “X” by default. Let’s keep track of this by adding another piece of state to the Board component:

```jsx
function Board() {  const [xIsNext, setXIsNext] = useState(true);  const [squares, setSquares] = useState(Array(9).fill(null));  // ...}
```

Each time a player moves,xIsNext(a boolean) will be flipped to determine which player goes next and the game’s state will be saved. You’ll update theBoard’shandleClickfunction to flip the value ofxIsNext:

```jsx
export default function Board() {  const [xIsNext, setXIsNext] = useState(true);  const [squares, setSquares] = useState(Array(9).fill(null));  function handleClick(i) {    const nextSquares = squares.slice();    if (xIsNext) {      nextSquares[i] = "X";    } else {      nextSquares[i] = "O";    }    setSquares(nextSquares);    setXIsNext(!xIsNext);  }  return (    //...  );}
```

Now, as you click on different squares, they will alternate betweenXandO, as they should!

But wait, there’s a problem. Try clicking on the same square multiple times:

TheXis overwritten by anO! While this would add a very interesting twist to the game, we’re going to stick to the original rules for now.

When you mark a square with anXor anOyou aren’t first checking to see if the square already has anXorOvalue. You can fix this byreturning early. You’ll check to see if the square already has anXor anO. If the square is already filled, you willreturnin thehandleClickfunction early—before it tries to update the board state.

```jsx
function handleClick(i) {  if (squares[i]) {    return;  }  const nextSquares = squares.slice();  //...}
```

Now you can only addX’s orO’s to empty squares! Here is what your code should look like at this point:

```jsx
import { useState } from 'react';

function Square({value, onSquareClick}) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

export default function Board() {
  const [xIsNext, setXIsNext] = useState(true);
  const [squares, setSquares] = useState(Array(9).fill(null));

  function handleClick(i) {
    if (squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    setSquares(nextSquares);
    setXIsNext(!xIsNext);
  }

  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}


```


### Declaring a winner
Now that the players can take turns, you’ll want to show when the game is won and there are no more turns to make. To do this you’ll add a helper function calledcalculateWinnerthat takes an array of 9 squares, checks for a winner and returns'X','O', ornullas appropriate. Don’t worry too much about thecalculateWinnerfunction; it’s not specific to React:

```jsx
export default function Board() {  //...}function calculateWinner(squares) {  const lines = [    [0, 1, 2],    [3, 4, 5],    [6, 7, 8],    [0, 3, 6],    [1, 4, 7],    [2, 5, 8],    [0, 4, 8],    [2, 4, 6]  ];  for (let i = 0; i < lines.length; i++) {    const [a, b, c] = lines[i];    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {      return squares[a];    }  }  return null;}
```


### Note
It does not matter whether you definecalculateWinnerbefore or after theBoard. Let’s put it at the end so that you don’t have to scroll past it every time you edit your components.

You will callcalculateWinner(squares)in theBoardcomponent’shandleClickfunction to check if a player has won. You can perform this check at the same time you check if a user has clicked a square that already has anXor anO. We’d like to return early in both cases:

```jsx
function handleClick(i) {  if (squares[i] || calculateWinner(squares)) {    return;  }  const nextSquares = squares.slice();  //...}
```

To let the players know when the game is over, you can display text such as “Winner: X” or “Winner: O”. To do that you’ll add astatussection to theBoardcomponent. The status will display the winner if the game is over and if the game is ongoing you’ll display which player’s turn is next:

```jsx
export default function Board() {  // ...  const winner = calculateWinner(squares);  let status;  if (winner) {    status = "Winner: " + winner;  } else {    status = "Next player: " + (xIsNext ? "X" : "O");  }  return (    <>      <div className="status">{status}</div>      <div className="board-row">        // ...  )}
```

Congratulations! You now have a working tic-tac-toe game. And you’ve just learned the basics of React too. Soyouare the real winner here. Here is what the code should look like:

```jsx
import { useState } from 'react';

function Square({value, onSquareClick}) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

export default function Board() {
  const [xIsNext, setXIsNext] = useState(true);
  const [squares, setSquares] = useState(Array(9).fill(null));

  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    setSquares(nextSquares);
    setXIsNext(!xIsNext);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```


## Adding time travel
As a final exercise, let’s make it possible to “go back in time” to the previous moves in the game.


### Storing a history of moves
If you mutated thesquaresarray, implementing time travel would be very difficult.

However, you usedslice()to create a new copy of thesquaresarray after every move, and treated it as immutable. This will allow you to store every past version of thesquaresarray, and navigate between the turns that have already happened.

You’ll store the pastsquaresarrays in another array calledhistory, which you’ll store as a new state variable. Thehistoryarray represents all board states, from the first to the last move, and has a shape like this:

```jsx
[  // Before first move  [null, null, null, null, null, null, null, null, null],  // After first move  [null, null, null, null, 'X', null, null, null, null],  // After second move  [null, null, null, null, 'X', null, null, null, 'O'],  // ...]
```


### Lifting state up, again
You will now write a new top-level component calledGameto display a list of past moves. That’s where you will place thehistorystate that contains the entire game history.

Placing thehistorystate into theGamecomponent will let you remove thesquaresstate from its childBoardcomponent. Just like you “lifted state up” from theSquarecomponent into theBoardcomponent, you will now lift it up from theBoardinto the top-levelGamecomponent. This gives theGamecomponent full control over theBoard’s data and lets it instruct theBoardto render previous turns from thehistory.

First, add aGamecomponent withexport default. Have it render theBoardcomponent and some markup:

```jsx
function Board() {  // ...}export default function Game() {  return (    <div className="game">      <div className="game-board">        <Board />      </div>      <div className="game-info">        <ol>{/*TODO*/}</ol>      </div>    </div>  );}
```

Note that you are removing theexport defaultkeywords before thefunction Board() {declaration and adding them before thefunction Game() {declaration. This tells yourindex.jsfile to use theGamecomponent as the top-level component instead of yourBoardcomponent. The additionaldivs returned by theGamecomponent are making room for the game information you’ll add to the board later.

Add some state to theGamecomponent to track which player is next and the history of moves:

```jsx
export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  // ...
```

Notice how[Array(9).fill(null)]is an array with a single item, which itself is an array of 9nulls.

To render the squares for the current move, you’ll want to read the last squares array from thehistory. You don’t needuseStatefor this—you already have enough information to calculate it during rendering:

```jsx
export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  // ...
```

Next, create ahandlePlayfunction inside theGamecomponent that will be called by theBoardcomponent to update the game. PassxIsNext,currentSquaresandhandlePlayas props to theBoardcomponent:

```jsx
export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  function handlePlay(nextSquares) {    // TODO  }  return (    <div className="game">      <div className="game-board">        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />        //...  )}
```

Let’s make theBoardcomponent fully controlled by the props it receives. Change theBoardcomponent to take three props:xIsNext,squares, and a newonPlayfunction thatBoardcan call with the updated squares array when a player makes a move. Next, remove the first two lines of theBoardfunction that calluseState:

```jsx
function Board({ xIsNext, squares, onPlay }) {  function handleClick(i) {    //...  }  // ...}
```

Now replace thesetSquaresandsetXIsNextcalls inhandleClickin theBoardcomponent with a single call to your newonPlayfunction so theGamecomponent can update theBoardwhen the user clicks a square:

```jsx
function Board({ xIsNext, squares, onPlay }) {  function handleClick(i) {    if (calculateWinner(squares) || squares[i]) {      return;    }    const nextSquares = squares.slice();    if (xIsNext) {      nextSquares[i] = "X";    } else {      nextSquares[i] = "O";    }    onPlay(nextSquares);  }  //...}
```

TheBoardcomponent is fully controlled by the props passed to it by theGamecomponent. You need to implement thehandlePlayfunction in theGamecomponent to get the game working again.

What shouldhandlePlaydo when called? Remember that Board used to callsetSquareswith an updated array; now it passes the updatedsquaresarray toonPlay.

ThehandlePlayfunction needs to updateGame’s state to trigger a re-render, but you don’t have asetSquaresfunction that you can call any more—you’re now using thehistorystate variable to store this information. You’ll want to updatehistoryby appending the updatedsquaresarray as a new history entry. You also want to togglexIsNext, just as Board used to do:

```jsx
export default function Game() {  //...  function handlePlay(nextSquares) {    setHistory([...history, nextSquares]);    setXIsNext(!xIsNext);  }  //...}
```

Here,[...history, nextSquares]creates a new array that contains all the items inhistory, followed bynextSquares. (You can read the...historyspread syntaxas “enumerate all the items inhistory”.)

For example, ifhistoryis[[null,null,null], ["X",null,null]]andnextSquaresis["X",null,"O"], then the new[...history, nextSquares]array will be[[null,null,null], ["X",null,null], ["X",null,"O"]].

At this point, you’ve moved the state to live in theGamecomponent, and the UI should be fully working, just as it was before the refactor. Here is what the code should look like at this point:

```jsx
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const currentSquares = history[history.length - 1];

  function handlePlay(nextSquares) {
    setHistory([...history, nextSquares]);
    setXIsNext(!xIsNext);
  }

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{/*TODO*/}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```


### Showing the past moves
Since you are recording the tic-tac-toe game’s history, you can now display a list of past moves to the player.

React elements like<button>are regular JavaScript objects; you can pass them around in your application. To render multiple items in React, you can use an array of React elements.

You already have an array ofhistorymoves in state, so now you need to transform it to an array of React elements. In JavaScript, to transform one array into another, you can use thearraymapmethod:

```jsx
[1, 2, 3].map((x) => x * 2) // [2, 4, 6]
```

You’ll usemapto transform yourhistoryof moves into React elements representing buttons on the screen, and display a list of buttons to “jump” to past moves. Let’smapover thehistoryin the Game component:

```jsx
export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const currentSquares = history[history.length - 1];  function handlePlay(nextSquares) {    setHistory([...history, nextSquares]);    setXIsNext(!xIsNext);  }  function jumpTo(nextMove) {    // TODO  }  const moves = history.map((squares, move) => {    let description;    if (move > 0) {      description = 'Go to move #' + move;    } else {      description = 'Go to game start';    }    return (      <li>        <button onClick={() => jumpTo(move)}>{description}</button>      </li>    );  });  return (    <div className="game">      <div className="game-board">        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />      </div>      <div className="game-info">        <ol>{moves}</ol>      </div>    </div>  );}
```

You can see what your code should look like below. Note that you should see an error in the developer tools console that says:

You’ll fix this error in the next section.

```jsx
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const currentSquares = history[history.length - 1];

  function handlePlay(nextSquares) {
    setHistory([...history, nextSquares]);
    setXIsNext(!xIsNext);
  }

  function jumpTo(nextMove) {
    // TODO
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```

As you iterate through thehistoryarray inside the function you passed tomap, thesquaresargument goes through each element ofhistory, and themoveargument goes through each array index:0,1,2, …. (In most cases, you’d need the actual array elements, but to render a list of moves you will only need indexes.)

For each move in the tic-tac-toe game’s history, you create a list item<li>which contains a button<button>. The button has anonClickhandler which calls a function calledjumpTo(that you haven’t implemented yet).

For now, you should see a list of the moves that occurred in the game and an error in the developer tools console. Let’s discuss what the “key” error means.


### Picking a key
When you render a list, React stores some information about each rendered list item. When you update a list, React needs to determine what has changed. You could have added, removed, re-arranged, or updated the list’s items.

Imagine transitioning from

```jsx
<li>Alexa: 7 tasks left</li><li>Ben: 5 tasks left</li>
```

to

```jsx
<li>Ben: 9 tasks left</li><li>Claudia: 8 tasks left</li><li>Alexa: 5 tasks left</li>
```

In addition to the updated counts, a human reading this would probably say that you swapped Alexa and Ben’s ordering and inserted Claudia between Alexa and Ben. However, React is a computer program and does not know what you intended, so you need to specify akeyproperty for each list item to differentiate each list item from its siblings. If your data was from a database, Alexa, Ben, and Claudia’s database IDs could be used as keys.

```jsx
<li key={user.id}>  {user.name}: {user.taskCount} tasks left</li>
```

When a list is re-rendered, React takes each list item’s key and searches the previous list’s items for a matching key. If the current list has a key that didn’t exist before, React creates a component. If the current list is missing a key that existed in the previous list, React destroys the previous component. If two keys match, the corresponding component is moved.

Keys tell React about the identity of each component, which allows React to maintain state between re-renders. If a component’s key changes, the component will be destroyed and re-created with a new state.

keyis a special and reserved property in React. When an element is created, React extracts thekeyproperty and stores the key directly on the returned element. Even thoughkeymay look like it is passed as props, React automatically useskeyto decide which components to update. There’s no way for a component to ask whatkeyits parent specified.

It’s strongly recommended that you assign proper keys whenever you build dynamic lists.If you don’t have an appropriate key, you may want to consider restructuring your data so that you do.

If no key is specified, React will report an error and use the array index as a key by default. Using the array index as a key is problematic when trying to re-order a list’s items or inserting/removing list items. Explicitly passingkey={i}silences the error but has the same problems as array indices and is not recommended in most cases.

Keys do not need to be globally unique; they only need to be unique between components and their siblings.


### Implementing time travel
In the tic-tac-toe game’s history, each past move has a unique ID associated with it: it’s the sequential number of the move. Moves will never be re-ordered, deleted, or inserted in the middle, so it’s safe to use the move index as a key.

In theGamefunction, you can add the key as<li key={move}>, and if you reload the rendered game, React’s “key” error should disappear:

```jsx
const moves = history.map((squares, move) => {  //...  return (    <li key={move}>      <button onClick={() => jumpTo(move)}>{description}</button>    </li>  );});
```

```jsx
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const currentSquares = history[history.length - 1];

  function handlePlay(nextSquares) {
    setHistory([...history, nextSquares]);
    setXIsNext(!xIsNext);
  }

  function jumpTo(nextMove) {
    // TODO
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```

Before you can implementjumpTo, you need theGamecomponent to keep track of which step the user is currently viewing. To do this, define a new state variable calledcurrentMove, defaulting to0:

```jsx
export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const currentSquares = history[history.length - 1];  //...}
```

Next, update thejumpTofunction insideGameto update thatcurrentMove. You’ll also setxIsNexttotrueif the number that you’re changingcurrentMoveto is even.

```jsx
export default function Game() {  // ...  function jumpTo(nextMove) {    setCurrentMove(nextMove);    setXIsNext(nextMove % 2 === 0);  }  //...}
```

You will now make two changes to theGame’shandlePlayfunction which is called when you click on a square.

- If you “go back in time” and then make a new move from that point, you only want to keep the history up to that point. Instead of addingnextSquaresafter all items (...spread syntax) inhistory, you’ll add it after all items inhistory.slice(0, currentMove + 1)so that you’re only keeping that portion of the old history.
- Each time a move is made, you need to updatecurrentMoveto point to the latest history entry.
```jsx
function handlePlay(nextSquares) {  const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];  setHistory(nextHistory);  setCurrentMove(nextHistory.length - 1);  setXIsNext(!xIsNext);}
```

Finally, you will modify theGamecomponent to render the currently selected move, instead of always rendering the final move:

```jsx
export default function Game() {  const [xIsNext, setXIsNext] = useState(true);  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const currentSquares = history[currentMove];  // ...}
```

If you click on any step in the game’s history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred.

```jsx
import { useState } from 'react';

function Square({value, onSquareClick}) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
    setXIsNext(!xIsNext);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
    setXIsNext(nextMove % 2 === 0);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```


### Final cleanup
If you look at the code very closely, you may notice thatxIsNext === truewhencurrentMoveis even andxIsNext === falsewhencurrentMoveis odd. In other words, if you know the value ofcurrentMove, then you can always figure out whatxIsNextshould be.

There’s no reason for you to store both of these in state. In fact, always try to avoid redundant state. Simplifying what you store in state reduces bugs and makes your code easier to understand. ChangeGameso that it doesn’t storexIsNextas a separate state variable and instead figures it out based on thecurrentMove:

```jsx
export default function Game() {  const [history, setHistory] = useState([Array(9).fill(null)]);  const [currentMove, setCurrentMove] = useState(0);  const xIsNext = currentMove % 2 === 0;  const currentSquares = history[currentMove];  function handlePlay(nextSquares) {    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];    setHistory(nextHistory);    setCurrentMove(nextHistory.length - 1);  }  function jumpTo(nextMove) {    setCurrentMove(nextMove);  }  // ...}
```

You no longer need thexIsNextstate declaration or the calls tosetXIsNext. Now, there’s no chance forxIsNextto get out of sync withcurrentMove, even if you make a mistake while coding the components.


### Wrapping up
Congratulations! You’ve created a tic-tac-toe game that:

- Lets you play tic-tac-toe,
- Indicates when a player has won the game,
- Stores a game’s history as a game progresses,
- Allows players to review a game’s history and see previous versions of a game’s board.
Nice work! We hope you now feel like you have a decent grasp of how React works.

Check out the final result here:

```jsx
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const xIsNext = currentMove % 2 === 0;
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}


```

If you have extra time or want to practice your new React skills, here are some ideas for improvements that you could make to the tic-tac-toe game, listed in order of increasing difficulty:

- For the current move only, show “You are at move #…” instead of a button.
- RewriteBoardto use two loops to make the squares instead of hardcoding them.
- Add a toggle button that lets you sort the moves in either ascending or descending order.
- When someone wins, highlight the three squares that caused the win (and when no one wins, display a message about the result being a draw).
- Display the location for each move in the format (row, col) in the move history list.
Throughout this tutorial, you’ve touched on React concepts including elements, components, props, and state. Now that you’ve seen how these concepts work when building a game, check outThinking in Reactto see how the same React concepts work when building an app’s UI.


--------------------------------------------------------------------------------


# Thinking in React
Source: https://react.dev/learn/thinking-in-react

React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces calledcomponents. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we’ll guide you through the thought process of building a searchable product data table with React.


## Start with the mockup
Imagine that you already have a JSON API and a mockup from a designer.

The JSON API returns some data that looks like this:

```jsx
[  { category: "Fruits", price: "$1", stocked: true, name: "Apple" },  { category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit" },  { category: "Fruits", price: "$2", stocked: false, name: "Passionfruit" },  { category: "Vegetables", price: "$2", stocked: true, name: "Spinach" },  { category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin" },  { category: "Vegetables", price: "$1", stocked: true, name: "Peas" }]
```

The mockup looks like this:

To implement a UI in React, you will usually follow the same five steps.


## Step 1: Break the UI into a component hierarchy
Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them!

Depending on your background, you can think about splitting up a design into components in different ways:

- Programming—use the same techniques for deciding if you should create a new function or object. One such technique is theseparation of concerns, that is, a component should ideally only be concerned with one thing. If it ends up growing, it should be decomposed into smaller subcomponents.
- CSS—consider what you would make class selectors for. (However, components are a bit less granular.)
- Design—consider how you would organize the design’s layers.
If your JSON is well-structured, you’ll often find that it naturally maps to the component structure of your UI. That’s because UI and data models often have the same information architecture—that is, the same shape. Separate your UI into components, where each component matches one piece of your data model.

There are five components on this screen:

- FilterableProductTable(grey) contains the entire app.
- SearchBar(blue) receives the user input.
- ProductTable(lavender) displays and filters the list according to the user input.
- ProductCategoryRow(green) displays a heading for each category.
- ProductRow(yellow) displays a row for each product.
If you look atProductTable(lavender), you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and you could go either way. For this example, it is a part ofProductTablebecause it appears inside theProductTable’s list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its ownProductTableHeadercomponent.

Now that you’ve identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy:

- FilterableProductTableSearchBarProductTableProductCategoryRowProductRow
- SearchBar
- ProductTableProductCategoryRowProductRow
- ProductCategoryRow
- ProductRow

## Step 2: Build a static version in React
Now that you have your component hierarchy, it’s time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity… yet! It’s often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing.

To build a static version of your app that renders your data model, you’ll want to buildcomponentsthat reuse other components and pass data usingprops.Props are a way of passing data from parent to child. (If you’re familiar with the concept ofstate, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.)

You can either build “top down” by starting with building the components higher up in the hierarchy (likeFilterableProductTable) or “bottom up” by working from components lower down (likeProductRow). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up.

```jsx
function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}

function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}

function ProductTable({ products }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}

function SearchBar() {
  return (
    <form>
      <input type="text" placeholder="Search..." />
      <label>
        <input type="checkbox" />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}

function FilterableProductTable({ products }) {
  return (
    <div>
      <SearchBar />
      <ProductTable products={products} />
    </div>
  );
}

const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];

export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}


```

(If this code looks intimidating, go through theQuick Startfirst!)

After building your components, you’ll have a library of reusable components that render your data model. Because this is a static app, the components will only return JSX. The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop. This is calledone-way data flowbecause the data flows down from the top-level component to the ones at the bottom of the tree.


### Pitfall
At this point, you should not be using any state values. That’s for the next step!


## Step 3: Find the minimal but complete representation of UI state
To make the UI interactive, you need to let users change your underlying data model. You will usestatefor this.

Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep itDRY (Don’t Repeat Yourself).Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if you’re building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don’t store the number of items as another state value—instead, read the length of your array.

Now think of all of the pieces of data in this example application:

- The original list of products
- The search text the user has entered
- The value of the checkbox
- The filtered list of products
Which of these are state? Identify the ones that are not:

- Does itremain unchangedover time? If so, it isn’t state.
- Is itpassed in from a parentvia props? If so, it isn’t state.
- Can you compute itbased on existing state or props in your component? If so, itdefinitelyisn’t state!
What’s left is probably state.

Let’s go through them one by one again:

- The original list of products ispassed in as props, so it’s not state.
- The search text seems to be state since it changes over time and can’t be computed from anything.
- The value of the checkbox seems to be state since it changes over time and can’t be computed from anything.
- The filtered list of productsisn’t state because it can be computedby taking the original list of products and filtering it according to the search text and value of the checkbox.
This means only the search text and the value of the checkbox are state! Nicely done!


#### Props vs State
There are two types of “model” data in React: props and state. The two are very different:

- Propsare like arguments you passto a function. They let a parent component pass data to a child component and customize its appearance. For example, aFormcan pass acolorprop to aButton.
- Stateis like a component’s memory.It lets a component keep track of some information and change it in response to interactions. For example, aButtonmight keep track ofisHoveredstate.
Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), andpass it downto child components as their props. It’s okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick!


## Step 4: Identify where your state should live
After identifying your app’s minimal state data, you need to identify which component is responsible for changing this state, orownsthe state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if you’re new to this concept, but you can figure it out by following these steps!

For each piece of state in your application:

- Identifyeverycomponent that renders something based on that state.
- Find their closest common parent component—a component above them all in the hierarchy.
- Decide where the state should live:Often, you can put the state directly into their common parent.You can also put the state into some component above their common parent.If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component.
- Often, you can put the state directly into their common parent.
- You can also put the state into some component above their common parent.
- If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component.
In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place.

Now let’s run through our strategy for them:

- Identify components that use state:ProductTableneeds to filter the product list based on that state (search text and checkbox value).SearchBarneeds to display that state (search text and checkbox value).
- ProductTableneeds to filter the product list based on that state (search text and checkbox value).
- SearchBarneeds to display that state (search text and checkbox value).
- Find their common parent:The first parent component both components share isFilterableProductTable.
- Decide where the state lives: We’ll keep the filter text and checked state values inFilterableProductTable.
So the state values will live inFilterableProductTable.

Add state to the component with theuseState()Hook.Hooks are special functions that let you “hook into” React. Add two state variables at the top ofFilterableProductTableand specify their initial state:

```jsx
function FilterableProductTable({ products }) {  const [filterText, setFilterText] = useState('');  const [inStockOnly, setInStockOnly] = useState(false);
```

Then, passfilterTextandinStockOnlytoProductTableandSearchBaras props:

```jsx
<div>  <SearchBar     filterText={filterText}     inStockOnly={inStockOnly} />  <ProductTable     products={products}    filterText={filterText}    inStockOnly={inStockOnly} /></div>
```

You can start seeing how your application will behave. Edit thefilterTextinitial value fromuseState('')touseState('fruit')in the sandbox code below. You’ll see both the search input text and the table update:

```jsx
import { useState } from 'react';

function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);

  return (
    <div>
      <SearchBar 
        filterText={filterText} 
        inStockOnly={inStockOnly} />
      <ProductTable 
        products={products}
        filterText={filterText}
        inStockOnly={inStockOnly} />
    </div>
  );
}

function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}

function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}

function ProductTable({ products, filterText, inStockOnly }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (
      product.name.toLowerCase().indexOf(
        filterText.toLowerCase()
      ) === -1
    ) {
      return;
    }
    if (inStockOnly && !product.stocked) {
      return;
    }
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}

function SearchBar({ filterText, inStockOnly }) {
  return (
    <form>
      <input 
        type="text" 
        value={filterText} 
        placeholder="Search..."/>
      <label>
        <input 
          type="checkbox" 
          checked={inStockOnly} />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}

const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];

export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}


```

Notice that editing the form doesn’t work yet. There is a console error in the sandbox above explaining why:

In the sandbox above,ProductTableandSearchBarread thefilterTextandinStockOnlyprops to render the table, the input, and the checkbox. For example, here is howSearchBarpopulates the input value:

```jsx
function SearchBar({ filterText, inStockOnly }) {  return (    <form>      <input         type="text"         value={filterText}         placeholder="Search..."/>
```

However, you haven’t added any code to respond to the user actions like typing yet. This will be your final step.


## Step 5: Add inverse data flow
Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state inFilterableProductTable.

React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, you’ll see that React ignores your input. This is intentional. By writing<input value={filterText} />, you’ve set thevalueprop of theinputto always be equal to thefilterTextstate passed in fromFilterableProductTable. SincefilterTextstate is never set, the input never changes.

You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned byFilterableProductTable, so only it can callsetFilterTextandsetInStockOnly. To letSearchBarupdate theFilterableProductTable’s state, you need to pass these functions down toSearchBar:

```jsx
function FilterableProductTable({ products }) {  const [filterText, setFilterText] = useState('');  const [inStockOnly, setInStockOnly] = useState(false);  return (    <div>      <SearchBar         filterText={filterText}         inStockOnly={inStockOnly}        onFilterTextChange={setFilterText}        onInStockOnlyChange={setInStockOnly} />
```

Inside theSearchBar, you will add theonChangeevent handlers and set the parent state from them:

```jsx
function SearchBar({  filterText,  inStockOnly,  onFilterTextChange,  onInStockOnlyChange}) {  return (    <form>      <input        type="text"        value={filterText}        placeholder="Search..."        onChange={(e) => onFilterTextChange(e.target.value)}      />      <label>        <input          type="checkbox"          checked={inStockOnly}          onChange={(e) => onInStockOnlyChange(e.target.checked)}
```

Now the application fully works!

```jsx
import { useState } from 'react';

function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);

  return (
    <div>
      <SearchBar 
        filterText={filterText} 
        inStockOnly={inStockOnly} 
        onFilterTextChange={setFilterText} 
        onInStockOnlyChange={setInStockOnly} />
      <ProductTable 
        products={products} 
        filterText={filterText}
        inStockOnly={inStockOnly} />
    </div>
  );
}

function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}

function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}

function ProductTable({ products, filterText, inStockOnly }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (
      product.name.toLowerCase().indexOf(
        filterText.toLowerCase()
      ) === -1
    ) {
      return;
    }
    if (inStockOnly && !product.stocked) {
      return;
    }
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}

function SearchBar({
  filterText,
  inStockOnly,
  onFilterTextChange,
  onInStockOnlyChange
}) {
  return (
    <form>
      <input 
        type="text" 
        value={filterText} placeholder="Search..." 
        onChange={(e) => onFilterTextChange(e.target.value)} />
      <label>
        <input 
          type="checkbox" 
          checked={inStockOnly} 
          onChange={(e) => onInStockOnlyChange(e.target.checked)} />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}

const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];

export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}


```

You can learn all about handling events and updating state in theAdding Interactivitysection.


## Where to go from here
This was a very brief introduction to how to think about building components and applications with React. You canstart a React projectright now ordive deeper on all the syntaxused in this tutorial.


--------------------------------------------------------------------------------


# Installation
Source: https://react.dev/learn/installation

React has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started.


## Try React
You don’t need to install anything to play with React. Try editing this sandbox!

```jsx
function Greeting({ name }) {
  return <h1>Hello, {name}</h1>;
}

export default function App() {
  return <Greeting name="world" />
}


```

You can edit it directly or open it in a new tab by pressing the “Fork” button in the upper right corner.

Most pages in the React documentation contain sandboxes like this. Outside of the React documentation, there are many online sandboxes that support React: for example,CodeSandbox,StackBlitz, orCodePen.

To try React locally on your computer,download this HTML page.Open it in your editor and in your browser!


## Creating a React App
If you want to start a new React app, you cancreate a React appusing a recommended framework.


## Build a React App from Scratch
If a framework is not a good fit for your project, you prefer to build your own framework, or you just want to learn the basics of a React app you canbuild a React app from scratch.


## Add React to an existing project
If want to try using React in your existing app or a website, you canadd React to an existing project.


### Note

#### Should I use Create React App?
No. Create React App has been deprecated. For more information, seeSunsetting Create React App.


## Next steps
Head to theQuick Startguide for a tour of the most important React concepts you will encounter every day.


--------------------------------------------------------------------------------


# Creating a React App
Source: https://react.dev/learn/creating-a-react-app

If you want to build a new app or website with React, we recommend starting with a framework.

If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you canbuild a React app from scratch.


## Full-stack frameworks
These recommended frameworks support all the features you need to deploy and scale your app in production. They have integrated the latest React features and take advantage of React’s architecture.


### Note

#### Full-stack frameworks do not require a server.
All the frameworks on this page support client-side rendering (CSR), single-page apps (SPA), and static-site generation (SSG). These apps can be deployed to aCDNor static hosting service without a server. Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case.

This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app. See your framework’s documentation for configuring the rendering strategy.


### Next.js (App Router)
Next.js’s App Routeris a React framework that takes full advantage of React’s architecture to enable full-stack React apps.

```jsx
npx create-next-app@latest
```

Next.js is maintained byVercel. You candeploy a Next.js appto any hosting provider that supports Node.js or Docker containers, or to your own server. Next.js also supportsstatic exportwhich doesn’t require a server.


### React Router (v7)
React Routeris the most popular routing library for React and can be paired with Vite to create a full-stack React framework. It emphasizes standard Web APIs and has severalready to deploy templatesfor various JavaScript runtimes and platforms.

To create a new React Router framework project, run:

```jsx
npx create-react-router@latest
```

React Router is maintained byShopify.


### Expo (for native apps)
Expois a React framework that lets you create universal Android, iOS, and web apps with truly native UIs.It provides an SDK forReact Nativethat makes the native parts easier to use. To create a new Expo project, run:

```jsx
npx create-expo-app@latest
```

If you’re new to Expo, check out theExpo tutorial.

Expo is maintained byExpo (the company). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services.


## Other frameworks
There are other up-and-coming frameworks that are working towards our full stack React vision:

- TanStack Start (Beta): TanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite.
- RedwoodSDK: Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications.

#### Which features make up the React team’s full-stack architecture vision?
Next.js’s App Router bundler fully implements the officialReact Server Components specification. This lets you mix build-time, server-only, and interactive components in a single React tree.

For example, you can write a server-only React component as anasyncfunction that reads from a database or from a file. Then you can pass data down from it to your interactive components:

```jsx
// This component runs *only* on the server (or during the build).async function Talks({ confId }) {  // 1. You're on the server, so you can talk to your data layer. API endpoint not required.  const talks = await db.Talks.findAll({ confId });  // 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.  const videos = talks.map(talk => talk.video);  // 3. Pass the data down to the components that will run in the browser.  return <SearchableVideoList videos={videos} />;}
```

Next.js’s App Router also integratesdata fetching with Suspense. This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:

```jsx
<Suspense fallback={<TalksLoading />}>  <Talks confId={conf.id} /></Suspense>
```

Server Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks.


## Start From Scratch
If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch.

Starting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns.  It’s a lot like building your own framework, instead of using a framework that already exists. Theframeworks we recommendhave built-in solutions for these problems.

If you want to build your own solutions, see our guide tobuild a React app from Scratchfor instructions on how to set up a new React project starting with a build tool likeVite,Parcel, orRSbuild.

If you’re a framework author interested in being included on this page,please let us know.


--------------------------------------------------------------------------------


# Build a React app from Scratch
Source: https://react.dev/learn/build-a-react-app-from-scratch

If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch.


#### Consider using a framework
Starting from scratch is an easy way to get started using React, but a major tradeoff to be aware of is that going this route is often the same as building your own adhoc framework. As your requirements evolve, you may need to solve more framework-like problems that our recommended frameworks already have well developed and supported solutions for.

For example, if in the future your app needs support for server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC), you will have to implement those on your own. Similarly, future React features that require integrating at the framework level will have to be implemented on your own if you want to use them.

Our recommended frameworks also help you build better performing apps. For example, reducing or eliminating waterfalls from network requests makes for a better user experience. This might not be a high priority when you are building a toy project, but if your app gains users you may want to improve its performance.

Going this route also makes it more difficult to get support, since the way you develop routing, data-fetching, and other features will be unique to your situation. You should only choose this option if you are comfortable tackling these problems on your own, or if you’re confident that you will never need these features.

For a list of recommended frameworks, check outCreating a React App.


## Step 1: Install a build tool
The first step is to install a build tool likevite,parcel, orrsbuild. These build tools provide features to package and run source code, provide a development server for local development and a build command to deploy your app to a production server.


### Vite
Viteis a build tool that aims to provide a faster and leaner development experience for modern web projects.

```jsx
npm create vite@latest my-app -- --template react-ts
```

Vite is opinionated and comes with sensible defaults out of the box. Vite has a rich ecosystem of plugins to support fast refresh, JSX,  Babel/SWC, and other common features. See Vite’sReact pluginorReact SWC pluginandReact SSR example projectto get started.

Vite is already being used as a build tool in one of ourrecommended frameworks:React Router.


### Parcel
Parcelcombines a great out-of-the-box development experience with a scalable architecture that can take your project from just getting started to massive production applications.

```jsx
npm install --save-dev parcel
```

Parcel supports fast refresh, JSX, TypeScript, Flow, and styling out of the box. SeeParcel’s React recipeto get started.


### Rsbuild
Rsbuildis an Rspack-powered build tool that provides a seamless development experience for React applications. It comes with carefully tuned defaults and performance optimizations ready to use.

```jsx
npx create-rsbuild --template react
```

Rsbuild includes built-in support for React features like fast refresh, JSX, TypeScript, and styling. SeeRsbuild’s React guideto get started.


### Note

#### Metro for React Native
If you’re starting from scratch with React Native you’ll need to useMetro, the JavaScript bundler for React Native. Metro supports bundling for platforms like iOS and Android, but lacks many features when compared to the tools here. We recommend starting with Vite, Parcel, or Rsbuild unless your project requires React Native support.


## Step 2: Build Common Application Patterns
The build tools listed above start off with a client-only, single-page app (SPA), but don’t include any further solutions for common functionality like routing, data fetching, or styling.

The React ecosystem includes many tools for these problems. We’ve listed a few that are widely used as a starting point, but feel free to choose other tools if those work better for you.


### Routing
Routing determines what content or pages to display when a user visits a particular URL. You need to set up a router to map URLs to different parts of your app. You’ll also need to handle nested routes, route parameters, and query parameters.  Routers can be configured within your code, or defined based on your component folder and file structures.

Routers are a core part of modern applications, and are usually integrated with data fetching (including prefetching data for a whole page for faster loading), code splitting (to minimize client bundle sizes), and page rendering approaches (to decide how each page gets generated).

We suggest using:

- React Router
- Tanstack Router

### Data Fetching
Fetching data from a server or other data source is a key part of most applications. Doing this properly requires handling loading states, error states, and caching the fetched data, which can be complex.

Purpose-built data fetching libraries do the hard work of fetching and caching the data for you, letting you focus on what data your app needs and how to display it.  These libraries are typically used directly in your components, but can also be integrated into routing loaders for faster pre-fetching and better performance, and in server rendering as well.

Note that fetching data directly in components can lead to slower loading times due to network request waterfalls, so we recommend prefetching data in router loaders or on the server as much as possible!  This allows a page’s data to be fetched all at once as the page is being displayed.

If you’re fetching data from most backends or REST-style APIs, we suggest using:

- TanStack Query
- SWR
- RTK Query
If you’re fetching data from a GraphQL API, we suggest using:

- Apollo
- Relay

### Code-splitting
Code-splitting is the process of breaking your app into smaller bundles that can be loaded on demand. An app’s code size increases with every new feature and additional dependency. Apps can become slow to load because all of the code for the entire app needs to be sent before it can be used. Caching, reducing features/dependencies, and moving some code to run on the server can help mitigate slow loading but are incomplete solutions that can sacrifice functionality if overused.

Similarly, if you rely on the apps using your framework to split the code, you might encounter situations where loading becomes slower than if no code splitting were happening at all. For example,lazily loadinga chart delays sending the code needed to render the chart, splitting the chart code from the rest of the app.Parcel supports code splitting with React.lazy. However, if the chart loads its dataafterit has been initially rendered you are now waiting twice. This is a waterfall: rather than fetching the data for the chart and sending the code to render it simultaneously, you must wait for each step to complete one after the other.

Splitting code by route, when integrated with bundling and data fetching, can reduce the initial load time of your app and the time it takes for the largest visible content of the app to render (Largest Contentful Paint).

For code-splitting instructions, see your build tool docs:

- Vite build optimizations
- Parcel code splitting
- Rsbuild code splitting

### Improving Application Performance
Since the build tool you select only supports single page apps (SPAs), you’ll need to implement otherrendering patternslike server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC). Even if you don’t need these features at first, in the future there may be some routes that would benefit SSR, SSG or RSC.

- Single-page apps (SPA)load a single HTML page and dynamically updates the page as the user interacts with the app. SPAs are easier to get started with, but they can have slower initial load times. SPAs are the default architecture for most build tools.
Single-page apps (SPA)load a single HTML page and dynamically updates the page as the user interacts with the app. SPAs are easier to get started with, but they can have slower initial load times. SPAs are the default architecture for most build tools.

- Streaming Server-side rendering (SSR)renders a page on the server and sends the fully rendered page to the client. SSR can improve performance, but it can be more complex to set up and maintain than a single-page app. With the addition of streaming, SSR can be very complex to set up and maintain. SeeVite’s SSR guide.
Streaming Server-side rendering (SSR)renders a page on the server and sends the fully rendered page to the client. SSR can improve performance, but it can be more complex to set up and maintain than a single-page app. With the addition of streaming, SSR can be very complex to set up and maintain. SeeVite’s SSR guide.

- Static site generation (SSG)generates static HTML files for your app at build time. SSG can improve performance, but it can be more complex to set up and maintain than server-side rendering. SeeVite’s SSG guide.
Static site generation (SSG)generates static HTML files for your app at build time. SSG can improve performance, but it can be more complex to set up and maintain than server-side rendering. SeeVite’s SSG guide.

- React Server Components (RSC)lets you mix build-time, server-only, and interactive components in a single React tree. RSC can improve performance, but it currently requires deep expertise to set up and maintain. SeeParcel’s RSC examples.
React Server Components (RSC)lets you mix build-time, server-only, and interactive components in a single React tree. RSC can improve performance, but it currently requires deep expertise to set up and maintain. SeeParcel’s RSC examples.

Your rendering strategies need to integrate with your router so apps built with your framework can choose the rendering strategy on a per-route level. This will enable different rendering strategies without having to rewrite your whole app. For example, the landing page for your app might benefit from being statically generated (SSG), while a page with a content feed might perform best with server-side rendering.

Using the right rendering strategy for the right routes can decrease the time it takes for the first byte of content to be loaded (Time to First Byte), the first piece of content to render (First Contentful Paint), and the largest visible content of the app to render (Largest Contentful Paint).


### And more…
These are just a few examples of the features a new app will need to consider when building from scratch. Many limitations you’ll hit can be difficult to solve as each problem is interconnected with the others and can require deep expertise in problem areas you may not be familiar with.

If you don’t want to solve these problems on your own, you canget started with a frameworkthat provides these features out of the box.


--------------------------------------------------------------------------------


# Add React to an Existing Project
Source: https://react.dev/learn/add-react-to-an-existing-project

If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere.


### Note
You need to installNode.jsfor local development.Although you cantry Reactonline or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js.


## Using React for an entire subroute of your existing website
Let’s say you have an existing web app atexample.combuilt with another server technology (like Rails), and you want to implement all routes starting withexample.com/some-app/fully with React.

Here’s how we recommend to set it up:

- Build the React part of your appusing one of theReact-based frameworks.
- Specify/some-appas thebase pathin your framework’s configuration (here’s how:Next.js,Gatsby).
- Configure your server or a proxyso that all requests under/some-app/are handled by your React app.
This ensures the React part of your app canbenefit from the best practicesbaked into those frameworks.

Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export (next exportoutputfor Next.js, default for Gatsby) at/some-app/instead.


## Using React for a part of your existing page
Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years!

You can do this in two steps:

- Set up a JavaScript environmentthat lets you use theJSX syntax, split your code into modules with theimport/exportsyntax, and use packages (for example, React) from thenpmpackage registry.
- Render your React componentswhere you want to see them on the page.
The exact approach depends on your existing page setup, so let’s walk through some details.


### Step 1: Set up a modular JavaScript environment
A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on thenpmregistry—including React itself! How you do this depends on your existing setup:

- If your app is already split into files that useimportstatements,try to use the setup you already have. Check whether writing<div />in your JS code causes a syntax error. If it causes a syntax error, you might need totransform your JavaScript code with Babel, and enable theBabel React presetto use JSX.
If your app is already split into files that useimportstatements,try to use the setup you already have. Check whether writing<div />in your JS code causes a syntax error. If it causes a syntax error, you might need totransform your JavaScript code with Babel, and enable theBabel React presetto use JSX.

- If your app doesn’t have an existing setup for compiling JavaScript modules,set it up withVite. The Vite community maintainsmany integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed,follow this guideto manually integrate Vite builds with your backend.
If your app doesn’t have an existing setup for compiling JavaScript modules,set it up withVite. The Vite community maintainsmany integrations with backend frameworks, including Rails, Django, and Laravel. If your backend framework is not listed,follow this guideto manually integrate Vite builds with your backend.

To check whether your setup works, run this command in your project folder:

```jsx
npm install react react-dom
```

Then add these lines of code at the top of your main JavaScript file (it might be calledindex.jsormain.js):

```jsx
import { createRoot } from 'react-dom/client';

// Clear the existing HTML content
document.body.innerHTML = '<div id="app"></div>';

// Render your React component instead
const root = createRoot(document.getElementById('app'));
root.render(<h1>Hello, world</h1>);


```

If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading.


### Note
Integrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try ourcommunity resourcesor theVite Chat.


### Step 2: Render React components anywhere on the page
In the previous step, you put this code at the top of your main file:

```jsx
import { createRoot } from 'react-dom/client';// Clear the existing HTML contentdocument.body.innerHTML = '<div id="app"></div>';// Render your React component insteadconst root = createRoot(document.getElementById('app'));root.render(<h1>Hello, world</h1>);
```

Of course, you don’t actually want to clear the existing HTML content!

Delete this code.

Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a uniqueidattribute to any tag, for example:

```jsx
<!-- ... somewhere in your html ... --><nav id="navigation"></nav><!-- ... more html ... -->
```

This lets you find that HTML element withdocument.getElementByIdand pass it tocreateRootso that you can render your own React component inside:

```jsx
import { createRoot } from 'react-dom/client';

function NavigationBar() {
  // TODO: Actually implement a navigation bar
  return <h1>Hello from React!</h1>;
}

const domNode = document.getElementById('navigation');
const root = createRoot(domNode);
root.render(<NavigationBar />);


```

Notice how the original HTML content fromindex.htmlis preserved, but your ownNavigationBarReact component now appears inside the<nav id="navigation">from your HTML. Read thecreateRootusage documentationto learn more about rendering React components inside an existing HTML page.

When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating toa React frameworkright after to get the most out of React.


## Using React Native in an existing native mobile app
React Nativecan also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift),follow this guideto add a React Native screen to it.


--------------------------------------------------------------------------------


# Setup
Source: https://react.dev/learn/setup

React integrates with tools like editors, TypeScript, browser extensions, and compilers. This section will help you get your environment set up.


## Editor Setup
See ourrecommended editorsand learn how to set them up to work with React.


## Using TypeScript
TypeScript is a popular way to add type definitions to JavaScript codebases.Learn how to integrate TypeScript into your React projects.


## React Developer Tools
React Developer Tools is a browser extension that can inspect React components, edit props and state, and identify performance problems. Learn how to install ithere.


## React Compiler
React Compiler is a tool that automatically optimizes your React app.Learn more.


## Next steps
Head to theQuick Startguide for a tour of the most important React concepts you will encounter every day.


--------------------------------------------------------------------------------


# Editor Setup
Source: https://react.dev/learn/editor-setup

A properly configured editor can make code clearer to read and faster to write. It can even help you catch bugs as you write them! If this is your first time setting up an editor or you’re looking to tune up your current editor, we have a few recommendations.


### You will learn
- What the most popular editors are
- How to format your code automatically

## Your editor
VS Codeis one of the most popular editors in use today. It has a large marketplace of extensions and integrates well with popular services like GitHub. Most of the features listed below can be added to VS Code as extensions as well, making it highly configurable!

Other popular text editors used in the React community include:

- WebStormis an integrated development environment designed specifically for JavaScript.
- Sublime Texthas support for JSX and TypeScript,syntax highlightingand autocomplete built in.
- Vimis a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as “vi” with most UNIX systems and with Apple OS X.

## Recommended text editor features
Some editors come with these features built in, but others might require adding an extension. Check to see what support your editor of choice provides to be sure!


### Linting
Code linters find problems in your code as you write, helping you fix them early.ESLintis a popular, open source linter for JavaScript.

- Install ESLint with the recommended configuration for React(be sure you haveNode installed!)
- Integrate ESLint in VSCode with the official extension
Make sure that you’ve enabled all theeslint-plugin-react-hooksrules for your project.They are essential and catch the most severe bugs early. The recommendedeslint-config-react-apppreset already includes them.


### Formatting
The last thing you want to do when sharing your code with another contributor is get into a discussion abouttabs vs spaces! Fortunately,Prettierwill clean up your code by reformatting it to conform to preset, configurable rules. Run Prettier, and all your tabs will be converted to spaces—and your indentation, quotes, etc will also all be changed to conform to the configuration. In the ideal setup, Prettier will run when you save your file, quickly making these edits for you.

You can install thePrettier extension in VSCodeby following these steps:

- Launch VS Code
- Use Quick Open (press Ctrl/Cmd+P)
- Paste inext install esbenp.prettier-vscode
- Press Enter

#### Formatting on save
Ideally, you should format your code on every save. VS Code has settings for this!

- In VS Code, pressCTRL/CMD + SHIFT + P.
- Type “settings”
- Hit Enter
- In the search bar, type “format on save”
- Be sure the “format on save” option is ticked!
If your ESLint preset has formatting rules, they may conflict with Prettier. We recommend disabling all formatting rules in your ESLint preset usingeslint-config-prettierso that ESLint isonlyused for catching logical mistakes. If you want to enforce that files are formatted before a pull request is merged, useprettier --checkfor your continuous integration.


--------------------------------------------------------------------------------


# Using TypeScript
Source: https://react.dev/learn/typescript

TypeScript is a popular way to add type definitions to JavaScript codebases. Out of the box, TypeScriptsupports JSXand you can get full React Web support by adding@types/reactand@types/react-domto your project.


### You will learn
- TypeScript with React Components
- Examples of typing with Hooks
- Common types from@types/react
- Further learning locations

## Installation
Allproduction-grade React frameworksoffer support for using TypeScript. Follow the framework specific guide for installation:

- Next.js
- Remix
- Gatsby
- Expo

### Adding TypeScript to an existing React project
To install the latest version of React’s type definitions:

```jsx
npm install --save-dev @types/react @types/react-dom
```

The following compiler options need to be set in yourtsconfig.json:

- dommust be included inlib(Note: If noliboption is specified,domis included by default).
- jsxmust be set to one of the valid options.preserveshould suffice for most applications.
If you’re publishing a library, consult thejsxdocumentationon what value to choose.

## TypeScript with React Components

### Note
Every file containing JSX must use the.tsxfile extension. This is a TypeScript-specific extension that tells TypeScript that this file contains JSX.

Writing TypeScript with React is very similar to writing JavaScript with React. The key difference when working with a component is that you can provide types for your component’s props. These types can be used for correctness checking and providing inline documentation in editors.

Taking theMyButtoncomponentfrom theQuick Startguide, we can add a type describing thetitlefor the button:

```jsx
function MyButton({ title }: { title: string }) {
  return (
    <button>{title}</button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton title="I'm a button" />
    </div>
  );
}


```


### Note
These sandboxes can handle TypeScript code, but they do not run the type-checker. This means you can amend the TypeScript sandboxes to learn, but you won’t get any type errors or warnings. To get type-checking, you can use theTypeScript Playgroundor use a more fully-featured online sandbox.

This inline syntax is the simplest way to provide types for a component, though once you start to have a few fields to describe it can become unwieldy. Instead, you can use aninterfaceortypeto describe the component’s props:

```jsx
interface MyButtonProps {
  /** The text to display inside the button */
  title: string;
  /** Whether the button can be interacted with */
  disabled: boolean;
}

function MyButton({ title, disabled }: MyButtonProps) {
  return (
    <button disabled={disabled}>{title}</button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton title="I'm a disabled button" disabled={true}/>
    </div>
  );
}


```

The type describing your component’s props can be as simple or as complex as you need, though they should be an object type described with either atypeorinterface. You can learn about how TypeScript describes objects inObject Typesbut you may also be interested in usingUnion Typesto describe a prop that can be one of a few different types and theCreating Types from Typesguide for more advanced use cases.


## Example Hooks
The type definitions from@types/reactinclude types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will getinferred typesa lot of the time and ideally do not need to handle the minutiae of providing the types.

However, we can look at a few examples of how to provide types for Hooks.


### useState
TheuseStateHookwill re-use the value passed in as the initial state to determine what the type of the value should be. For example:

```jsx
// Infer the type as "boolean"const [enabled, setEnabled] = useState(false);
```

This will assign the type ofbooleantoenabled, andsetEnabledwill be a function accepting either abooleanargument, or a function that returns aboolean. If you want to explicitly provide a type for the state, you can do so by providing a type argument to theuseStatecall:

```jsx
// Explicitly set the type to "boolean"const [enabled, setEnabled] = useState<boolean>(false);
```

This isn’t very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example,statushere can be one of a few different strings:

```jsx
type Status = "idle" | "loading" | "success" | "error";const [status, setStatus] = useState<Status>("idle");
```

Or, as recommended inPrinciples for structuring state, you can group related state as an object and describe the different possibilities via object types:

```jsx
type RequestState =  | { status: 'idle' }  | { status: 'loading' }  | { status: 'success', data: any }  | { status: 'error', error: Error };const [requestState, setRequestState] = useState<RequestState>({ status: 'idle' });
```


### useReducer
TheuseReducerHookis a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to theuseReducercall to provide a type for the state, but it is often better to set the type on the initial state instead:

```jsx
import {useReducer} from 'react';

interface State {
   count: number
};

type CounterAction =
  | { type: "reset" }
  | { type: "setCount"; value: State["count"] }

const initialState: State = { count: 0 };

function stateReducer(state: State, action: CounterAction): State {
  switch (action.type) {
    case "reset":
      return initialState;
    case "setCount":
      return { ...state, count: action.value };
    default:
      throw new Error("Unknown action");
  }
}

export default function App() {
  const [state, dispatch] = useReducer(stateReducer, initialState);

  const addFive = () => dispatch({ type: "setCount", value: state.count + 5 });
  const reset = () => dispatch({ type: "reset" });

  return (
    <div>
      <h1>Welcome to my counter</h1>

      <p>Count: {state.count}</p>
      <button onClick={addFive}>Add 5</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}


```

We are using TypeScript in a few key places:

- interface Statedescribes the shape of the reducer’s state.
- type CounterActiondescribes the different actions which can be dispatched to the reducer.
- const initialState: Stateprovides a type for the initial state, and also the type which is used byuseReducerby default.
- stateReducer(state: State, action: CounterAction): Statesets the types for the reducer function’s arguments and return value.
A more explicit alternative to setting the type oninitialStateis to provide a type argument touseReducer:

```jsx
import { stateReducer, State } from './your-reducer-implementation';const initialState = { count: 0 };export default function App() {  const [state, dispatch] = useReducer<State>(stateReducer, initialState);}
```


### useContext
TheuseContextHookis a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component.

The type of the value provided by the context is inferred from the value passed to thecreateContextcall:

```jsx
import { createContext, useContext, useState } from 'react';

type Theme = "light" | "dark" | "system";
const ThemeContext = createContext<Theme>("system");

const useGetTheme = () => useContext(ThemeContext);

export default function MyApp() {
  const [theme, setTheme] = useState<Theme>('light');

  return (
    <ThemeContext value={theme}>
      <MyComponent />
    </ThemeContext>
  )
}

function MyComponent() {
  const theme = useGetTheme();

  return (
    <div>
      <p>Current theme: {theme}</p>
    </div>
  )
}


```

This technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those casesnullcan feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly setContextShape | nullon thecreateContext.

This causes the issue that you need to eliminate the| nullin the type for context consumers. Our recommendation is to have the Hook do a runtime check for it’s existence and throw an error when not present:

```jsx
import { createContext, useContext, useState, useMemo } from 'react';// This is a simpler example, but you can imagine a more complex object heretype ComplexObject = {  kind: string};// The context is created with `| null` in the type, to accurately reflect the default value.const Context = createContext<ComplexObject | null>(null);// The `| null` will be removed via the check in the Hook.const useGetComplexObject = () => {  const object = useContext(Context);  if (!object) { throw new Error("useGetComplexObject must be used within a Provider") }  return object;}export default function MyApp() {  const object = useMemo(() => ({ kind: "complex" }), []);  return (    <Context value={object}>      <MyComponent />    </Context>  )}function MyComponent() {  const object = useGetComplexObject();  return (    <div>      <p>Current object: {object.kind}</p>    </div>  )}
```


### useMemo

### Note
React Compilerautomatically memoizes values and functions, reducing the need for manualuseMemocalls. You can use the compiler to handle memoization automatically.

TheuseMemoHooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook.

```jsx
// The type of visibleTodos is inferred from the return value of filterTodosconst visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
```


### useCallback

### Note
React Compilerautomatically memoizes values and functions, reducing the need for manualuseCallbackcalls. You can use the compiler to handle memoization automatically.

TheuseCallbackprovide a stable reference to a function as long as the dependencies passed into the second parameter are the same. LikeuseMemo, the function’s type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook.

```jsx
const handleClick = useCallback(() => {  // ...}, [todos]);
```

When working in TypeScript strict modeuseCallbackrequires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood.

Depending on your code-style preferences, you could use the*EventHandlerfunctions from the React types to provide the type for the event handler at the same time as defining the callback:

```jsx
import { useState, useCallback } from 'react';export default function Form() {  const [value, setValue] = useState("Change me");  const handleChange = useCallback<React.ChangeEventHandler<HTMLInputElement>>((event) => {    setValue(event.currentTarget.value);  }, [setValue])  return (    <>      <input value={value} onChange={handleChange} />      <p>Value: {value}</p>    </>  );}
```


## Useful Types
There is quite an expansive set of types which come from the@types/reactpackage, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find themin React’s folder in DefinitelyTyped. We will cover a few of the more common types here.


### DOM Events
When working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event.

```jsx
import { useState } from 'react';

export default function Form() {
  const [value, setValue] = useState("Change me");

  function handleChange(event: React.ChangeEvent<HTMLInputElement>) {
    setValue(event.currentTarget.value);
  }

  return (
    <>
      <input value={value} onChange={handleChange} />
      <p>Value: {value}</p>
    </>
  );
}


```

There are many types of events provided in the React types - the full list can be foundherewhich is based on themost popular events from the DOM.

When determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event.

If you need to use an event that is not included in this list, you can use theReact.SyntheticEventtype, which is the base type for all events.


### Children
There are two common paths to describing the children of a component. The first is to use theReact.ReactNodetype, which is a union of all the possible types that can be passed as children in JSX:

```jsx
interface ModalRendererProps {  title: string;  children: React.ReactNode;}
```

This is a very broad definition of children. The second is to use theReact.ReactElementtype, which is only JSX elements and not JavaScript primitives like strings or numbers:

```jsx
interface ModalRendererProps {  title: string;  children: React.ReactElement;}
```

Note, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts<li>children.

You can see an example of bothReact.ReactNodeandReact.ReactElementwith the type-checker inthis TypeScript playground.


### Style Props
When using inline styles in React, you can useReact.CSSPropertiesto describe the object passed to thestyleprop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to thestyleprop, and to get auto-complete in your editor.

```jsx
interface MyComponentProps {  style: React.CSSProperties;}
```


## Further learning
This guide has covered the basics of using TypeScript with React, but there is a lot more to learn.
Individual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript.

We recommend the following resources:

- The TypeScript handbookis the official documentation for TypeScript, and covers most key language features.
The TypeScript handbookis the official documentation for TypeScript, and covers most key language features.

- The TypeScript release notescover new features in depth.
The TypeScript release notescover new features in depth.

- React TypeScript Cheatsheetis a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.
React TypeScript Cheatsheetis a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.

- TypeScript Community Discordis a great place to ask questions and get help with TypeScript and React issues.
TypeScript Community Discordis a great place to ask questions and get help with TypeScript and React issues.


--------------------------------------------------------------------------------


# React Developer Tools
Source: https://react.dev/learn/react-developer-tools

Use React Developer Tools to inspect Reactcomponents, editpropsandstate, and identify performance problems.


### You will learn
- How to install React Developer Tools

## Browser extension
The easiest way to debug websites built with React is to install the React Developer Tools browser extension. It is available for several popular browsers:

- Install forChrome
- Install forFirefox
- Install forEdge
Now, if you visit a websitebuilt with React,you will see theComponentsandProfilerpanels.


### Safari and other browsers
For other browsers (for example, Safari), install thereact-devtoolsnpm package:

```jsx
# Yarnyarn global add react-devtools# Npmnpm install -g react-devtools
```

Next open the developer tools from the terminal:

```jsx
react-devtools
```

Then connect your website by adding the following<script>tag to the beginning of your website’s<head>:

```jsx
<html>  <head>    <script src="http://localhost:8097"></script>
```

Reload your website in the browser now to view it in developer tools.


## Mobile (React Native)
To inspect apps built withReact Native, you can useReact Native DevTools, the built-in debugger that deeply integrates React Developer Tools. All features work identically to the browser extension, including native element highlighting and selection.

Learn more about debugging in React Native.

For versions of React Native earlier than 0.76, please use the standalone build of React DevTools by following theSafari and other browsersguide above.


--------------------------------------------------------------------------------


# React Compiler
Source: https://react.dev/learn/react-compiler


## Introduction
Learnwhat React Compiler doesand how it automatically optimizes your React application by handling memoization for you, eliminating the need for manualuseMemo,useCallback, andReact.memo.


## Installation
Get started withinstalling React Compilerand learn how to configure it with your build tools.


## Incremental Adoption
Learnstrategies for gradually adopting React Compilerin your existing codebase if you’re not ready to enable it everywhere yet.


## Debugging and Troubleshooting
When things don’t work as expected, use ourdebugging guideto understand the difference between compiler errors and runtime issues, identify common breaking patterns, and follow a systematic debugging workflow.


## Configuration and Reference
For detailed configuration options and API reference:

- Configuration Options- All compiler configuration options including React version compatibility
- Directives- Function-level compilation control
- Compiling Libraries- Shipping pre-compiled libraries

## Additional resources
In addition to these docs, we recommend checking theReact Compiler Working Groupfor additional information and discussion about the compiler.


--------------------------------------------------------------------------------


# Introduction
Source: https://react.dev/learn/react-compiler/introduction

React Compiler is a new build-time tool that automatically optimizes your React app. It works with plain JavaScript, and understands theRules of React, so you don’t need to rewrite any code to use it.


### You will learn
- What React Compiler does
- Getting started with the compiler
- Incremental adoption strategies
- Debugging and troubleshooting when things go wrong
- Using the compiler on your React library

## What does React Compiler do?
React Compiler automatically optimizes your React application at build time. React is often fast enough without optimization, but sometimes you need to manually memoize components and values to keep your app responsive. This manual memoization is tedious, easy to get wrong, and adds extra code to maintain. React Compiler does this optimization automatically for you, freeing you from this mental burden so you can focus on building features.


### Before React Compiler
Without the compiler, you need to manually memoize components and values to optimize re-renders:

```jsx
import { useMemo, useCallback, memo } from 'react';const ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {  const processedData = useMemo(() => {    return expensiveProcessing(data);  }, [data]);  const handleClick = useCallback((item) => {    onClick(item.id);  }, [onClick]);  return (    <div>      {processedData.map(item => (        <Item key={item.id} onClick={() => handleClick(item)} />      ))}    </div>  );});
```


### Note
This manual memoization has a subtle bug that breaks memoization:

```jsx
<Item key={item.id} onClick={() => handleClick(item)} />
```

Even thoughhandleClickis wrapped inuseCallback, the arrow function() => handleClick(item)creates a new function every time the component renders. This means thatItemwill always receive a newonClickprop, breaking memoization.

React Compiler is able to optimize this correctly with or without the arrow function, ensuring thatItemonly re-renders whenprops.onClickchanges.


### After React Compiler
With React Compiler, you write the same code without manual memoization:

```jsx
function ExpensiveComponent({ data, onClick }) {  const processedData = expensiveProcessing(data);  const handleClick = (item) => {    onClick(item.id);  };  return (    <div>      {processedData.map(item => (        <Item key={item.id} onClick={() => handleClick(item)} />      ))}    </div>  );}
```

See this example in the React Compiler Playground

React Compiler automatically applies the optimal memoization, ensuring your app only re-renders when necessary.


#### What kind of memoization does React Compiler add?
React Compiler’s automatic memoization is primarily focused onimproving update performance(re-rendering existing components), so it focuses on these two use cases:

- Skipping cascading re-rendering of componentsRe-rendering<Parent />causes many components in its component tree to re-render, even though only<Parent />has changed
- Re-rendering<Parent />causes many components in its component tree to re-render, even though only<Parent />has changed
- Skipping expensive calculations from outside of ReactFor example, callingexpensivelyProcessAReallyLargeArrayOfObjects()inside of your component or hook that needs that data
- For example, callingexpensivelyProcessAReallyLargeArrayOfObjects()inside of your component or hook that needs that data

#### Optimizing Re-renders
React lets you express your UI as a function of their current state (more concretely: their props, state, and context). In its current implementation, when a component’s state changes, React will re-render that componentand all of its children— unless you have applied some form of manual memoization withuseMemo(),useCallback(), orReact.memo(). For example, in the following example,<MessageButton>will re-render whenever<FriendList>’s state changes:

```jsx
function FriendList({ friends }) {  const onlineCount = useFriendOnlineCount();  if (friends.length === 0) {    return <NoFriends />;  }  return (    <div>      <span>{onlineCount} online</span>      {friends.map((friend) => (        <FriendListCard key={friend.id} friend={friend} />      ))}      <MessageButton />    </div>  );}
```

See this example in the React Compiler Playground

React Compiler automatically applies the equivalent of manual memoization, ensuring that only the relevant parts of an app re-render as state changes, which is sometimes referred to as “fine-grained reactivity”. In the above example, React Compiler determines that the return value of<FriendListCard />can be reused even asfriendschanges, and can avoid recreating this JSXandavoid re-rendering<MessageButton>as the count changes.


#### Expensive calculations also get memoized
React Compiler can also automatically memoize expensive calculations used during rendering:

```jsx
// **Not** memoized by React Compiler, since this is not a component or hookfunction expensivelyProcessAReallyLargeArrayOfObjects() { /* ... */ }// Memoized by React Compiler since this is a componentfunction TableContainer({ items }) {  // This function call would be memoized:  const data = expensivelyProcessAReallyLargeArrayOfObjects(items);  // ...}
```

See this example in the React Compiler Playground

However, ifexpensivelyProcessAReallyLargeArrayOfObjectsis truly an expensive function, you may want to consider implementing its own memoization outside of React, because:

- React Compiler only memoizes React components and hooks, not every function
- React Compiler’s memoization is not shared across multiple components or hooks
So ifexpensivelyProcessAReallyLargeArrayOfObjectswas used in many different components, even if the same exact items were passed down, that expensive calculation would be run repeatedly. We recommendprofilingfirst to see if it really is that expensive before making code more complicated.


## Should I try out the compiler?
We encourage everyone to start using React Compiler. While the compiler is still an optional addition to React today, in the future some features may require the compiler in order to fully work.


### Is it safe to use?
React Compiler is now stable and has been tested extensively in production. While it has been used in production at companies like Meta, rolling out the compiler to production for your app will depend on the health of your codebase and how well you’ve followed theRules of React.


## What build tools are supported?
React Compiler can be installed acrossseveral build toolssuch as Babel, Vite, Metro, and Rsbuild.

React Compiler is primarily a light Babel plugin wrapper around the core compiler, which was designed to be decoupled from Babel itself. While the initial stable version of the compiler will remain primarily a Babel plugin, we are working with the swc andoxcteams to build first class support for React Compiler so you won’t have to add Babel back to your build pipelines in the future.

Next.js users can enable the swc-invoked React Compiler by usingv15.3.1and up.


## What should I do about useMemo, useCallback, and React.memo?
By default, React Compiler will memoize your code based on its analysis and heuristics. In most cases, this memoization will be as precise, or moreso, than what you may have written.

However, in some cases developers may need more control over memoization. TheuseMemoanduseCallbackhooks can continue to be used with React Compiler as an escape hatch to provide control over which values are memoized. A common use-case for this is if a memoized value is used as an effect dependency, in order to ensure that an effect does not fire repeatedly even when its dependencies do not meaningfully change.

For new code, we recommend relying on the compiler for memoization and usinguseMemo/useCallbackwhere needed to achieve precise control.

For existing code, we recommend either leaving existing memoization in place (removing it can change compilation output) or carefully testing before removing the memoization.


## Try React Compiler
This section will help you get started with React Compiler and understand how to use it effectively in your projects.

- Installation- Install React Compiler and configure it for your build tools
- React Version Compatibility- Support for React 17, 18, and 19
- Configuration- Customize the compiler for your specific needs
- Incremental Adoption- Strategies for gradually rolling out the compiler in existing codebases
- Debugging and Troubleshooting- Identify and fix issues when using the compiler
- Compiling Libraries- Best practices for shipping compiled code
- API Reference- Detailed documentation of all configuration options

## Additional resources
In addition to these docs, we recommend checking theReact Compiler Working Groupfor additional information and discussion about the compiler.


--------------------------------------------------------------------------------


# Installation
Source: https://react.dev/learn/react-compiler/installation

This guide will help you install and configure React Compiler in your React application.


### You will learn
- How to install React Compiler
- Basic configuration for different build tools
- How to verify your setup is working

## Prerequisites
React Compiler is designed to work best with React 19, but it also supports React 17 and 18. Learn more aboutReact version compatibility.


## Installation
Install React Compiler as adevDependency:

```jsx
npm install -D babel-plugin-react-compiler@latest
```

Or with Yarn:

```jsx
yarn add -D babel-plugin-react-compiler@latest
```

Or with pnpm:

```jsx
pnpm install -D babel-plugin-react-compiler@latest
```


## Basic Setup
React Compiler is designed to work by default without any configuration. However, if you need to configure it in special circumstances (for example, to target React versions below 19), refer to thecompiler options reference.

The setup process depends on your build tool. React Compiler includes a Babel plugin that integrates with your build pipeline.


### Pitfall
React Compiler must runfirstin your Babel plugin pipeline. The compiler needs the original source information for proper analysis, so it must process your code before other transformations.


### Babel
Create or update yourbabel.config.js:

```jsx
module.exports = {  plugins: [    'babel-plugin-react-compiler', // must run first!    // ... other plugins  ],  // ... other config};
```


### Vite
If you use Vite, you can add the plugin to vite-plugin-react:

```jsx
// vite.config.jsimport { defineConfig } from 'vite';import react from '@vitejs/plugin-react';export default defineConfig({  plugins: [    react({      babel: {        plugins: ['babel-plugin-react-compiler'],      },    }),  ],});
```

Alternatively, if you prefer a separate Babel plugin for Vite:

```jsx
npm install -D vite-plugin-babel
```

```jsx
// vite.config.jsimport babel from 'vite-plugin-babel';import { defineConfig } from 'vite';import react from '@vitejs/plugin-react';export default defineConfig({  plugins: [    react(),    babel({      babelConfig: {        plugins: ['babel-plugin-react-compiler'],      },    }),  ],});
```


### Next.js
Please refer to theNext.js docsfor more information.


### React Router
Installvite-plugin-babel, and add the compiler’s Babel plugin to it:

```jsx
npm install vite-plugin-babel
```

```jsx
// vite.config.jsimport { defineConfig } from "vite";import babel from "vite-plugin-babel";import { reactRouter } from "@react-router/dev/vite";const ReactCompilerConfig = { /* ... */ };export default defineConfig({  plugins: [    reactRouter(),    babel({      filter: /\.[jt]sx?$/,      babelConfig: {        presets: ["@babel/preset-typescript"], // if you use TypeScript        plugins: [          ["babel-plugin-react-compiler", ReactCompilerConfig],        ],      },    }),  ],});
```


### Webpack
A community webpack loader isnow available here.


### Expo
Please refer toExpo’s docsto enable and use the React Compiler in Expo apps.


### Metro (React Native)
React Native uses Babel via Metro, so refer to theUsage with Babelsection for installation instructions.


### Rspack
Please refer toRspack’s docsto enable and use the React Compiler in Rspack apps.


### Rsbuild
Please refer toRsbuild’s docsto enable and use the React Compiler in Rsbuild apps.


## ESLint Integration
React Compiler includes an ESLint rule that helps identify code that can’t be optimized. When the ESLint rule reports an error, it means the compiler will skip optimizing that specific component or hook. This is safe: the compiler will continue optimizing other parts of your codebase. You don’t need to fix all violations immediately. Address them at your own pace to gradually increase the number of optimized components.

Install the ESLint plugin:

```jsx
npm install -D eslint-plugin-react-hooks@latest
```

If you haven’t already configured eslint-plugin-react-hooks, follow theinstallation instructions in the readme. The compiler rules are available in therecommended-latestpreset.

The ESLint rule will:

- Identify violations of theRules of React
- Show which components can’t be optimized
- Provide helpful error messages for fixing issues

## Verify Your Setup
After installation, verify that React Compiler is working correctly.


### Check React DevTools
Components optimized by React Compiler will show a “Memo ✨” badge in React DevTools:

- Install theReact Developer Toolsbrowser extension
- Open your app in development mode
- Open React DevTools
- Look for the ✨ emoji next to component names
If the compiler is working:

- Components will show a “Memo ✨” badge in React DevTools
- Expensive calculations will be automatically memoized
- No manualuseMemois required

### Check Build Output
You can also verify the compiler is running by checking your build output. The compiled code will include automatic memoization logic that the compiler adds automatically.

```jsx
import { c as _c } from "react/compiler-runtime";export default function MyApp() {  const $ = _c(1);  let t0;  if ($[0] === Symbol.for("react.memo_cache_sentinel")) {    t0 = <div>Hello World</div>;    $[0] = t0;  } else {    t0 = $[0];  }  return t0;}
```


## Troubleshooting

### Opting out specific components
If a component is causing issues after compilation, you can temporarily opt it out using the"use no memo"directive:

```jsx
function ProblematicComponent() {  "use no memo";  // Component code here}
```

This tells the compiler to skip optimization for this specific component. You should fix the underlying issue and remove the directive once resolved.

For more troubleshooting help, see thedebugging guide.


## Next Steps
Now that you have React Compiler installed, learn more about:

- React version compatibilityfor React 17 and 18
- Configuration optionsto customize the compiler
- Incremental adoption strategiesfor existing codebases
- Debugging techniquesfor troubleshooting issues
- Compiling Libraries guidefor compiling your React library

--------------------------------------------------------------------------------


# Incremental Adoption
Source: https://react.dev/learn/react-compiler/incremental-adoption

React Compiler can be adopted incrementally, allowing you to try it on specific parts of your codebase first. This guide shows you how to gradually roll out the compiler in existing projects.


### You will learn
- Why incremental adoption is recommended
- Using Babel overrides for directory-based adoption
- Using the “use memo” directive for opt-in compilation
- Using the “use no memo” directive to exclude components
- Runtime feature flags with gating
- Monitoring your adoption progress

## Why Incremental Adoption?
React Compiler is designed to optimize your entire codebase automatically, but you don’t have to adopt it all at once. Incremental adoption gives you control over the rollout process, letting you test the compiler on small parts of your app before expanding to the rest.

Starting small helps you build confidence in the compiler’s optimizations. You can verify that your app behaves correctly with compiled code, measure performance improvements, and identify any edge cases specific to your codebase. This approach is especially valuable for production applications where stability is critical.

Incremental adoption also makes it easier to address any Rules of React violations the compiler might find. Instead of fixing violations across your entire codebase at once, you can tackle them systematically as you expand compiler coverage. This keeps the migration manageable and reduces the risk of introducing bugs.

By controlling which parts of your code get compiled, you can also run A/B tests to measure the real-world impact of the compiler’s optimizations. This data helps you make informed decisions about full adoption and demonstrates the value to your team.


## Approaches to Incremental Adoption
There are three main approaches to adopt React Compiler incrementally:

- Babel overrides- Apply the compiler to specific directories
- Opt-in with “use memo”- Only compile components that explicitly opt in
- Runtime gating- Control compilation with feature flags
All approaches allow you to test the compiler on specific parts of your application before full rollout.


## Directory-Based Adoption with Babel Overrides
Babel’soverridesoption lets you apply different plugins to different parts of your codebase. This is ideal for gradually adopting React Compiler directory by directory.


### Basic Configuration
Start by applying the compiler to a specific directory:

```jsx
// babel.config.jsmodule.exports = {  plugins: [    // Global plugins that apply to all files  ],  overrides: [    {      test: './src/modern/**/*.{js,jsx,ts,tsx}',      plugins: [        'babel-plugin-react-compiler'      ]    }  ]};
```


### Expanding Coverage
As you gain confidence, add more directories:

```jsx
// babel.config.jsmodule.exports = {  plugins: [    // Global plugins  ],  overrides: [    {      test: ['./src/modern/**/*.{js,jsx,ts,tsx}', './src/features/**/*.{js,jsx,ts,tsx}'],      plugins: [        'babel-plugin-react-compiler'      ]    },    {      test: './src/legacy/**/*.{js,jsx,ts,tsx}',      plugins: [        // Different plugins for legacy code      ]    }  ]};
```


### With Compiler Options
You can also configure compiler options per override:

```jsx
// babel.config.jsmodule.exports = {  plugins: [],  overrides: [    {      test: './src/experimental/**/*.{js,jsx,ts,tsx}',      plugins: [        ['babel-plugin-react-compiler', {          // options ...        }]      ]    },    {      test: './src/production/**/*.{js,jsx,ts,tsx}',      plugins: [        ['babel-plugin-react-compiler', {          // options ...        }]      ]    }  ]};
```


## Opt-in Mode with “use memo”
For maximum control, you can usecompilationMode: 'annotation'to only compile components and hooks that explicitly opt in with the"use memo"directive.


### Note
This approach gives you fine-grained control over individual components and hooks. It’s useful when you want to test the compiler on specific components without affecting entire directories.


### Annotation Mode Configuration
```jsx
// babel.config.jsmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      compilationMode: 'annotation',    }],  ],};
```


### Using the Directive
Add"use memo"at the beginning of functions you want to compile:

```jsx
function TodoList({ todos }) {  "use memo"; // Opt this component into compilation  const sortedTodos = todos.slice().sort();  return (    <ul>      {sortedTodos.map(todo => (        <TodoItem key={todo.id} todo={todo} />      ))}    </ul>  );}function useSortedData(data) {  "use memo"; // Opt this hook into compilation  return data.slice().sort();}
```

WithcompilationMode: 'annotation', you must:

- Add"use memo"to every component you want optimized
- Add"use memo"to every custom hook
- Remember to add it to new components
This gives you precise control over which components are compiled while you evaluate the compiler’s impact.


## Runtime Feature Flags with Gating
Thegatingoption enables you to control compilation at runtime using feature flags. This is useful for running A/B tests or gradually rolling out the compiler based on user segments.


### How Gating Works
The compiler wraps optimized code in a runtime check. If the gate returnstrue, the optimized version runs. Otherwise, the original code runs.


### Gating Configuration
```jsx
// babel.config.jsmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      gating: {        source: 'ReactCompilerFeatureFlags',        importSpecifierName: 'isCompilerEnabled',      },    }],  ],};
```


### Implementing the Feature Flag
Create a module that exports your gating function:

```jsx
// ReactCompilerFeatureFlags.jsexport function isCompilerEnabled() {  // Use your feature flag system  return getFeatureFlag('react-compiler-enabled');}
```


## Troubleshooting Adoption
If you encounter issues during adoption:

- Use"use no memo"to temporarily exclude problematic components
- Check thedebugging guidefor common issues
- Fix Rules of React violations identified by the ESLint plugin
- Consider usingcompilationMode: 'annotation'for more gradual adoption

## Next Steps
- Read theconfiguration guidefor more options
- Learn aboutdebugging techniques
- Check theAPI referencefor all compiler options

--------------------------------------------------------------------------------


# Debugging and Troubleshooting
Source: https://react.dev/learn/react-compiler/debugging

This guide helps you identify and fix issues when using React Compiler. Learn how to debug compilation problems and resolve common issues.


### You will learn
- The difference between compiler errors and runtime issues
- Common patterns that break compilation
- Step-by-step debugging workflow

## Understanding Compiler Behavior
React Compiler is designed to handle code that follows theRules of React. When it encounters code that might break these rules, it safely skips optimization rather than risk changing your app’s behavior.


### Compiler Errors vs Runtime Issues
Compiler errorsoccur at build time and prevent your code from compiling. These are rare because the compiler is designed to skip problematic code rather than fail.

Runtime issuesoccur when compiled code behaves differently than expected. Most of the time, if you encounter an issue with React Compiler, it’s a runtime issue. This typically happens when your code violates the Rules of React in subtle ways that the compiler couldn’t detect, and the compiler mistakenly compiled a component it should have skipped.

When debugging runtime issues, focus your efforts on finding Rules of React violations in the affected components that were not detected by the ESLint rule. The compiler relies on your code following these rules, and when they’re broken in ways it can’t detect, that’s when runtime problems occur.


## Common Breaking Patterns
One of the main ways React Compiler can break your app is if your code was written to rely on memoization for correctness. This means your app depends on specific values being memoized to work properly. Since the compiler may memoize differently than your manual approach, this can lead to unexpected behavior like effects over-firing, infinite loops, or missing updates.

Common scenarios where this occurs:

- Effects that rely on referential equality- When effects depend on objects or arrays maintaining the same reference across renders
- Dependency arrays that need stable references- When unstable dependencies cause effects to fire too often or create infinite loops
- Conditional logic based on reference checks- When code uses referential equality checks for caching or optimization

## Debugging Workflow
Follow these steps when you encounter issues:


### Compiler Build Errors
If you encounter a compiler error that unexpectedly breaks your build, this is likely a bug in the compiler. Report it to thefacebook/reactrepository with:

- The error message
- The code that caused the error
- Your React and compiler versions

### Runtime Issues
For runtime behavior issues:


### 1. Temporarily Disable Compilation
Use"use no memo"to isolate whether an issue is compiler-related:

```jsx
function ProblematicComponent() {  "use no memo"; // Skip compilation for this component  // ... rest of component}
```

If the issue disappears, it’s likely related to a Rules of React violation.

You can also try removing manual memoization (useMemo, useCallback, memo) from the problematic component to verify that your app works correctly without any memoization. If the bug still occurs when all memoization is removed, you have a Rules of React violation that needs to be fixed.


### 2. Fix Issues Step by Step
- Identify the root cause (often memoization-for-correctness)
- Test after each fix
- Remove"use no memo"once fixed
- Verify the component shows the ✨ badge in React DevTools

## Reporting Compiler Bugs
If you believe you’ve found a compiler bug:

- Verify it’s not a Rules of React violation- Check with ESLint
- Create a minimal reproduction- Isolate the issue in a small example
- Test without the compiler- Confirm the issue only occurs with compilation
- File anissue:React and compiler versionsMinimal reproduction codeExpected vs actual behaviorAny error messages
- React and compiler versions
- Minimal reproduction code
- Expected vs actual behavior
- Any error messages

## Next Steps
- Review theRules of Reactto prevent issues
- Check theincremental adoption guidefor gradual rollout strategies

--------------------------------------------------------------------------------


# Describing the UI
Source: https://react.dev/learn/describing-the-ui

React is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestablecomponents.From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, you’ll learn to create, customize, and conditionally display React components.


### In this chapter
- How to write your first React component
- When and how to create multi-component files
- How to add markup to JavaScript with JSX
- How to use curly braces with JSX to access JavaScript functionality from your components
- How to configure components with props
- How to conditionally render components
- How to render multiple components at a time
- How to avoid confusing bugs by keeping components pure
- Why understanding your UI as trees is useful

## Your first component
React applications are built from isolated pieces of UI calledcomponents. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is aGallerycomponent rendering threeProfilecomponents:

```jsx
function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}


```


## Ready to learn this topic?
ReadYour First Componentto learn how to declare and use React components.


## Importing and exporting components
You can declare many components in one file, but large files can get difficult to navigate. To solve this, you canexporta component into its own file, and thenimportthat component from another file:

```jsx
import Profile from './Profile.js';

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}


```


## Ready to learn this topic?
ReadImporting and Exporting Componentsto learn how to split components into their own files.


## Writing markup with JSX
Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information.

If we paste existing HTML markup into a React component, it won’t always work:

```jsx
export default function TodoList() {
  return (
    // This doesn't quite work!
    <h1>Hedy Lamarr's Todos</h1>
    <img
      src="https://i.imgur.com/yXOvdOSs.jpg"
      alt="Hedy Lamarr"
      class="photo"
    >
    <ul>
      <li>Invent new traffic lights
      <li>Rehearse a movie scene
      <li>Improve spectrum technology
    </ul>


```

If you have existing HTML like this, you can fix it using aconverter:

```jsx
export default function TodoList() {
  return (
    <>
      <h1>Hedy Lamarr's Todos</h1>
      <img
        src="https://i.imgur.com/yXOvdOSs.jpg"
        alt="Hedy Lamarr"
        className="photo"
      />
      <ul>
        <li>Invent new traffic lights</li>
        <li>Rehearse a movie scene</li>
        <li>Improve spectrum technology</li>
      </ul>
    </>
  );
}


```


## Ready to learn this topic?
ReadWriting Markup with JSXto learn how to write valid JSX.


## JavaScript in JSX with curly braces
JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to “open a window” to JavaScript:

```jsx
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}


```


## Ready to learn this topic?
ReadJavaScript in JSX with Curly Bracesto learn how to access JavaScript data from JSX.


## Passing props to a component
React components usepropsto communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX!

```jsx
import { getImageUrl } from './utils.js'

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}


```


## Ready to learn this topic?
ReadPassing Props to a Componentto learn how to pass and read props.


## Conditional rendering
Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax likeifstatements,&&, and? :operators.

In this example, the JavaScript&&operator is used to conditionally render a checkmark:

```jsx
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item
          isPacked={true}
          name="Space suit"
        />
        <Item
          isPacked={true}
          name="Helmet with a golden leaf"
        />
        <Item
          isPacked={false}
          name="Photo of Tam"
        />
      </ul>
    </section>
  );
}


```


## Ready to learn this topic?
ReadConditional Renderingto learn the different ways to render content conditionally.


## Rendering lists
You will often want to display multiple similar components from a collection of data. You can use JavaScript’sfilter()andmap()with React to filter and transform your array of data into an array of components.

For each array item, you will need to specify akey. Usually, you will want to use an ID from the database as akey. Keys let React keep track of each item’s place in the list even if the list changes.

```jsx
import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const listItems = people.map(person =>
    <li key={person.id}>
      <img
        src={getImageUrl(person)}
        alt={person.name}
      />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  );
  return (
    <article>
      <h1>Scientists</h1>
      <ul>{listItems}</ul>
    </article>
  );
}


```


## Ready to learn this topic?
ReadRendering Liststo learn how to render a list of components, and how to choose a key.


## Keeping components pure
Some JavaScript functions arepure.A pure function:

- Minds its own business.It does not change any objects or variables that existed before it was called.
- Same inputs, same output.Given the same inputs, a pure function should always return the same result.
By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component:

```jsx
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}


```

You can make this component pure by passing a prop instead of modifying a preexisting variable:

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}


```


## Ready to learn this topic?
ReadKeeping Components Pureto learn how to write components as pure, predictable functions.


## Your UI as a tree
React uses trees to model the relationships between components and modules.

A React render tree is a representation of the parent and child relationship between components.

An example React render tree.

Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance.

Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree.

An example module dependency tree.

A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues.


## Ready to learn this topic?
ReadYour UI as a Treeto learn how to create a render and module dependency trees for a React app and how they’re useful mental models for improving user experience and performance.


## What’s next?
Head over toYour First Componentto start reading this chapter page by page!

Or, if you’re already familiar with these topics, why not read aboutAdding Interactivity?


--------------------------------------------------------------------------------


# Your First Component
Source: https://react.dev/learn/your-first-component

Componentsare one of the core concepts of React. They are the foundation upon which you build user interfaces (UI), which makes them the perfect place to start your React journey!


### You will learn
- What a component is
- What role components play in a React application
- How to write your first React component

## Components: UI building blocks
On the Web, HTML lets us create rich structured documents with its built-in set of tags like<h1>and<li>:

```jsx
<article>  <h1>My First Component</h1>  <ol>    <li>Components: UI Building Blocks</li>    <li>Defining a Component</li>    <li>Using a Component</li>  </ol></article>
```

This markup represents this article<article>, its heading<h1>, and an (abbreviated) table of contents as an ordered list<ol>. Markup like this, combined with CSS for style, and JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown—every piece of UI you see on the Web.

React lets you combine your markup, CSS, and JavaScript into custom “components”,reusable UI elements for your app.The table of contents code you saw above could be turned into a<TableOfContents />component you could render on every page. Under the hood, it still uses the same HTML tags like<article>,<h1>, etc.

Just like with HTML tags, you can compose, order and nest components to design whole pages. For example, the documentation page you’re reading is made out of React components:

```jsx
<PageLayout>  <NavigationHeader>    <SearchBar />    <Link to="/docs">Docs</Link>  </NavigationHeader>  <Sidebar />  <PageContent>    <TableOfContents />    <DocumentationText />  </PageContent></PageLayout>
```

As your project grows, you will notice that many of your designs can be composed by reusing components you already wrote, speeding up your development. Our table of contents above could be added to any screen with<TableOfContents />! You can even jumpstart your project with the thousands of components shared by the React open source community likeChakra UIandMaterial UI.


## Defining a component
Traditionally when creating web pages, web developers marked up their content and then added interaction by sprinkling on some JavaScript. This worked great when interaction was a nice-to-have on the web. Now it is expected for many sites and all apps. React puts interactivity first while still using the same technology:a React component is a JavaScript function that you cansprinkle with markup.Here’s what that looks like (you can edit the example below):

```jsx
export default function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3Am.jpg"
      alt="Katherine Johnson"
    />
  )
}


```

And here’s how to build a component:


### Step 1: Export the component
Theexport defaultprefix is astandard JavaScript syntax(not specific to React). It lets you mark the main function in a file so that you can later import it from other files. (More on importing inImporting and Exporting Components!)


### Step 2: Define the function
Withfunction Profile() { }you define a JavaScript function with the nameProfile.


### Pitfall
React components are regular JavaScript functions, buttheir names must start with a capital letteror they won’t work!


### Step 3: Add markup
The component returns an<img />tag withsrcandaltattributes.<img />is written like HTML, but it is actually JavaScript under the hood! This syntax is calledJSX, and it lets you embed markup inside JavaScript.

Return statements can be written all on one line, as in this component:

```jsx
return <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />;
```

But if your markup isn’t all on the same line as thereturnkeyword, you must wrap it in a pair of parentheses:

```jsx
return (  <div>    <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />  </div>);
```


### Pitfall
Without parentheses, any code on the lines afterreturnwill be ignored!


## Using a component
Now that you’ve defined yourProfilecomponent, you can nest it inside other components. For example, you can export aGallerycomponent that uses multipleProfilecomponents:

```jsx
function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}


```


### What the browser sees
Notice the difference in casing:

- <section>is lowercase, so React knows we refer to an HTML tag.
- <Profile />starts with a capitalP, so React knows that we want to use our component calledProfile.
AndProfilecontains even more HTML:<img />. In the end, this is what the browser sees:

```jsx
<section>  <h1>Amazing scientists</h1>  <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />  <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />  <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" /></section>
```


### Nesting and organizing components
Components are regular JavaScript functions, so you can keep multiple components in the same file. This is convenient when components are relatively small or tightly related to each other. If this file gets crowded, you can always moveProfileto a separate file. You will learn how to do this shortly on thepage about imports.

Because theProfilecomponents are rendered insideGallery—even several times!—we can say thatGalleryis aparent component,rendering eachProfileas a “child”. This is part of the magic of React: you can define a component once, and then use it in as many places and as many times as you like.


### Pitfall
Components can render other components, butyou must never nest their definitions:

```jsx
export default function Gallery() {  // 🔴 Never define a component inside another component!  function Profile() {    // ...  }  // ...}
```

The snippet above isvery slow and causes bugs.Instead, define every component at the top level:

```jsx
export default function Gallery() {  // ...}// ✅ Declare components at the top levelfunction Profile() {  // ...}
```

When a child component needs some data from a parent,pass it by propsinstead of nesting definitions.


#### Components all the way down
Your React application begins at a “root” component. Usually, it is created automatically when you start a new project. For example, if you useCodeSandboxor if you use the frameworkNext.js, the root component is defined inpages/index.js. In these examples, you’ve been exporting root components.

Most React apps use components all the way down. This means that you won’t only use components for reusable pieces like buttons, but also for larger pieces like sidebars, lists, and ultimately, complete pages! Components are a handy way to organize UI code and markup, even if some of them are only used once.

React-based frameworkstake this a step further. Instead of using an empty HTML file and letting React “take over” managing the page with JavaScript, theyalsogenerate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads.

Still, many websites only use React toadd interactivity to existing HTML pages.They have many root components instead of a single one for the entire page. You can use as much—or as little—React as you need.


## Recap
You’ve just gotten your first taste of React! Let’s recap some key points.

- React lets you create components,reusable UI elements for your app.
React lets you create components,reusable UI elements for your app.

- In a React app, every piece of UI is a component.
In a React app, every piece of UI is a component.

- React components are regular JavaScript functions except:Their names always begin with a capital letter.They return JSX markup.
React components are regular JavaScript functions except:

- Their names always begin with a capital letter.
- They return JSX markup.

## Try out some challenges

#### Challenge1of4:Export the component
This sandbox doesn’t work because the root component is not exported:

```jsx
function Profile() {
  return (
    <img
      src="https://i.imgur.com/lICfvbD.jpg"
      alt="Aklilu Lemma"
    />
  );
}


```

Try to fix it yourself before looking at the solution!


--------------------------------------------------------------------------------


# Importing and Exporting Components
Source: https://react.dev/learn/importing-and-exporting-components

The magic of components lies in their reusability: you can create components that are composed of other components. But as you nest more and more components, it often makes sense to start splitting them into different files. This lets you keep your files easy to scan and reuse components in more places.


### You will learn
- What a root component file is
- How to import and export a component
- When to use default and named imports and exports
- How to import and export multiple components from one file
- How to split components into multiple files

## The root component file
InYour First Component, you made aProfilecomponent and aGallerycomponent that renders it:

```jsx
function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}


```

These currently live in aroot component file,namedApp.jsin this example. Depending on your setup, your root component could be in another file, though. If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.


## Exporting and importing a component
What if you want to change the landing screen in the future and put a list of science books there? Or place all the profiles somewhere else? It makes sense to moveGalleryandProfileout of the root component file. This will make them more modular and reusable in other files. You can move a component in three steps:

- Makea new JS file to put the components in.
- Exportyour function component from that file (using eitherdefaultornamedexports).
- Importit in the file where you’ll use the component (using the corresponding technique for importingdefaultornamedexports).
Here bothProfileandGalleryhave been moved out ofApp.jsinto a new file calledGallery.js. Now you can changeApp.jsto importGalleryfromGallery.js:

```jsx
import Gallery from './Gallery.js';

export default function App() {
  return (
    <Gallery />
  );
}


```

Notice how this example is broken down into two component files now:

- Gallery.js:Defines theProfilecomponent which is only used within the same file and is not exported.Exports theGallerycomponent as adefault export.
- Defines theProfilecomponent which is only used within the same file and is not exported.
- Exports theGallerycomponent as adefault export.
- App.js:ImportsGalleryas adefault importfromGallery.js.Exports the rootAppcomponent as adefault export.
- ImportsGalleryas adefault importfromGallery.js.
- Exports the rootAppcomponent as adefault export.

### Note
You may encounter files that leave off the.jsfile extension like so:

```jsx
import Gallery from './Gallery';
```

Either'./Gallery.js'or'./Gallery'will work with React, though the former is closer to hownative ES Moduleswork.


#### Default vs named exports
There are two primary ways to export values with JavaScript: default exports and named exports. So far, our examples have only used default exports. But you can use one or both of them in the same file.A file can have no more than onedefaultexport, but it can have as manynamedexports as you like.

How you export your component dictates how you must import it. You will get an error if you try to import a default export the same way you would a named export! This chart can help you keep track:

When you write adefaultimport, you can put any name you want afterimport. For example, you could writeimport Banana from './Button.js'instead and it would still provide you with the same default export. In contrast, with named imports, the name has to match on both sides. That’s why they are callednamedimports!

People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values.Regardless of which coding style you prefer, always give meaningful names to your component functions and the files that contain them. Components without names, likeexport default () => {}, are discouraged because they make debugging harder.


## Exporting and importing multiple components from the same file
What if you want to show just oneProfileinstead of a gallery? You can export theProfilecomponent, too. ButGallery.jsalready has adefaultexport, and you can’t havetwodefault exports. You could create a new file with a default export, or you could add anamedexport forProfile.A file can only have one default export, but it can have numerous named exports!


### Note
To reduce the potential confusion between default and named exports, some teams choose to only stick to one style (default or named), or avoid mixing them in a single file. Do what works best for you!

First,exportProfilefromGallery.jsusing a named export (nodefaultkeyword):

```jsx
export function Profile() {  // ...}
```

Then,importProfilefromGallery.jstoApp.jsusing a named import (with the curly braces):

```jsx
import { Profile } from './Gallery.js';
```

Finally,render<Profile />from theAppcomponent:

```jsx
export default function App() {  return <Profile />;}
```

NowGallery.jscontains two exports: a defaultGalleryexport, and a namedProfileexport.App.jsimports both of them. Try editing<Profile />to<Gallery />and back in this example:

```jsx
import Gallery from './Gallery.js';
import { Profile } from './Gallery.js';

export default function App() {
  return (
    <Profile />
  );
}


```

Now you’re using a mix of default and named exports:

- Gallery.js:Exports theProfilecomponent as anamed export calledProfile.Exports theGallerycomponent as adefault export.
- Exports theProfilecomponent as anamed export calledProfile.
- Exports theGallerycomponent as adefault export.
- App.js:ImportsProfileas anamed import calledProfilefromGallery.js.ImportsGalleryas adefault importfromGallery.js.Exports the rootAppcomponent as adefault export.
- ImportsProfileas anamed import calledProfilefromGallery.js.
- ImportsGalleryas adefault importfromGallery.js.
- Exports the rootAppcomponent as adefault export.

## Recap
On this page you learned:

- What a root component file is
- How to import and export a component
- When and how to use default and named imports and exports
- How to export multiple components from the same file

## Try out some challenges

#### Challenge1of1:Split the components further
Currently,Gallery.jsexports bothProfileandGallery, which is a bit confusing.

Move theProfilecomponent to its ownProfile.js, and then change theAppcomponent to render both<Profile />and<Gallery />one after another.

You may use either a default or a named export forProfile, but make sure that you use the corresponding import syntax in bothApp.jsandGallery.js! You can refer to the table from the deep dive above:

```jsx
// Move me to Profile.js!
export function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}


```

After you get it working with one kind of exports, make it work with the other kind.


--------------------------------------------------------------------------------


# Writing Markup with JSX
Source: https://react.dev/learn/writing-markup-with-jsx

JSXis a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although there are other ways to write components, most React developers prefer the conciseness of JSX, and most codebases use it.


### You will learn
- Why React mixes markup with rendering logic
- How JSX is different from HTML
- How to display information with JSX

## JSX: Putting markup into JavaScript
The Web has been built on HTML, CSS, and JavaScript. For many years, web developers kept content in HTML, design in CSS, and logic in JavaScript—often in separate files! Content was marked up inside HTML while the page’s logic lived separately in JavaScript:

HTML

JavaScript

But as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is whyin React, rendering logic and markup live together in the same place—components.

Sidebar.jsReact component

Form.jsReact component

Keeping a button’s rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button’s markup and a sidebar’s markup, are isolated from each other, making it safer to change either of them on their own.

Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. The best way to understand this is to convert some HTML markup to JSX markup.


### Note
JSX and React are two separate things. They’re often used together, but youcanuse them independentlyof each other. JSX is a syntax extension, while React is a JavaScript library.


## Converting HTML to JSX
Suppose that you have some (perfectly valid) HTML:

```jsx
<h1>Hedy Lamarr's Todos</h1><img   src="https://i.imgur.com/yXOvdOSs.jpg"   alt="Hedy Lamarr"   class="photo"><ul>    <li>Invent new traffic lights    <li>Rehearse a movie scene    <li>Improve the spectrum technology</ul>
```

And you want to put it into your component:

```jsx
export default function TodoList() {  return (    // ???  )}
```

If you copy and paste it as is, it will not work:

```jsx
export default function TodoList() {
  return (
    // This doesn't quite work!
    <h1>Hedy Lamarr's Todos</h1>
    <img 
      src="https://i.imgur.com/yXOvdOSs.jpg" 
      alt="Hedy Lamarr" 
      class="photo"
    >
    <ul>
      <li>Invent new traffic lights
      <li>Rehearse a movie scene
      <li>Improve the spectrum technology
    </ul>


```

This is because JSX is stricter and has a few more rules than HTML! If you read the error messages above, they’ll guide you to fix the markup, or you can follow the guide below.


### Note
Most of the time, React’s on-screen error messages will help you find where the problem is. Give them a read if you get stuck!


## The Rules of JSX

### 1. Return a single root element
To return multiple elements from a component,wrap them with a single parent tag.

For example, you can use a<div>:

```jsx
<div>  <h1>Hedy Lamarr's Todos</h1>  <img     src="https://i.imgur.com/yXOvdOSs.jpg"     alt="Hedy Lamarr"     class="photo"  >  <ul>    ...  </ul></div>
```

If you don’t want to add an extra<div>to your markup, you can write<>and</>instead:

```jsx
<>  <h1>Hedy Lamarr's Todos</h1>  <img     src="https://i.imgur.com/yXOvdOSs.jpg"     alt="Hedy Lamarr"     class="photo"  >  <ul>    ...  </ul></>
```

This empty tag is called aFragment.Fragments let you group things without leaving any trace in the browser HTML tree.


#### Why do multiple JSX tags need to be wrapped?
JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment.


### 2. Close all the tags
JSX requires tags to be explicitly closed: self-closing tags like<img>must become<img />, and wrapping tags like<li>orangesmust be written as<li>oranges</li>.

This is how Hedy Lamarr’s image and list items look closed:

```jsx
<>  <img     src="https://i.imgur.com/yXOvdOSs.jpg"     alt="Hedy Lamarr"     class="photo"   />  <ul>    <li>Invent new traffic lights</li>    <li>Rehearse a movie scene</li>    <li>Improve the spectrum technology</li>  </ul></>
```


### 3. camelCaseallmost of the things!
JSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects. In your own components, you will often want to read those attributes into variables. But JavaScript has limitations on variable names. For example, their names can’t contain dashes or be reserved words likeclass.

This is why, in React, many HTML and SVG attributes are written in camelCase. For example, instead ofstroke-widthyou usestrokeWidth. Sinceclassis a reserved word, in React you writeclassNameinstead, named after thecorresponding DOM property:

```jsx
<img   src="https://i.imgur.com/yXOvdOSs.jpg"   alt="Hedy Lamarr"   className="photo"/>
```

You canfind all these attributes in the list of DOM component props.If you get one wrong, don’t worry—React will print a message with a possible correction to thebrowser console.


### Pitfall
For historical reasons,aria-*anddata-*attributes are written as in HTML with dashes.


### Pro-tip: Use a JSX Converter
Converting all these attributes in existing markup can be tedious! We recommend using aconverterto translate your existing HTML and SVG to JSX. Converters are very useful in practice, but it’s still worth understanding what is going on so that you can comfortably write JSX on your own.

Here is your final result:

```jsx
export default function TodoList() {
  return (
    <>
      <h1>Hedy Lamarr's Todos</h1>
      <img 
        src="https://i.imgur.com/yXOvdOSs.jpg" 
        alt="Hedy Lamarr" 
        className="photo" 
      />
      <ul>
        <li>Invent new traffic lights</li>
        <li>Rehearse a movie scene</li>
        <li>Improve the spectrum technology</li>
      </ul>
    </>
  );
}


```


## Recap
Now you know why JSX exists and how to use it in components:

- React components group rendering logic together with markup because they are related.
- JSX is similar to HTML, with a few differences. You can use aconverterif you need to.
- Error messages will often point you in the right direction to fixing your markup.

## Try out some challenges

#### Challenge1of1:Convert some HTML to JSX
This HTML was pasted into a component, but it’s not valid JSX. Fix it:

```jsx
export default function Bio() {
  return (
    <div class="intro">
      <h1>Welcome to my website!</h1>
    </div>
    <p class="summary">
      You can find my thoughts here.
      <br><br>
      <b>And <i>pictures</b></i> of scientists!
    </p>
  );
}


```

Whether to do it by hand or using the converter is up to you!


--------------------------------------------------------------------------------


# JavaScript in JSX with Curly Braces
Source: https://react.dev/learn/javascript-in-jsx-with-curly-braces

JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to open a window to JavaScript.


### You will learn
- How to pass strings with quotes
- How to reference a JavaScript variable inside JSX with curly braces
- How to call a JavaScript function inside JSX with curly braces
- How to use a JavaScript object inside JSX with curly braces

## Passing strings with quotes
When you want to pass a string attribute to JSX, you put it in single or double quotes:

```jsx
export default function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/7vQD0fPs.jpg"
      alt="Gregorio Y. Zara"
    />
  );
}


```

Here,"https://i.imgur.com/7vQD0fPs.jpg"and"Gregorio Y. Zara"are being passed as strings.

But what if you want to dynamically specify thesrcoralttext? You coulduse a value from JavaScript by replacing"and"with{and}:

```jsx
export default function Avatar() {
  const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';
  const description = 'Gregorio Y. Zara';
  return (
    <img
      className="avatar"
      src={avatar}
      alt={description}
    />
  );
}


```

Notice the difference betweenclassName="avatar", which specifies an"avatar"CSS class name that makes the image round, andsrc={avatar}that reads the value of the JavaScript variable calledavatar. That’s because curly braces let you work with JavaScript right there in your markup!


## Using curly braces: A window into the JavaScript world
JSX is a special way of writing JavaScript. That means it’s possible to use JavaScript inside it—with curly braces{ }. The example below first declares a name for the scientist,name, then embeds it with curly braces inside the<h1>:

```jsx
export default function TodoList() {
  const name = 'Gregorio Y. Zara';
  return (
    <h1>{name}'s To Do List</h1>
  );
}


```

Try changing thename’s value from'Gregorio Y. Zara'to'Hedy Lamarr'. See how the list title changes?

Any JavaScript expression will work between curly braces, including function calls likeformatDate():

```jsx
const today = new Date();

function formatDate(date) {
  return new Intl.DateTimeFormat(
    'en-US',
    { weekday: 'long' }
  ).format(date);
}

export default function TodoList() {
  return (
    <h1>To Do List for {formatDate(today)}</h1>
  );
}


```


### Where to use curly braces
You can only use curly braces in two ways inside JSX:

- As textdirectly inside a JSX tag:<h1>{name}'s To Do List</h1>works, but<{tag}>Gregorio Y. Zara's To Do List</{tag}>will not.
- As attributesimmediately following the=sign:src={avatar}will read theavatarvariable, butsrc="{avatar}"will pass the string"{avatar}".

## Using “double curlies”: CSS and other objects in JSX
In addition to strings, numbers, and other JavaScript expressions, you can even pass objects in JSX. Objects are also denoted with curly braces, like{ name: "Hedy Lamarr", inventions: 5 }. Therefore, to pass a JS object in JSX, you must wrap the object in another pair of curly braces:person={{ name: "Hedy Lamarr", inventions: 5 }}.

You may see this with inline CSS styles in JSX. React does not require you to use inline styles (CSS classes work great for most cases). But when you need an inline style, you pass an object to thestyleattribute:

```jsx
export default function TodoList() {
  return (
    <ul style={{
      backgroundColor: 'black',
      color: 'pink'
    }}>
      <li>Improve the videophone</li>
      <li>Prepare aeronautics lectures</li>
      <li>Work on the alcohol-fuelled engine</li>
    </ul>
  );
}


```

Try changing the values ofbackgroundColorandcolor.

You can really see the JavaScript object inside the curly braces when you write it like this:

```jsx
<ul style={  {    backgroundColor: 'black',    color: 'pink'  }}>
```

The next time you see{{and}}in JSX, know that it’s nothing more than an object inside the JSX curlies!


### Pitfall
Inlinestyleproperties are written in camelCase. For example, HTML<ul style="background-color: black">would be written as<ul style={{ backgroundColor: 'black' }}>in your component.


## More fun with JavaScript objects and curly braces
You can move several expressions into one object, and reference them in your JSX inside curly braces:

```jsx
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}


```

In this example, thepersonJavaScript object contains anamestring and athemeobject:

```jsx
const person = {  name: 'Gregorio Y. Zara',  theme: {    backgroundColor: 'black',    color: 'pink'  }};
```

The component can use these values frompersonlike so:

```jsx
<div style={person.theme}>  <h1>{person.name}'s Todos</h1>
```

JSX is very minimal as a templating language because it lets you organize data and logic using JavaScript.


## Recap
Now you know almost everything about JSX:

- JSX attributes inside quotes are passed as strings.
- Curly braces let you bring JavaScript logic and variables into your markup.
- They work inside the JSX tag content or immediately after=in attributes.
- {{and}}is not special syntax: it’s a JavaScript object tucked inside JSX curly braces.

## Try out some challenges

#### Challenge1of3:Fix the mistake
This code crashes with an error sayingObjects are not valid as a React child:

```jsx
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}


```

Can you find the problem?


--------------------------------------------------------------------------------


# Passing Props to a Component
Source: https://react.dev/learn/passing-props-to-a-component

React components usepropsto communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.


### You will learn
- How to pass props to a component
- How to read props from a component
- How to specify default values for props
- How to pass some JSX to a component
- How props change over time

## Familiar props
Props are the information that you pass to a JSX tag. For example,className,src,alt,width, andheightare some of the props you can pass to an<img>:

```jsx
function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/1bX5QH6.jpg"
      alt="Lin Lanying"
      width={100}
      height={100}
    />
  );
}

export default function Profile() {
  return (
    <Avatar />
  );
}


```

The props you can pass to an<img>tag are predefined (ReactDOM conforms tothe HTML standard). But you can pass any props toyour owncomponents, such as<Avatar>, to customize them. Here’s how!


## Passing props to a component
In this code, theProfilecomponent isn’t passing any props to its child component,Avatar:

```jsx
export default function Profile() {  return (    <Avatar />  );}
```

You can giveAvatarsome props in two steps.


### Step 1: Pass props to the child component
First, pass some props toAvatar. For example, let’s pass two props:person(an object), andsize(a number):

```jsx
export default function Profile() {  return (    <Avatar      person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}      size={100}    />  );}
```


### Note
If double curly braces afterperson=confuse you, recallthey’re merely an objectinside the JSX curlies.

Now you can read these props inside theAvatarcomponent.


### Step 2: Read props inside the child component
You can read these props by listing their namesperson, sizeseparated by the commas inside({and})directly afterfunction Avatar. This lets you use them inside theAvatarcode, like you would with a variable.

```jsx
function Avatar({ person, size }) {  // person and size are available here}
```

Add some logic toAvatarthat uses thepersonandsizeprops for rendering, and you’re done.

Now you can configureAvatarto render in many different ways with different props. Try tweaking the values!

```jsx
import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

export default function Profile() {
  return (
    <div>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi', 
          imageId: 'YfeOqp2'
        }}
      />
      <Avatar
        size={80}
        person={{
          name: 'Aklilu Lemma', 
          imageId: 'OKS67lh'
        }}
      />
      <Avatar
        size={50}
        person={{ 
          name: 'Lin Lanying',
          imageId: '1bX5QH6'
        }}
      />
    </div>
  );
}


```

Props let you think about parent and child components independently. For example, you can change thepersonor thesizeprops insideProfilewithout having to think about howAvataruses them. Similarly, you can change how theAvataruses these props, without looking at theProfile.

You can think of props like “knobs” that you can adjust. They serve the same role as arguments serve for functions—in fact, propsarethe only argument to your component! React component functions accept a single argument, apropsobject:

```jsx
function Avatar(props) {  let person = props.person;  let size = props.size;  // ...}
```

Usually you don’t need the wholepropsobject itself, so you destructure it into individual props.


### Pitfall
Don’t miss the pair of{and}curliesinside of(and)when declaring props:

```jsx
function Avatar({ person, size }) {  // ...}
```

This syntax is called“destructuring”and is equivalent to reading properties from a function parameter:

```jsx
function Avatar(props) {  let person = props.person;  let size = props.size;  // ...}
```


## Specifying a default value for a prop
If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting=and the default value right after the parameter:

```jsx
function Avatar({ person, size = 100 }) {  // ...}
```

Now, if<Avatar person={...} />is rendered with nosizeprop, thesizewill be set to100.

The default value is only used if thesizeprop is missing or if you passsize={undefined}. But if you passsize={null}orsize={0}, the default value willnotbe used.


## Forwarding props with the JSX spread syntax
Sometimes, passing props gets very repetitive:

```jsx
function Profile({ person, size, isSepia, thickBorder }) {  return (    <div className="card">      <Avatar        person={person}        size={size}        isSepia={isSepia}        thickBorder={thickBorder}      />    </div>  );}
```

There’s nothing wrong with repetitive code—it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how thisProfiledoes withAvatar. Because they don’t use any of their props directly, it can make sense to use a more concise “spread” syntax:

```jsx
function Profile(props) {  return (    <div className="card">      <Avatar {...props} />    </div>  );}
```

This forwards all ofProfile’s props to theAvatarwithout listing each of their names.

Use spread syntax with restraint.If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next!


## Passing JSX as children
It is common to nest built-in browser tags:

```jsx
<div>  <img /></div>
```

Sometimes you’ll want to nest your own components the same way:

```jsx
<Card>  <Avatar /></Card>
```

When you nest content inside a JSX tag, the parent component will receive that content in a prop calledchildren. For example, theCardcomponent below will receive achildrenprop set to<Avatar />and render it in a wrapper div:

```jsx
import Avatar from './Avatar.js';

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}


```

Try replacing the<Avatar>inside<Card>with some text to see how theCardcomponent can wrap any nested content. It doesn’t need to “know” what’s being rendered inside of it. You will see this flexible pattern in many places.

You can think of a component with achildrenprop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. You will often use thechildrenprop for visual wrappers: panels, grids, etc.

Illustrated byRachel Lee Nabors


## How props change over time
TheClockcomponent below receives two props from its parent component:colorandtime. (The parent component’s code is omitted because it usesstate, which we won’t dive into just yet.)

Try changing the color in the select box below:

```jsx
export default function Clock({ color, time }) {
  return (
    <h1 style={{ color: color }}>
      {time}
    </h1>
  );
}


```

This example illustrates thata component may receive different props over time.Props are not always static! Here, thetimeprop changes every second, and thecolorprop changes when you select another color. Props reflect a component’s data at any point in time, rather than only in the beginning.

However, props areimmutable—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass itdifferent props—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them.

Don’t try to “change props”.When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about inState: A Component’s Memory.


## Recap
- To pass props, add them to the JSX, just like you would with HTML attributes.
- To read props, use thefunction Avatar({ person, size })destructuring syntax.
- You can specify a default value likesize = 100, which is used for missing andundefinedprops.
- You can forward all props with<Avatar {...props} />JSX spread syntax, but don’t overuse it!
- Nested JSX like<Card><Avatar /></Card>will appear asCardcomponent’schildrenprop.
- Props are read-only snapshots in time: every render receives a new version of props.
- You can’t change props. When you need interactivity, you’ll need to set state.

## Try out some challenges

#### Challenge1of3:Extract a component
ThisGallerycomponent contains some very similar markup for two profiles. Extract aProfilecomponent out of it to reduce the duplication. You’ll need to choose what props to pass to it.

```jsx
import { getImageUrl } from './utils.js';

export default function Gallery() {
  return (
    <div>
      <h1>Notable Scientists</h1>
      <section className="profile">
        <h2>Maria Skłodowska-Curie</h2>
        <img
          className="avatar"
          src={getImageUrl('szV5sdG')}
          alt="Maria Skłodowska-Curie"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            physicist and chemist
          </li>
          <li>
            <b>Awards: 4 </b> 
            (Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal, Matteucci Medal)
          </li>
          <li>
            <b>Discovered: </b>
            polonium (chemical element)
          </li>
        </ul>
      </section>
      <section className="profile">
        <h2>Katsuko Saruhashi</h2>
        <img
          className="avatar"
          src={getImageUrl('YfeOqp2')}
          alt="Katsuko Saruhashi"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            geochemist
          </li>
          <li>
            <b>Awards: 2 </b> 
            (Miyake Prize for geochemistry, Tanaka Prize)
          </li>
          <li>
            <b>Discovered: </b>
            a method for measuring carbon dioxide in seawater
          </li>
        </ul>
      </section>
    </div>
  );
}


```


--------------------------------------------------------------------------------


# Conditional Rendering
Source: https://react.dev/learn/conditional-rendering

Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax likeifstatements,&&, and? :operators.


### You will learn
- How to return different JSX depending on a condition
- How to conditionally include or exclude a piece of JSX
- Common conditional syntax shortcuts you’ll encounter in React codebases

## Conditionally returning JSX
Let’s say you have aPackingListcomponent rendering severalItems, which can be marked as packed or not:

```jsx
function Item({ name, isPacked }) {
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

Notice that some of theItemcomponents have theirisPackedprop set totrueinstead offalse. You want to add a checkmark (✅) to packed items ifisPacked={true}.

You can write this as anif/elsestatementlike so:

```jsx
if (isPacked) {  return <li className="item">{name} ✅</li>;}return <li className="item">{name}</li>;
```

If theisPackedprop istrue, this codereturns a different JSX tree.With this change, some of the items get a checkmark at the end:

```jsx
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✅</li>;
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

Try editing what gets returned in either case, and see how the result changes!

Notice how you’re creating branching logic with JavaScript’sifandreturnstatements. In React, control flow (like conditions) is handled by JavaScript.


### Conditionally returning nothing withnull
In some situations, you won’t want to render anything at all. For example, say you don’t want to show packed items at all. A component must return something. In this case, you can returnnull:

```jsx
if (isPacked) {  return null;}return <li className="item">{name}</li>;
```

IfisPackedis true, the component will return nothing,null. Otherwise, it will return JSX to render.

```jsx
function Item({ name, isPacked }) {
  if (isPacked) {
    return null;
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

In practice, returningnullfrom a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX. Here’s how to do that!


## Conditionally including JSX
In the previous example, you controlled which (if any!) JSX tree would be returned by the component. You may already have noticed some duplication in the render output:

```jsx
<li className="item">{name} ✅</li>
```

is very similar to

```jsx
<li className="item">{name}</li>
```

Both of the conditional branches return<li className="item">...</li>:

```jsx
if (isPacked) {  return <li className="item">{name} ✅</li>;}return <li className="item">{name}</li>;
```

While this duplication isn’t harmful, it could make your code harder to maintain. What if you want to change theclassName? You’d have to do it in two places in your code! In such a situation, you could conditionally include a little JSX to make your code moreDRY.


### Conditional (ternary) operator (? :)
JavaScript has a compact syntax for writing a conditional expression — theconditional operatoror “ternary operator”.

Instead of this:

```jsx
if (isPacked) {  return <li className="item">{name} ✅</li>;}return <li className="item">{name}</li>;
```

You can write this:

```jsx
return (  <li className="item">    {isPacked ? name + ' ✅' : name}  </li>);
```

You can read it as“ifisPackedis true, then (?) rendername + ' ✅', otherwise (:) rendername”.


#### Are these two examples fully equivalent?
If you’re coming from an object-oriented programming background, you might assume that the two examples above are subtly different because one of them may create two different “instances” of<li>. But JSX elements aren’t “instances” because they don’t hold any internal state and aren’t real DOM nodes. They’re lightweight descriptions, like blueprints. So these two examples, in fact,arecompletely equivalent.Preserving and Resetting Stategoes into detail about how this works.

Now let’s say you want to wrap the completed item’s text into another HTML tag, like<del>to strike it out. You can add even more newlines and parentheses so that it’s easier to nest more JSX in each of the cases:

```jsx
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {isPacked ? (
        <del>
          {name + ' ✅'}
        </del>
      ) : (
        name
      )}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

This style works well for simple conditions, but use it in moderation. If your components get messy with too much nested conditional markup, consider extracting child components to clean things up. In React, markup is a part of your code, so you can use tools like variables and functions to tidy up complex expressions.


### Logical AND operator (&&)
Another common shortcut you’ll encounter is theJavaScript logical AND (&&) operator.Inside React components, it often comes up when you want to render some JSX when the condition is true,or render nothing otherwise.With&&, you could conditionally render the checkmark only ifisPackedistrue:

```jsx
return (  <li className="item">    {name} {isPacked && '✅'}  </li>);
```

You can read this as“ifisPacked, then (&&) render the checkmark, otherwise, render nothing”.

Here it is in action:

```jsx
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

AJavaScript && expressionreturns the value of its right side (in our case, the checkmark) if the left side (our condition) istrue. But if the condition isfalse, the whole expression becomesfalse. React considersfalseas a “hole” in the JSX tree, just likenullorundefined, and doesn’t render anything in its place.


### Pitfall
Don’t put numbers on the left side of&&.

To test the condition, JavaScript converts the left side to a boolean automatically. However, if the left side is0, then the whole expression gets that value (0), and React will happily render0rather than nothing.

For example, a common mistake is to write code likemessageCount && <p>New messages</p>. It’s easy to assume that it renders nothing whenmessageCountis0, but it really renders the0itself!

To fix it, make the left side a boolean:messageCount > 0 && <p>New messages</p>.


### Conditionally assigning JSX to a variable
When the shortcuts get in the way of writing plain code, try using anifstatement and a variable. You can reassign variables defined withlet, so start by providing the default content you want to display, the name:

```jsx
let itemContent = name;
```

Use anifstatement to reassign a JSX expression toitemContentifisPackedistrue:

```jsx
if (isPacked) {  itemContent = name + " ✅";}
```

Curly braces open the “window into JavaScript”.Embed the variable with curly braces in the returned JSX tree, nesting the previously calculated expression inside of JSX:

```jsx
<li className="item">  {itemContent}</li>
```

This style is the most verbose, but it’s also the most flexible. Here it is in action:

```jsx
function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = name + " ✅";
  }
  return (
    <li className="item">
      {itemContent}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

Like before, this works not only for text, but for arbitrary JSX too:

```jsx
function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = (
      <del>
        {name + " ✅"}
      </del>
    );
  }
  return (
    <li className="item">
      {itemContent}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```

If you’re not familiar with JavaScript, this variety of styles might seem overwhelming at first. However, learning them will help you read and write any JavaScript code — and not just React components! Pick the one you prefer for a start, and then consult this reference again if you forget how the other ones work.


## Recap
- In React, you control branching logic with JavaScript.
- You can return a JSX expression conditionally with anifstatement.
- You can conditionally save some JSX to a variable and then include it inside other JSX by using the curly braces.
- In JSX,{cond ? <A /> : <B />}means“ifcond, render<A />, otherwise<B />”.
- In JSX,{cond && <A />}means“ifcond, render<A />, otherwise nothing”.
- The shortcuts are common, but you don’t have to use them if you prefer plainif.

## Try out some challenges

#### Challenge1of3:Show an icon for incomplete items with? :
Use the conditional operator (cond ? a : b) to render a ❌ ifisPackedisn’ttrue.

```jsx
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}


```


--------------------------------------------------------------------------------


# Rendering Lists
Source: https://react.dev/learn/rendering-lists

You will often want to display multiple similar components from a collection of data. You can use theJavaScript array methodsto manipulate an array of data. On this page, you’ll usefilter()andmap()with React to filter and transform your array of data into an array of components.


### You will learn
- How to render components from an array using JavaScript’smap()
- How to render only specific components using JavaScript’sfilter()
- When and why to use React keys

## Rendering data from arrays
Say that you have a list of content.

```jsx
<ul>  <li>Creola Katherine Johnson: mathematician</li>  <li>Mario José Molina-Pasquel Henríquez: chemist</li>  <li>Mohammad Abdus Salam: physicist</li>  <li>Percy Lavon Julian: chemist</li>  <li>Subrahmanyan Chandrasekhar: astrophysicist</li></ul>
```

The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods likemap()andfilter()to render lists of components from them.

Here’s a short example of how to generate a list of items from an array:

- Movethe data into an array:
```jsx
const people = [  'Creola Katherine Johnson: mathematician',  'Mario José Molina-Pasquel Henríquez: chemist',  'Mohammad Abdus Salam: physicist',  'Percy Lavon Julian: chemist',  'Subrahmanyan Chandrasekhar: astrophysicist'];
```

- Mapthepeoplemembers into a new array of JSX nodes,listItems:
```jsx
const listItems = people.map(person => <li>{person}</li>);
```

- ReturnlistItemsfrom your component wrapped in a<ul>:
```jsx
return <ul>{listItems}</ul>;
```

Here is the result:

```jsx
const people = [
  'Creola Katherine Johnson: mathematician',
  'Mario José Molina-Pasquel Henríquez: chemist',
  'Mohammad Abdus Salam: physicist',
  'Percy Lavon Julian: chemist',
  'Subrahmanyan Chandrasekhar: astrophysicist'
];

export default function List() {
  const listItems = people.map(person =>
    <li>{person}</li>
  );
  return <ul>{listItems}</ul>;
}


```

Notice the sandbox above displays a console error:

You’ll learn how to fix this error later on this page. Before we get to that, let’s add some structure to your data.


## Filtering arrays of items
This data can be structured even more.

```jsx
const people = [{  id: 0,  name: 'Creola Katherine Johnson',  profession: 'mathematician',}, {  id: 1,  name: 'Mario José Molina-Pasquel Henríquez',  profession: 'chemist',}, {  id: 2,  name: 'Mohammad Abdus Salam',  profession: 'physicist',}, {  id: 3,  name: 'Percy Lavon Julian',  profession: 'chemist',  }, {  id: 4,  name: 'Subrahmanyan Chandrasekhar',  profession: 'astrophysicist',}];
```

Let’s say you want a way to only show people whose profession is'chemist'. You can use JavaScript’sfilter()method to return just those people. This method takes an array of items, passes them through a “test” (a function that returnstrueorfalse), and returns a new array of only those items that passed the test (returnedtrue).

You only want the items whereprofessionis'chemist'. The “test” function for this looks like(person) => person.profession === 'chemist'. Here’s how to put it together:

- Createa new array of just “chemist” people,chemists, by callingfilter()on thepeoplefiltering byperson.profession === 'chemist':
```jsx
const chemists = people.filter(person =>  person.profession === 'chemist');
```

- Nowmapoverchemists:
```jsx
const listItems = chemists.map(person =>  <li>     <img       src={getImageUrl(person)}       alt={person.name}     />     <p>       <b>{person.name}:</b>       {' ' + person.profession + ' '}       known for {person.accomplishment}     </p>  </li>);
```

- Lastly,returnthelistItemsfrom your component:
```jsx
return <ul>{listItems}</ul>;
```

```jsx
import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const chemists = people.filter(person =>
    person.profession === 'chemist'
  );
  const listItems = chemists.map(person =>
    <li>
      <img
        src={getImageUrl(person)}
        alt={person.name}
      />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  );
  return <ul>{listItems}</ul>;
}


```


### Pitfall
Arrow functions implicitly return the expression right after=>, so you didn’t need areturnstatement:

```jsx
const listItems = chemists.map(person =>  <li>...</li> // Implicit return!);
```

However,you must writereturnexplicitly if your=>is followed by a{curly brace!

```jsx
const listItems = chemists.map(person => { // Curly brace  return <li>...</li>;});
```

Arrow functions containing=> {are said to have a“block body”.They let you write more than a single line of code, but youhave towrite areturnstatement yourself. If you forget it, nothing gets returned!


## Keeping list items in order withkey
Notice that all the sandboxes above show an error in the console:

You need to give each array item akey— a string or a number that uniquely identifies it among other items in that array:

```jsx
<li key={person.id}>...</li>
```


### Note
JSX elements directly inside amap()call always need keys!

Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosenkeyhelps React infer what exactly has happened, and make the correct updates to the DOM tree.

Rather than generating keys on the fly, you should include them in your data:

```jsx
export const people = [{
  id: 0, // Used in JSX as a key
  name: 'Creola Katherine Johnson',
  profession: 'mathematician',
  accomplishment: 'spaceflight calculations',
  imageId: 'MK3eW3A'
}, {
  id: 1, // Used in JSX as a key
  name: 'Mario José Molina-Pasquel Henríquez',
  profession: 'chemist',
  accomplishment: 'discovery of Arctic ozone hole',
  imageId: 'mynHUSa'
}, {
  id: 2, // Used in JSX as a key
  name: 'Mohammad Abdus Salam',
  profession: 'physicist',
  accomplishment: 'electromagnetism theory',
  imageId: 'bE7W1ji'
}, {
  id: 3, // Used in JSX as a key
  name: 'Percy Lavon Julian',
  profession: 'chemist',
  accomplishment: 'pioneering cortisone drugs, steroids and birth control pills',
  imageId: 'IOjWm71'
}, {
  id: 4, // Used in JSX as a key
  name: 'Subrahmanyan Chandrasekhar',
  profession: 'astrophysicist',
  accomplishment: 'white dwarf star mass calculations',
  imageId: 'lrWQx8l'
}];


```


#### Displaying several DOM nodes for each list item
What do you do when each item needs to render not one, but several DOM nodes?

The short<>...</>Fragmentsyntax won’t let you pass a key, so you need to either group them into a single<div>, or use the slightly longer andmore explicit<Fragment>syntax:

```jsx
import { Fragment } from 'react';// ...const listItems = people.map(person =>  <Fragment key={person.id}>    <h1>{person.name}</h1>    <p>{person.bio}</p>  </Fragment>);
```

Fragments disappear from the DOM, so this will produce a flat list of<h1>,<p>,<h1>,<p>, and so on.


### Where to get yourkey
Different sources of data provide different sources of keys:

- Data from a database:If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.
- Locally generated data:If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter,crypto.randomUUID()or a package likeuuidwhen creating items.

### Rules of keys
- Keys must be unique among siblings.However, it’s okay to use the same keys for JSX nodes indifferentarrays.
- Keys must not changeor that defeats their purpose! Don’t generate them while rendering.

### Why does React need keys?
Imagine that files on your desktop didn’t have names. Instead, you’d refer to them by their order — the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on.

File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if thepositionchanges due to reordering, thekeylets React identify the item throughout its lifetime.


### Pitfall
You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify akeyat all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.

Similarly, do not generate keys on the fly, e.g. withkey={Math.random()}. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.

Note that your components won’t receivekeyas a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop:<Profile key={id} userId={id} />.


## Recap
On this page you learned:

- How to move data out of components and into data structures like arrays and objects.
- How to generate sets of similar components with JavaScript’smap().
- How to create arrays of filtered items with JavaScript’sfilter().
- Why and how to setkeyon each component in a collection so React can keep track of each of them even if their position or data changes.

## Try out some challenges

#### Challenge1of4:Splitting a list in two
This example shows a list of all people.

Change it to show two separate lists one after another:ChemistsandEveryone Else.Like previously, you can determine whether a person is a chemist by checking ifperson.profession === 'chemist'.

```jsx
import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const listItems = people.map(person =>
    <li key={person.id}>
      <img
        src={getImageUrl(person)}
        alt={person.name}
      />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  );
  return (
    <article>
      <h1>Scientists</h1>
      <ul>{listItems}</ul>
    </article>
  );
}


```


--------------------------------------------------------------------------------


# Keeping Components Pure
Source: https://react.dev/learn/keeping-components-pure

Some JavaScript functions arepure.Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow.


### You will learn
- What purity is and how it helps you avoid bugs
- How to keep components pure by keeping changes out of the render phase
- How to use Strict Mode to find mistakes in your components

## Purity: Components as formulas
In computer science (and especially the world of functional programming),a pure functionis a function with the following characteristics:

- It minds its own business.It does not change any objects or variables that existed before it was called.
- Same inputs, same output.Given the same inputs, a pure function should always return the same result.
You might already be familiar with one example of pure functions: formulas in math.

Consider this math formula:y= 2x.

Ifx= 2theny= 4. Always.

Ifx= 3theny= 6. Always.

Ifx= 3,ywon’t sometimes be9or–1or2.5depending on the time of day or the state of the stock market.

Ify= 2xandx= 3,ywillalwaysbe6.

If we made this into a JavaScript function, it would look like this:

```jsx
function double(number) {  return 2 * number;}
```

In the above example,doubleis apure function.If you pass it3, it will return6. Always.

React is designed around this concept.React assumes that every component you write is a pure function.This means that React components you write must always return the same JSX given the same inputs:

```jsx
function Recipe({ drinkers }) {
  return (
    <ol>    
      <li>Boil {drinkers} cups of water.</li>
      <li>Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.</li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}


```

When you passdrinkers={2}toRecipe, it will return JSX containing2 cups of water. Always.

If you passdrinkers={4}, it will return JSX containing4 cups of water. Always.

Just like a math formula.

You could think of your components as recipes: if you follow them and don’t introduce new ingredients during the cooking process, you will get the same dish every time. That “dish” is the JSX that the component serves to React torender.

Illustrated byRachel Lee Nabors


## Side Effects: (un)intended consequences
React’s rendering process must always be pure. Components should onlyreturntheir JSX, and notchangeany objects or variables that existed before rendering—that would make them impure!

Here is a component that breaks this rule:

```jsx
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}


```

This component is reading and writing aguestvariable declared outside of it. This means thatcalling this component multiple times will produce different JSX!And what’s more, ifothercomponents readguest, they will produce different JSX, too, depending on when they were rendered! That’s not predictable.

Going back to our formulay= 2x, now even ifx= 2, we cannot trust thaty= 4. Our tests could fail, our users would be baffled, planes would fall out of the sky—you can see how this would lead to confusing bugs!

You can fix this component bypassingguestas a prop instead:

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}


```

Now your component is pure, as the JSX it returns only depends on theguestprop.

In general, you should not expect your components to be rendered in any particular order. It doesn’t matter if you cally= 2xbefore or aftery= 5x: both formulas will resolve independently of each other. In the same way, each component should only “think for itself”, and not attempt to coordinate with or depend upon others during rendering. Rendering is like a school exam: each component should calculate JSX on their own!


#### Detecting impure calculations with StrictMode
Although you might not have used them all yet, in React there are three kinds of inputs that you can read while rendering:props,state, andcontext.You should always treat these inputs as read-only.

When you want tochangesomething in response to user input, you shouldset stateinstead of writing to a variable. You should never change preexisting variables or objects while your component is rendering.

React offers a “Strict Mode” in which it calls each component’s function twice during development.By calling the component functions twice, Strict Mode helps find components that break these rules.

Notice how the original example displayed “Guest #2”, “Guest #4”, and “Guest #6” instead of “Guest #1”, “Guest #2”, and “Guest #3”. The original function was impure, so calling it twice broke it. But the fixed pure version works even if the function is called twice every time.Pure functions only calculate, so calling them twice won’t change anything—just like callingdouble(2)twice doesn’t change what’s returned, and solvingy= 2xtwice doesn’t change whatyis. Same inputs, same outputs. Always.

Strict Mode has no effect in production, so it won’t slow down the app for your users. To opt into Strict Mode, you can wrap your root component into<React.StrictMode>. Some frameworks do this by default.


### Local mutation: Your component’s little secret
In the above example, the problem was that the component changed apreexistingvariable while rendering. This is often called a“mutation”to make it sound a bit scarier. Pure functions don’t mutate variables outside of the function’s scope or objects that were created before the call—that makes them impure!

However,it’s completely fine to change variables and objects that you’vejustcreated while rendering.In this example, you create an[]array, assign it to acupsvariable, and thenpusha dozen cups into it:

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  const cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}


```

If thecupsvariable or the[]array were created outside theTeaGatheringfunction, this would be a huge problem! You would be changing apreexistingobject by pushing items into that array.

However, it’s fine because you’ve created themduring the same render, insideTeaGathering. No code outside ofTeaGatheringwill ever know that this happened. This is called“local mutation”—it’s like your component’s little secret.


## Where youcancause side effects
While functional programming relies heavily on purity, at some point, somewhere,somethinghas to change. That’s kind of the point of programming! These changes—updating the screen, starting an animation, changing the data—are calledside effects.They’re things that happen“on the side”, not during rendering.

In React,side effects usually belong insideevent handlers.Event handlers are functions that React runs when you perform some action—for example, when you click a button. Even though event handlers are definedinsideyour component, they don’t runduringrendering!So event handlers don’t need to be pure.

If you’ve exhausted all other options and can’t find the right event handler for your side effect, you can still attach it to your returned JSX with auseEffectcall in your component. This tells React to execute it later, after rendering, when side effects are allowed.However, this approach should be your last resort.

When possible, try to express your logic with rendering alone. You’ll be surprised how far this can take you!


#### Why does React care about purity?
Writing pure functions takes some habit and discipline. But it also unlocks marvelous opportunities:

- Your components could run in a different environment—for example, on the server! Since they return the same result for the same inputs, one component can serve many user requests.
- You can improve performance byskipping renderingcomponents whose inputs have not changed. This is safe because pure functions always return the same results, so they are safe to cache.
- If some data changes in the middle of rendering a deep component tree, React can restart rendering without wasting time to finish the outdated render. Purity makes it safe to stop calculating at any time.
Every new React feature we’re building takes advantage of purity. From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm.


## Recap
- A component must be pure, meaning:It minds its own business.It should not change any objects or variables that existed before rendering.Same inputs, same output.Given the same inputs, a component should always return the same JSX.
- It minds its own business.It should not change any objects or variables that existed before rendering.
- Same inputs, same output.Given the same inputs, a component should always return the same JSX.
- Rendering can happen at any time, so components should not depend on each others’ rendering sequence.
- You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen,“set” stateinstead of mutating preexisting objects.
- Strive to express your component’s logic in the JSX you return. When you need to “change things”, you’ll usually want to do it in an event handler. As a last resort, you canuseEffect.
- Writing pure functions takes a bit of practice, but it unlocks the power of React’s paradigm.

## Try out some challenges

#### Challenge1of3:Fix a broken clock
This component tries to set the<h1>’s CSS class to"night"during the time from midnight to six hours in the morning, and"day"at all other times. However, it doesn’t work. Can you fix this component?

You can verify whether your solution works by temporarily changing the computer’s timezone. When the current time is between midnight and six in the morning, the clock should have inverted colors!

```jsx
export default function Clock({ time }) {
  const hours = time.getHours();
  if (hours >= 0 && hours <= 6) {
    document.getElementById('time').className = 'night';
  } else {
    document.getElementById('time').className = 'day';
  }
  return (
    <h1 id="time">
      {time.toLocaleTimeString()}
    </h1>
  );
}


```


--------------------------------------------------------------------------------


# Understanding Your UI as a Tree
Source: https://react.dev/learn/understanding-your-ui-as-a-tree

Your React app is taking shape with many components being nested within each other. How does React keep track of your app’s component structure?

React, and many other UI libraries, model UI as a tree. Thinking of your app as a tree is useful for understanding the relationship between components. This understanding will help you debug future concepts like performance and state management.


### You will learn
- How React “sees” component structures
- What a render tree is and what it is useful for
- What a module dependency tree is and what it is useful for

## Your UI as a tree
Trees are a relationship model between items. The UI is often represented using tree structures. For example, browsers use tree structures to model HTML (DOM) and CSS (CSSOM). Mobile platforms also use trees to represent their view hierarchy.

React creates a UI tree from your components. In this example, the UI tree is then used to render to the DOM.

Like browsers and mobile platforms, React also uses tree structures to manage and model the relationship between components in a React app. These trees are useful tools to understand how data flows through a React app and how to optimize rendering and app size.


## The Render Tree
A major feature of components is the ability to compose components of other components. As wenest components, we have the concept of parent and child components, where each parent component may itself be a child of another component.

When we render a React app, we can model this relationship in a tree, known as the render tree.

Here is a React app that renders inspirational quotes.

```jsx
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
  return (
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
  );
}


```

React creates arender tree, a UI tree, composed of the rendered components.

From the example app, we can construct the above render tree.

The tree is composed of nodes, each of which represents a component.App,FancyText,Copyright, to name a few, are all nodes in our tree.

The root node in a React render tree is theroot componentof the app. In this case, the root component isAppand it is the first component React renders. Each arrow in the tree points from a parent component to a child component.


#### Where are the HTML tags in the render tree?
You’ll notice in the above render tree, there is no mention of the HTML tags that each component renders. This is because the render tree is only composed of Reactcomponents.

React, as a UI framework, is platform agnostic. On react.dev, we showcase examples that render to the web, which uses HTML markup as its UI primitives. But a React app could just as likely render to a mobile or desktop platform, which may use different UI primitives likeUIVieworFrameworkElement.

These platform UI primitives are not a part of React. React render trees can provide insight to our React app regardless of what platform your app renders to.

A render tree represents a single render pass of a React application. Withconditional rendering, a parent component may render different children depending on the data passed.

We can update the app to conditionally render either an inspirational quote or color.

```jsx
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
  return (
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
  );
}


```

With conditional rendering, across different renders, the render tree may render different components.

In this example, depending on whatinspiration.typeis, we may render<FancyText>or<Color>. The render tree may be different for each render pass.

Although render trees may differ across render passes, these trees are generally helpful for identifying what thetop-levelandleaf componentsare in a React app. Top-level components are the components nearest to the root component and affect the rendering performance of all the components beneath them and often contain the most complexity. Leaf components are near the bottom of the tree and have no child components and are often frequently re-rendered.

Identifying these categories of components are useful for understanding data flow and performance of your app.


## The Module Dependency Tree
Another relationship in a React app that can be modeled with a tree are an app’s module dependencies. As webreak up our componentsand logic into separate files, we createJS moduleswhere we may export components, functions, or constants.

Each node in a module dependency tree is a module and each branch represents animportstatement in that module.

If we take the previous Inspirations app, we can build a module dependency tree, or dependency tree for short.

The module dependency tree for the Inspirations app.

The root node of the tree is the root module, also known as the entrypoint file. It often is the module that contains the root component.

Comparing to the render tree of the same app, there are similar structures but some notable differences:

- The nodes that make-up the tree represent modules, not components.
- Non-component modules, likeinspirations.js, are also represented in this tree. The render tree only encapsulates components.
- Copyright.jsappears underApp.jsbut in the render tree,Copyright, the component, appears as a child ofInspirationGenerator. This is becauseInspirationGeneratoraccepts JSX aschildren props, so it rendersCopyrightas a child component but does not import the module.
Dependency trees are useful to determine what modules are necessary to run your React app. When building a React app for production, there is typically a build step that will bundle all the necessary JavaScript to ship to the client. The tool responsible for this is called abundler, and bundlers will use the dependency tree to determine what modules should be included.

As your app grows, often the bundle size does too. Large bundle sizes are expensive for a client to download and run. Large bundle sizes can delay the time for your UI to get drawn. Getting a sense of your app’s dependency tree may help with debugging these issues.


## Recap
- Trees are a common way to represent the relationship between entities. They are often used to model UI.
- Render trees represent the nested relationship between React components across a single render.
- With conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.
- Render trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.
- Dependency trees represent the module dependencies in a React app.
- Dependency trees are used by build tools to bundle the necessary code to ship an app.
- Dependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled.

--------------------------------------------------------------------------------


# Adding Interactivity
Source: https://react.dev/learn/adding-interactivity

Some things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is calledstate.You can add state to any component, and update it as needed. In this chapter, you’ll learn how to write components that handle interactions, update their state, and display different output over time.


### In this chapter
- How to handle user-initiated events
- How to make components “remember” information with state
- How React updates the UI in two phases
- Why state doesn’t update right after you change it
- How to queue multiple state updates
- How to update an object in state
- How to update an array in state

## Responding to events
React lets you addevent handlersto your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on.

Built-in components like<button>only support built-in browser events likeonClick. However, you can also create your own components, and give their event handler props any application-specific names that you like.

```jsx
export default function App() {
  return (
    <Toolbar
      onPlayMovie={() => alert('Playing!')}
      onUploadImage={() => alert('Uploading!')}
    />
  );
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>
        Play Movie
      </Button>
      <Button onClick={onUploadImage}>
        Upload Image
      </Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}


```


## Ready to learn this topic?
ReadResponding to Eventsto learn how to add event handlers.


## State: a component’s memory
Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” puts a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is calledstate.

You can add state to a component with auseStateHook.Hooksare special functions that let your components use React features (state is one of those features). TheuseStateHook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it.

```jsx
const [index, setIndex] = useState(0);const [showMore, setShowMore] = useState(false);
```

Here is how an image gallery uses and updates state on click:

```jsx
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);
  const hasNext = index < sculptureList.length - 1;

  function handleNextClick() {
    if (hasNext) {
      setIndex(index + 1);
    } else {
      setIndex(0);
    }
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img
        src={sculpture.url}
        alt={sculpture.alt}
      />
    </>
  );
}


```


## Ready to learn this topic?
ReadState: A Component’s Memoryto learn how to remember a value and update it on interaction.


## Render and commit
Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.

Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:

- Triggeringa render (delivering the diner’s order to the kitchen)
- Renderingthe component (preparing the order in the kitchen)
- Committingto the DOM (placing the order on the table)
- Trigger
- Render
- Commit
Illustrated byRachel Lee Nabors


## Ready to learn this topic?
ReadRender and Committo learn the lifecycle of a UI update.


## State as a snapshot
Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first!

```jsx
console.log(count);  // 0setCount(count + 1); // Request a re-render with 1console.log(count);  // Still 0!
```

This behavior helps you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press “Send” first andthenchange the recipient to Bob. Whose name will appear in thealertfive seconds later?

```jsx
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select
          value={to}
          onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}


```


## Ready to learn this topic?
ReadState as a Snapshotto learn why state appears “fixed” and unchanging inside the event handlers.


## Queueing a series of state updates
This component is buggy: clicking “+3” increments the score only once.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [score, setScore] = useState(0);

  function increment() {
    setScore(score + 1);
  }

  return (
    <>
      <button onClick={() => increment()}>+1</button>
      <button onClick={() => {
        increment();
        increment();
        increment();
      }}>+3</button>
      <h1>Score: {score}</h1>
    </>
  )
}


```

State as a Snapshotexplains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. Soscorecontinues to be0right after you callsetScore(score + 1).

```jsx
console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0setScore(score + 1); // setScore(0 + 1);console.log(score);  // 0
```

You can fix this by passing anupdater functionwhen setting state. Notice how replacingsetScore(score + 1)withsetScore(s => s + 1)fixes the “+3” button. This lets you queue multiple state updates.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [score, setScore] = useState(0);

  function increment() {
    setScore(s => s + 1);
  }

  return (
    <>
      <button onClick={() => increment()}>+1</button>
      <button onClick={() => {
        increment();
        increment();
        increment();
      }}>+3</button>
      <h1>Score: {score}</h1>
    </>
  )
}


```


## Ready to learn this topic?
ReadQueueing a Series of State Updatesto learn how to queue a sequence of state updates.


## Updating objects in state
State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy.

Usually, you will use the...spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this:

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value
      }
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value
      }
    });
  }

  return (
    <>
      <label>
        Name:
        <input
          value={person.name}
          onChange={handleNameChange}
        />
      </label>
      <label>
        Title:
        <input
          value={person.artwork.title}
          onChange={handleTitleChange}
        />
      </label>
      <label>
        City:
        <input
          value={person.artwork.city}
          onChange={handleCityChange}
        />
      </label>
      <label>
        Image:
        <input
          value={person.artwork.image}
          onChange={handleImageChange}
        />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img
        src={person.artwork.image}
        alt={person.artwork.title}
      />
    </>
  );
}


```

If copying objects in code gets tedious, you can use a library likeImmerto reduce repetitive code:

```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```


## Ready to learn this topic?
ReadUpdating Objects in Stateto learn how to update objects correctly.


## Updating arrays in state
Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array:

```jsx
import { useState } from 'react';

const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [list, setList] = useState(
    initialList
  );

  function handleToggle(artworkId, nextSeen) {
    setList(list.map(artwork => {
      if (artwork.id === artworkId) {
        return { ...artwork, seen: nextSeen };
      } else {
        return artwork;
      }
    }));
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={list}
        onToggle={handleToggle} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}


```

If copying arrays in code gets tedious, you can use a library likeImmerto reduce repetitive code:

```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```


## Ready to learn this topic?
ReadUpdating Arrays in Stateto learn how to update arrays correctly.


## What’s next?
Head over toResponding to Eventsto start reading this chapter page by page!

Or, if you’re already familiar with these topics, why not read aboutManaging State?


--------------------------------------------------------------------------------


# Responding to Events
Source: https://react.dev/learn/responding-to-events

React lets you addevent handlersto your JSX. Event handlers are your own functions that will be triggered in response to interactions like clicking, hovering, focusing form inputs, and so on.


### You will learn
- Different ways to write an event handler
- How to pass event handling logic from a parent component
- How events propagate and how to stop them

## Adding event handlers
To add an event handler, you will first define a function and thenpass it as a propto the appropriate JSX tag. For example, here is a button that doesn’t do anything yet:

```jsx
export default function Button() {
  return (
    <button>
      I don't do anything
    </button>
  );
}


```

You can make it show a message when a user clicks by following these three steps:

- Declare a function calledhandleClickinsideyourButtoncomponent.
- Implement the logic inside that function (usealertto show the message).
- AddonClick={handleClick}to the<button>JSX.
```jsx
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}


```

You defined thehandleClickfunction and thenpassed it as a propto<button>.handleClickis anevent handler.Event handler functions:

- Are usually definedinsideyour components.
- Have names that start withhandle, followed by the name of the event.
By convention, it is common to name event handlers ashandlefollowed by the event name. You’ll often seeonClick={handleClick},onMouseEnter={handleMouseEnter}, and so on.

Alternatively, you can define an event handler inline in the JSX:

```jsx
<button onClick={function handleClick() {  alert('You clicked me!');}}>
```

Or, more concisely, using an arrow function:

```jsx
<button onClick={() => {  alert('You clicked me!');}}>
```

All of these styles are equivalent. Inline event handlers are convenient for short functions.


### Pitfall
Functions passed to event handlers must be passed, not called. For example:

The difference is subtle. In the first example, thehandleClickfunction is passed as anonClickevent handler. This tells React to remember it and only call your function when the user clicks the button.

In the second example, the()at the end ofhandleClick()fires the functionimmediatelyduringrendering, without any clicks. This is because JavaScript inside theJSX{and}executes right away.

When you write code inline, the same pitfall presents itself in a different way:

Passing inline code like this won’t fire on click—it fires every time the component renders:

```jsx
// This alert fires when the component renders, not when clicked!<button onClick={alert('You clicked me!')}>
```

If you want to define your event handler inline, wrap it in an anonymous function like so:

```jsx
<button onClick={() => alert('You clicked me!')}>
```

Rather than executing the code inside with every render, this creates a function to be called later.

In both cases, what you want to pass is a function:

- <button onClick={handleClick}>passes thehandleClickfunction.
- <button onClick={() => alert('...')}>passes the() => alert('...')function.
Read more about arrow functions.


### Reading props in event handlers
Because event handlers are declared inside of a component, they have access to the component’s props. Here is a button that, when clicked, shows an alert with itsmessageprop:

```jsx
function AlertButton({ message, children }) {
  return (
    <button onClick={() => alert(message)}>
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">
        Play Movie
      </AlertButton>
      <AlertButton message="Uploading!">
        Upload Image
      </AlertButton>
    </div>
  );
}


```

This lets these two buttons show different messages. Try changing the messages passed to them.


### Passing event handlers as props
Often you’ll want the parent component to specify a child’s event handler. Consider buttons: depending on where you’re using aButtoncomponent, you might want to execute a different function—perhaps one plays a movie and another uploads an image.

To do this, pass a prop the component receives from its parent as the event handler like so:

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return (
    <Button onClick={handlePlayClick}>
      Play "{movieName}"
    </Button>
  );
}

function UploadButton() {
  return (
    <Button onClick={() => alert('Uploading!')}>
      Upload Image
    </Button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}


```

Here, theToolbarcomponent renders aPlayButtonand anUploadButton:

- PlayButtonpasseshandlePlayClickas theonClickprop to theButtoninside.
- UploadButtonpasses() => alert('Uploading!')as theonClickprop to theButtoninside.
Finally, yourButtoncomponent accepts a prop calledonClick. It passes that prop directly to the built-in browser<button>withonClick={onClick}. This tells React to call the passed function on click.

If you use adesign system, it’s common for components like buttons to contain styling but not specify behavior. Instead, components likePlayButtonandUploadButtonwill pass event handlers down.


### Naming event handler props
Built-in components like<button>and<div>only supportbrowser event nameslikeonClick. However, when you’re building your own components, you can name their event handler props any way that you like.

By convention, event handler props should start withon, followed by a capital letter.

For example, theButtoncomponent’sonClickprop could have been calledonSmash:

```jsx
function Button({ onSmash, children }) {
  return (
    <button onClick={onSmash}>
      {children}
    </button>
  );
}

export default function App() {
  return (
    <div>
      <Button onSmash={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onSmash={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}


```

In this example,<button onClick={onSmash}>shows that the browser<button>(lowercase) still needs a prop calledonClick, but the prop name received by your customButtoncomponent is up to you!

When your component supports multiple interactions, you might name event handler props for app-specific concepts. For example, thisToolbarcomponent receivesonPlayMovieandonUploadImageevent handlers:

```jsx
export default function App() {
  return (
    <Toolbar
      onPlayMovie={() => alert('Playing!')}
      onUploadImage={() => alert('Uploading!')}
    />
  );
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>
        Play Movie
      </Button>
      <Button onClick={onUploadImage}>
        Upload Image
      </Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}


```

Notice how theAppcomponent does not need to knowwhatToolbarwill do withonPlayMovieoronUploadImage. That’s an implementation detail of theToolbar. Here,Toolbarpasses them down asonClickhandlers to itsButtons, but it could later also trigger them on a keyboard shortcut. Naming props after app-specific interactions likeonPlayMoviegives you the flexibility to change how they’re used later.


### Note
Make sure that you use the appropriate HTML tags for your event handlers. For example, to handle clicks, use<button onClick={handleClick}>instead of<div onClick={handleClick}>. Using a real browser<button>enables built-in browser behaviors like keyboard navigation. If you don’t like the default browser styling of a button and want to make it look more like a link or a different UI element, you can achieve it with CSS.Learn more about writing accessible markup.


## Event propagation
Event handlers will also catch events from any children your component might have. We say that an event “bubbles” or “propagates” up the tree: it starts with where the event happened, and then goes up the tree.

This<div>contains two buttons. Both the<div>andeach button have their ownonClickhandlers. Which handlers do you think will fire when you click a button?

```jsx
export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <button onClick={() => alert('Playing!')}>
        Play Movie
      </button>
      <button onClick={() => alert('Uploading!')}>
        Upload Image
      </button>
    </div>
  );
}


```

If you click on either button, itsonClickwill run first, followed by the parent<div>’sonClick. So two messages will appear. If you click the toolbar itself, only the parent<div>’sonClickwill run.


### Pitfall
All events propagate in React exceptonScroll, which only works on the JSX tag you attach it to.


### Stopping propagation
Event handlers receive anevent objectas their only argument. By convention, it’s usually callede, which stands for “event”. You can use this object to read information about the event.

That event object also lets you stop the propagation. If you want to prevent an event from reaching parent components, you need to calle.stopPropagation()like thisButtoncomponent does:

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <Button onClick={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onClick={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}


```

When you click on a button:

- React calls theonClickhandler passed to<button>.
- That handler, defined inButton, does the following:Callse.stopPropagation(), preventing the event from bubbling further.Calls theonClickfunction, which is a prop passed from theToolbarcomponent.
- Callse.stopPropagation(), preventing the event from bubbling further.
- Calls theonClickfunction, which is a prop passed from theToolbarcomponent.
- That function, defined in theToolbarcomponent, displays the button’s own alert.
- Since the propagation was stopped, the parent<div>’sonClickhandler doesnotrun.
As a result ofe.stopPropagation(), clicking on the buttons now only shows a single alert (from the<button>) rather than the two of them (from the<button>and the parent toolbar<div>). Clicking a button is not the same thing as clicking the surrounding toolbar, so stopping the propagation makes sense for this UI.


#### Capture phase events
In rare cases, you might need to catch all events on child elements,even if they stopped propagation. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by addingCaptureat the end of the event name:

```jsx
<div onClickCapture={() => { /* this runs first */ }}>  <button onClick={e => e.stopPropagation()} />  <button onClick={e => e.stopPropagation()} /></div>
```

Each event propagates in three phases:

- It travels down, calling allonClickCapturehandlers.
- It runs the clicked element’sonClickhandler.
- It travels upwards, calling allonClickhandlers.
Capture events are useful for code like routers or analytics, but you probably won’t use them in app code.


### Passing handlers as alternative to propagation
Notice how this click handler runs a line of codeand thencalls theonClickprop passed by the parent:

```jsx
function Button({ onClick, children }) {  return (    <button onClick={e => {      e.stopPropagation();      onClick();    }}>      {children}    </button>  );}
```

You could add more code to this handler before calling the parentonClickevent handler, too. This pattern provides analternativeto propagation. It lets the child component handle the event, while also letting the parent component specify some additional behavior. Unlike propagation, it’s not automatic. But the benefit of this pattern is that you can clearly follow the whole chain of code that executes as a result of some event.

If you rely on propagation and it’s difficult to trace which handlers execute and why, try this approach instead.


### Preventing default behavior
Some browser events have default behavior associated with them. For example, a<form>submit event, which happens when a button inside of it is clicked, will reload the whole page by default:

```jsx
export default function Signup() {
  return (
    <form onSubmit={() => alert('Submitting!')}>
      <input />
      <button>Send</button>
    </form>
  );
}


```

You can calle.preventDefault()on the event object to stop this from happening:

```jsx
export default function Signup() {
  return (
    <form onSubmit={e => {
      e.preventDefault();
      alert('Submitting!');
    }}>
      <input />
      <button>Send</button>
    </form>
  );
}


```

Don’t confusee.stopPropagation()ande.preventDefault(). They are both useful, but are unrelated:

- e.stopPropagation()stops the event handlers attached to the tags above from firing.
- e.preventDefault()prevents the default browser behavior for the few events that have it.

## Can event handlers have side effects?
Absolutely! Event handlers are the best place for side effects.

Unlike rendering functions, event handlers don’t need to bepure, so it’s a great place tochangesomething—for example, change an input’s value in response to typing, or change a list in response to a button press. However, in order to change some information, you first need some way to store it. In React, this is done by usingstate, a component’s memory.You will learn all about it on the next page.


## Recap
- You can handle events by passing a function as a prop to an element like<button>.
- Event handlers must be passed,not called!onClick={handleClick}, notonClick={handleClick()}.
- You can define an event handler function separately or inline.
- Event handlers are defined inside a component, so they can access props.
- You can declare an event handler in a parent and pass it as a prop to a child.
- You can define your own event handler props with application-specific names.
- Events propagate upwards. Calle.stopPropagation()on the first argument to prevent that.
- Events may have unwanted default browser behavior. Calle.preventDefault()to prevent that.
- Explicitly calling an event handler prop from a child handler is a good alternative to propagation.

## Try out some challenges

#### Challenge1of2:Fix an event handler
Clicking this button is supposed to switch the page background between white and black. However, nothing happens when you click it. Fix the problem. (Don’t worry about the logic insidehandleClick—that part is fine.)

```jsx
export default function LightSwitch() {
  function handleClick() {
    let bodyStyle = document.body.style;
    if (bodyStyle.backgroundColor === 'black') {
      bodyStyle.backgroundColor = 'white';
    } else {
      bodyStyle.backgroundColor = 'black';
    }
  }

  return (
    <button onClick={handleClick()}>
      Toggle the lights
    </button>
  );
}


```


--------------------------------------------------------------------------------


# State: A Component's Memory
Source: https://react.dev/learn/state-a-components-memory

Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” should put a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is calledstate.


### You will learn
- How to add a state variable with theuseStateHook
- What pair of values theuseStateHook returns
- How to add more than one state variable
- Why state is called local

## When a regular variable isn’t enough
Here’s a component that renders a sculpture image. Clicking the “Next” button should show the next sculpture by changing theindexto1, then2, and so on. However, thiswon’t work(you can try it!):

```jsx
import { sculptureList } from './data.js';

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
      <p>
        {sculpture.description}
      </p>
    </>
  );
}


```

ThehandleClickevent handler is updating a local variable,index. But two things prevent that change from being visible:

- Local variables don’t persist between renders.When React renders this component a second time, it renders it from scratch—it doesn’t consider any changes to the local variables.
- Changes to local variables won’t trigger renders.React doesn’t realize it needs to render the component again with the new data.
To update a component with new data, two things need to happen:

- Retainthe data between renders.
- TriggerReact to render the component with new data (re-rendering).
TheuseStateHook provides those two things:

- Astate variableto retain the data between renders.
- Astate setter functionto update the variable and trigger React to render the component again.

## Adding a state variable
To add a state variable, importuseStatefrom React at the top of the file:

```jsx
import { useState } from 'react';
```

Then, replace this line:

```jsx
let index = 0;
```

with

```jsx
const [index, setIndex] = useState(0);
```

indexis a state variable andsetIndexis the setter function.

The[and]syntax here is calledarray destructuringand it lets you read values from an array. The array returned byuseStatealways has exactly two items.

This is how they work together inhandleClick:

```jsx
function handleClick() {  setIndex(index + 1);}
```

Now clicking the “Next” button switches the current sculpture:

```jsx
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
      <p>
        {sculpture.description}
      </p>
    </>
  );
}


```


### Meet your first Hook
In React,useState, as well as any other function starting with “use”, is called a Hook.

Hooksare special functions that are only available while React isrendering(which we’ll get into in more detail on the next page). They let you “hook into” different React features.

State is just one of those features, but you will meet the other Hooks later.


### Pitfall
Hooks—functions starting withuse—can only be called at the top level of your components oryour own Hooks.You can’t call Hooks inside conditions, loops, or other nested functions. Hooks are functions, but it’s helpful to think of them as unconditional declarations about your component’s needs. You “use” React features at the top of your component similar to how you “import” modules at the top of your file.


### Anatomy ofuseState
When you calluseState, you are telling React that you want this component to remember something:

```jsx
const [index, setIndex] = useState(0);
```

In this case, you want React to rememberindex.


### Note
The convention is to name this pair likeconst [something, setSomething]. You could name it anything you like, but conventions make things easier to understand across projects.

The only argument touseStateis theinitial valueof your state variable. In this example, theindex’s initial value is set to0withuseState(0).

Every time your component renders,useStategives you an array containing two values:

- Thestate variable(index) with the value you stored.
- Thestate setter function(setIndex) which can update the state variable and trigger React to render the component again.
Here’s how that happens in action:

```jsx
const [index, setIndex] = useState(0);
```

- Your component renders the first time.Because you passed0touseStateas the initial value forindex, it will return[0, setIndex]. React remembers0is the latest state value.
- You update the state.When a user clicks the button, it callssetIndex(index + 1).indexis0, so it’ssetIndex(1). This tells React to rememberindexis1now and triggers another render.
- Your component’s second render.React still seesuseState(0), but because Reactremembersthat you setindexto1, it returns[1, setIndex]instead.
- And so on!

## Giving a component multiple state variables
You can have as many state variables of as many types as you like in one component. This component has two state variables, a numberindexand a booleanshowMorethat’s toggled when you click “Show details”:

```jsx
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}


```

It is a good idea to have multiple state variables if their state is unrelated, likeindexandshowMorein this example. But if you find that you often change two state variables together, it might be easier to combine them into one. For example, if you have a form with many fields, it’s more convenient to have a single state variable that holds an object than state variable per field. ReadChoosing the State Structurefor more tips.


#### How does React know which state to return?
You might have noticed that theuseStatecall does not receive any information aboutwhichstate variable it refers to. There is no “identifier” that is passed touseState, so how does it know which of the state variables to return? Does it rely on some magic like parsing your functions? The answer is no.

Instead, to enable their concise syntax, Hooksrely on a stable call order on every render of the same component.This works well in practice because if you follow the rule above (“only call Hooks at the top level”), Hooks will always be called in the same order. Additionally, alinter plugincatches most mistakes.

Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to0before rendering. Each time you calluseState, React gives you the next state pair and increments the index. You can read more about this mechanism inReact Hooks: Not Magic, Just Arrays.

This exampledoesn’t use Reactbut it gives you an idea of howuseStateworks internally:

```jsx
let componentHooks = [];
let currentHookIndex = 0;

// How useState works inside React (simplified).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // This is not the first render,
    // so the state pair already exists.
    // Return it and prepare for next Hook call.
    currentHookIndex++;
    return pair;
  }

  // This is the first time we're rendering,
  // so create a state pair and store it.
  pair = [initialState, setState];

  function setState(nextState) {
    // When the user requests a state change,
    // put the new value into the pair.
    pair[0] = nextState;
    updateDOM();
  }

  // Store the pair for future renders
  // and prepare for the next Hook call.
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}

function Gallery() {
  // Each useState() call will get the next pair.
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  // This example doesn't use React, so
  // return an output object instead of JSX.
  return {
    onNextClick: handleNextClick,
    onMoreClick: handleMoreClick,
    header: `${sculpture.name} by ${sculpture.artist}`,
    counter: `${index + 1} of ${sculptureList.length}`,
    more: `${showMore ? 'Hide' : 'Show'} details`,
    description: showMore ? sculpture.description : null,
    imageSrc: sculpture.url,
    imageAlt: sculpture.alt
  };
}

function updateDOM() {
  // Reset the current Hook index
  // before rendering the component.
  currentHookIndex = 0;
  let output = Gallery();

  // Update the DOM to match the output.
  // This is the part React does for you.
  nextButton.onclick = output.onNextClick;
  header.textContent = output.header;
  moreButton.onclick = output.onMoreClick;
  moreButton.textContent = output.more;
  image.src = output.imageSrc;
  image.alt = output.imageAlt;
  if (output.description !== null) {
    description.textContent = output.description;
    description.style.display = '';
  } else {
    description.style.display = 'none';
  }
}

let nextButton = document.getElementById('nextButton');
let header = document.getElementById('header');
let moreButton = document.getElementById('moreButton');
let description = document.getElementById('description');
let image = document.getElementById('image');
let sculptureList = [{
  name: 'Homenaje a la Neurocirugía',
  artist: 'Marta Colvin Andrade',
  description: 'Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.',
  url: 'https://i.imgur.com/Mx7dA2Y.jpg',
  alt: 'A bronze statue of two crossed hands delicately holding a human brain in their fingertips.'  
}, {
  name: 'Floralis Genérica',
  artist: 'Eduardo Catalano',
  description: 'This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.',
  url: 'https://i.imgur.com/ZF6s192m.jpg',
  alt: 'A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.'
}, {
  name: 'Eternal Presence',
  artist: 'John Woodrow Wilson',
  description: 'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as "a symbolic Black presence infused with a sense of universal humanity."',
  url: 'https://i.imgur.com/aTtVpES.jpg',
  alt: 'The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.'
}, {
  name: 'Moai',
  artist: 'Unknown Artist',
  description: 'Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.',
  url: 'https://i.imgur.com/RCwLEoQm.jpg',
  alt: 'Three monumental stone busts with the heads that are disproportionately large with somber faces.'
}, {
  name: 'Blue Nana',
  artist: 'Niki de Saint Phalle',
  description: 'The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.',
  url: 'https://i.imgur.com/Sd1AgUOm.jpg',
  alt: 'A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.'
}, {
  name: 'Ultimate Form',
  artist: 'Barbara Hepworth',
  description: 'This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.',
  url: 'https://i.imgur.com/2heNQDcm.jpg',
  alt: 'A tall sculpture made of three elements stacked on each other reminding of a human figure.'
}, {
  name: 'Cavaliere',
  artist: 'Lamidi Olonade Fakeye',
  description: "Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.",
  url: 'https://i.imgur.com/wIdGuZwm.png',
  alt: 'An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.'
}, {
  name: 'Big Bellies',
  artist: 'Alina Szapocznikow',
  description: "Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.",
  url: 'https://i.imgur.com/AlHTAdDm.jpg',
  alt: 'The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.'
}, {
  name: 'Terracotta Army',
  artist: 'Unknown Artist',
  description: 'The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.',
  url: 'https://i.imgur.com/HMFmH6m.jpg',
  alt: '12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.'
}, {
  name: 'Lunar Landscape',
  artist: 'Louise Nevelson',
  description: 'Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism’s geometric abstraction of space and form.',
  url: 'https://i.imgur.com/rN7hY6om.jpg',
  alt: 'A black matte sculpture where the individual elements are initially indistinguishable.'
}, {
  name: 'Aureole',
  artist: 'Ranjani Shettar',
  description: 'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a "fine synthesis of unlikely materials."',
  url: 'https://i.imgur.com/okTpbHhm.jpg',
  alt: 'A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.'
}, {
  name: 'Hippos',
  artist: 'Taipei Zoo',
  description: 'The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.',
  url: 'https://i.imgur.com/6o5Vuyu.jpg',
  alt: 'A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.'
}];

// Make UI match the initial state.
updateDOM();


```

You don’t have to understand it to use React, but you might find this a helpful mental model.


## State is isolated and private
State is local to a component instance on the screen. In other words,if you render the same component twice, each copy will have completely isolated state!Changing one of them will not affect the other.

In this example, theGallerycomponent from earlier is rendered twice with no changes to its logic. Try clicking the buttons inside each of the galleries. Notice that their state is independent:

```jsx
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}


```

This is what makes state different from regular variables that you might declare at the top of your module. State is not tied to a particular function call or a place in the code, but it’s “local” to the specific place on the screen. You rendered two<Gallery />components, so their state is stored separately.

Also notice how thePagecomponent doesn’t “know” anything about theGallerystate or even whether it has any. Unlike props,state is fully private to the component declaring it.The parent component can’t change it. This lets you add state to any component or remove it without impacting the rest of the components.

What if you wanted both galleries to keep their states in sync? The right way to do it in React is toremovestate from child components and add it to their closest shared parent. The next few pages will focus on organizing state of a single component, but we will return to this topic inSharing State Between Components.


## Recap
- Use a state variable when a component needs to “remember” some information between renders.
- State variables are declared by calling theuseStateHook.
- Hooks are special functions that start withuse. They let you “hook into” React features like state.
- Hooks might remind you of imports: they need to be called unconditionally. Calling Hooks, includinguseState, is only valid at the top level of a component or another Hook.
- TheuseStateHook returns a pair of values: the current state and the function to update it.
- You can have more than one state variable. Internally, React matches them up by their order.
- State is private to the component. If you render it in two places, each copy gets its own state.

## Try out some challenges

#### Challenge1of4:Complete the gallery
When you press “Next” on the last sculpture, the code crashes. Fix the logic to prevent the crash. You may do this by adding extra logic to event handler or by disabling the button when the action is not possible.

After fixing the crash, add a “Previous” button that shows the previous sculpture. It shouldn’t crash on the first sculpture.

```jsx
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}


```


--------------------------------------------------------------------------------


# Render and Commit
Source: https://react.dev/learn/render-and-commit

Before your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.


### You will learn
- What rendering means in React
- When and why React renders a component
- The steps involved in displaying a component on screen
- Why rendering does not always produce a DOM update
Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:

- Triggeringa render (delivering the guest’s order to the kitchen)
- Renderingthe component (preparing the order in the kitchen)
- Committingto the DOM (placing the order on the table)
- Trigger
- Render
- Commit
Illustrated byRachel Lee Nabors


## Step 1: Trigger a render
There are two reasons for a component to render:

- It’s the component’sinitial render.
- The component’s (or one of its ancestors’)state has been updated.

### Initial render
When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it’s done by callingcreateRootwith the target DOM node, and then calling itsrendermethod with your component:

```jsx
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);


```

Try commenting out theroot.render()call and see the component disappear!


### Re-renders when state updates
Once the component has been initially rendered, you can trigger further renders by updating its state with thesetfunction.Updating your component’s state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)

- State update...
- ...triggers...
- ...render!
Illustrated byRachel Lee Nabors


## Step 2: React renders your components
After you trigger a render, React calls your components to figure out what to display on screen.“Rendering” is React calling your components.

- On initial render,React will call the root component.
- For subsequent renders,React will call the function component whose state update triggered the render.
This process is recursive: if the updated component returns some other component, React will renderthatcomponent next, and if that component also returns something, it will renderthatcomponent next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen.

In the following example, React will callGallery()andImage()several times:

```jsx
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}


```

- During the initial render,React willcreate the DOM nodesfor<section>,<h1>, and three<img>tags.
- During a re-render,React will calculate which of their properties, if any, have changed since the previous render. It won’t do anything with that information until the next step, the commit phase.

### Pitfall
Rendering must always be apure calculation:

- Same inputs, same output.Given the same inputs, a component should always return the same JSX. (When someone orders a salad with tomatoes, they should not receive a salad with onions!)
- It minds its own business.It should not change any objects or variables that existed before rendering. (One order should not change anyone else’s order.)
Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes caused by impure functions.


#### Optimizing performance
The default behavior of rendering all components nested within the updated component is not optimal for performance if the updated component is very high in the tree. If you run into a performance issue, there are several opt-in ways to solve it described in thePerformancesection.Don’t optimize prematurely!


## Step 3: React commits changes to the DOM
After rendering (calling) your components, React will modify the DOM.

- For the initial render,React will use theappendChild()DOM API to put all the DOM nodes it has created on screen.
- For re-renders,React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.
React only changes the DOM nodes if there’s a difference between renders.For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the<input>, updating itsvalue, but the text doesn’t disappear when the component re-renders:

```jsx
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}


```

This works because during this last step, React only updates the content of<h1>with the newtime. It sees that the<input>appears in the JSX in the same place as last time, so React doesn’t touch the<input>—or itsvalue!


## Epilogue: Browser paint
After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion throughout the docs.

Illustrated byRachel Lee Nabors


## Recap
- Any screen update in a React app happens in three steps:TriggerRenderCommit
- Trigger
- Render
- Commit
- You can use Strict Mode to find mistakes in your components
- React does not touch the DOM if the rendering result is the same as last time

--------------------------------------------------------------------------------


# State as a Snapshot
Source: https://react.dev/learn/state-as-a-snapshot

State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.


### You will learn
- How setting state triggers re-renders
- When and how state updates
- Why state does not update immediately after you set it
- How event handlers access a “snapshot” of the state

## Setting state triggers renders
You might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw thatsetting state requests a re-renderfrom React. This means that for an interface to react to the event, you need toupdate the state.

In this example, when you press “send”,setIsSent(true)tells React to re-render the UI:

```jsx
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>
  }
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      setIsSent(true);
      sendMessage(message);
    }}>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}


```

Here’s what happens when you click the button:

- TheonSubmitevent handler executes.
- setIsSent(true)setsisSenttotrueand queues a new render.
- React re-renders the component according to the newisSentvalue.
Let’s take a closer look at the relationship between state and rendering.


## Rendering takes a snapshot in time
“Rendering”means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculatedusing its state at the time of the render.

Unlike a photograph or a movie frame, the UI “snapshot” you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.

When React re-renders a component:

- React calls your function again.
- Your function returns a new JSX snapshot.
- React then updates the screen to match the snapshot your function returned.
- React executing the function
- Calculating the snapshot
- Updating the DOM tree
Illustrated byRachel Lee Nabors

As a component’s memory, state is not like a regular variable that disappears after your function returns. State actually “lives” in React itself—as if on a shelf!—outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculatedusing the state values from that render!

- You tell React to update the state
- React updates the state value
- React passes a snapshot of the state value into the component
Illustrated byRachel Lee Nabors

Here’s a little experiment to show you how this works. In this example, you might expect that clicking the “+3” button would increment the counter three times because it callssetNumber(number + 1)three times.

See what happens when you click the “+3” button:

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}


```

Notice thatnumberonly increments once per click!

Setting state only changes it for thenextrender.During the first render,numberwas0. This is why, inthat render’sonClickhandler, the value ofnumberis still0even aftersetNumber(number + 1)was called:

```jsx
<button onClick={() => {  setNumber(number + 1);  setNumber(number + 1);  setNumber(number + 1);}}>+3</button>
```

Here is what this button’s click handler tells React to do:

- setNumber(number + 1):numberis0sosetNumber(0 + 1).React prepares to changenumberto1on the next render.
- React prepares to changenumberto1on the next render.
- setNumber(number + 1):numberis0sosetNumber(0 + 1).React prepares to changenumberto1on the next render.
- React prepares to changenumberto1on the next render.
- setNumber(number + 1):numberis0sosetNumber(0 + 1).React prepares to changenumberto1on the next render.
- React prepares to changenumberto1on the next render.
Even though you calledsetNumber(number + 1)three times, inthis render’sevent handlernumberis always0, so you set the state to1three times. This is why, after your event handler finishes, React re-renders the component withnumberequal to1rather than3.

You can also visualize this by mentally substituting state variables with their values in your code. Since thenumberstate variable is0forthis render, its event handler looks like this:

```jsx
<button onClick={() => {  setNumber(0 + 1);  setNumber(0 + 1);  setNumber(0 + 1);}}>+3</button>
```

For the next render,numberis1, sothat render’sclick handler looks like this:

```jsx
<button onClick={() => {  setNumber(1 + 1);  setNumber(1 + 1);  setNumber(1 + 1);}}>+3</button>
```

This is why clicking the button again will set the counter to2, then to3on the next click, and so on.


## State over time
Well, that was fun. Try to guess what clicking this button will alert:

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        alert(number);
      }}>+5</button>
    </>
  )
}


```

If you use the substitution method from before, you can guess that the alert shows “0”:

```jsx
setNumber(0 + 5);alert(0);
```

But what if you put a timer on the alert, so it only firesafterthe component re-rendered? Would it say “0” or “5”? Have a guess!

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setTimeout(() => {
          alert(number);
        }, 3000);
      }}>+5</button>
    </>
  )
}


```

Surprised? If you use the substitution method, you can see the “snapshot” of the state passed to the alert.

```jsx
setNumber(0 + 5);setTimeout(() => {  alert(0);}, 3000);
```

The state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!

A state variable’s value never changes within a render,even if its event handler’s code is asynchronous. Insidethat render’sonClick, the value ofnumbercontinues to be0even aftersetNumber(number + 5)was called. Its value was “fixed” when React “took the snapshot” of the UI by calling your component.

Here is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:

- You press the “Send” button, sending “Hello” to Alice.
- Before the five-second delay ends, you change the value of the “To” field to “Bob”.
What do you expect thealertto display? Would it display, “You said Hello to Alice”? Or would it display, “You said Hello to Bob”? Make a guess based on what you know, and then try it:

```jsx
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select
          value={to}
          onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}


```

React keeps the state values “fixed” within one render’s event handlers.You don’t need to worry whether the state has changed while the code is running.

But what if you wanted to read the latest state before a re-render? You’ll want to use astate updater function, covered on the next page!


## Recap
- Setting state requests a new render.
- React stores state outside of your component, as if on a shelf.
- When you calluseState, React gives you a snapshot of the statefor that render.
- Variables and event handlers don’t “survive” re-renders. Every render has its own event handlers.
- Every render (and functions inside it) will always “see” the snapshot of the state that React gave tothatrender.
- You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.
- Event handlers created in the past have the state values from the render in which they were created.

## Try out some challenges

#### Challenge1of1:Implement a traffic light
Here is a crosswalk light component that toggles when the button is pressed:

```jsx
import { useState } from 'react';

export default function TrafficLight() {
  const [walk, setWalk] = useState(true);

  function handleClick() {
    setWalk(!walk);
  }

  return (
    <>
      <button onClick={handleClick}>
        Change to {walk ? 'Stop' : 'Walk'}
      </button>
      <h1 style={{
        color: walk ? 'darkgreen' : 'darkred'
      }}>
        {walk ? 'Walk' : 'Stop'}
      </h1>
    </>
  );
}


```

Add analertto the click handler. When the light is green and says “Walk”, clicking the button should say “Stop is next”. When the light is red and says “Stop”, clicking the button should say “Walk is next”.

Does it make a difference whether you put thealertbefore or after thesetWalkcall?


--------------------------------------------------------------------------------


# Queueing a Series of State Updates
Source: https://react.dev/learn/queueing-a-series-of-state-updates

Setting a state variable will queue another render. But sometimes you might want to perform multiple operations on the value before queueing the next render. To do this, it helps to understand how React batches state updates.


### You will learn
- What “batching” is and how React uses it to process multiple state updates
- How to apply several updates to the same state variable in a row

## React batches state updates
You might expect that clicking the “+3” button will increment the counter three times because it callssetNumber(number + 1)three times:

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}


```

However, as you might recall from the previous section,each render’s state values are fixed, so the value ofnumberinside the first render’s event handler is always0, no matter how many times you callsetNumber(1):

```jsx
setNumber(0 + 1);setNumber(0 + 1);setNumber(0 + 1);
```

But there is one other factor at play here.React waits untilallcode in the event handlers has run before processing your state updates.This is why the re-render only happensafterall thesesetNumber()calls.

This might remind you of a waiter taking an order at the restaurant. A waiter doesn’t run to the kitchen at the mention of your first dish! Instead, they let you finish your order, let you make changes to it, and even take orders from other people at the table.

Illustrated byRachel Lee Nabors

This lets you update multiple state variables—even from multiple components—without triggering too manyre-renders.But this also means that the UI won’t be updated untilafteryour event handler, and any code in it, completes. This behavior, also known asbatching,makes your React app run much faster. It also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated.

React does not batch acrossmultipleintentional events like clicks—each click is handled separately. Rest assured that React only does batching when it’s generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again.


## Updating the same state multiple times before the next render
It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing thenext state valuelikesetNumber(number + 1), you can pass afunctionthat calculates the next state based on the previous one in the queue, likesetNumber(n => n + 1). It is a way to tell React to “do something with the state value” instead of just replacing it.

Try incrementing the counter now:

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(n => n + 1);
        setNumber(n => n + 1);
        setNumber(n => n + 1);
      }}>+3</button>
    </>
  )
}


```

Here,n => n + 1is called anupdater function.When you pass it to a state setter:

- React queues this function to be processed after all the other code in the event handler has run.
- During the next render, React goes through the queue and gives you the final updated state.
```jsx
setNumber(n => n + 1);setNumber(n => n + 1);setNumber(n => n + 1);
```

Here’s how React works through these lines of code while executing the event handler:

- setNumber(n => n + 1):n => n + 1is a function. React adds it to a queue.
- setNumber(n => n + 1):n => n + 1is a function. React adds it to a queue.
- setNumber(n => n + 1):n => n + 1is a function. React adds it to a queue.
When you calluseStateduring the next render, React goes through the queue. The previousnumberstate was0, so that’s what React passes to the first updater function as thenargument. Then React takes the return value of your previous updater function and passes it to the next updater asn, and so on:

React stores3as the final result and returns it fromuseState.

This is why clicking “+3” in the above example correctly increments the value by 3.


### What happens if you update state after replacing it
What about this event handler? What do you thinknumberwill be in the next render?

```jsx
<button onClick={() => {  setNumber(number + 5);  setNumber(n => n + 1);}}>
```

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
      }}>Increase the number</button>
    </>
  )
}


```

Here’s what this event handler tells React to do:

- setNumber(number + 5):numberis0, sosetNumber(0 + 5). React adds“replace with5”to its queue.
- setNumber(n => n + 1):n => n + 1is an updater function. React addsthat functionto its queue.
During the next render, React goes through the state queue:

React stores6as the final result and returns it fromuseState.


### Note
You may have noticed thatsetState(5)actually works likesetState(n => 5), butnis unused!


### What happens if you replace state after updating it
Let’s try one more example. What do you thinknumberwill be in the next render?

```jsx
<button onClick={() => {  setNumber(number + 5);  setNumber(n => n + 1);  setNumber(42);}}>
```

```jsx
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
        setNumber(42);
      }}>Increase the number</button>
    </>
  )
}


```

Here’s how React works through these lines of code while executing this event handler:

- setNumber(number + 5):numberis0, sosetNumber(0 + 5). React adds“replace with5”to its queue.
- setNumber(n => n + 1):n => n + 1is an updater function. React addsthat functionto its queue.
- setNumber(42): React adds“replace with42”to its queue.
During the next render, React goes through the state queue:

Then React stores42as the final result and returns it fromuseState.

To summarize, here’s how you can think of what you’re passing to thesetNumberstate setter:

- An updater function(e.g.n => n + 1) gets added to the queue.
- Any other value(e.g. number5) adds “replace with5” to the queue, ignoring what’s already queued.
After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, soupdater functions must bepureand onlyreturnthe result. Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.


### Naming conventions
It’s common to name the updater function argument by the first letters of the corresponding state variable:

```jsx
setEnabled(e => !e);setLastName(ln => ln.reverse());setFriendCount(fc => fc * 2);
```

If you prefer more verbose code, another common convention is to repeat the full state variable name, likesetEnabled(enabled => !enabled), or to use a prefix likesetEnabled(prevEnabled => !prevEnabled).


## Recap
- Setting state does not change the variable in the existing render, but it requests a new render.
- React processes state updates after event handlers have finished running. This is called batching.
- To update some state multiple times in one event, you can usesetNumber(n => n + 1)updater function.

## Try out some challenges

#### Challenge1of2:Fix a request counter
You’re working on an art marketplace app that lets the user submit multiple orders for an art item at the same time. Each time the user presses the “Buy” button, the “Pending” counter should increase by one. After three seconds, the “Pending” counter should decrease, and the “Completed” counter should increase.

However, the “Pending” counter does not behave as intended. When you press “Buy”, it decreases to-1(which should not be possible!). And if you click fast twice, both counters seem to behave unpredictably.

Why does this happen? Fix both counters.

```jsx
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>
        Pending: {pending}
      </h3>
      <h3>
        Completed: {completed}
      </h3>
      <button onClick={handleClick}>
        Buy     
      </button>
    </>
  );
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}


```


--------------------------------------------------------------------------------


# Updating Objects in State
Source: https://react.dev/learn/updating-objects-in-state

State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.


### You will learn
- How to correctly update an object in React state
- How to update a nested object without mutating it
- What immutability is, and how not to break it
- How to make object copying less repetitive with Immer

## What’s a mutation?
You can store any kind of JavaScript value in state.

```jsx
const [x, setX] = useState(0);
```

So far you’ve been working with numbers, strings, and booleans. These kinds of JavaScript values are “immutable”, meaning unchangeable or “read-only”. You can trigger a re-render toreplacea value:

```jsx
setX(5);
```

Thexstate changed from0to5, but thenumber0itselfdid not change. It’s not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.

Now consider an object in state:

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Technically, it is possible to change the contents ofthe object itself.This is called a mutation:

```jsx
position.x = 5;
```

However, although objects in React state are technically mutable, you should treat themas ifthey were immutable—like numbers, booleans, and strings. Instead of mutating them, you should always replace them.


## Treat state as read-only
In other words, you shouldtreat any JavaScript object that you put into state as read-only.

This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But the dot stays in the initial position:

```jsx
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  );
}


```

The problem is with this bit of code.

```jsx
onPointerMove={e => {  position.x = e.clientX;  position.y = e.clientY;}}
```

This code modifies the object assigned topositionfromthe previous render.But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It’s like trying to change the order after you’ve already eaten the meal. While mutating state can work in some cases, we don’t recommend it. You should treat the state value you have access to in a render as read-only.

To actuallytrigger a re-renderin this case,create anewobject and pass it to the state setting function:

```jsx
onPointerMove={e => {  setPosition({    x: e.clientX,    y: e.clientY  });}}
```

WithsetPosition, you’re telling React:

- Replacepositionwith this new object
- And render this component again
Notice how the red dot now follows your pointer when you touch or hover over the preview area:

```jsx
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  );
}


```


#### Local mutation is fine
Code like this is a problem because it modifies anexistingobject in state:

```jsx
position.x = e.clientX;position.y = e.clientY;
```

But code like this isabsolutely finebecause you’re mutating a fresh object you havejust created:

```jsx
const nextPosition = {};nextPosition.x = e.clientX;nextPosition.y = e.clientY;setPosition(nextPosition);
```

In fact, it is completely equivalent to writing this:

```jsx
setPosition({  x: e.clientX,  y: e.clientY});
```

Mutation is only a problem when you changeexistingobjects that are already in state. Mutating an object you’ve just created is okay becauseno other code references it yet.Changing it isn’t going to accidentally impact something that depends on it. This is called a “local mutation”. You can even do local mutationwhile rendering.Very convenient and completely okay!


## Copying objects with the spread syntax
In the previous example, thepositionobject is always created fresh from the current cursor position. But often, you will want to includeexistingdata as a part of the new object you’re creating. For example, you may want to updateonly onefield in a form, but keep the previous values for all other fields.

These input fields don’t work because theonChangehandlers mutate the state:

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}


```

For example, this line mutates the state from a past render:

```jsx
person.firstName = e.target.value;
```

The reliable way to get the behavior you’re looking for is to create a new object and pass it tosetPerson. But here, you want to alsocopy the existing data into itbecause only one of the fields has changed:

```jsx
setPerson({  firstName: e.target.value, // New first name from the input  lastName: person.lastName,  email: person.email});
```

You can use the...object spreadsyntax so that you don’t need to copy every property separately.

```jsx
setPerson({  ...person, // Copy the old fields  firstName: e.target.value // But override this one});
```

Now the form works!

Notice how you didn’t declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient—as long as you update it correctly!

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}


```

Note that the...spread syntax is “shallow”—it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you’ll have to use it more than once.


#### Using a single event handler for multiple fields
You can also use the[and]braces inside your object definition to specify a property with a dynamic name. Here is the same example, but with a single event handler instead of three different ones:

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name="firstName"
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name="lastName"
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input
          name="email"
          value={person.email}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}


```

Here,e.target.namerefers to thenameproperty given to the<input>DOM element.


## Updating a nested object
Consider a nested object structure like this:

```jsx
const [person, setPerson] = useState({  name: 'Niki de Saint Phalle',  artwork: {    title: 'Blue Nana',    city: 'Hamburg',    image: 'https://i.imgur.com/Sd1AgUOm.jpg',  }});
```

If you wanted to updateperson.artwork.city, it’s clear how to do it with mutation:

```jsx
person.artwork.city = 'New Delhi';
```

But in React, you treat state as immutable! In order to changecity, you would first need to produce the newartworkobject (pre-populated with data from the previous one), and then produce the newpersonobject which points at the newartwork:

```jsx
const nextArtwork = { ...person.artwork, city: 'New Delhi' };const nextPerson = { ...person, artwork: nextArtwork };setPerson(nextPerson);
```

Or, written as a single function call:

```jsx
setPerson({  ...person, // Copy other fields  artwork: { // but replace the artwork    ...person.artwork, // with the same one    city: 'New Delhi' // but in New Delhi!  }});
```

This gets a bit wordy, but it works fine for many cases:

```jsx
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value
      }
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value
      }
    });
  }

  return (
    <>
      <label>
        Name:
        <input
          value={person.name}
          onChange={handleNameChange}
        />
      </label>
      <label>
        Title:
        <input
          value={person.artwork.title}
          onChange={handleTitleChange}
        />
      </label>
      <label>
        City:
        <input
          value={person.artwork.city}
          onChange={handleCityChange}
        />
      </label>
      <label>
        Image:
        <input
          value={person.artwork.image}
          onChange={handleImageChange}
        />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img 
        src={person.artwork.image} 
        alt={person.artwork.title}
      />
    </>
  );
}


```


#### Objects are not really nested
An object like this appears “nested” in code:

```jsx
let obj = {  name: 'Niki de Saint Phalle',  artwork: {    title: 'Blue Nana',    city: 'Hamburg',    image: 'https://i.imgur.com/Sd1AgUOm.jpg',  }};
```

However, “nesting” is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a “nested” object. You are really looking at two different objects:

```jsx
let obj1 = {  title: 'Blue Nana',  city: 'Hamburg',  image: 'https://i.imgur.com/Sd1AgUOm.jpg',};let obj2 = {  name: 'Niki de Saint Phalle',  artwork: obj1};
```

Theobj1object is not “inside”obj2. For example,obj3could “point” atobj1too:

```jsx
let obj1 = {  title: 'Blue Nana',  city: 'Hamburg',  image: 'https://i.imgur.com/Sd1AgUOm.jpg',};let obj2 = {  name: 'Niki de Saint Phalle',  artwork: obj1};let obj3 = {  name: 'Copycat',  artwork: obj1};
```

If you were to mutateobj3.artwork.city, it would affect bothobj2.artwork.cityandobj1.city. This is becauseobj3.artwork,obj2.artwork, andobj1are the same object. This is difficult to see when you think of objects as “nested”. Instead, they are separate objects “pointing” at each other with properties.


### Write concise update logic with Immer
If your state is deeply nested, you might want to considerflattening it.But, if you don’t want to change your state structure, you might prefer a shortcut to nested spreads.Immeris a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are “breaking the rules” and mutating an object:

```jsx
updatePerson(draft => {  draft.artwork.city = 'Lagos';});
```

But unlike a regular mutation, it doesn’t overwrite the past state!


#### How does Immer work?
Thedraftprovided by Immer is a special type of object, called aProxy, that “records” what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of thedrafthave been changed, and produces a completely new object that contains your edits.

To try Immer:

- Runnpm install use-immerto add Immer as a dependency
- Then replaceimport { useState } from 'react'withimport { useImmer } from 'use-immer'
Here is the above example converted to Immer:

```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Notice how much more concise the event handlers have become. You can mix and matchuseStateanduseImmerin a single component as much as you like. Immer is a great way to keep the update handlers concise, especially if there’s nesting in your state, and copying objects leads to repetitive code.


#### Why is mutating state not recommended in React?
There are a few reasons:

- Debugging:If you useconsole.logand don’t mutate state, your past logs won’t get clobbered by the more recent state changes. So you can clearly see how state has changed between renders.
- Optimizations:Common Reactoptimization strategiesrely on skipping work if previous props or state are the same as the next ones. If you never mutate state, it is very fast to check whether there were any changes. IfprevObj === obj, you can be sure that nothing could have changed inside of it.
- New Features:The new React features we’re building rely on state beingtreated like a snapshot.If you’re mutating past versions of state, that may prevent you from using the new features.
- Requirement Changes:Some application features, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values, are easier to do when nothing is mutated. This is because you can keep past copies of state in memory, and reuse them when appropriate. If you start with a mutative approach, features like this can be difficult to add later on.
- Simpler Implementation:Because React does not rely on mutation, it does not need to do anything special with your objects. It does not need to hijack their properties, always wrap them into Proxies, or do other work at initialization as many “reactive” solutions do. This is also why React lets you put any object into state—no matter how large—without additional performance or correctness pitfalls.
In practice, you can often “get away” with mutating state in React, but we strongly advise you not to do that so that you can use new React features developed with this approach in mind. Future contributors and perhaps even your future self will thank you!


## Recap
- Treat all state in React as immutable.
- When you store objects in state, mutating them will not trigger renders and will change the state in previous render “snapshots”.
- Instead of mutating an object, create anewversion of it, and trigger a re-render by setting state to it.
- You can use the{...obj, something: 'newValue'}object spread syntax to create copies of objects.
- Spread syntax is shallow: it only copies one level deep.
- To update a nested object, you need to create copies all the way up from the place you’re updating.
- To reduce repetitive copying code, use Immer.

## Try out some challenges

#### Challenge1of3:Fix incorrect state updates
This form has a few bugs. Click the button that increases the score a few times. Notice that it does not increase. Then edit the first name, and notice that the score has suddenly “caught up” with your changes. Finally, edit the last name, and notice that the score has disappeared completely.

Your task is to fix all of these bugs. As you fix them, explain why each of them happens.

```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    player.score++;
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      lastName: e.target.value
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>
        {' '}
        <button onClick={handlePlusClick}>
          +1
        </button>
      </label>
      <label>
        First name:
        <input
          value={player.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={player.lastName}
          onChange={handleLastNameChange}
        />
      </label>
    </>
  );
}


```


--------------------------------------------------------------------------------


# Updating Arrays in State
Source: https://react.dev/learn/updating-arrays-in-state

Arrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array.


### You will learn
- How to add, remove, or change items in an array in React state
- How to update an object inside of an array
- How to make array copying less repetitive with Immer

## Updating arrays without mutation
In JavaScript, arrays are just another kind of object.Like with objects,you should treat arrays in React state as read-only.This means that you shouldn’t reassign items inside an array likearr[0] = 'bird', and you also shouldn’t use methods that mutate the array, such aspush()andpop().

Instead, every time you want to update an array, you’ll want to pass anewarray to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods likefilter()andmap(). Then you can set your state to the resulting new array.

Here is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:

Alternatively, you canuse Immerwhich lets you use methods from both columns.


### Pitfall
Unfortunately,sliceandspliceare named similarly but are very different:

- slicelets you copy an array or a part of it.
- splicemutatesthe array (to insert or delete items).
In React, you will be usingslice(nop!) a lot more often because you don’t want to mutate objects or arrays in state.Updating Objectsexplains what mutation is and why it’s not recommended for state.


### Adding to an array
push()will mutate an array, which you don’t want:

```jsx
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => {
        artists.push({
          id: nextId++,
          name: name,
        });
      }}>Add</button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}


```

Instead, create anewarray which contains the existing itemsanda new item at the end. There are multiple ways to do this, but the easiest one is to use the...array spreadsyntax:

```jsx
setArtists( // Replace the state  [ // with a new array    ...artists, // that contains all the old items    { id: nextId++, name: name } // and one new item at the end  ]);
```

Now it works correctly:

```jsx
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => {
        setArtists([
          ...artists,
          { id: nextId++, name: name }
        ]);
      }}>Add</button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}


```

The array spread syntax also lets you prepend an item by placing itbeforethe original...artists:

```jsx
setArtists([  { id: nextId++, name: name },  ...artists // Put old items at the end]);
```

In this way, spread can do the job of bothpush()by adding to the end of an array andunshift()by adding to the beginning of an array. Try it in the sandbox above!


### Removing from an array
The easiest way to remove an item from an array is tofilter it out. In other words, you will produce a new array that will not contain that item. To do this, use thefiltermethod, for example:

```jsx
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [artists, setArtists] = useState(
    initialArtists
  );

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button onClick={() => {
              setArtists(
                artists.filter(a =>
                  a.id !== artist.id
                )
              );
            }}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}


```

Click the “Delete” button a few times, and look at its click handler.

```jsx
setArtists(  artists.filter(a => a.id !== artist.id));
```

Here,artists.filter(a => a.id !== artist.id)means “create an array that consists of thoseartistswhose IDs are different fromartist.id”. In other words, each artist’s “Delete” button will filterthatartist out of the array, and then request a re-render with the resulting array. Note thatfilterdoes not modify the original array.


### Transforming an array
If you want to change some or all items of the array, you can usemap()to create anewarray. The function you will pass tomapcan decide what to do with each item, based on its data or its index (or both).

In this example, an array holds coordinates of two circles and a square. When you press the button, it moves only the circles down by 50 pixels. It does this by producing a new array of data usingmap():

```jsx
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(
    initialShapes
  );

  function handleClick() {
    const nextShapes = shapes.map(shape => {
      if (shape.type === 'square') {
        // No change
        return shape;
      } else {
        // Return a new circle 50px below
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // Re-render with the new array
    setShapes(nextShapes);
  }

  return (
    <>
      <button onClick={handleClick}>
        Move circles down!
      </button>
      {shapes.map(shape => (
        <div
          key={shape.id}
          style={{
          background: 'purple',
          position: 'absolute',
          left: shape.x,
          top: shape.y,
          borderRadius:
            shape.type === 'circle'
              ? '50%' : '',
          width: 20,
          height: 20,
        }} />
      ))}
    </>
  );
}


```


### Replacing items in an array
It is particularly common to want to replace one or more items in an array. Assignments likearr[0] = 'bird'are mutating the original array, so instead you’ll want to usemapfor this as well.

To replace an item, create a new array withmap. Inside yourmapcall, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:

```jsx
import { useState } from 'react';

let initialCounters = [
  0, 0, 0
];

export default function CounterList() {
  const [counters, setCounters] = useState(
    initialCounters
  );

  function handleIncrementClick(index) {
    const nextCounters = counters.map((c, i) => {
      if (i === index) {
        // Increment the clicked counter
        return c + 1;
      } else {
        // The rest haven't changed
        return c;
      }
    });
    setCounters(nextCounters);
  }

  return (
    <ul>
      {counters.map((counter, i) => (
        <li key={i}>
          {counter}
          <button onClick={() => {
            handleIncrementClick(i);
          }}>+1</button>
        </li>
      ))}
    </ul>
  );
}


```


### Inserting into an array
Sometimes, you may want to insert an item at a particular position that’s neither at the beginning nor at the end. To do this, you can use the...array spread syntax together with theslice()method. Theslice()method lets you cut a “slice” of the array. To insert an item, you will create an array that spreads the slicebeforethe insertion point, then the new item, and then the rest of the original array.

In this example, the Insert button always inserts at the index1:

```jsx
import { useState } from 'react';

let nextId = 3;
const initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState(
    initialArtists
  );

  function handleClick() {
    const insertAt = 1; // Could be any index
    const nextArtists = [
      // Items before the insertion point:
      ...artists.slice(0, insertAt),
      // New item:
      { id: nextId++, name: name },
      // Items after the insertion point:
      ...artists.slice(insertAt)
    ];
    setArtists(nextArtists);
    setName('');
  }

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={handleClick}>
        Insert
      </button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}


```


### Making other changes to an array
There are some things you can’t do with the spread syntax and non-mutating methods likemap()andfilter()alone. For example, you may want to reverse or sort an array. The JavaScriptreverse()andsort()methods are mutating the original array, so you can’t use them directly.

However, you can copy the array first, and then make changes to it.

For example:

```jsx
import { useState } from 'react';

const initialList = [
  { id: 0, title: 'Big Bellies' },
  { id: 1, title: 'Lunar Landscape' },
  { id: 2, title: 'Terracotta Army' },
];

export default function List() {
  const [list, setList] = useState(initialList);

  function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
  }

  return (
    <>
      <button onClick={handleClick}>
        Reverse
      </button>
      <ul>
        {list.map(artwork => (
          <li key={artwork.id}>{artwork.title}</li>
        ))}
      </ul>
    </>
  );
}


```

Here, you use the[...list]spread syntax to create a copy of the original array first. Now that you have a copy, you can use mutating methods likenextList.reverse()ornextList.sort(), or even assign individual items withnextList[0] = "something".

However,even if you copy an array, you can’t mutate existing itemsinsideof it directly.This is because copying is shallow—the new array will contain the same items as the original one. So if you modify an object inside the copied array, you are mutating the existing state. For example, code like this is a problem.

```jsx
const nextList = [...list];nextList[0].seen = true; // Problem: mutates list[0]setList(nextList);
```

AlthoughnextListandlistare two different arrays,nextList[0]andlist[0]point to the same object.So by changingnextList[0].seen, you are also changinglist[0].seen. This is a state mutation, which you should avoid! You can solve this issue in a similar way toupdating nested JavaScript objects—by copying individual items you want to change instead of mutating them. Here’s how.


## Updating objects inside arrays
Objects are notreallylocated “inside” arrays. They might appear to be “inside” in code, but each object in an array is a separate value, to which the array “points”. This is why you need to be careful when changing nested fields likelist[0]. Another person’s artwork list may point to the same element of the array!

When updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level.Let’s see how this works.

In this example, two separate artwork lists have the same initial state. They are supposed to be isolated, but because of a mutation, their state is accidentally shared, and checking a box in one list affects the other list:

```jsx
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(
    initialList
  );

  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find(
      a => a.id === artworkId
    );
    artwork.seen = nextSeen;
    setMyList(myNextList);
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    const artwork = yourNextList.find(
      a => a.id === artworkId
    );
    artwork.seen = nextSeen;
    setYourList(yourNextList);
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={myList}
        onToggle={handleToggleMyList} />
      <h2>Your list of art to see:</h2>
      <ItemList
        artworks={yourList}
        onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}


```

The problem is in code like this:

```jsx
const myNextList = [...myList];const artwork = myNextList.find(a => a.id === artworkId);artwork.seen = nextSeen; // Problem: mutates an existing itemsetMyList(myNextList);
```

Although themyNextListarray itself is new, theitems themselvesare the same as in the originalmyListarray. So changingartwork.seenchanges theoriginalartwork item. That artwork item is also inyourList, which causes the bug. Bugs like this can be difficult to think about, but thankfully they disappear if you avoid mutating state.

You can usemapto substitute an old item with its updated version without mutation.

```jsx
setMyList(myList.map(artwork => {  if (artwork.id === artworkId) {    // Create a *new* object with changes    return { ...artwork, seen: nextSeen };  } else {    // No changes    return artwork;  }}));
```

Here,...is the object spread syntax used tocreate a copy of an object.

With this approach, none of the existing state items are being mutated, and the bug is fixed:

```jsx
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(
    initialList
  );

  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(myList.map(artwork => {
      if (artwork.id === artworkId) {
        // Create a *new* object with changes
        return { ...artwork, seen: nextSeen };
      } else {
        // No changes
        return artwork;
      }
    }));
  }

  function handleToggleYourList(artworkId, nextSeen) {
    setYourList(yourList.map(artwork => {
      if (artwork.id === artworkId) {
        // Create a *new* object with changes
        return { ...artwork, seen: nextSeen };
      } else {
        // No changes
        return artwork;
      }
    }));
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={myList}
        onToggle={handleToggleMyList} />
      <h2>Your list of art to see:</h2>
      <ItemList
        artworks={yourList}
        onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}


```

In general,you should only mutate objects that you have just created.If you were inserting anewartwork, you could mutate it, but if you’re dealing with something that’s already in state, you need to make a copy.


### Write concise update logic with Immer
Updating nested arrays without mutation can get a little bit repetitive.Just as with objects:

- Generally, you shouldn’t need to update state more than a couple of levels deep. If your state objects are very deep, you might want torestructure them differentlyso that they are flat.
- If you don’t want to change your state structure, you might prefer to useImmer, which lets you write using the convenient but mutating syntax and takes care of producing the copies for you.
Here is the Art Bucket List example rewritten with Immer:

```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Note how with Immer,mutation likeartwork.seen = nextSeenis now okay:

```jsx
updateMyTodos(draft => {  const artwork = draft.find(a => a.id === artworkId);  artwork.seen = nextSeen;});
```

This is because you’re not mutating theoriginalstate, but you’re mutating a specialdraftobject provided by Immer. Similarly, you can apply mutating methods likepush()andpop()to the content of thedraft.

Behind the scenes, Immer always constructs the next state from scratch according to the changes that you’ve done to thedraft. This keeps your event handlers very concise without ever mutating state.


## Recap
- You can put arrays into state, but you can’t change them.
- Instead of mutating an array, create anewversion of it, and update the state to it.
- You can use the[...arr, newItem]array spread syntax to create arrays with new items.
- You can usefilter()andmap()to create new arrays with filtered or transformed items.
- You can use Immer to keep your code concise.

## Try out some challenges

#### Challenge1of4:Update an item in the shopping cart
Fill in thehandleIncreaseClicklogic so that pressing ”+” increases the corresponding number:

```jsx
import { useState } from 'react';

const initialProducts = [{
  id: 0,
  name: 'Baklava',
  count: 1,
}, {
  id: 1,
  name: 'Cheese',
  count: 5,
}, {
  id: 2,
  name: 'Spaghetti',
  count: 2,
}];

export default function ShoppingCart() {
  const [
    products,
    setProducts
  ] = useState(initialProducts)

  function handleIncreaseClick(productId) {

  }

  return (
    <ul>
      {products.map(product => (
        <li key={product.id}>
          {product.name}
          {' '}
          (<b>{product.count}</b>)
          <button onClick={() => {
            handleIncreaseClick(product.id);
          }}>
            +
          </button>
        </li>
      ))}
    </ul>
  );
}


```


--------------------------------------------------------------------------------


# Managing State
Source: https://react.dev/learn/managing-state

As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you’ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components.


### In this chapter
- How to think about UI changes as state changes
- How to structure state well
- How to “lift state up” to share it between components
- How to control whether the state gets preserved or reset
- How to consolidate complex state logic in a function
- How to pass information without “prop drilling”
- How to scale state management as your app grows

## Reacting to input with state
With React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input. This is similar to how designers think about UI.

Here is a quiz form built using React. Note how it uses thestatusstate variable to determine whether to enable or disable the submit button, and whether to show the success message instead.

```jsx
import { useState } from 'react';

export default function Form() {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('typing');

  if (status === 'success') {
    return <h1>That's right!</h1>
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('submitting');
    try {
      await submitForm(answer);
      setStatus('success');
    } catch (err) {
      setStatus('typing');
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === 'submitting'}
        />
        <br />
        <button disabled={
          answer.length === 0 ||
          status === 'submitting'
        }>
          Submit
        </button>
        {error !== null &&
          <p className="Error">
            {error.message}
          </p>
        }
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== 'lima'
      if (shouldError) {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      } else {
        resolve();
      }
    }, 1500);
  });
}


```


## Ready to learn this topic?
ReadReacting to Input with Stateto learn how to approach interactions with a state-driven mindset.


## Choosing the state structure
Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs!

For example, this form has aredundantfullNamestate variable:

```jsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}


```

You can remove it and simplify the code by calculatingfullNamewhile the component is rendering:

```jsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  const fullName = firstName + ' ' + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}


```

This might seem like a small change, but many bugs in React apps are fixed this way.


## Ready to learn this topic?
ReadChoosing the State Structureto learn how to design the state shape to avoid bugs.


## Sharing state between components
Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code.

In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.

```jsx
import { useState } from 'react';

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title="About"
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title="Etymology"
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({
  title,
  children,
  isActive,
  onShow
}) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={onShow}>
          Show
        </button>
      )}
    </section>
  );
}


```


## Ready to learn this topic?
ReadSharing State Between Componentsto learn how to lift state up and keep components in sync.


## Preserving and resetting state
When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree.

However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:

```jsx
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat contact={to} />
    </div>
  )
}

const contacts = [
  { name: 'Taylor', email: 'taylor@mail.com' },
  { name: 'Alice', email: 'alice@mail.com' },
  { name: 'Bob', email: 'bob@mail.com' }
];


```

React lets you override the default behavior, andforcea component to reset its state by passing it a differentkey, like<Chat key={email} />. This tells React that if the recipient is different, it should be considered adifferentChatcomponent that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.

```jsx
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat key={to.email} contact={to} />
    </div>
  )
}

const contacts = [
  { name: 'Taylor', email: 'taylor@mail.com' },
  { name: 'Alice', email: 'alice@mail.com' },
  { name: 'Bob', email: 'bob@mail.com' }
];


```


## Ready to learn this topic?
ReadPreserving and Resetting Stateto learn the lifetime of state and how to control it.


## Extracting state logic into a reducer
Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!

```jsx
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask
        onAddTask={handleAddTask}
      />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false }
];


```


## Ready to learn this topic?
ReadExtracting State Logic into a Reducerto learn how to consolidate logic in the reducer function.


## Passing data deeply with context
Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props.

Here, theHeadingcomponent determines its heading level by “asking” the closestSectionfor its level. EachSectiontracks its own level by asking the parentSectionand adding one to it. EverySectionprovides information to all components below it without passing props—it does that through context.

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading>Title</Heading>
      <Section>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}


```


## Ready to learn this topic?
ReadPassing Data Deeply with Contextto learn about using context as an alternative to passing props.


## Scaling up with reducer and context
Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.

With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state.

```jsx
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksProvider } from './TasksContext.js';

export default function TaskApp() {
  return (
    <TasksProvider>
      <h1>Day off in Kyoto</h1>
      <AddTask />
      <TaskList />
    </TasksProvider>
  );
}


```


## Ready to learn this topic?
ReadScaling Up with Reducer and Contextto learn how state management scales in a growing app.


## What’s next?
Head over toReacting to Input with Stateto start reading this chapter page by page!

Or, if you’re already familiar with these topics, why not read aboutEscape Hatches?


--------------------------------------------------------------------------------


# Reacting to Input with State
Source: https://react.dev/learn/reacting-to-input-with-state

React provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.


### You will learn
- How declarative UI programming differs from imperative UI programming
- How to enumerate the different visual states your component can be in
- How to trigger the changes between the different visual states from code

## How declarative UI compares to imperative
When you design UI interactions, you probably think about how the UIchangesin response to user actions. Consider a form that lets the user submit an answer:

- When you type something into the form, the “Submit” buttonbecomes enabled.
- When you press “Submit”, both the form and the buttonbecome disabled,and a spinnerappears.
- If the network request succeeds, the formgets hidden,and the “Thank you” messageappears.
- If the network request fails, an error messageappears,and the formbecomes enabledagain.
Inimperative programming,the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here’s another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.

Illustrated byRachel Lee Nabors

They don’t know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It’s calledimperativebecause you have to “command” each element, from the spinner to the button, telling the computerhowto update the UI.

In this example of imperative UI programming, the form is builtwithoutReact. It only uses the browserDOM:

```jsx
async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}

function handleTextareaChange() {
  if (textarea.value.length === 0) {
    disable(button);
  } else {
    enable(button);
  }
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

function enable(el) {
  el.disabled = false;
}

function disable(el) {
  el.disabled = true;
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (answer.toLowerCase() === 'istanbul') {
        resolve();
      } else {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      }
    }, 1500);
  });
}

let form = document.getElementById('form');
let textarea = document.getElementById('textarea');
let button = document.getElementById('button');
let loadingMessage = document.getElementById('loading');
let errorMessage = document.getElementById('error');
let successMessage = document.getElementById('success');
form.onsubmit = handleFormSubmit;
textarea.oninput = handleTextareaChange;


```

Manipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven’t introduced a bug (for example, forgetting to show or hide something).

React was built to solve this problem.

In React, you don’t directly manipulate the UI—meaning you don’t enable, disable, show, or hide components directly. Instead, youdeclare what you want to show,and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It’s the driver’s job to get you there, and they might even know some shortcuts you haven’t considered!

Illustrated byRachel Lee Nabors


## Thinking about UI declaratively
You’ve seen how to implement a form imperatively above. To better understand how to think in React, you’ll walk through reimplementing this UI in React below:

- Identifyyour component’s different visual states
- Determinewhat triggers those state changes
- Representthe state in memory usinguseState
- Removeany non-essential state variables
- Connectthe event handlers to set the state

### Step 1: Identify your component’s different visual states
In computer science, you may hear about a“state machine”being in one of several “states”. If you work with a designer, you may have seen mockups for different “visual states”. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration.

First, you need to visualize all the different “states” of the UI the user might see:

- Empty: Form has a disabled “Submit” button.
- Typing: Form has an enabled “Submit” button.
- Submitting: Form is completely disabled. Spinner is shown.
- Success: “Thank you” message is shown instead of a form.
- Error: Same as Typing state, but with an extra error message.
Just like a designer, you’ll want to “mock up” or create “mocks” for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop calledstatuswith a default value of'empty':

```jsx
export default function Form({
  status = 'empty'
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea />
        <br />
        <button>
          Submit
        </button>
      </form>
    </>
  )
}


```

You could call that prop anything you like, the naming is not important. Try editingstatus = 'empty'tostatus = 'success'to see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still “controlled” by thestatusprop:

```jsx
export default function Form({
  // Try 'submitting', 'error', 'success':
  status = 'empty'
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea disabled={
          status === 'submitting'
        } />
        <br />
        <button disabled={
          status === 'empty' ||
          status === 'submitting'
        }>
          Submit
        </button>
        {status === 'error' &&
          <p className="Error">
            Good guess but a wrong answer. Try again!
          </p>
        }
      </form>
      </>
  );
}


```


#### Displaying many visual states at once
If a component has a lot of visual states, it can be convenient to show them all on one page:

```jsx
import Form from './Form.js';

let statuses = [
  'empty',
  'typing',
  'submitting',
  'success',
  'error',
];

export default function App() {
  return (
    <>
      {statuses.map(status => (
        <section key={status}>
          <h4>Form ({status}):</h4>
          <Form status={status} />
        </section>
      ))}
    </>
  );
}


```

Pages like this are often called “living styleguides” or “storybooks”.


### Step 2: Determine what triggers those state changes
You can trigger state updates in response to two kinds of inputs:

- Human inputs,like clicking a button, typing in a field, navigating a link.
- Computer inputs,like a network response arriving, a timeout completing, an image loading.
Illustrated byRachel Lee Nabors

In both cases,you must setstate variablesto update the UI.For the form you’re developing, you will need to change state in response to a few different inputs:

- Changing the text input(human) should switch it from theEmptystate to theTypingstate or back, depending on whether the text box is empty or not.
- Clicking the Submit button(human) should switch it to theSubmittingstate.
- Successful network response(computer) should switch it to theSuccessstate.
- Failed network response(computer) should switch it to theErrorstate with the matching error message.

### Note
Notice that human inputs often requireevent handlers!

To help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation.

Form states


### Step 3: Represent the state in memory withuseState
Next you’ll need to represent the visual states of your component in memory withuseState.Simplicity is key: each piece of state is a “moving piece”, andyou want as few “moving pieces” as possible.More complexity leads to more bugs!

Start with the state thatabsolutely mustbe there. For example, you’ll need to store theanswerfor the input, and theerror(if it exists) to store the last error:

```jsx
const [answer, setAnswer] = useState('');const [error, setError] = useState(null);
```

Then, you’ll need a state variable representing which one of the visual states that you want to display. There’s usually more than a single way to represent that in memory, so you’ll need to experiment with it.

If you struggle to think of the best way immediately, start by adding enough state that you’redefinitelysure that all the possible visual states are covered:

```jsx
const [isEmpty, setIsEmpty] = useState(true);const [isTyping, setIsTyping] = useState(false);const [isSubmitting, setIsSubmitting] = useState(false);const [isSuccess, setIsSuccess] = useState(false);const [isError, setIsError] = useState(false);
```

Your first idea likely won’t be the best, but that’s ok—refactoring state is a part of the process!


### Step 4: Remove any non-essential state variables
You want to avoid duplication in the state content so you’re only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is toprevent the cases where the state in memory doesn’t represent any valid UI that you’d want a user to see.(For example, you never want to show an error message and disable the input at the same time, or the user won’t be able to correct the error!)

Here are some questions you can ask about your state variables:

- Does this state cause a paradox?For example,isTypingandisSubmittingcan’t both betrue. A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the “impossible” state, you can combine these into astatusthat must be one of three values:'typing','submitting', or'success'.
- Is the same information available in another state variable already?Another paradox:isEmptyandisTypingcan’t betrueat the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can removeisEmptyand instead checkanswer.length === 0.
- Can you get the same information from the inverse of another state variable?isErroris not needed because you can checkerror !== nullinstead.
After this clean-up, you’re left with 3 (down from 7!)essentialstate variables:

```jsx
const [answer, setAnswer] = useState('');const [error, setError] = useState(null);const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success'
```

You know they are essential, because you can’t remove any of them without breaking the functionality.


#### Eliminating “impossible” states with a reducer
These three variables are a good enough representation of this form’s state. However, there are still some intermediate states that don’t fully make sense. For example, a non-nullerrordoesn’t make sense whenstatusis'success'. To model the state more precisely, you canextract it into a reducer.Reducers let you unify multiple state variables into a single object and consolidate all the related logic!


### Step 5: Connect the event handlers to set state
Lastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:

```jsx
import { useState } from 'react';

export default function Form() {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('typing');

  if (status === 'success') {
    return <h1>That's right!</h1>
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('submitting');
    try {
      await submitForm(answer);
      setStatus('success');
    } catch (err) {
      setStatus('typing');
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === 'submitting'}
        />
        <br />
        <button disabled={
          answer.length === 0 ||
          status === 'submitting'
        }>
          Submit
        </button>
        {error !== null &&
          <p className="Error">
            {error.message}
          </p>
        }
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== 'lima'
      if (shouldError) {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      } else {
        resolve();
      }
    }, 1500);
  });
}


```

Although this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.


## Recap
- Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).
- When developing a component:Identify all its visual states.Determine the human and computer triggers for state changes.Model the state withuseState.Remove non-essential state to avoid bugs and paradoxes.Connect the event handlers to set state.
- Identify all its visual states.
- Determine the human and computer triggers for state changes.
- Model the state withuseState.
- Remove non-essential state to avoid bugs and paradoxes.
- Connect the event handlers to set state.

## Try out some challenges

#### Challenge1of3:Add and remove a CSS class
Make it so that clicking on the pictureremovesthebackground--activeCSS class from the outer<div>, butaddsthepicture--activeclass to the<img>. Clicking the background again should restore the original CSS classes.

Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight.

```jsx
export default function Picture() {
  return (
    <div className="background background--active">
      <img
        className="picture"
        alt="Rainbow houses in Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
      />
    </div>
  );
}


```


--------------------------------------------------------------------------------


# Choosing the State Structure
Source: https://react.dev/learn/choosing-the-state-structure

Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. Here are some tips you should consider when structuring state.


### You will learn
- When to use a single vs multiple state variables
- What to avoid when organizing state
- How to fix common issues with the state structure

## Principles for structuring state
When you write a component that holds some state, you’ll have to make choices about how many state variables to use and what the shape of their data should be. While it’s possible to write correct programs even with a suboptimal state structure, there are a few principles that can guide you to make better choices:

- Group related state.If you always update two or more state variables at the same time, consider merging them into a single state variable.
- Avoid contradictions in state.When the state is structured in a way that several pieces of state may contradict and “disagree” with each other, you leave room for mistakes. Try to avoid this.
- Avoid redundant state.If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.
- Avoid duplication in state.When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can.
- Avoid deeply nested state.Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way.
The goal behind these principles is tomake state easy to update without introducing mistakes. Removing redundant and duplicate data from state helps ensure that all its pieces stay in sync. This is similar to how a database engineer might want to“normalize” the database structureto reduce the chance of bugs. To paraphrase Albert Einstein,“Make your state as simple as it can be—but no simpler.”

Now let’s see how these principles apply in action.


## Group related state
You might sometimes be unsure between using a single or multiple state variables.

Should you do this?

```jsx
const [x, setX] = useState(0);const [y, setY] = useState(0);
```

Or this?

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Technically, you can use either of these approaches. Butif some two state variables always change together, it might be a good idea to unify them into a single state variable.Then you won’t forget to always keep them in sync, like in this example where moving the cursor updates both coordinates of the red dot:

```jsx
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  )
}


```

Another case where you’ll group data into an object or an array is when you don’t know how many pieces of state you’ll need. For example, it’s helpful when you have a form where the user can add custom fields.


### Pitfall
If your state variable is an object, remember thatyou can’t update only one field in itwithout explicitly copying the other fields. For example, you can’t dosetPosition({ x: 100 })in the above example because it would not have theyproperty at all! Instead, if you wanted to setxalone, you would either dosetPosition({ ...position, x: 100 }), or split them into two state variables and dosetX(100).


## Avoid contradictions in state
Here is a hotel feedback form withisSendingandisSentstate variables:

```jsx
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isSent, setIsSent] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsSending(true);
    await sendMessage(text);
    setIsSending(false);
    setIsSent(true);
  }

  if (isSent) {
    return <h1>Thanks for feedback!</h1>
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button
        disabled={isSending}
        type="submit"
      >
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}


```

While this code works, it leaves the door open for “impossible” states. For example, if you forget to callsetIsSentandsetIsSendingtogether, you may end up in a situation where bothisSendingandisSentaretrueat the same time. The more complex your component is, the harder it is to understand what happened.

SinceisSendingandisSentshould never betrueat the same time, it is better to replace them with onestatusstate variable that may take one ofthreevalid states:'typing'(initial),'sending', and'sent':

```jsx
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [status, setStatus] = useState('typing');

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('sending');
    await sendMessage(text);
    setStatus('sent');
  }

  const isSending = status === 'sending';
  const isSent = status === 'sent';

  if (isSent) {
    return <h1>Thanks for feedback!</h1>
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button
        disabled={isSending}
        type="submit"
      >
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}


```

You can still declare some constants for readability:

```jsx
const isSending = status === 'sending';const isSent = status === 'sent';
```

But they’re not state variables, so you don’t need to worry about them getting out of sync with each other.


## Avoid redundant state
If you can calculate some information from the component’s props or its existing state variables during rendering, youshould notput that information into that component’s state.

For example, take this form. It works, but can you find any redundant state in it?

```jsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}


```

This form has three state variables:firstName,lastName, andfullName. However,fullNameis redundant.You can always calculatefullNamefromfirstNameandlastNameduring render, so remove it from state.

This is how you can do it:

```jsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  const fullName = firstName + ' ' + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}


```

Here,fullNameisnota state variable. Instead, it’s calculated during render:

```jsx
const fullName = firstName + ' ' + lastName;
```

As a result, the change handlers don’t need to do anything special to update it. When you callsetFirstNameorsetLastName, you trigger a re-render, and then the nextfullNamewill be calculated from the fresh data.


#### Don’t mirror props in state
A common example of redundant state is code like this:

```jsx
function Message({ messageColor }) {  const [color, setColor] = useState(messageColor);
```

Here, acolorstate variable is initialized to themessageColorprop. The problem is thatif the parent component passes a different value ofmessageColorlater (for example,'red'instead of'blue'), thecolorstate variablewould not be updated!The state is only initialized during the first render.

This is why “mirroring” some prop in a state variable can lead to confusion. Instead, use themessageColorprop directly in your code. If you want to give it a shorter name, use a constant:

```jsx
function Message({ messageColor }) {  const color = messageColor;
```

This way it won’t get out of sync with the prop passed from the parent component.

”Mirroring” props into state only makes sense when youwantto ignore all updates for a specific prop. By convention, start the prop name withinitialordefaultto clarify that its new values are ignored:

```jsx
function Message({ initialColor }) {  // The `color` state variable holds the *first* value of `initialColor`.  // Further changes to the `initialColor` prop are ignored.  const [color, setColor] = useState(initialColor);
```


## Avoid duplication in state
This menu list component lets you choose a single travel snack out of several:

```jsx
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(
    items[0]
  );

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.title}
            {' '}
            <button onClick={() => {
              setSelectedItem(item);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}


```

Currently, it stores the selected item as an object in theselectedItemstate variable. However, this is not great:the contents of theselectedItemis the same object as one of the items inside theitemslist.This means that the information about the item itself is duplicated in two places.

Why is this a problem? Let’s make each item editable:

```jsx
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(
    items[0]
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }

  return (
    <>
      <h2>What's your travel snack?</h2> 
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedItem(item);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}


```

Notice how if you first click “Choose” on an item andthenedit it,the input updates but the label at the bottom does not reflect the edits.This is because you have duplicated state, and you forgot to updateselectedItem.

Although you could updateselectedItemtoo, an easier fix is to remove duplication. In this example, instead of aselectedItemobject (which creates a duplication with objects insideitems), you hold theselectedIdin state, andthenget theselectedItemby searching theitemsarray for an item with that ID:

```jsx
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);

  const selectedItem = items.find(item =>
    item.id === selectedId
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedId(item.id);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}


```

The state used to be duplicated like this:

- items = [{ id: 0, title: 'pretzels'}, ...]
- selectedItem = {id: 0, title: 'pretzels'}
But after the change it’s like this:

- items = [{ id: 0, title: 'pretzels'}, ...]
- selectedId = 0
The duplication is gone, and you only keep the essential state!

Now if you edit theselecteditem, the message below will update immediately. This is becausesetItemstriggers a re-render, anditems.find(...)would find the item with the updated title. You didn’t need to holdthe selected itemin state, because only theselected IDis essential. The rest could be calculated during render.


## Avoid deeply nested state
Imagine a travel plan consisting of planets, continents, and countries. You might be tempted to structure its state using nested objects and arrays, like in this example:

```jsx
export const initialTravelPlan = {
  id: 0,
  title: '(Root)',
  childPlaces: [{
    id: 1,
    title: 'Earth',
    childPlaces: [{
      id: 2,
      title: 'Africa',
      childPlaces: [{
        id: 3,
        title: 'Botswana',
        childPlaces: []
      }, {
        id: 4,
        title: 'Egypt',
        childPlaces: []
      }, {
        id: 5,
        title: 'Kenya',
        childPlaces: []
      }, {
        id: 6,
        title: 'Madagascar',
        childPlaces: []
      }, {
        id: 7,
        title: 'Morocco',
        childPlaces: []
      }, {
        id: 8,
        title: 'Nigeria',
        childPlaces: []
      }, {
        id: 9,
        title: 'South Africa',
        childPlaces: []
      }]
    }, {
      id: 10,
      title: 'Americas',
      childPlaces: [{
        id: 11,
        title: 'Argentina',
        childPlaces: []
      }, {
        id: 12,
        title: 'Brazil',
        childPlaces: []
      }, {
        id: 13,
        title: 'Barbados',
        childPlaces: []
      }, {
        id: 14,
        title: 'Canada',
        childPlaces: []
      }, {
        id: 15,
        title: 'Jamaica',
        childPlaces: []
      }, {
        id: 16,
        title: 'Mexico',
        childPlaces: []
      }, {
        id: 17,
        title: 'Trinidad and Tobago',
        childPlaces: []
      }, {
        id: 18,
        title: 'Venezuela',
        childPlaces: []
      }]
    }, {
      id: 19,
      title: 'Asia',
      childPlaces: [{
        id: 20,
        title: 'China',
        childPlaces: []
      }, {
        id: 21,
        title: 'India',
        childPlaces: []
      }, {
        id: 22,
        title: 'Singapore',
        childPlaces: []
      }, {
        id: 23,
        title: 'South Korea',
        childPlaces: []
      }, {
        id: 24,
        title: 'Thailand',
        childPlaces: []
      }, {
        id: 25,
        title: 'Vietnam',
        childPlaces: []
      }]
    }, {
      id: 26,
      title: 'Europe',
      childPlaces: [{
        id: 27,
        title: 'Croatia',
        childPlaces: [],
      }, {
        id: 28,
        title: 'France',
        childPlaces: [],
      }, {
        id: 29,
        title: 'Germany',
        childPlaces: [],
      }, {
        id: 30,
        title: 'Italy',
        childPlaces: [],
      }, {
        id: 31,
        title: 'Portugal',
        childPlaces: [],
      }, {
        id: 32,
        title: 'Spain',
        childPlaces: [],
      }, {
        id: 33,
        title: 'Turkey',
        childPlaces: [],
      }]
    }, {
      id: 34,
      title: 'Oceania',
      childPlaces: [{
        id: 35,
        title: 'Australia',
        childPlaces: [],
      }, {
        id: 36,
        title: 'Bora Bora (French Polynesia)',
        childPlaces: [],
      }, {
        id: 37,
        title: 'Easter Island (Chile)',
        childPlaces: [],
      }, {
        id: 38,
        title: 'Fiji',
        childPlaces: [],
      }, {
        id: 39,
        title: 'Hawaii (the USA)',
        childPlaces: [],
      }, {
        id: 40,
        title: 'New Zealand',
        childPlaces: [],
      }, {
        id: 41,
        title: 'Vanuatu',
        childPlaces: [],
      }]
    }]
  }, {
    id: 42,
    title: 'Moon',
    childPlaces: [{
      id: 43,
      title: 'Rheita',
      childPlaces: []
    }, {
      id: 44,
      title: 'Piccolomini',
      childPlaces: []
    }, {
      id: 45,
      title: 'Tycho',
      childPlaces: []
    }]
  }, {
    id: 46,
    title: 'Mars',
    childPlaces: [{
      id: 47,
      title: 'Corn Town',
      childPlaces: []
    }, {
      id: 48,
      title: 'Green Hill',
      childPlaces: []      
    }]
  }]
};


```

Now let’s say you want to add a button to delete a place you’ve already visited. How would you go about it?Updating nested stateinvolves making copies of objects all the way up from the part that changed. Deleting a deeply nested place would involve copying its entire parent place chain. Such code can be very verbose.

If the state is too nested to update easily, consider making it “flat”.Here is one way you can restructure this data. Instead of a tree-like structure where eachplacehas an array ofits child places, you can have each place hold an array ofits child place IDs. Then store a mapping from each place ID to the corresponding place.

This data restructuring might remind you of seeing a database table:

```jsx
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 26, 34]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  }, 
  3: {
    id: 3,
    title: 'Botswana',
    childIds: []
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: []
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: []
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: []
  }, 
  7: {
    id: 7,
    title: 'Morocco',
    childIds: []
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: []
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: []
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: []
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: []
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: []
  }, 
  14: {
    id: 14,
    title: 'Canada',
    childIds: []
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: []
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: []
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: []
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: []
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25],   
  },
  20: {
    id: 20,
    title: 'China',
    childIds: []
  },
  21: {
    id: 21,
    title: 'India',
    childIds: []
  },
  22: {
    id: 22,
    title: 'Singapore',
    childIds: []
  },
  23: {
    id: 23,
    title: 'South Korea',
    childIds: []
  },
  24: {
    id: 24,
    title: 'Thailand',
    childIds: []
  },
  25: {
    id: 25,
    title: 'Vietnam',
    childIds: []
  },
  26: {
    id: 26,
    title: 'Europe',
    childIds: [27, 28, 29, 30, 31, 32, 33],   
  },
  27: {
    id: 27,
    title: 'Croatia',
    childIds: []
  },
  28: {
    id: 28,
    title: 'France',
    childIds: []
  },
  29: {
    id: 29,
    title: 'Germany',
    childIds: []
  },
  30: {
    id: 30,
    title: 'Italy',
    childIds: []
  },
  31: {
    id: 31,
    title: 'Portugal',
    childIds: []
  },
  32: {
    id: 32,
    title: 'Spain',
    childIds: []
  },
  33: {
    id: 33,
    title: 'Turkey',
    childIds: []
  },
  34: {
    id: 34,
    title: 'Oceania',
    childIds: [35, 36, 37, 38, 39, 40, 41],   
  },
  35: {
    id: 35,
    title: 'Australia',
    childIds: []
  },
  36: {
    id: 36,
    title: 'Bora Bora (French Polynesia)',
    childIds: []
  },
  37: {
    id: 37,
    title: 'Easter Island (Chile)',
    childIds: []
  },
  38: {
    id: 38,
    title: 'Fiji',
    childIds: []
  },
  39: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: []
  },
  40: {
    id: 40,
    title: 'New Zealand',
    childIds: []
  },
  41: {
    id: 41,
    title: 'Vanuatu',
    childIds: []
  },
  42: {
    id: 42,
    title: 'Moon',
    childIds: [43, 44, 45]
  },
  43: {
    id: 43,
    title: 'Rheita',
    childIds: []
  },
  44: {
    id: 44,
    title: 'Piccolomini',
    childIds: []
  },
  45: {
    id: 45,
    title: 'Tycho',
    childIds: []
  },
  46: {
    id: 46,
    title: 'Mars',
    childIds: [47, 48]
  },
  47: {
    id: 47,
    title: 'Corn Town',
    childIds: []
  },
  48: {
    id: 48,
    title: 'Green Hill',
    childIds: []
  }
};


```

Now that the state is “flat” (also known as “normalized”), updating nested items becomes easier.

In order to remove a place now, you only need to update two levels of state:

- The updated version of itsparentplace should exclude the removed ID from itschildIdsarray.
- The updated version of the root “table” object should include the updated version of the parent place.
Here is an example of how you could go about it:

```jsx
import { useState } from 'react';
import { initialTravelPlan } from './places.js';

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);

  function handleComplete(parentId, childId) {
    const parent = plan[parentId];
    // Create a new version of the parent place
    // that doesn't include this child ID.
    const nextParent = {
      ...parent,
      childIds: parent.childIds
        .filter(id => id !== childId)
    };
    // Update the root state object...
    setPlan({
      ...plan,
      // ...so that it has the updated parent.
      [parentId]: nextParent
    });
  }

  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}

function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button onClick={() => {
        onComplete(parentId, id);
      }}>
        Complete
      </button>
      {childIds.length > 0 &&
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      }
    </li>
  );
}


```

You can nest state as much as you like, but making it “flat” can solve numerous problems. It makes state easier to update, and it helps ensure you don’t have duplication in different parts of a nested object.


#### Improving memory usage
Ideally, you would also remove the deleted items (and their children!) from the “table” object to improve memory usage. This version does that. It alsouses Immerto make the update logic more concise.

```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Sometimes, you can also reduce state nesting by moving some of the nested state into the child components. This works well for ephemeral UI state that doesn’t need to be stored, like whether an item is hovered.


## Recap
- If two state variables always update together, consider merging them into one.
- Choose your state variables carefully to avoid creating “impossible” states.
- Structure your state in a way that reduces the chances that you’ll make a mistake updating it.
- Avoid redundant and duplicate state so that you don’t need to keep it in sync.
- Don’t put propsintostate unless you specifically want to prevent updates.
- For UI patterns like selection, keep ID or index in state instead of the object itself.
- If updating deeply nested state is complicated, try flattening it.

## Try out some challenges

#### Challenge1of4:Fix a component that’s not updating
ThisClockcomponent receives two props:colorandtime. When you select a different color in the select box, theClockcomponent receives a differentcolorprop from its parent component. However, for some reason, the displayed color doesn’t update. Why? Fix the problem.

```jsx
import { useState } from 'react';

export default function Clock(props) {
  const [color, setColor] = useState(props.color);
  return (
    <h1 style={{ color: color }}>
      {props.time}
    </h1>
  );
}


```


--------------------------------------------------------------------------------


# Sharing State Between Components
Source: https://react.dev/learn/sharing-state-between-components

Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known aslifting state up,and it’s one of the most common things you will do writing React code.


### You will learn
- How to share state between components by lifting it up
- What are controlled and uncontrolled components

## Lifting state up by example
In this example, a parentAccordioncomponent renders two separatePanels:

- AccordionPanelPanel
- Panel
- Panel
EachPanelcomponent has a booleanisActivestate that determines whether its content is visible.

Press the Show button for both panels:

```jsx
import { useState } from 'react';

function Panel({ title, children }) {
  const [isActive, setIsActive] = useState(false);
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>
          Show
        </button>
      )}
    </section>
  );
}

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title="About">
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title="Etymology">
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}


```

Notice how pressing one panel’s button does not affect the other panel—they are independent.

Initially, eachPanel’sisActivestate isfalse, so they both appear collapsed

Clicking eitherPanel’s button will only update thatPanel’sisActivestate alone

But now let’s say you want to change it so that only one panel is expanded at any given time.With that design, expanding the second panel should collapse the first one. How would you do that?

To coordinate these two panels, you need to “lift their state up” to a parent component in three steps:

- Removestate from the child components.
- Passhardcoded data from the common parent.
- Addstate to the common parent and pass it down together with the event handlers.
This will allow theAccordioncomponent to coordinate bothPanels and only expand one at a time.


### Step 1: Remove state from the child components
You will give control of thePanel’sisActiveto its parent component. This means that the parent component will passisActivetoPanelas a prop instead. Start byremoving this linefrom thePanelcomponent:

```jsx
const [isActive, setIsActive] = useState(false);
```

And instead, addisActiveto thePanel’s list of props:

```jsx
function Panel({ title, children, isActive }) {
```

Now thePanel’s parent component cancontrolisActivebypassing it down as a prop.Conversely, thePanelcomponent now hasno controlover the value ofisActive—it’s now up to the parent component!


### Step 2: Pass hardcoded data from the common parent
To lift state up, you must locate the closest common parent component ofbothof the child components that you want to coordinate:

- Accordion(closest common parent)PanelPanel
- Panel
- Panel
In this example, it’s theAccordioncomponent. Since it’s above both panels and can control their props, it will become the “source of truth” for which panel is currently active. Make theAccordioncomponent pass a hardcoded value ofisActive(for example,true) to both panels:

```jsx
import { useState } from 'react';

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title="About" isActive={true}>
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title="Etymology" isActive={true}>
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({ title, children, isActive }) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>
          Show
        </button>
      )}
    </section>
  );
}


```

Try editing the hardcodedisActivevalues in theAccordioncomponent and see the result on the screen.


### Step 3: Add state to the common parent
Lifting state up often changes the nature of what you’re storing as state.

In this case, only one panel should be active at a time. This means that theAccordioncommon parent component needs to keep track ofwhichpanel is the active one. Instead of abooleanvalue, it could use a number as the index of the activePanelfor the state variable:

```jsx
const [activeIndex, setActiveIndex] = useState(0);
```

When theactiveIndexis0, the first panel is active, and when it’s1, it’s the second one.

Clicking the “Show” button in eitherPanelneeds to change the active index inAccordion. APanelcan’t set theactiveIndexstate directly because it’s defined inside theAccordion. TheAccordioncomponent needs toexplicitly allowthePanelcomponent to change its state bypassing an event handler down as a prop:

```jsx
<>  <Panel    isActive={activeIndex === 0}    onShow={() => setActiveIndex(0)}  >    ...  </Panel>  <Panel    isActive={activeIndex === 1}    onShow={() => setActiveIndex(1)}  >    ...  </Panel></>
```

The<button>inside thePanelwill now use theonShowprop as its click event handler:

```jsx
import { useState } from 'react';

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title="About"
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title="Etymology"
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({
  title,
  children,
  isActive,
  onShow
}) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={onShow}>
          Show
        </button>
      )}
    </section>
  );
}


```

This completes lifting state up! Moving state into the common parent component allowed you to coordinate the two panels. Using the active index instead of two “is shown” flags ensured that only one panel is active at a given time. And passing down the event handler to the child allowed the child to change the parent’s state.

Initially,Accordion’sactiveIndexis0, so the firstPanelreceivesisActive = true

WhenAccordion’sactiveIndexstate changes to1, the secondPanelreceivesisActive = trueinstead


#### Controlled and uncontrolled components
It is common to call a component with some local state “uncontrolled”. For example, the originalPanelcomponent with anisActivestate variable is uncontrolled because its parent cannot influence whether the panel is active or not.

In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. The finalPanelcomponent with theisActiveprop is controlled by theAccordioncomponent.

Uncontrolled components are easier to use within their parents because they require less configuration. But they’re less flexible when you want to coordinate them together. Controlled components are maximally flexible, but they require the parent components to fully configure them with props.

In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer.

When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). But you can always change your mind and refactor later.


## A single source of truth for each state
In a React application, many components will have their own state. Some state may “live” close to the leaf components (components at the bottom of the tree) like inputs. Other state may “live” closer to the top of the app. For example, even client-side routing libraries are usually implemented by storing the current route in the React state, and passing it down by props!

For each unique piece of state, you will choose the component that “owns” it.This principle is also known as having a“single source of truth”.It doesn’t mean that all state lives in one place—but that foreachpiece of state, there is aspecificcomponent that holds that piece of information. Instead of duplicating shared state between components,lift it upto their common shared parent, andpass it downto the children that need it.

Your app will change as you work on it. It is common that you will move state down or back up while you’re still figuring out where each piece of the state “lives”. This is all part of the process!

To see what this feels like in practice with a few more components, readThinking in React.


## Recap
- When you want to coordinate two components, move their state to their common parent.
- Then pass the information down through props from their common parent.
- Finally, pass the event handlers down so that the children can change the parent’s state.
- It’s useful to consider components as “controlled” (driven by props) or “uncontrolled” (driven by state).

## Try out some challenges

#### Challenge1of2:Synced inputs
These two inputs are independent. Make them stay in sync: editing one input should update the other input with the same text, and vice versa.

```jsx
import { useState } from 'react';

export default function SyncedInputs() {
  return (
    <>
      <Input label="First input" />
      <Input label="Second input" />
    </>
  );
}

function Input({ label }) {
  const [text, setText] = useState('');

  function handleChange(e) {
    setText(e.target.value);
  }

  return (
    <label>
      {label}
      {' '}
      <input
        value={text}
        onChange={handleChange}
      />
    </label>
  );
}


```


--------------------------------------------------------------------------------


# Preserving and Resetting State
Source: https://react.dev/learn/preserving-and-resetting-state

State is isolated between components. React keeps track of which state belongs to which component based on their place in the UI tree. You can control when to preserve state and when to reset it between re-renders.


### You will learn
- When React chooses to preserve or reset the state
- How to force React to reset component’s state
- How keys and types affect whether the state is preserved

## State is tied to a position in the render tree
React buildsrender treesfor the component structure in your UI.

When you give a component state, you might think the state “lives” inside the component. But the state is actually held inside React. React associates each piece of state it’s holding with the correct component by where that component sits in the render tree.

Here, there is only one<Counter />JSX tag, but it’s rendered at two different positions:

```jsx
import { useState } from 'react';

export default function App() {
  const counter = <Counter />;
  return (
    <div>
      {counter}
      {counter}
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

Here’s how these look as a tree:

React tree

These are two separate counters because each is rendered at its own position in the tree.You don’t usually have to think about these positions to use React, but it can be useful to understand how it works.

In React, each component on the screen has fully isolated state. For example, if you render twoCountercomponents side by side, each of them will get its own, independent,scoreandhoverstates.

Try clicking both counters and notice they don’t affect each other:

```jsx
import { useState } from 'react';

export default function App() {
  return (
    <div>
      <Counter />
      <Counter />
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

As you can see, when one counter is updated, only the state for that component is updated:

Updating state

React will keep the state around for as long as you render the same component at the same position in the tree. To see this, increment both counters, then remove the second component by unchecking “Render the second counter” checkbox, and then add it back by ticking it again:

```jsx
import { useState } from 'react';

export default function App() {
  const [showB, setShowB] = useState(true);
  return (
    <div>
      <Counter />
      {showB && <Counter />} 
      <label>
        <input
          type="checkbox"
          checked={showB}
          onChange={e => {
            setShowB(e.target.checked)
          }}
        />
        Render the second counter
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

Notice how the moment you stop rendering the second counter, its state disappears completely. That’s because when React removes a component, it destroys its state.

Deleting a component

When you tick “Render the second counter”, a secondCounterand its state are initialized from scratch (score = 0) and added to the DOM.

Adding a component

React preserves a component’s state for as long as it’s being rendered at its position in the UI tree.If it gets removed, or a different component gets rendered at the same position, React discards its state.


## Same component at the same position preserves state
In this example, there are two different<Counter />tags:

```jsx
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <Counter isFancy={true} /> 
      ) : (
        <Counter isFancy={false} /> 
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

When you tick or clear the checkbox, the counter state does not get reset. WhetherisFancyistrueorfalse, you always have a<Counter />as the first child of thedivreturned from the rootAppcomponent:

Updating theAppstate does not reset theCounterbecauseCounterstays in the same position

It’s the same component at the same position, so from React’s perspective, it’s the same counter.


### Pitfall
Remember thatit’s the position in the UI tree—not in the JSX markup—that matters to React!This component has tworeturnclauses with different<Counter />JSX tags inside and outside theif:

```jsx
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  if (isFancy) {
    return (
      <div>
        <Counter isFancy={true} />
        <label>
          <input
            type="checkbox"
            checked={isFancy}
            onChange={e => {
              setIsFancy(e.target.checked)
            }}
          />
          Use fancy styling
        </label>
      </div>
    );
  }
  return (
    <div>
      <Counter isFancy={false} />
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

You might expect the state to reset when you tick checkbox, but it doesn’t! This is becauseboth of these<Counter />tags are rendered at the same position.React doesn’t know where you place the conditions in your function. All it “sees” is the tree you return.

In both cases, theAppcomponent returns a<div>with<Counter />as a first child. To React, these two counters have the same “address”: the first child of the first child of the root. This is how React matches them up between the previous and next renders, regardless of how you structure your logic.


## Different components at the same position reset state
In this example, ticking the checkbox will replace<Counter>with a<p>:

```jsx
import { useState } from 'react';

export default function App() {
  const [isPaused, setIsPaused] = useState(false);
  return (
    <div>
      {isPaused ? (
        <p>See you later!</p> 
      ) : (
        <Counter /> 
      )}
      <label>
        <input
          type="checkbox"
          checked={isPaused}
          onChange={e => {
            setIsPaused(e.target.checked)
          }}
        />
        Take a break
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

Here, you switch betweendifferentcomponent types at the same position. Initially, the first child of the<div>contained aCounter. But when you swapped in ap, React removed theCounterfrom the UI tree and destroyed its state.

WhenCounterchanges top, theCounteris deleted and thepis added

When switching back, thepis deleted and theCounteris added

Also,when you render a different component in the same position, it resets the state of its entire subtree.To see how this works, increment the counter and then tick the checkbox:

```jsx
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <div>
          <Counter isFancy={true} /> 
        </div>
      ) : (
        <section>
          <Counter isFancy={false} />
        </section>
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

The counter state gets reset when you click the checkbox. Although you render aCounter, the first child of thedivchanges from asectionto adiv. When the childsectionwas removed from the DOM, the whole tree below it (including theCounterand its state) was destroyed as well.

Whensectionchanges todiv, thesectionis deleted and the newdivis added

When switching back, thedivis deleted and the newsectionis added

As a rule of thumb,if you want to preserve the state between re-renders, the structure of your tree needs to “match up”from one render to another. If the structure is different, the state gets destroyed because React destroys state when it removes a component from the tree.


### Pitfall
This is why you should not nest component function definitions.

Here, theMyTextFieldcomponent function is definedinsideMyComponent:

```jsx
import { useState } from 'react';

export default function MyComponent() {
  const [counter, setCounter] = useState(0);

  function MyTextField() {
    const [text, setText] = useState('');

    return (
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
    );
  }

  return (
    <>
      <MyTextField />
      <button onClick={() => {
        setCounter(counter + 1)
      }}>Clicked {counter} times</button>
    </>
  );
}


```

Every time you click the button, the input state disappears! This is because adifferentMyTextFieldfunction is created for every render ofMyComponent. You’re rendering adifferentcomponent in the same position, so React resets all state below. This leads to bugs and performance problems. To avoid this problem,always declare component functions at the top level, and don’t nest their definitions.


## Resetting state at the same position
By default, React preserves state of a component while it stays at the same position. Usually, this is exactly what you want, so it makes sense as the default behavior. But sometimes, you may want to reset a component’s state. Consider this app that lets two players keep track of their scores during each turn:

```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter person="Taylor" />
      ) : (
        <Counter person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{person}'s score: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

Currently, when you change the player, the score is preserved. The twoCounters appear in the same position, so React sees them asthe sameCounterwhosepersonprop has changed.

But conceptually, in this app they should be two separate counters. They might appear in the same place in the UI, but one is a counter for Taylor, and another is a counter for Sarah.

There are two ways to reset state when switching between them:

- Render components in different positions
- Give each component an explicit identity withkey

### Option 1: Rendering a component in different positions
If you want these twoCounters to be independent, you can render them in two different positions:

```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA &&
        <Counter person="Taylor" />
      }
      {!isPlayerA &&
        <Counter person="Sarah" />
      }
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{person}'s score: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

- Initially,isPlayerAistrue. So the first position containsCounterstate, and the second one is empty.
- When you click the “Next player” button the first position clears but the second one now contains aCounter.
Initial state

Clicking “next”

Clicking “next” again

EachCounter’s state gets destroyed each time it’s removed from the DOM. This is why they reset every time you click the button.

This solution is convenient when you only have a few independent components rendered in the same place. In this example, you only have two, so it’s not a hassle to render both separately in the JSX.


### Option 2: Resetting state with a key
There is also another, more generic, way to reset a component’s state.

You might have seenkeys whenrendering lists.Keys aren’t just for lists! You can use keys to make React distinguish between any components. By default, React uses order within the parent (“first counter”, “second counter”) to discern between components. But keys let you tell React that this is not just afirstcounter, or asecondcounter, but a specific counter—for example,Taylor’scounter. This way, React will knowTaylor’scounter wherever it appears in the tree!

In this example, the two<Counter />s don’t share state even though they appear in the same place in JSX:

```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key="Taylor" person="Taylor" />
      ) : (
        <Counter key="Sarah" person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{person}'s score: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}


```

Switching between Taylor and Sarah does not preserve the state. This is becauseyou gave them differentkeys:

```jsx
{isPlayerA ? (  <Counter key="Taylor" person="Taylor" />) : (  <Counter key="Sarah" person="Sarah" />)}
```

Specifying akeytells React to use thekeyitself as part of the position, instead of their order within the parent. This is why, even though you render them in the same place in JSX, React sees them as two different counters, and so they will never share state. Every time a counter appears on the screen, its state is created. Every time it is removed, its state is destroyed. Toggling between them resets their state over and over.


### Note
Remember that keys are not globally unique. They only specify the positionwithin the parent.


### Resetting a form with a key
Resetting state with a key is particularly useful when dealing with forms.

In this chat app, the<Chat>component contains the text input state:

```jsx
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat contact={to} />
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];


```

Try entering something into the input, and then press “Alice” or “Bob” to choose a different recipient. You will notice that the input state is preserved because the<Chat>is rendered at the same position in the tree.

In many apps, this may be the desired behavior, but not in a chat app!You don’t want to let the user send a message they already typed to a wrong person due to an accidental click. To fix it, add akey:

```jsx
<Chat key={to.id} contact={to} />
```

This ensures that when you select a different recipient, theChatcomponent will be recreated from scratch, including any state in the tree below it. React will also re-create the DOM elements instead of reusing them.

Now switching the recipient always clears the text field:

```jsx
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat key={to.id} contact={to} />
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];


```


#### Preserving state for removed components
In a real chat app, you’d probably want to recover the input state when the user selects the previous recipient again. There are a few ways to keep the state “alive” for a component that’s no longer visible:

- You could renderallchats instead of just the current one, but hide all the others with CSS. The chats would not get removed from the tree, so their local state would be preserved. This solution works great for simple UIs. But it can get very slow if the hidden trees are large and contain a lot of DOM nodes.
- You couldlift the state upand hold the pending message for each recipient in the parent component. This way, when the child components get removed, it doesn’t matter, because it’s the parent that keeps the important information. This is the most common solution.
- You might also use a different source in addition to React state. For example, you probably want a message draft to persist even if the user accidentally closes the page. To implement this, you could have theChatcomponent initialize its state by reading from thelocalStorage, and save the drafts there too.
No matter which strategy you pick, a chatwith Aliceis conceptually distinct from a chatwith Bob, so it makes sense to give akeyto the<Chat>tree based on the current recipient.


## Recap
- React keeps state for as long as the same component is rendered at the same position.
- State is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.
- You can force a subtree to reset its state by giving it a different key.
- Don’t nest component definitions, or you’ll reset state by accident.

## Try out some challenges

#### Challenge1of5:Fix disappearing input text
This example shows a message when you press the button. However, pressing the button also accidentally resets the input. Why does this happen? Fix it so that pressing the button does not reset the input text.

```jsx
import { useState } from 'react';

export default function App() {
  const [showHint, setShowHint] = useState(false);
  if (showHint) {
    return (
      <div>
        <p><i>Hint: Your favorite city?</i></p>
        <Form />
        <button onClick={() => {
          setShowHint(false);
        }}>Hide hint</button>
      </div>
    );
  }
  return (
    <div>
      <Form />
      <button onClick={() => {
        setShowHint(true);
      }}>Show hint</button>
    </div>
  );
}

function Form() {
  const [text, setText] = useState('');
  return (
    <textarea
      value={text}
      onChange={e => setText(e.target.value)}
    />
  );
}


```


--------------------------------------------------------------------------------


# Extracting State Logic into a Reducer
Source: https://react.dev/learn/extracting-state-logic-into-a-reducer

Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called areducer.


### You will learn
- What a reducer function is
- How to refactoruseStatetouseReducer
- When to use a reducer
- How to write one well

## Consolidate state logic with a reducer
As your components grow in complexity, it can get harder to see at a glance all the different ways in which a component’s state gets updated. For example, theTaskAppcomponent below holds an array oftasksin state and uses three different event handlers to add, remove, and edit tasks:

```jsx
import { useState } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, setTasks] = useState(initialTasks);

  function handleAddTask(text) {
    setTasks([
      ...tasks,
      {
        id: nextId++,
        text: text,
        done: false,
      },
    ]);
  }

  function handleChangeTask(task) {
    setTasks(
      tasks.map((t) => {
        if (t.id === task.id) {
          return task;
        } else {
          return t;
        }
      })
    );
  }

  function handleDeleteTask(taskId) {
    setTasks(tasks.filter((t) => t.id !== taskId));
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  {id: 0, text: 'Visit Kafka Museum', done: true},
  {id: 1, text: 'Watch a puppet show', done: false},
  {id: 2, text: 'Lennon Wall pic', done: false},
];


```

Each of its event handlers callssetTasksin order to update the state. As this component grows, so does the amount of state logic sprinkled throughout it. To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component,called a “reducer”.

Reducers are a different way to handle state. You can migrate fromuseStatetouseReducerin three steps:

- Movefrom setting state to dispatching actions.
- Writea reducer function.
- Usethe reducer from your component.

### Step 1: Move from setting state to dispatching actions
Your event handlers currently specifywhat to doby setting state:

```jsx
function handleAddTask(text) {  setTasks([    ...tasks,    {      id: nextId++,      text: text,      done: false,    },  ]);}function handleChangeTask(task) {  setTasks(    tasks.map((t) => {      if (t.id === task.id) {        return task;      } else {        return t;      }    })  );}function handleDeleteTask(taskId) {  setTasks(tasks.filter((t) => t.id !== taskId));}
```

Remove all the state setting logic. What you are left with are three event handlers:

- handleAddTask(text)is called when the user presses “Add”.
- handleChangeTask(task)is called when the user toggles a task or presses “Save”.
- handleDeleteTask(taskId)is called when the user presses “Delete”.
Managing state with reducers is slightly different from directly setting state. Instead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers. (The state update logic will live elsewhere!) So instead of “settingtasks” via an event handler, you’re dispatching an “added/changed/deleted a task” action. This is more descriptive of the user’s intent.

```jsx
function handleAddTask(text) {  dispatch({    type: 'added',    id: nextId++,    text: text,  });}function handleChangeTask(task) {  dispatch({    type: 'changed',    task: task,  });}function handleDeleteTask(taskId) {  dispatch({    type: 'deleted',    id: taskId,  });}
```

The object you pass todispatchis called an “action”:

```jsx
function handleDeleteTask(taskId) {  dispatch(    // "action" object:    {      type: 'deleted',      id: taskId,    }  );}
```

It is a regular JavaScript object. You decide what to put in it, but generally it should contain the minimal information aboutwhat happened. (You will add thedispatchfunction itself in a later step.)


### Note
An action object can have any shape.

By convention, it is common to give it a stringtypethat describes what happened, and pass any additional information in other fields. Thetypeis specific to a component, so in this example either'added'or'added_task'would be fine. Choose a name that says what happened!

```jsx
dispatch({  // specific to component  type: 'what_happened',  // other fields go here});
```


### Step 2: Write a reducer function
A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:

```jsx
function yourReducer(state, action) {  // return next state for React to set}
```

React will set the state to what you return from the reducer.

To move your state setting logic from your event handlers to a reducer function in this example, you will:

- Declare the current state (tasks) as the first argument.
- Declare theactionobject as the second argument.
- Return thenextstate from the reducer (which React will set the state to).
Here is all the state setting logic migrated to a reducer function:

```jsx
function tasksReducer(tasks, action) {  if (action.type === 'added') {    return [      ...tasks,      {        id: action.id,        text: action.text,        done: false,      },    ];  } else if (action.type === 'changed') {    return tasks.map((t) => {      if (t.id === action.task.id) {        return action.task;      } else {        return t;      }    });  } else if (action.type === 'deleted') {    return tasks.filter((t) => t.id !== action.id);  } else {    throw Error('Unknown action: ' + action.type);  }}
```

Because the reducer function takes state (tasks) as an argument, you candeclare it outside of your component.This decreases the indentation level and can make your code easier to read.


### Note
The code above uses if/else statements, but it’s a convention to useswitch statementsinside reducers. The result is the same, but it can be easier to read switch statements at a glance.

We’ll be using them throughout the rest of this documentation like so:

```jsx
function tasksReducer(tasks, action) {  switch (action.type) {    case 'added': {      return [        ...tasks,        {          id: action.id,          text: action.text,          done: false,        },      ];    }    case 'changed': {      return tasks.map((t) => {        if (t.id === action.task.id) {          return action.task;        } else {          return t;        }      });    }    case 'deleted': {      return tasks.filter((t) => t.id !== action.id);    }    default: {      throw Error('Unknown action: ' + action.type);    }  }}
```

We recommend wrapping eachcaseblock into the{and}curly braces so that variables declared inside of differentcases don’t clash with each other. Also, acaseshould usually end with areturn. If you forget toreturn, the code will “fall through” to the nextcase, which can lead to mistakes!

If you’re not yet comfortable with switch statements, using if/else is completely fine.


#### Why are reducers called this way?
Although reducers can “reduce” the amount of code inside your component, they are actually named after thereduce()operation that you can perform on arrays.

Thereduce()operation lets you take an array and “accumulate” a single value out of many:

```jsx
const arr = [1, 2, 3, 4, 5];const sum = arr.reduce(  (result, number) => result + number); // 1 + 2 + 3 + 4 + 5
```

The function you pass toreduceis known as a “reducer”. It takes theresult so farand thecurrent item,then it returns thenext result.React reducers are an example of the same idea: they take thestate so farand theaction, and return thenext state.In this way, they accumulate actions over time into state.

You could even use thereduce()method with aninitialStateand an array ofactionsto calculate the final state by passing your reducer function to it:

```jsx
import tasksReducer from './tasksReducer.js';

let initialState = [];
let actions = [
  {type: 'added', id: 1, text: 'Visit Kafka Museum'},
  {type: 'added', id: 2, text: 'Watch a puppet show'},
  {type: 'deleted', id: 1},
  {type: 'added', id: 3, text: 'Lennon Wall pic'},
];

let finalState = actions.reduce(tasksReducer, initialState);

const output = document.getElementById('output');
output.textContent = JSON.stringify(finalState, null, 2);


```

You probably won’t need to do this yourself, but this is similar to what React does!


### Step 3: Use the reducer from your component
Finally, you need to hook up thetasksReducerto your component. Import theuseReducerHook from React:

```jsx
import { useReducer } from 'react';
```

Then you can replaceuseState:

```jsx
const [tasks, setTasks] = useState(initialTasks);
```

withuseReducerlike so:

```jsx
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

TheuseReducerHook is similar touseState—you must pass it an initial state and it returns a stateful value and a way to set state (in this case, the dispatch function). But it’s a little different.

TheuseReducerHook takes two arguments:

- A reducer function
- An initial state
And it returns:

- A stateful value
- A dispatch function (to “dispatch” user actions to the reducer)
Now it’s fully wired up! Here, the reducer is declared at the bottom of the component file:

```jsx
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  {id: 0, text: 'Visit Kafka Museum', done: true},
  {id: 1, text: 'Watch a puppet show', done: false},
  {id: 2, text: 'Lennon Wall pic', done: false},
];


```

If you want, you can even move the reducer to a different file:

```jsx
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import tasksReducer from './tasksReducer.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  {id: 0, text: 'Visit Kafka Museum', done: true},
  {id: 1, text: 'Watch a puppet show', done: false},
  {id: 2, text: 'Lennon Wall pic', done: false},
];


```

Component logic can be easier to read when you separate concerns like this. Now the event handlers only specifywhat happenedby dispatching actions, and the reducer function determineshow the state updatesin response to them.


## ComparinguseStateanduseReducer
Reducers are not without downsides! Here’s a few ways you can compare them:

- Code size:Generally, withuseStateyou have to write less code upfront. WithuseReducer, you have to write both a reducer functionanddispatch actions. However,useReducercan help cut down on the code if many event handlers modify state in a similar way.
- Readability:useStateis very easy to read when the state updates are simple. When they get more complex, they can bloat your component’s code and make it difficult to scan. In this case,useReducerlets you cleanly separate thehowof update logic from thewhat happenedof event handlers.
- Debugging:When you have a bug withuseState, it can be difficult to tellwherethe state was set incorrectly, andwhy. WithuseReducer, you can add a console log into your reducer to see every state update, andwhyit happened (due to whichaction). If eachactionis correct, you’ll know that the mistake is in the reducer logic itself. However, you have to step through more code than withuseState.
- Testing:A reducer is a pure function that doesn’t depend on your component. This means that you can export and test it separately in isolation. While generally it’s best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.
- Personal preference:Some people like reducers, others don’t. That’s okay. It’s a matter of preference. You can always convert betweenuseStateanduseReducerback and forth: they are equivalent!
We recommend using a reducer if you often encounter bugs due to incorrect state updates in some component, and want to introduce more structure to its code. You don’t have to use reducers for everything: feel free to mix and match! You can evenuseStateanduseReducerin the same component.


## Writing reducers well
Keep these two tips in mind when writing reducers:

- Reducers must be pure.Similar tostate updater functions, reducers run during rendering! (Actions are queued until the next render.) This means that reducersmust be pure—same inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should updateobjectsandarrayswithout mutations.
- Each action describes a single user interaction, even if that leads to multiple changes in the data.For example, if a user presses “Reset” on a form with five fields managed by a reducer, it makes more sense to dispatch onereset_formaction rather than five separateset_fieldactions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!

## Writing concise reducers with Immer
Just like withupdating objectsandarraysin regular state, you can use the Immer library to make reducers more concise. Here,useImmerReducerlets you mutate the state withpushorarr[i] =assignment:

```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Reducers must be pure, so they shouldn’t mutate state. But Immer provides you with a specialdraftobject which is safe to mutate. Under the hood, Immer will create a copy of your state with the changes you made to thedraft. This is why reducers managed byuseImmerReducercan mutate their first argument and don’t need to return state.


## Recap
- To convert fromuseStatetouseReducer:Dispatch actions from event handlers.Write a reducer function that returns the next state for a given state and action.ReplaceuseStatewithuseReducer.
- Dispatch actions from event handlers.
- Write a reducer function that returns the next state for a given state and action.
- ReplaceuseStatewithuseReducer.
- Reducers require you to write a bit more code, but they help with debugging and testing.
- Reducers must be pure.
- Each action describes a single user interaction.
- Use Immer if you want to write reducers in a mutating style.

## Try out some challenges

#### Challenge1of4:Dispatch actions from event handlers
Currently, the event handlers inContactList.jsandChat.jshave// TODOcomments. This is why typing into the input doesn’t work, and clicking on the buttons doesn’t change the selected recipient.

Replace these two// TODOs with the code todispatchthe corresponding actions. To see the expected shape and the type of the actions, check the reducer inmessengerReducer.js. The reducer is already written so you won’t need to change it. You only need to dispatch the actions inContactList.jsandChat.js.

```jsx
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];


```


--------------------------------------------------------------------------------


# Passing Data Deeply with Context
Source: https://react.dev/learn/passing-data-deeply-with-context

Usually, you will pass information from a parent component to a child component via props. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information.Contextlets the parent component make some information available to any component in the tree below it—no matter how deep—without passing it explicitly through props.


### You will learn
- What “prop drilling” is
- How to replace repetitive prop passing with context
- Common use cases for context
- Common alternatives to context

## The problem with passing props
Passing propsis a great way to explicitly pipe data through your UI tree to the components that use it.

But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. The nearest common ancestor could be far removed from the components that need data, andlifting state upthat high can lead to a situation called “prop drilling”.

Lifting state up

Prop drilling

Wouldn’t it be great if there were a way to “teleport” data to the components in the tree that need it without passing props? With React’s context feature, there is!


## Context: an alternative to passing props
Context lets a parent component provide data to the entire tree below it. There are many uses for context. Here is one example. Consider thisHeadingcomponent that accepts alevelfor its size:

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Heading level={2}>Heading</Heading>
      <Heading level={3}>Sub-heading</Heading>
      <Heading level={4}>Sub-sub-heading</Heading>
      <Heading level={5}>Sub-sub-sub-heading</Heading>
      <Heading level={6}>Sub-sub-sub-sub-heading</Heading>
    </Section>
  );
}


```

Let’s say you want multiple headings within the sameSectionto always have the same size:

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Section>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Section>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Section>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}


```

Currently, you pass thelevelprop to each<Heading>separately:

```jsx
<Section>  <Heading level={3}>About</Heading>  <Heading level={3}>Photos</Heading>  <Heading level={3}>Videos</Heading></Section>
```

It would be nice if you could pass thelevelprop to the<Section>component instead and remove it from the<Heading>. This way you could enforce that all headings in the same section have the same size:

```jsx
<Section level={3}>  <Heading>About</Heading>  <Heading>Photos</Heading>  <Heading>Videos</Heading></Section>
```

But how can the<Heading>component know the level of its closest<Section>?That would require some way for a child to “ask” for data from somewhere above in the tree.

You can’t do it with props alone. This is where context comes into play. You will do it in three steps:

- Createa context. (You can call itLevelContext, since it’s for the heading level.)
- Usethat context from the component that needs the data. (Headingwill useLevelContext.)
- Providethat context from the component that specifies the data. (Sectionwill provideLevelContext.)
Context lets a parent—even a distant one!—provide some data to the entire tree inside of it.

Using context in close children

Using context in distant children


### Step 1: Create the context
First, you need to create the context. You’ll need toexport it from a fileso that your components can use it:

```jsx
import { createContext } from 'react';

export const LevelContext = createContext(1);


```

The only argument tocreateContextis thedefaultvalue. Here,1refers to the biggest heading level, but you could pass any kind of value (even an object). You will see the significance of the default value in the next step.


### Step 2: Use the context
Import theuseContextHook from React and your context:

```jsx
import { useContext } from 'react';import { LevelContext } from './LevelContext.js';
```

Currently, theHeadingcomponent readslevelfrom props:

```jsx
export default function Heading({ level, children }) {  // ...}
```

Instead, remove thelevelprop and read the value from the context you just imported,LevelContext:

```jsx
export default function Heading({ children }) {  const level = useContext(LevelContext);  // ...}
```

useContextis a Hook. Just likeuseStateanduseReducer, you can only call a Hook immediately inside a React component (not inside loops or conditions).useContexttells React that theHeadingcomponent wants to read theLevelContext.

Now that theHeadingcomponent doesn’t have alevelprop, you don’t need to pass the level prop toHeadingin your JSX like this anymore:

```jsx
<Section>  <Heading level={4}>Sub-sub-heading</Heading>  <Heading level={4}>Sub-sub-heading</Heading>  <Heading level={4}>Sub-sub-heading</Heading></Section>
```

Update the JSX so that it’s theSectionthat receives it instead:

```jsx
<Section level={4}>  <Heading>Sub-sub-heading</Heading>  <Heading>Sub-sub-heading</Heading>  <Heading>Sub-sub-heading</Heading></Section>
```

As a reminder, this is the markup that you were trying to get working:

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}


```

Notice this example doesn’t quite work, yet! All the headings have the same size becauseeven though you’reusingthe context, you have notprovidedit yet.React doesn’t know where to get it!

If you don’t provide the context, React will use the default value you’ve specified in the previous step. In this example, you specified1as the argument tocreateContext, souseContext(LevelContext)returns1, setting all those headings to<h1>. Let’s fix this problem by having eachSectionprovide its own context.


### Step 3: Provide the context
TheSectioncomponent currently renders its children:

```jsx
export default function Section({ children }) {  return (    <section className="section">      {children}    </section>  );}
```

Wrap them with a context providerto provide theLevelContextto them:

```jsx
import { LevelContext } from './LevelContext.js';export default function Section({ level, children }) {  return (    <section className="section">      <LevelContext value={level}>        {children}      </LevelContext>    </section>  );}
```

This tells React: “if any component inside this<Section>asks forLevelContext, give them thislevel.” The component will use the value of the nearest<LevelContext>in the UI tree above it.

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}


```

It’s the same result as the original code, but you did not need to pass thelevelprop to eachHeadingcomponent! Instead, it “figures out” its heading level by asking the closestSectionabove:

- You pass alevelprop to the<Section>.
- Sectionwraps its children into<LevelContext value={level}>.
- Headingasks the closest value ofLevelContextabove withuseContext(LevelContext).

## Using and providing context from the same component
Currently, you still have to specify each section’slevelmanually:

```jsx
export default function Page() {  return (    <Section level={1}>      ...      <Section level={2}>        ...        <Section level={3}>          ...
```

Since context lets you read information from a component above, eachSectioncould read thelevelfrom theSectionabove, and passlevel + 1down automatically. Here is how you could do it:

```jsx
import { useContext } from 'react';import { LevelContext } from './LevelContext.js';export default function Section({ children }) {  const level = useContext(LevelContext);  return (    <section className="section">      <LevelContext value={level + 1}>        {children}      </LevelContext>    </section>  );}
```

With this change, you don’t need to pass thelevelpropeitherto the<Section>or to the<Heading>:

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading>Title</Heading>
      <Section>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}


```

Now bothHeadingandSectionread theLevelContextto figure out how “deep” they are. And theSectionwraps its children into theLevelContextto specify that anything inside of it is at a “deeper” level.


### Note
This example uses heading levels because they show visually how nested components can override context. But context is useful for many other use cases too. You can pass down any information needed by the entire subtree: the current color theme, the currently logged in user, and so on.


## Context passes through intermediate components
You can insert as many components as you like between the component that provides context and the one that uses it. This includes both built-in components like<div>and components you might build yourself.

In this example, the samePostcomponent (with a dashed border) is rendered at two different nesting levels. Notice that the<Heading>inside of it gets its level automatically from the closest<Section>:

```jsx
import Heading from './Heading.js';
import Section from './Section.js';

export default function ProfilePage() {
  return (
    <Section>
      <Heading>My Profile</Heading>
      <Post
        title="Hello traveller!"
        body="Read about my adventures."
      />
      <AllPosts />
    </Section>
  );
}

function AllPosts() {
  return (
    <Section>
      <Heading>Posts</Heading>
      <RecentPosts />
    </Section>
  );
}

function RecentPosts() {
  return (
    <Section>
      <Heading>Recent Posts</Heading>
      <Post
        title="Flavors of Lisbon"
        body="...those pastéis de nata!"
      />
      <Post
        title="Buenos Aires in the rhythm of tango"
        body="I loved it!"
      />
    </Section>
  );
}

function Post({ title, body }) {
  return (
    <Section isFancy={true}>
      <Heading>
        {title}
      </Heading>
      <p><i>{body}</i></p>
    </Section>
  );
}


```

You didn’t do anything special for this to work. ASectionspecifies the context for the tree inside it, so you can insert a<Heading>anywhere, and it will have the correct size. Try it in the sandbox above!

Context lets you write components that “adapt to their surroundings” and display themselves differently depending onwhere(or, in other words,in which context) they are being rendered.

How context works might remind you ofCSS property inheritance.In CSS, you can specifycolor: bluefor a<div>, and any DOM node inside of it, no matter how deep, will inherit that color unless some other DOM node in the middle overrides it withcolor: green. Similarly, in React, the only way to override some context coming from above is to wrap children into a context provider with a different value.

In CSS, different properties likecolorandbackground-colordon’t override each other. You can set all<div>’scolorto red without impactingbackground-color. Similarly,different React contexts don’t override each other.Each context that you make withcreateContext()is completely separate from other ones, and ties together components using and providingthat particularcontext. One component may use or provide many different contexts without a problem.


## Before you use context
Context is very tempting to use! However, this also means it’s too easy to overuse it.Just because you need to pass some props several levels deep doesn’t mean you should put that information into context.

Here’s a few alternatives you should consider before using context:

- Start bypassing props.If your components are not trivial, it’s not unusual to pass a dozen props down through a dozen components. It may feel like a slog, but it makes it very clear which components use which data! The person maintaining your code will be glad you’ve made the data flow explicit with props.
- Extract components andpass JSX aschildrento them.If you pass some data through many layers of intermediate components that don’t use that data (and only pass it further down), this often means that you forgot to extract some components along the way. For example, maybe you pass data props likepoststo visual components that don’t use them directly, like<Layout posts={posts} />. Instead, makeLayouttakechildrenas a prop, and render<Layout><Posts posts={posts} /></Layout>. This reduces the number of layers between the component specifying the data and the one that needs it.
If neither of these approaches works well for you, consider context.


## Use cases for context
- Theming:If your app lets the user change its appearance (e.g. dark mode), you can put a context provider at the top of your app, and use that context in components that need to adjust their visual look.
- Current account:Many components might need to know the currently logged in user. Putting it in context makes it convenient to read it anywhere in the tree. Some apps also let you operate multiple accounts at the same time (e.g. to leave a comment as a different user). In those cases, it can be convenient to wrap a part of the UI into a nested provider with a different current account value.
- Routing:Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.
- Managing state:As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common touse a reducer together with contextto manage complex state and pass it down to distant components without too much hassle.
Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state.

In general, if some information is needed by distant components in different parts of the tree, it’s a good indication that context will help you.


## Recap
- Context lets a component provide some information to the entire tree below it.
- To pass context:Create and export it withexport const MyContext = createContext(defaultValue).Pass it to theuseContext(MyContext)Hook to read it in any child component, no matter how deep.Wrap children into<MyContext value={...}>to provide it from a parent.
- Create and export it withexport const MyContext = createContext(defaultValue).
- Pass it to theuseContext(MyContext)Hook to read it in any child component, no matter how deep.
- Wrap children into<MyContext value={...}>to provide it from a parent.
- Context passes through any components in the middle.
- Context lets you write components that “adapt to their surroundings”.
- Before you use context, try passing props or passing JSX aschildren.

## Try out some challenges

#### Challenge1of1:Replace prop drilling with context
In this example, toggling the checkbox changes theimageSizeprop passed to each<PlaceImage>. The checkbox state is held in the top-levelAppcomponent, but each<PlaceImage>needs to be aware of it.

Currently,ApppassesimageSizetoList, which passes it to eachPlace, which passes it to thePlaceImage. Remove theimageSizeprop, and instead pass it from theAppcomponent directly toPlaceImage.

You can declare context inContext.js.

```jsx
import { useState } from 'react';
import { places } from './data.js';
import { getImageUrl } from './utils.js';

export default function App() {
  const [isLarge, setIsLarge] = useState(false);
  const imageSize = isLarge ? 150 : 100;
  return (
    <>
      <label>
        <input
          type="checkbox"
          checked={isLarge}
          onChange={e => {
            setIsLarge(e.target.checked);
          }}
        />
        Use large images
      </label>
      <hr />
      <List imageSize={imageSize} />
    </>
  )
}

function List({ imageSize }) {
  const listItems = places.map(place =>
    <li key={place.id}>
      <Place
        place={place}
        imageSize={imageSize}
      />
    </li>
  );
  return <ul>{listItems}</ul>;
}

function Place({ place, imageSize }) {
  return (
    <>
      <PlaceImage
        place={place}
        imageSize={imageSize}
      />
      <p>
        <b>{place.name}</b>
        {': ' + place.description}
      </p>
    </>
  );
}

function PlaceImage({ place, imageSize }) {
  return (
    <img
      src={getImageUrl(place)}
      alt={place.name}
      width={imageSize}
      height={imageSize}
    />
  );
}


```


--------------------------------------------------------------------------------


# Scaling Up with Reducer and Context
Source: https://react.dev/learn/scaling-up-with-reducer-and-context

Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.


### You will learn
- How to combine a reducer with context
- How to avoid passing state and dispatch through props
- How to keep context and state logic in a separate file

## Combining a reducer with context
In this example fromthe introduction to reducers, the state is managed by a reducer. The reducer function contains all of the state update logic and is declared at the bottom of this file:

```jsx
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <>
      <h1>Day off in Kyoto</h1>
      <AddTask
        onAddTask={handleAddTask}
      />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Philosopher’s Path', done: true },
  { id: 1, text: 'Visit the temple', done: false },
  { id: 2, text: 'Drink matcha', done: false }
];


```

A reducer helps keep the event handlers short and concise. However, as your app grows, you might run into another difficulty.Currently, thetasksstate and thedispatchfunction are only available in the top-levelTaskAppcomponent.To let other components read the list of tasks or change it, you have to explicitlypass downthe current state and the event handlers that change it as props.

For example,TaskApppasses a list of tasks and the event handlers toTaskList:

```jsx
<TaskList  tasks={tasks}  onChangeTask={handleChangeTask}  onDeleteTask={handleDeleteTask}/>
```

AndTaskListpasses the event handlers toTask:

```jsx
<Task  task={task}  onChange={onChangeTask}  onDelete={onDeleteTask}/>
```

In a small example like this, this works well, but if you have tens or hundreds of components in the middle, passing down all state and functions can be quite frustrating!

This is why, as an alternative to passing them through props, you might want to put both thetasksstate and thedispatchfunctioninto context.This way, any component belowTaskAppin the tree can read the tasks and dispatch actions without the repetitive “prop drilling”.

Here is how you can combine a reducer with context:

- Createthe context.
- Putstate and dispatch into context.
- Usecontext anywhere in the tree.

### Step 1: Create the context
TheuseReducerHook returns the currenttasksand thedispatchfunction that lets you update them:

```jsx
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

To pass them down the tree, you willcreatetwo separate contexts:

- TasksContextprovides the current list of tasks.
- TasksDispatchContextprovides the function that lets components dispatch actions.
Export them from a separate file so that you can later import them from other files:

```jsx
import { createContext } from 'react';

export const TasksContext = createContext(null);
export const TasksDispatchContext = createContext(null);


```

Here, you’re passingnullas the default value to both contexts. The actual values will be provided by theTaskAppcomponent.


### Step 2: Put state and dispatch into context
Now you can import both contexts in yourTaskAppcomponent. Take thetasksanddispatchreturned byuseReducer()andprovide themto the entire tree below:

```jsx
import { TasksContext, TasksDispatchContext } from './TasksContext.js';export default function TaskApp() {  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);  // ...  return (    <TasksContext value={tasks}>      <TasksDispatchContext value={dispatch}>        ...      </TasksDispatchContext>    </TasksContext>  );}
```

For now, you pass the information both via props and in context:

```jsx
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <TasksContext value={tasks}>
      <TasksDispatchContext value={dispatch}>
        <h1>Day off in Kyoto</h1>
        <AddTask
          onAddTask={handleAddTask}
        />
        <TaskList
          tasks={tasks}
          onChangeTask={handleChangeTask}
          onDeleteTask={handleDeleteTask}
        />
      </TasksDispatchContext>
    </TasksContext>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Philosopher’s Path', done: true },
  { id: 1, text: 'Visit the temple', done: false },
  { id: 2, text: 'Drink matcha', done: false }
];


```

In the next step, you will remove prop passing.


### Step 3: Use context anywhere in the tree
Now you don’t need to pass the list of tasks or the event handlers down the tree:

```jsx
<TasksContext value={tasks}>  <TasksDispatchContext value={dispatch}>    <h1>Day off in Kyoto</h1>    <AddTask />    <TaskList />  </TasksDispatchContext></TasksContext>
```

Instead, any component that needs the task list can read it from theTasksContext:

```jsx
export default function TaskList() {  const tasks = useContext(TasksContext);  // ...
```

To update the task list, any component can read thedispatchfunction from context and call it:

```jsx
export default function AddTask() {  const [text, setText] = useState('');  const dispatch = useContext(TasksDispatchContext);  // ...  return (    // ...    <button onClick={() => {      setText('');      dispatch({        type: 'added',        id: nextId++,        text: text,      });    }}>Add</button>    // ...
```

TheTaskAppcomponent does not pass any event handlers down, and theTaskListdoes not pass any event handlers to theTaskcomponent either.Each component reads the context that it needs:

```jsx
import { useState, useContext } from 'react';
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskList() {
  const tasks = useContext(TasksContext);
  return (
    <ul>
      {tasks.map(task => (
        <li key={task.id}>
          <Task task={task} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task }) {
  const [isEditing, setIsEditing] = useState(false);
  const dispatch = useContext(TasksDispatchContext);
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={e => {
            dispatch({
              type: 'changed',
              task: {
                ...task,
                text: e.target.value
              }
            });
          }} />
        <button onClick={() => setIsEditing(false)}>
          Save
        </button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>
          Edit
        </button>
      </>
    );
  }
  return (
    <label>
      <input
        type="checkbox"
        checked={task.done}
        onChange={e => {
          dispatch({
            type: 'changed',
            task: {
              ...task,
              done: e.target.checked
            }
          });
        }}
      />
      {taskContent}
      <button onClick={() => {
        dispatch({
          type: 'deleted',
          id: task.id
        });
      }}>
        Delete
      </button>
    </label>
  );
}


```

The state still “lives” in the top-levelTaskAppcomponent, managed withuseReducer.But itstasksanddispatchare now available to every component below in the tree by importing and using these contexts.


## Moving all wiring into a single file
You don’t have to do this, but you could further declutter the components by moving both reducer and context into a single file. Currently,TasksContext.jscontains only two context declarations:

```jsx
import { createContext } from 'react';export const TasksContext = createContext(null);export const TasksDispatchContext = createContext(null);
```

This file is about to get crowded! You’ll move the reducer into that same file. Then you’ll declare a newTasksProvidercomponent in the same file. This component will tie all the pieces together:

- It will manage the state with a reducer.
- It will provide both contexts to components below.
- It willtakechildrenas a propso you can pass JSX to it.
```jsx
export function TasksProvider({ children }) {  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);  return (    <TasksContext value={tasks}>      <TasksDispatchContext value={dispatch}>        {children}      </TasksDispatchContext>    </TasksContext>  );}
```

This removes all the complexity and wiring from yourTaskAppcomponent:

```jsx
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksProvider } from './TasksContext.js';

export default function TaskApp() {
  return (
    <TasksProvider>
      <h1>Day off in Kyoto</h1>
      <AddTask />
      <TaskList />
    </TasksProvider>
  );
}


```

You can also export functions thatusethe context fromTasksContext.js:

```jsx
export function useTasks() {  return useContext(TasksContext);}export function useTasksDispatch() {  return useContext(TasksDispatchContext);}
```

When a component needs to read context, it can do it through these functions:

```jsx
const tasks = useTasks();const dispatch = useTasksDispatch();
```

This doesn’t change the behavior in any way, but it lets you later split these contexts further or add some logic to these functions.Now all of the context and reducer wiring is inTasksContext.js. This keeps the components clean and uncluttered, focused on what they display rather than where they get the data:

```jsx
import { useState } from 'react';
import { useTasks, useTasksDispatch } from './TasksContext.js';

export default function TaskList() {
  const tasks = useTasks();
  return (
    <ul>
      {tasks.map(task => (
        <li key={task.id}>
          <Task task={task} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task }) {
  const [isEditing, setIsEditing] = useState(false);
  const dispatch = useTasksDispatch();
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={e => {
            dispatch({
              type: 'changed',
              task: {
                ...task,
                text: e.target.value
              }
            });
          }} />
        <button onClick={() => setIsEditing(false)}>
          Save
        </button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>
          Edit
        </button>
      </>
    );
  }
  return (
    <label>
      <input
        type="checkbox"
        checked={task.done}
        onChange={e => {
          dispatch({
            type: 'changed',
            task: {
              ...task,
              done: e.target.checked
            }
          });
        }}
      />
      {taskContent}
      <button onClick={() => {
        dispatch({
          type: 'deleted',
          id: task.id
        });
      }}>
        Delete
      </button>
    </label>
  );
}


```

You can think ofTasksProvideras a part of the screen that knows how to deal with tasks,useTasksas a way to read them, anduseTasksDispatchas a way to update them from any component below in the tree.


### Note
Functions likeuseTasksanduseTasksDispatchare calledCustom Hooks.Your function is considered a custom Hook if its name starts withuse. This lets you use other Hooks, likeuseContext, inside it.

As your app grows, you may have many context-reducer pairs like this. This is a powerful way to scale your app andlift state upwithout too much work whenever you want to access the data deep in the tree.


## Recap
- You can combine reducer with context to let any component read and update state above it.
- To provide state and the dispatch function to components below:Create two contexts (for state and for dispatch functions).Provide both contexts from the component that uses the reducer.Use either context from components that need to read them.
- Create two contexts (for state and for dispatch functions).
- Provide both contexts from the component that uses the reducer.
- Use either context from components that need to read them.
- You can further declutter the components by moving all wiring into one file.You can export a component likeTasksProviderthat provides context.You can also export custom Hooks likeuseTasksanduseTasksDispatchto read it.
- You can export a component likeTasksProviderthat provides context.
- You can also export custom Hooks likeuseTasksanduseTasksDispatchto read it.
- You can have many context-reducer pairs like this in your app.

--------------------------------------------------------------------------------


# Escape Hatches
Source: https://react.dev/learn/escape-hatches

Some of your components may need to control and synchronize with systems outside of React. For example, you might need to focus an input using the browser API, play and pause a video player implemented without React, or connect and listen to messages from a remote server. In this chapter, you’ll learn the escape hatches that let you “step outside” React and connect to external systems. Most of your application logic and data flow should not rely on these features.


### In this chapter
- How to “remember” information without re-rendering
- How to access DOM elements managed by React
- How to synchronize components with external systems
- How to remove unnecessary Effects from your components
- How an Effect’s lifecycle is different from a component’s
- How to prevent some values from re-triggering Effects
- How to make your Effect re-run less often
- How to share logic between components

## Referencing values with refs
When you want a component to “remember” some information, but you don’t want that information totrigger new renders, you can use aref:

```jsx
const ref = useRef(0);
```

Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not! You can access the current value of that ref through theref.currentproperty.

```jsx
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}


```

A ref is like a secret pocket of your component that React doesn’t track. For example, you can use refs to storetimeout IDs,DOM elements, and other objects that don’t impact the component’s rendering output.


## Ready to learn this topic?
ReadReferencing Values with Refsto learn how to use refs to remember information.


## Manipulating the DOM with refs
React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node. For example, clicking the button will focus the input using a ref:

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


```


## Ready to learn this topic?
ReadManipulating the DOM with Refsto learn how to access DOM elements managed by React.


## Synchronizing with Effects
Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Unlike event handlers, which let you handle particular events,Effectslet you run some code after rendering. Use them to synchronize your component with a system outside of React.

Press Play/Pause a few times and see how the video player stays synchronized to theisPlayingprop value:

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


```

Many Effects also “clean up” after themselves. For example, an Effect that sets up a connection to a chat server should return acleanup functionthat tells React how to disconnect your component from that server:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}


```

In development, React will immediately run and clean up your Effect one extra time. This is why you see"✅ Connecting..."printed twice. This ensures that you don’t forget to implement the cleanup function.


## Ready to learn this topic?
ReadSynchronizing with Effectsto learn how to synchronize components with external systems.


## You Might Not Need An Effect
Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.

There are two common cases in which you don’t need Effects:

- You don’t need Effects to transform data for rendering.
- You don’t need Effects to handle user events.
For example, you don’t need an Effect to adjust some state based on other state:

```jsx
function Form() {  const [firstName, setFirstName] = useState('Taylor');  const [lastName, setLastName] = useState('Swift');  // 🔴 Avoid: redundant state and unnecessary Effect  const [fullName, setFullName] = useState('');  useEffect(() => {    setFullName(firstName + ' ' + lastName);  }, [firstName, lastName]);  // ...}
```

Instead, calculate as much as you can while rendering:

```jsx
function Form() {  const [firstName, setFirstName] = useState('Taylor');  const [lastName, setLastName] = useState('Swift');  // ✅ Good: calculated during rendering  const fullName = firstName + ' ' + lastName;  // ...}
```

However, youdoneed Effects to synchronize with external systems.


## Ready to learn this topic?
ReadYou Might Not Need an Effectto learn how to remove unnecessary Effects.


## Lifecycle of reactive effects
Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time.

This Effect depends on the value of theroomIdprop. Props arereactive values,which means they can change on a re-render. Notice that the Effectre-synchronizes(and re-connects to the server) ifroomIdchanges:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. If you forget to specifyroomIdin the list of dependencies in the above example, the linter will find that bug automatically.


## Ready to learn this topic?
ReadLifecycle of Reactive Eventsto learn how an Effect’s lifecycle is different from a component’s.


## Separating events from Effects
Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if any of the values they read, like props or state, are different than during last render. Sometimes, you want a mix of both behaviors: an Effect that re-runs in response to some values but not others.

All code inside Effects isreactive.It will run again if some reactive value it reads has changed due to a re-render. For example, this Effect will re-connect to the chat if eitherroomIdorthemehave changed:

```jsx
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'} 
      />
    </>
  );
}


```

This is not ideal. You want to re-connect to the chat only if theroomIdhas changed. Switching thethemeshouldn’t re-connect to the chat! Move the code readingthemeout of your Effect into anEffect Event:

```jsx
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'} 
      />
    </>
  );
}


```

Code inside Effect Events isn’t reactive, so changing thethemeno longer makes your Effect re-connect.


## Ready to learn this topic?
ReadSeparating Events from Effectsto learn how to prevent some values from re-triggering Effects.


## Removing Effect dependencies
When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. The way you remove them depends on the case.

For example, this Effect depends on theoptionsobject which gets re-created every time you edit the input:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

You don’t want the chat to re-connect every time you start typing a message in that chat. To fix this problem, move creation of theoptionsobject inside the Effect so that the Effect only depends on theroomIdstring:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

Notice that you didn’t start by editing the dependency list to remove theoptionsdependency. That would be wrong. Instead, you changed the surrounding code so that the dependency becameunnecessary.Think of the dependency list as a list of all the reactive values used by your Effect’s code. You don’t intentionally choose what to put on that list. The list describes your code. To change the dependency list, change the code.


## Ready to learn this topic?
ReadRemoving Effect Dependenciesto learn how to make your Effect re-run less often.


## Reusing logic with custom Hooks
React comes with built-in Hooks likeuseState,useContext, anduseEffect. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. To do this, you can create your own Hooks for your application’s needs.

In this example, theusePointerPositioncustom Hook tracks the cursor position, whileuseDelayedValuecustom Hook returns a value that’s “lagging behind” the value you passed by a certain number of milliseconds. Move the cursor over the sandbox preview area to see a moving trail of dots following the cursor:

```jsx
import { usePointerPosition } from './usePointerPosition.js';
import { useDelayedValue } from './useDelayedValue.js';

export default function Canvas() {
  const pos1 = usePointerPosition();
  const pos2 = useDelayedValue(pos1, 100);
  const pos3 = useDelayedValue(pos2, 200);
  const pos4 = useDelayedValue(pos3, 100);
  const pos5 = useDelayedValue(pos4, 50);
  return (
    <>
      <Dot position={pos1} opacity={1} />
      <Dot position={pos2} opacity={0.8} />
      <Dot position={pos3} opacity={0.6} />
      <Dot position={pos4} opacity={0.4} />
      <Dot position={pos5} opacity={0.2} />
    </>
  );
}

function Dot({ position, opacity }) {
  return (
    <div style={{
      position: 'absolute',
      backgroundColor: 'pink',
      borderRadius: '50%',
      opacity,
      transform: `translate(${position.x}px, ${position.y}px)`,
      pointerEvents: 'none',
      left: -20,
      top: -20,
      width: 40,
      height: 40,
    }} />
  );
}


```

You can create custom Hooks, compose them together, pass data between them, and reuse them between components. As your app grows, you will write fewer Effects by hand because you’ll be able to reuse custom Hooks you already wrote. There are also many excellent custom Hooks maintained by the React community.


## Ready to learn this topic?
ReadReusing Logic with Custom Hooksto learn how to share logic between components.


## What’s next?
Head over toReferencing Values with Refsto start reading this chapter page by page!


--------------------------------------------------------------------------------


# Referencing Values with Refs
Source: https://react.dev/learn/referencing-values-with-refs

When you want a component to “remember” some information, but you don’t want that information totrigger new renders, you can use aref.


### You will learn
- How to add a ref to your component
- How to update a ref’s value
- How refs are different from state
- How to use refs safely

## Adding a ref to your component
You can add a ref to your component by importing theuseRefHook from React:

```jsx
import { useRef } from 'react';
```

Inside your component, call theuseRefHook and pass the initial value that you want to reference as the only argument. For example, here is a ref to the value0:

```jsx
const ref = useRef(0);
```

useRefreturns an object like this:

```jsx
{   current: 0 // The value you passed to useRef}
```

Illustrated byRachel Lee Nabors

You can access the current value of that ref through theref.currentproperty. This value is intentionally mutable, meaning you can both read and write to it. It’s like a secret pocket of your component that React doesn’t track. (This is what makes it an “escape hatch” from React’s one-way data flow—more on that below!)

Here, a button will incrementref.currenton every click:

```jsx
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}


```

The ref points to a number, but, likestate, you could point to anything: a string, an object, or even a function. Unlike state, ref is a plain JavaScript object with thecurrentproperty that you can read and modify.

Note thatthe component doesn’t re-render with every increment.Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!


## Example: building a stopwatch
You can combine refs and state in a single component. For example, let’s make a stopwatch that the user can start or stop by pressing a button. In order to display how much time has passed since the user pressed “Start”, you will need to keep track of when the Start button was pressed and what the current time is.This information is used for rendering, so you’ll keep it in state:

```jsx
const [startTime, setStartTime] = useState(null);const [now, setNow] = useState(null);
```

When the user presses “Start”, you’ll usesetIntervalin order to update the time every 10 milliseconds:

```jsx
import { useState } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  function handleStart() {
    // Start counting.
    setStartTime(Date.now());
    setNow(Date.now());

    setInterval(() => {
      // Update the current time every 10ms.
      setNow(Date.now());
    }, 10);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>
        Start
      </button>
    </>
  );
}


```

When the “Stop” button is pressed, you need to cancel the existing interval so that it stops updating thenowstate variable. You can do this by callingclearInterval, but you need to give it the interval ID that was previously returned by thesetIntervalcall when the user pressed Start. You need to keep the interval ID somewhere.Since the interval ID is not used for rendering, you can keep it in a ref:

```jsx
import { useState, useRef } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>
        Start
      </button>
      <button onClick={handleStop}>
        Stop
      </button>
    </>
  );
}


```

When a piece of information is used for rendering, keep it in state. When a piece of information is only needed by event handlers and changing it doesn’t require a re-render, using a ref may be more efficient.


## Differences between refs and state
Perhaps you’re thinking refs seem less “strict” than state—you can mutate them instead of always having to use a state setting function, for instance. But in most cases, you’ll want to use state. Refs are an “escape hatch” you won’t need often. Here’s how state and refs compare:

Here is a counter button that’s implemented with state:

```jsx
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      You clicked {count} times
    </button>
  );
}


```

Because thecountvalue is displayed, it makes sense to use a state value for it. When the counter’s value is set withsetCount(), React re-renders the component and the screen updates to reflect the new count.

If you tried to implement this with a ref, React would never re-render the component, so you’d never see the count change! See how clicking this buttondoes not update its text:

```jsx
import { useRef } from 'react';

export default function Counter() {
  let countRef = useRef(0);

  function handleClick() {
    // This doesn't re-render the component!
    countRef.current = countRef.current + 1;
  }

  return (
    <button onClick={handleClick}>
      You clicked {countRef.current} times
    </button>
  );
}


```

This is why readingref.currentduring render leads to unreliable code. If you need that, use state instead.


#### How does useRef work inside?
Although bothuseStateanduseRefare provided by React, in principleuseRefcould be implementedon top ofuseState. You can imagine that inside of React,useRefis implemented like this:

```jsx
// Inside of Reactfunction useRef(initialValue) {  const [ref, unused] = useState({ current: initialValue });  return ref;}
```

During the first render,useRefreturns{ current: initialValue }. This object is stored by React, so during the next render the same object will be returned. Note how the state setter is unused in this example. It is unnecessary becauseuseRefalways needs to return the same object!

React provides a built-in version ofuseRefbecause it is common enough in practice. But you can think of it as a regular state variable without a setter. If you’re familiar with object-oriented programming, refs might remind you of instance fields—but instead ofthis.somethingyou writesomethingRef.current.


## When to use refs
Typically, you will use a ref when your component needs to “step outside” React and communicate with external APIs—often a browser API that won’t impact the appearance of the component. Here are a few of these rare situations:

- Storingtimeout IDs
- Storing and manipulatingDOM elements, which we cover onthe next page
- Storing other objects that aren’t necessary to calculate the JSX.
If your component needs to store some value, but it doesn’t impact the rendering logic, choose refs.


## Best practices for refs
Following these principles will make your components more predictable:

- Treat refs as an escape hatch.Refs are useful when you work with external systems or browser APIs. If much of your application logic and data flow relies on refs, you might want to rethink your approach.
- Don’t read or writeref.currentduring rendering.If some information is needed during rendering, usestateinstead. Since React doesn’t know whenref.currentchanges, even reading it while rendering makes your component’s behavior difficult to predict. (The only exception to this is code likeif (!ref.current) ref.current = new Thing()which only sets the ref once during the first render.)
Limitations of React state don’t apply to refs. For example, state acts like asnapshot for every renderanddoesn’t update synchronously.But when you mutate the current value of a ref, it changes immediately:

```jsx
ref.current = 5;console.log(ref.current); // 5
```

This is becausethe ref itself is a regular JavaScript object,and so it behaves like one.

You also don’t need to worry aboutavoiding mutationwhen you work with a ref. As long as the object you’re mutating isn’t used for rendering, React doesn’t care what you do with the ref or its contents.


## Refs and the DOM
You can point a ref to any value. However, the most common use case for a ref is to access a DOM element. For example, this is handy if you want to focus an input programmatically. When you pass a ref to arefattribute in JSX, like<div ref={myRef}>, React will put the corresponding DOM element intomyRef.current. Once the element is removed from the DOM, React will updatemyRef.currentto benull. You can read more about this inManipulating the DOM with Refs.


## Recap
- Refs are an escape hatch to hold onto values that aren’t used for rendering. You won’t need them often.
- A ref is a plain JavaScript object with a single property calledcurrent, which you can read or set.
- You can ask React to give you a ref by calling theuseRefHook.
- Like state, refs let you retain information between re-renders of a component.
- Unlike state, setting the ref’scurrentvalue does not trigger a re-render.
- Don’t read or writeref.currentduring rendering. This makes your component hard to predict.

## Try out some challenges

#### Challenge1of4:Fix a broken chat input
Type a message and click “Send”. You will notice there is a three second delay before you see the “Sent!” alert. During this delay, you can see an “Undo” button. Click it. This “Undo” button is supposed to stop the “Sent!” message from appearing. It does this by callingclearTimeoutfor the timeout ID saved duringhandleSend. However, even after “Undo” is clicked, the “Sent!” message still appears. Find why it doesn’t work, and fix it.

```jsx
import { useState } from 'react';

export default function Chat() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  let timeoutID = null;

  function handleSend() {
    setIsSending(true);
    timeoutID = setTimeout(() => {
      alert('Sent!');
      setIsSending(false);
    }, 3000);
  }

  function handleUndo() {
    setIsSending(false);
    clearTimeout(timeoutID);
  }

  return (
    <>
      <input
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button
        disabled={isSending}
        onClick={handleSend}>
        {isSending ? 'Sending...' : 'Send'}
      </button>
      {isSending &&
        <button onClick={handleUndo}>
          Undo
        </button>
      }
    </>
  );
}


```


--------------------------------------------------------------------------------


# Manipulating the DOM with Refs
Source: https://react.dev/learn/manipulating-the-dom-with-refs

React automatically updates theDOMto match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need arefto the DOM node.


### You will learn
- How to access a DOM node managed by React with therefattribute
- How therefJSX attribute relates to theuseRefHook
- How to access another component’s DOM node
- In which cases it’s safe to modify the DOM managed by React

## Getting a ref to the node
To access a DOM node managed by React, first, import theuseRefHook:

```jsx
import { useRef } from 'react';
```

Then, use it to declare a ref inside your component:

```jsx
const myRef = useRef(null);
```

Finally, pass your ref as therefattribute to the JSX tag for which you want to get the DOM node:

```jsx
<div ref={myRef}>
```

TheuseRefHook returns an object with a single property calledcurrent. Initially,myRef.currentwill benull. When React creates a DOM node for this<div>, React will put a reference to this node intomyRef.current. You can then access this DOM node from yourevent handlersand use the built-inbrowser APIsdefined on it.

```jsx
// You can use any browser APIs, for example:myRef.current.scrollIntoView();
```


### Example: Focusing a text input
In this example, clicking the button will focus the input:

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


```

To implement this:

- DeclareinputRefwith theuseRefHook.
- Pass it as<input ref={inputRef}>. This tells React toput this<input>’s DOM node intoinputRef.current.
- In thehandleClickfunction, read the input DOM node frominputRef.currentand callfocus()on it withinputRef.current.focus().
- Pass thehandleClickevent handler to<button>withonClick.
While DOM manipulation is the most common use case for refs, theuseRefHook can be used for storing other things outside React, like timer IDs. Similarly to state, refs remain between renders. Refs are like state variables that don’t trigger re-renders when you set them. Read about refs inReferencing Values with Refs.


### Example: Scrolling to an element
You can have more than a single ref in a component. In this example, there is a carousel of three images. Each button centers an image by calling the browserscrollIntoView()method on the corresponding DOM node:

```jsx
import { useRef } from 'react';

export default function CatFriends() {
  const firstCatRef = useRef(null);
  const secondCatRef = useRef(null);
  const thirdCatRef = useRef(null);

  function handleScrollToFirstCat() {
    firstCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function handleScrollToSecondCat() {
    secondCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function handleScrollToThirdCat() {
    thirdCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  return (
    <>
      <nav>
        <button onClick={handleScrollToFirstCat}>
          Neo
        </button>
        <button onClick={handleScrollToSecondCat}>
          Millie
        </button>
        <button onClick={handleScrollToThirdCat}>
          Bella
        </button>
      </nav>
      <div>
        <ul>
          <li>
            <img
              src="https://placecats.com/neo/300/200"
              alt="Neo"
              ref={firstCatRef}
            />
          </li>
          <li>
            <img
              src="https://placecats.com/millie/200/200"
              alt="Millie"
              ref={secondCatRef}
            />
          </li>
          <li>
            <img
              src="https://placecats.com/bella/199/200"
              alt="Bella"
              ref={thirdCatRef}
            />
          </li>
        </ul>
      </div>
    </>
  );
}


```


#### How to manage a list of refs using a ref callback
In the above examples, there is a predefined number of refs. However, sometimes you might need a ref to each item in the list, and you don’t know how many you will have. Something like thiswouldn’t work:

```jsx
<ul>  {items.map((item) => {    // Doesn't work!    const ref = useRef(null);    return <li ref={ref} />;  })}</ul>
```

This is becauseHooks must only be called at the top-level of your component.You can’t calluseRefin a loop, in a condition, or inside amap()call.

One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods likequerySelectorAllto “find” the individual child nodes from it. However, this is brittle and can break if your DOM structure changes.

Another solution is topass a function to therefattribute.This is called arefcallback.React will call your ref callback with the DOM node when it’s time to set the ref, and call the cleanup function returned from the callback when it’s time to clear it. This lets you maintain your own array or aMap, and access any ref by its index or some kind of ID.

This example shows how you can use this approach to scroll to an arbitrary node in a long list:

```jsx
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef(null);
  const [catList, setCatList] = useState(setupCatList);

  function scrollToCat(cat) {
    const map = getMap();
    const node = map.get(cat);
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // Initialize the Map on first usage.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToCat(catList[0])}>Neo</button>
        <button onClick={() => scrollToCat(catList[5])}>Millie</button>
        <button onClick={() => scrollToCat(catList[8])}>Bella</button>
      </nav>
      <div>
        <ul>
          {catList.map((cat) => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                map.set(cat, node);

                return () => {
                  map.delete(cat);
                };
              }}
            >
              <img src={cat.imageUrl} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catCount = 10;
  const catList = new Array(catCount)
  for (let i = 0; i < catCount; i++) {
    let imageUrl = '';
    if (i < 5) {
      imageUrl = "https://placecats.com/neo/320/240";
    } else if (i < 8) {
      imageUrl = "https://placecats.com/millie/320/240";
    } else {
      imageUrl = "https://placecats.com/bella/320/240";
    }
    catList[i] = {
      id: i,
      imageUrl,
    };
  }
  return catList;
}


```

In this example,itemsRefdoesn’t hold a single DOM node. Instead, it holds aMapfrom item ID to a DOM node. (Refs can hold any values!) Therefcallbackon every list item takes care to update the Map:

```jsx
<li  key={cat.id}  ref={node => {    const map = getMap();    // Add to the Map    map.set(cat, node);    return () => {      // Remove from the Map      map.delete(cat);    };  }}>
```

This lets you read individual DOM nodes from the Map later.


### Note
When Strict Mode is enabled, ref callbacks will run twice in development.

Read more abouthow this helps find bugsin callback refs.


## Accessing another component’s DOM nodes

### Pitfall
Refs are an escape hatch. Manually manipulatinganothercomponent’s DOM nodes can make your code fragile.

You can pass refs from parent component to child componentsjust like any other prop.

```jsx
import { useRef } from 'react';function MyInput({ ref }) {  return <input ref={ref} />;}function MyForm() {  const inputRef = useRef(null);  return <MyInput ref={inputRef} />}
```

In the above example, a ref is created in the parent component,MyForm, and is passed to the child component,MyInput.MyInputthen passes the ref to<input>. Because<input>is abuilt-in componentReact sets the.currentproperty of the ref to the<input>DOM element.

TheinputRefcreated inMyFormnow points to the<input>DOM element returned byMyInput. A click handler created inMyFormcan accessinputRefand callfocus()to set the focus on<input>.

```jsx
import { useRef } from 'react';

function MyInput({ ref }) {
  return <input ref={ref} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


```


#### Exposing a subset of the API with an imperative handle
In the above example, the ref passed toMyInputis passed on to the original DOM input element. This lets the parent component callfocus()on it. However, this also lets the parent component do something else—for example, change its CSS styles. In uncommon cases, you may want to restrict the exposed functionality. You can do that withuseImperativeHandle:

```jsx
import { useRef, useImperativeHandle } from "react";

function MyInput({ ref }) {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Only expose focus and nothing else
    focus() {
      realInputRef.current.focus();
    },
  }));
  return <input ref={realInputRef} />;
};

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}


```

Here,realInputRefinsideMyInputholds the actual input DOM node. However,useImperativeHandleinstructs React to provide your own special object as the value of a ref to the parent component. SoinputRef.currentinside theFormcomponent will only have thefocusmethod. In this case, the ref “handle” is not the DOM node, but the custom object you create insideuseImperativeHandlecall.


## When React attaches the refs
In React, every update is split intwo phases:

- Duringrender,React calls your components to figure out what should be on the screen.
- Duringcommit,React applies changes to the DOM.
In general, youdon’t wantto access refs during rendering. That goes for refs holding DOM nodes as well. During the first render, the DOM nodes have not yet been created, soref.currentwill benull. And during the rendering of updates, the DOM nodes haven’t been updated yet. So it’s too early to read them.

React setsref.currentduring the commit. Before updating the DOM, React sets the affectedref.currentvalues tonull. After updating the DOM, React immediately sets them to the corresponding DOM nodes.

Usually, you will access refs from event handlers.If you want to do something with a ref, but there is no particular event to do it in, you might need an Effect. We will discuss Effects on the next pages.


#### Flushing state updates synchronously with flushSync
Consider code like this, which adds a new todo and scrolls the screen down to the last child of the list. Notice how, for some reason, it always scrolls to the todo that wasjust beforethe last added one:

```jsx
import { useState, useRef } from 'react';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText('');
    setTodos([ ...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}


```

The issue is with these two lines:

```jsx
setTodos([ ...todos, newTodo]);listRef.current.lastChild.scrollIntoView();
```

In React,state updates are queued.Usually, this is what you want. However, here it causes a problem becausesetTodosdoes not immediately update the DOM. So the time you scroll the list to its last element, the todo has not yet been added. This is why scrolling always “lags behind” by one item.

To fix this issue, you can force React to update (“flush”) the DOM synchronously. To do this, importflushSyncfromreact-domandwrap the state updateinto aflushSynccall:

```jsx
flushSync(() => {  setTodos([ ...todos, newTodo]);});listRef.current.lastChild.scrollIntoView();
```

This will instruct React to update the DOM synchronously right after the code wrapped influshSyncexecutes. As a result, the last todo will already be in the DOM by the time you try to scroll to it:

```jsx
import { useState, useRef } from 'react';
import { flushSync } from 'react-dom';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    flushSync(() => {
      setText('');
      setTodos([ ...todos, newTodo]);
    });
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}


```


## Best practices for DOM manipulation with refs
Refs are an escape hatch. You should only use them when you have to “step outside React”. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose.

If you stick to non-destructive actions like focusing and scrolling, you shouldn’t encounter any problems. However, if you try tomodifythe DOM manually, you can risk conflicting with the changes React is making.

To illustrate this problem, this example includes a welcome message and two buttons. The first button toggles its presence usingconditional renderingandstate, as you would usually do in React. The second button uses theremove()DOM APIto forcefully remove it from the DOM outside of React’s control.

Try pressing “Toggle with setState” a few times. The message should disappear and appear again. Then press “Remove from the DOM”. This will forcefully remove it. Finally, press “Toggle with setState”:

```jsx
import { useState, useRef } from 'react';

export default function Counter() {
  const [show, setShow] = useState(true);
  const ref = useRef(null);

  return (
    <div>
      <button
        onClick={() => {
          setShow(!show);
        }}>
        Toggle with setState
      </button>
      <button
        onClick={() => {
          ref.current.remove();
        }}>
        Remove from the DOM
      </button>
      {show && <p ref={ref}>Hello world</p>}
    </div>
  );
}


```

After you’ve manually removed the DOM element, trying to usesetStateto show it again will lead to a crash. This is because you’ve changed the DOM, and React doesn’t know how to continue managing it correctly.

Avoid changing DOM nodes managed by React.Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above.

However, this doesn’t mean that you can’t do it at all. It requires caution.You can safely modify parts of the DOM that React hasno reasonto update.For example, if some<div>is always empty in the JSX, React won’t have a reason to touch its children list. Therefore, it is safe to manually add or remove elements there.


## Recap
- Refs are a generic concept, but most often you’ll use them to hold DOM elements.
- You instruct React to put a DOM node intomyRef.currentby passing<div ref={myRef}>.
- Usually, you will use refs for non-destructive actions like focusing, scrolling, or measuring DOM elements.
- A component doesn’t expose its DOM nodes by default. You can opt into exposing a DOM node by using therefprop.
- Avoid changing DOM nodes managed by React.
- If you do modify DOM nodes managed by React, modify parts that React has no reason to update.

## Try out some challenges

#### Challenge1of4:Play and pause the video
In this example, the button toggles a state variable to switch between a playing and a paused state. However, in order to actually play or pause the video, toggling state is not enough. You also need to callplay()andpause()on the DOM element for the<video>. Add a ref to it, and make the button work.

```jsx
import { useState, useRef } from 'react';

export default function VideoPlayer() {
  const [isPlaying, setIsPlaying] = useState(false);

  function handleClick() {
    const nextIsPlaying = !isPlaying;
    setIsPlaying(nextIsPlaying);
  }

  return (
    <>
      <button onClick={handleClick}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <video width="250">
        <source
          src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
          type="video/mp4"
        />
      </video>
    </>
  )
}


```

For an extra challenge, keep the “Play” button in sync with whether the video is playing even if the user right-clicks the video and plays it using the built-in browser media controls. You might want to listen toonPlayandonPauseon the video to do that.


--------------------------------------------------------------------------------


# Synchronizing with Effects
Source: https://react.dev/learn/synchronizing-with-effects

Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen.Effectslet you run some code after rendering so that you can synchronize your component with some system outside of React.


### You will learn
- What Effects are
- How Effects are different from events
- How to declare an Effect in your component
- How to skip re-running an Effect unnecessarily
- Why Effects run twice in development and how to fix them

## What are Effects and how are they different from events?
Before getting to Effects, you need to be familiar with two types of logic inside React components:

- Rendering code(introduced inDescribing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen.Rendering code must be pure.Like a math formula, it should onlycalculatethe result, but not do anything else.
Rendering code(introduced inDescribing the UI) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen.Rendering code must be pure.Like a math formula, it should onlycalculatethe result, but not do anything else.

- Event handlers(introduced inAdding Interactivity) are nested functions inside your components thatdothings rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain“side effects”(they change the program’s state) caused by a specific user action (for example, a button click or typing).
Event handlers(introduced inAdding Interactivity) are nested functions inside your components thatdothings rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain“side effects”(they change the program’s state) caused by a specific user action (for example, a button click or typing).

Sometimes this isn’t enough. Consider aChatRoomcomponent that must connect to the chat server whenever it’s visible on the screen. Connecting to a server is not a pure calculation (it’s a side effect) so it can’t happen during rendering. However, there is no single particular event like a click that causesChatRoomto be displayed.

Effectslet you specify side effects that are caused by rendering itself, rather than by a particular event.Sending a message in the chat is aneventbecause it is directly caused by the user clicking a specific button. However, setting up a server connection is anEffectbecause it should happen no matter which interaction caused the component to appear. Effects run at the end of acommitafter the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).


### Note
Here and later in this text, capitalized “Effect” refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we’ll say “side effect”.


## You might not need an Effect
Don’t rush to add Effects to your components.Keep in mind that Effects are typically used to “step out” of your React code and synchronize with someexternalsystem. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state,you might not need an Effect.


## How to write an Effect
To write an Effect, follow these three steps:

- Declare an Effect.By default, your Effect will run after everycommit.
- Specify the Effect dependencies.Most Effects should only re-runwhen neededrather than after every render. For example, a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes. You will learn how to control this by specifyingdependencies.
- Add cleanup if needed.Some Effects need to specify how to stop, undo, or clean up whatever they were doing. For example, “connect” needs “disconnect”, “subscribe” needs “unsubscribe”, and “fetch” needs either “cancel” or “ignore”. You will learn how to do this by returning acleanup function.
Let’s look at each of these steps in detail.


### Step 1: Declare an Effect
To declare an Effect in your component, import theuseEffectHookfrom React:

```jsx
import { useEffect } from 'react';
```

Then, call it at the top level of your component and put some code inside your Effect:

```jsx
function MyComponent() {  useEffect(() => {    // Code here will run after *every* render  });  return <div />;}
```

Every time your component renders, React will update the screenand thenrun the code insideuseEffect. In other words,useEffect“delays” a piece of code from running until that render is reflected on the screen.

Let’s see how you can use an Effect to synchronize with an external system. Consider a<VideoPlayer>React component. It would be nice to control whether it’s playing or paused by passing anisPlayingprop to it:

```jsx
<VideoPlayer isPlaying={isPlaying} />;
```

Your customVideoPlayercomponent renders the built-in browser<video>tag:

```jsx
function VideoPlayer({ src, isPlaying }) {  // TODO: do something with isPlaying  return <video src={src} />;}
```

However, the browser<video>tag does not have anisPlayingprop. The only way to control it is to manually call theplay()andpause()methods on the DOM element.You need to synchronize the value ofisPlayingprop, which tells whether the videoshouldcurrently be playing, with calls likeplay()andpause().

We’ll need to firstget a refto the<video>DOM node.

You might be tempted to try to callplay()orpause()during rendering, but that isn’t correct:

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play();  // Calling these while rendering isn't allowed.
  } else {
    ref.current.pause(); // Also, this crashes.
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


```

The reason this code isn’t correct is that it tries to do something with the DOM node during rendering. In React,rendering should be a pure calculationof JSX and should not contain side effects like modifying the DOM.

Moreover, whenVideoPlayeris called for the first time, its DOM does not exist yet! There isn’t a DOM node yet to callplay()orpause()on, because React doesn’t know what DOM to create until you return the JSX.

The solution here is towrap the side effect withuseEffectto move it out of the rendering calculation:

```jsx
import { useEffect, useRef } from 'react';function VideoPlayer({ src, isPlaying }) {  const ref = useRef(null);  useEffect(() => {    if (isPlaying) {      ref.current.play();    } else {      ref.current.pause();    }  });  return <video ref={ref} src={src} loop playsInline />;}
```

By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.

When yourVideoPlayercomponent renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the<video>tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will callplay()orpause()depending on the value ofisPlaying.

Press Play/Pause multiple times and see how the video player stays synchronized to theisPlayingvalue:

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


```

In this example, the “external system” you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.

Note that controlling a video player is much more complex in practice. Callingplay()may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.


### Pitfall
By default, Effects run aftereveryrender. This is why code like this willproduce an infinite loop:

```jsx
const [count, setCount] = useState(0);useEffect(() => {  setCount(count + 1);});
```

Effects run as aresultof rendering. Setting statetriggersrendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.

Effects should usually synchronize your components with anexternalsystem. If there’s no external system and you only want to adjust some state based on other state,you might not need an Effect.


### Step 2: Specify the Effect dependencies
By default, Effects run aftereveryrender. Often, this isnot what you want:

- Sometimes, it’s slow. Synchronizing with an external system is not always instant, so you might want to skip doing it unless it’s necessary. For example, you don’t want to reconnect to the chat server on every keystroke.
- Sometimes, it’s wrong. For example, you don’t want to trigger a component fade-in animation on every keystroke. The animation should only play once when the component appears for the first time.
To demonstrate the issue, here is the previous example with a fewconsole.logcalls and a text input that updates the parent component’s state. Notice how typing causes the Effect to re-run:

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


```

You can tell React toskip unnecessarily re-running the Effectby specifying an array ofdependenciesas the second argument to theuseEffectcall. Start by adding an empty[]array to the above example on line 14:

```jsx
  useEffect(() => {    // ...  }, []);
```

You should see an error sayingReact Hook useEffect has a missing dependency: 'isPlaying':

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, []); // This causes an error

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


```

The problem is that the code inside of your Effectdepends ontheisPlayingprop to decide what to do, but this dependency was not explicitly declared. To fix this issue, addisPlayingto the dependency array:

```jsx
  useEffect(() => {    if (isPlaying) { // It's used here...      // ...    } else {      // ...    }  }, [isPlaying]); // ...so it must be declared here!
```

Now all dependencies are declared, so there is no error. Specifying[isPlaying]as the dependency array tells React that it should skip re-running your Effect ifisPlayingis the same as it was during the previous render. With this change, typing into the input doesn’t cause the Effect to re-run, but pressing Play/Pause does:

```jsx
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}


```

The dependency array can contain multiple dependencies. React will only skip re-running the Effect ifallof the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using theObject.iscomparison. See theuseEffectreferencefor details.

Notice that you can’t “choose” your dependencies.You will get a lint error if the dependencies you specified don’t match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don’t want some code to re-run,edit the Effect code itselfto not “need” that dependency.


### Pitfall
The behaviors without the dependency array and with anempty[]dependency array are different:

```jsx
useEffect(() => {  // This runs after every render});useEffect(() => {  // This runs only on mount (when the component appears)}, []);useEffect(() => {  // This runs on mount *and also* if either a or b have changed since the last render}, [a, b]);
```

We’ll take a close look at what “mount” means in the next step.


#### Why was the ref omitted from the dependency array?
This Effect usesbothrefandisPlaying, but onlyisPlayingis declared as a dependency:

```jsx
function VideoPlayer({ src, isPlaying }) {  const ref = useRef(null);  useEffect(() => {    if (isPlaying) {      ref.current.play();    } else {      ref.current.pause();    }  }, [isPlaying]);
```

This is because therefobject has astable identity:React guaranteesyou’ll always get the same objectfrom the sameuseRefcall on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:

```jsx
function VideoPlayer({ src, isPlaying }) {  const ref = useRef(null);  useEffect(() => {    if (isPlaying) {      ref.current.play();    } else {      ref.current.pause();    }  }, [isPlaying, ref]);
```

Thesetfunctionsreturned byuseStatealso have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.

Omitting always-stable dependencies only works when the linter can “see” that the object is stable. For example, ifrefwas passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can’t know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effectwoulddepend on which ref is passed.


### Step 3: Add cleanup if needed
Consider a different example. You’re writing aChatRoomcomponent that needs to connect to the chat server when it appears. You are given acreateConnection()API that returns an object withconnect()anddisconnect()methods. How do you keep the component connected while it is displayed to the user?

Start by writing the Effect logic:

```jsx
useEffect(() => {  const connection = createConnection();  connection.connect();});
```

It would be slow to connect to the chat after every re-render, so you add the dependency array:

```jsx
useEffect(() => {  const connection = createConnection();  connection.connect();}, []);
```

The code inside the Effect does not use any props or state, so your dependency array is[](empty). This tells React to only run this code when the component “mounts”, i.e. appears on the screen for the first time.

Let’s try running this code:

```jsx
import { useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}


```

This Effect only runs on mount, so you might expect"✅ Connecting..."to be printed once in the console.However, if you check the console,"✅ Connecting..."gets printed twice. Why does it happen?

Imagine theChatRoomcomponent is a part of a larger app with many different screens. The user starts their journey on theChatRoompage. The component mounts and callsconnection.connect(). Then imagine the user navigates to another screen—for example, to the Settings page. TheChatRoomcomponent unmounts. Finally, the user clicks Back andChatRoommounts again. This would set up a second connection—but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.

Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.

Seeing the"✅ Connecting..."log twice helps you notice the real issue: your code doesn’t close the connection when the component unmounts.

To fix the issue, return acleanup functionfrom your Effect:

```jsx
  useEffect(() => {    const connection = createConnection();    connection.connect();    return () => {      connection.disconnect();    };  }, []);
```

React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let’s see what happens when the cleanup function is implemented:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}


```

Now you get three console logs in development:

- "✅ Connecting..."
- "❌ Disconnected."
- "✅ Connecting..."
This is the correct behavior in development.By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There’s an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal—don’t try to make it go away!

In production, you would only see"✅ Connecting..."printed once.Remounting components only happens in development to help you find Effects that need cleanup. You can turn offStrict Modeto opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.


## How to handle the Effect firing twice in development?
React intentionally remounts your components in development to find bugs like in the last example.The right question isn’t “how to run an Effect once”, but “how to fix my Effect so that it works after remounting”.

Usually, the answer is to implement the cleanup function.  The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the Effect running once (as in production) and asetup → cleanup → setupsequence (as you’d see in development).

Most of the Effects you’ll write will fit into one of the common patterns below.


### Pitfall

#### Don’t use refs to prevent Effects from firing
A common pitfall for preventing Effects firing twice in development is to use arefto prevent the Effect from running more than once. For example, you could “fix” the above bug with auseRef:

```jsx
  const connectionRef = useRef(null);  useEffect(() => {    // 🚩 This wont fix the bug!!!    if (!connectionRef.current) {      connectionRef.current = createConnection();      connectionRef.current.connect();    }  }, []);
```

This makes it so you only see"✅ Connecting..."once in development, but it doesn’t fix the bug.

When the user navigates away, the connection still isn’t closed and when they navigate back, a new connection is created. As the user navigates across the app, the connections would keep piling up, the same as it would before the “fix”.

To fix the bug, it is not enough to just make the Effect run once. The effect needs to work after re-mounting, which means the connection needs to be cleaned up like in the solution above.

See the examples below for how to handle common patterns.


### Controlling non-React widgets
Sometimes you need to add UI widgets that aren’t written in React. For example, let’s say you’re adding a map component to your page. It has asetZoomLevel()method, and you’d like to keep the zoom level in sync with azoomLevelstate variable in your React code. Your Effect would look similar to this:

```jsx
useEffect(() => {  const map = mapRef.current;  map.setZoomLevel(zoomLevel);}, [zoomLevel]);
```

Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because callingsetZoomLeveltwice with the same value does not do anything. It may be slightly slower, but this doesn’t matter because it won’t remount needlessly in production.

Some APIs may not allow you to call them twice in a row. For example, theshowModalmethod of the built-in<dialog>element throws if you call it twice. Implement the cleanup function and make it close the dialog:

```jsx
useEffect(() => {  const dialog = dialogRef.current;  dialog.showModal();  return () => dialog.close();}, []);
```

In development, your Effect will callshowModal(), then immediatelyclose(), and thenshowModal()again. This has the same user-visible behavior as callingshowModal()once, as you would see in production.


### Subscribing to events
If your Effect subscribes to something, the cleanup function should unsubscribe:

```jsx
useEffect(() => {  function handleScroll(e) {    console.log(window.scrollX, window.scrollY);  }  window.addEventListener('scroll', handleScroll);  return () => window.removeEventListener('scroll', handleScroll);}, []);
```

In development, your Effect will calladdEventListener(), then immediatelyremoveEventListener(), and thenaddEventListener()again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as callingaddEventListener()once, as in production.


### Triggering animations
If your Effect animates something in, the cleanup function should reset the animation to the initial values:

```jsx
useEffect(() => {  const node = ref.current;  node.style.opacity = 1; // Trigger the animation  return () => {    node.style.opacity = 0; // Reset to the initial value  };}, []);
```

In development, opacity will be set to1, then to0, and then to1again. This should have the same user-visible behavior as setting it to1directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.


### Fetching data
If your Effect fetches something, the cleanup function should eitherabort the fetchor ignore its result:

```jsx
useEffect(() => {  let ignore = false;  async function startFetching() {    const json = await fetchTodos(userId);    if (!ignore) {      setTodos(json);    }  }  startFetching();  return () => {    ignore = true;  };}, [userId]);
```

You can’t “undo” a network request that already happened, but your cleanup function should ensure that the fetch that’snot relevant anymoredoes not keep affecting your application. If theuserIdchanges from'Alice'to'Bob', cleanup ensures that the'Alice'response is ignored even if it arrives after'Bob'.

In development, you will see two fetches in the Network tab.There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of theignorevariable will be set totrue. So even though there is an extra request, it won’t affect the state thanks to theif (!ignore)check.

In production, there will only be one request.If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:

```jsx
function TodoList() {  const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);  // ...
```

This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won’t have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.


#### What are good alternatives to data fetching in Effects?
Writingfetchcalls inside Effects is apopular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:

- Effects don’t run on the server.This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
- Fetching directly in Effects makes it easy to create “network waterfalls”.You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
- Fetching directly in Effects usually means you don’t preload or cache data.For example, if the component unmounts and then mounts again, it would have to fetch the data again.
- It’s not very ergonomic.There’s quite a bit of boilerplate code involved when writingfetchcalls in a way that doesn’t suffer from bugs likerace conditions.
This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:

- If you use aframework, use its built-in data fetching mechanism.Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.
- Otherwise, consider using or building a client-side cache.Popular open source solutions includeTanStack Query,useSWR, andReact Router 6.4+.You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).
You can continue fetching data directly in Effects if neither of these approaches suit you.


### Sending analytics
Consider this code that sends an analytics event on the page visit:

```jsx
useEffect(() => {  logVisit(url); // Sends a POST request}, [url]);
```

In development,logVisitwill be called twice for every URL, so you might be tempted to try to fix that.We recommend keeping this code as is.Like with earlier examples, there is nouser-visiblebehavior difference between running it once and running it twice. From a practical point of view,logVisitshould not do anything in development because you don’t want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.

In production, there will be no duplicate visit logs.

To debug the analytics events you’re sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out ofStrict Modeand its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics,intersection observerscan help track which components are in the viewport and how long they remain visible.


### Not an Effect: Initializing the application
Some logic should only run once when the application starts. You can put it outside your components:

```jsx
if (typeof window !== 'undefined') { // Check if we're running in the browser.  checkAuthToken();  loadDataFromLocalStorage();}function App() {  // ...}
```

This guarantees that such logic only runs once after the browser loads the page.


### Not an Effect: Buying a product
Sometimes, even if you write a cleanup function, there’s no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:

```jsx
useEffect(() => {  // 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.  fetch('/api/buy', { method: 'POST' });}, []);
```

You wouldn’t want to buy the product twice. However, this is also why you shouldn’t put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don’t want to buy the product when the uservisitsa page; you want to buy it when the userclicksthe Buy button.

Buying is not caused by rendering; it’s caused by a specific interaction. It should run only when the user presses the button.Delete the Effect and move your/api/buyrequest into the Buy button event handler:

```jsx
  function handleClick() {    // ✅ Buying is an event because it is caused by a particular interaction.    fetch('/api/buy', { method: 'POST' });  }
```

This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.From a user’s perspective, visiting a page shouldn’t be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.


## Putting it all together
This playground can help you “get a feel” for how Effects work in practice.

This example usessetTimeoutto schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing “Mount the component”:

```jsx
import { useState, useEffect } from 'react';

function Playground() {
  const [text, setText] = useState('a');

  useEffect(() => {
    function onTimeout() {
      console.log('⏰ ' + text);
    }

    console.log('🔵 Schedule "' + text + '" log');
    const timeoutId = setTimeout(onTimeout, 3000);

    return () => {
      console.log('🟡 Cancel "' + text + '" log');
      clearTimeout(timeoutId);
    };
  }, [text]);

  return (
    <>
      <label>
        What to log:{' '}
        <input
          value={text}
          onChange={e => setText(e.target.value)}
        />
      </label>
      <h1>{text}</h1>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Unmount' : 'Mount'} the component
      </button>
      {show && <hr />}
      {show && <Playground />}
    </>
  );
}


```

You will see three logs at first:Schedule "a" log,Cancel "a" log, andSchedule "a" logagain. Three second later there will also be a log sayinga. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you’ve implemented cleanup well.

Now edit the input to sayabc. If you do it fast enough, you’ll seeSchedule "ab" logimmediately followed byCancel "ab" logandSchedule "abc" log.React always cleans up the previous render’s Effect before the next render’s Effect.This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.

Type something into the input and then immediately press “Unmount the component”. Notice how unmounting cleans up the last render’s Effect. Here, it clears the last timeout before it has a chance to fire.

Finally, edit the component above and comment out the cleanup function so that the timeouts don’t get cancelled. Try typingabcdefast. What do you expect to happen in three seconds? Willconsole.log(text)inside the timeout print thelatesttextand produce fiveabcdelogs? Give it a try to check your intuition!

Three seconds later, you should see a sequence of logs (a,ab,abc,abcd, andabcde) rather than fiveabcdelogs.Each Effect “captures” thetextvalue from its corresponding render.It doesn’t matter that thetextstate changed: an Effect from the render withtext = 'ab'will always see'ab'. In other words, Effects from each render are isolated from each other. If you’re curious how this works, you can read aboutclosures.


#### Each render has its own Effects
You can think ofuseEffectas “attaching” a piece of behavior to the render output. Consider this Effect:

```jsx
export default function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);  return <h1>Welcome to {roomId}!</h1>;}
```

Let’s see what exactly happens as the user navigates around the app.


#### Initial render
The user visits<ChatRoom roomId="general" />. Let’smentally substituteroomIdwith'general':

```jsx
  // JSX for the first render (roomId = "general")  return <h1>Welcome to general!</h1>;
```

The Effect isalsoa part of the rendering output.The first render’s Effect becomes:

```jsx
  // Effect for the first render (roomId = "general")  () => {    const connection = createConnection('general');    connection.connect();    return () => connection.disconnect();  },  // Dependencies for the first render (roomId = "general")  ['general']
```

React runs this Effect, which connects to the'general'chat room.


#### Re-render with same dependencies
Let’s say<ChatRoom roomId="general" />re-renders. The JSX output is the same:

```jsx
  // JSX for the second render (roomId = "general")  return <h1>Welcome to general!</h1>;
```

React sees that the rendering output has not changed, so it doesn’t update the DOM.

The Effect from the second render looks like this:

```jsx
  // Effect for the second render (roomId = "general")  () => {    const connection = createConnection('general');    connection.connect();    return () => connection.disconnect();  },  // Dependencies for the second render (roomId = "general")  ['general']
```

React compares['general']from the second render with['general']from the first render.Because all dependencies are the same, Reactignoresthe Effect from the second render.It never gets called.


#### Re-render with different dependencies
Then, the user visits<ChatRoom roomId="travel" />. This time, the component returns different JSX:

```jsx
  // JSX for the third render (roomId = "travel")  return <h1>Welcome to travel!</h1>;
```

React updates the DOM to change"Welcome to general"into"Welcome to travel".

The Effect from the third render looks like this:

```jsx
  // Effect for the third render (roomId = "travel")  () => {    const connection = createConnection('travel');    connection.connect();    return () => connection.disconnect();  },  // Dependencies for the third render (roomId = "travel")  ['travel']
```

React compares['travel']from the third render with['general']from the second render. One dependency is different:Object.is('travel', 'general')isfalse. The Effect can’t be skipped.

Before React can apply the Effect from the third render, it needs to clean up the last Effect thatdidrun.The second render’s Effect was skipped, so React needs to clean up the first render’s Effect. If you scroll up to the first render, you’ll see that its cleanup callsdisconnect()on the connection that was created withcreateConnection('general'). This disconnects the app from the'general'chat room.

After that, React runs the third render’s Effect. It connects to the'travel'chat room.


#### Unmount
Finally, let’s say the user navigates away, and theChatRoomcomponent unmounts. React runs the last Effect’s cleanup function. The last Effect was from the third render. The third render’s cleanup destroys thecreateConnection('travel')connection. So the app disconnects from the'travel'room.


#### Development-only behaviors
WhenStrict Modeis on, React remounts every component once after mount (state and DOM are preserved). Thishelps you find Effects that need cleanupand exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.


## Recap
- Unlike events, Effects are caused by rendering itself rather than a particular interaction.
- Effects let you synchronize a component with some external system (third-party API, network, etc).
- By default, Effects run after every render (including the initial one).
- React will skip the Effect if all of its dependencies have the same values as during the last render.
- You can’t “choose” your dependencies. They are determined by the code inside the Effect.
- Empty dependency array ([]) corresponds to the component “mounting”, i.e. being added to the screen.
- In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.
- If your Effect breaks because of remounting, you need to implement a cleanup function.
- React will call your cleanup function before the Effect runs next time, and during the unmount.

## Try out some challenges

#### Challenge1of4:Focus a field on mount
In this example, the form renders a<MyInput />component.

Use the input’sfocus()method to makeMyInputautomatically focus when it appears on the screen. There is already a commented out implementation, but it doesn’t quite work. Figure out why it doesn’t work, and fix it. (If you’re familiar with theautoFocusattribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)

```jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  // TODO: This doesn't quite work. Fix it.
  // ref.current.focus()

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}


```

To verify that your solution works, press “Show form” and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press “Hide form” and “Show form” again. Verify the input is highlighted again.

MyInputshould only focuson mountrather than after every render. To verify that the behavior is right, press “Show form” and then repeatedly press the “Make it uppercase” checkbox. Clicking the checkbox shouldnotfocus the input above it.


--------------------------------------------------------------------------------


# You Might Not Need an Effect
Source: https://react.dev/learn/you-might-not-need-an-effect

Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.


### You will learn
- Why and how to remove unnecessary Effects from your components
- How to cache expensive computations without Effects
- How to reset and adjust component state without Effects
- How to share logic between event handlers
- Which logic should be moved to event handlers
- How to notify parent components about changes

## How to remove unnecessary Effects
There are two common cases in which you don’t need Effects:

- You don’t need Effects to transform data for rendering.For example, let’s say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will“commit”these changes to the DOM, updating the screen. Then React will run your Effects. If your Effectalsoimmediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.
- You don’t need Effects to handle user events.For example, let’s say you want to send an/api/buyPOST request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don’t knowwhatthe user did (for example, which button was clicked). This is why you’ll usually handle user events in the corresponding event handlers.
Youdoneed Effects tosynchronizewith external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modernframeworksprovide more efficient built-in data fetching mechanisms than writing Effects directly in your components.

To help you gain the right intuition, let’s look at some common concrete examples!


### Updating state based on props or state
Suppose you have a component with two state variables:firstNameandlastName. You want to calculate afullNamefrom them by concatenating them. Moreover, you’d likefullNameto update wheneverfirstNameorlastNamechange. Your first instinct might be to add afullNamestate variable and update it in an Effect:

```jsx
function Form() {  const [firstName, setFirstName] = useState('Taylor');  const [lastName, setLastName] = useState('Swift');  // 🔴 Avoid: redundant state and unnecessary Effect  const [fullName, setFullName] = useState('');  useEffect(() => {    setFullName(firstName + ' ' + lastName);  }, [firstName, lastName]);  // ...}
```

This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value forfullName, then immediately re-renders with the updated value. Remove the state variable and the Effect:

```jsx
function Form() {  const [firstName, setFirstName] = useState('Taylor');  const [lastName, setLastName] = useState('Swift');  // ✅ Good: calculated during rendering  const fullName = firstName + ' ' + lastName;  // ...}
```

When something can be calculated from the existing props or state,don’t put it in state.Instead, calculate it during rendering.This makes your code faster (you avoid the extra “cascading” updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you,Thinking in Reactexplains what should go into state.


### Caching expensive calculations
This component computesvisibleTodosby taking thetodosit receives by props and filtering them according to thefilterprop. You might feel tempted to store the result in state and update it from an Effect:

```jsx
function TodoList({ todos, filter }) {  const [newTodo, setNewTodo] = useState('');  // 🔴 Avoid: redundant state and unnecessary Effect  const [visibleTodos, setVisibleTodos] = useState([]);  useEffect(() => {    setVisibleTodos(getFilteredTodos(todos, filter));  }, [todos, filter]);  // ...}
```

Like in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:

```jsx
function TodoList({ todos, filter }) {  const [newTodo, setNewTodo] = useState('');  // ✅ This is fine if getFilteredTodos() is not slow.  const visibleTodos = getFilteredTodos(todos, filter);  // ...}
```

Usually, this code is fine! But maybegetFilteredTodos()is slow or you have a lot oftodos. In that case you don’t want to recalculategetFilteredTodos()if some unrelated state variable likenewTodohas changed.

You can cache (or“memoize”) an expensive calculation by wrapping it in auseMemoHook:


### Note
React Compilercan automatically memoize expensive calculations for you, eliminating the need for manualuseMemoin many cases.

```jsx
import { useMemo, useState } from 'react';function TodoList({ todos, filter }) {  const [newTodo, setNewTodo] = useState('');  const visibleTodos = useMemo(() => {    // ✅ Does not re-run unless todos or filter change    return getFilteredTodos(todos, filter);  }, [todos, filter]);  // ...}
```

Or, written as a single line:

```jsx
import { useMemo, useState } from 'react';function TodoList({ todos, filter }) {  const [newTodo, setNewTodo] = useState('');  // ✅ Does not re-run getFilteredTodos() unless todos or filter change  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);  // ...}
```

This tells React that you don’t want the inner function to re-run unless eithertodosorfilterhave changed.React will remember the return value ofgetFilteredTodos()during the initial render. During the next renders, it will check iftodosorfilterare different. If they’re the same as last time,useMemowill return the last result it has stored. But if they are different, React will call the inner function again (and store its result).

The function you wrap inuseMemoruns during rendering, so this only works forpure calculations.


#### How to tell if a calculation is expensive?
In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:

```jsx
console.time('filter array');const visibleTodos = getFilteredTodos(todos, filter);console.timeEnd('filter array');
```

Perform the interaction you’re measuring (for example, typing into the input). You will then see logs likefilter array: 0.15msin your console. If the overall logged time adds up to a significant amount (say,1msor more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation inuseMemoto verify whether the total logged time has decreased for that interaction or not:

```jsx
console.time('filter array');const visibleTodos = useMemo(() => {  return getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed}, [todos, filter]);console.timeEnd('filter array');
```

useMemowon’t make thefirstrender faster. It only helps you skip unnecessary work on updates.

Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers aCPU Throttlingoption for this.

Also note that measuring performance in development will not give you the most accurate results. (For example, whenStrict Modeis on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.


### Resetting all state when a prop changes
ThisProfilePagecomponent receives auserIdprop. The page contains a comment input, and you use acommentstate variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, thecommentstate does not get reset. As a result, it’s easy to accidentally post a comment on a wrong user’s profile. To fix the issue, you want to clear out thecommentstate variable whenever theuserIdchanges:

```jsx
export default function ProfilePage({ userId }) {  const [comment, setComment] = useState('');  // 🔴 Avoid: Resetting state on prop change in an Effect  useEffect(() => {    setComment('');  }, [userId]);  // ...}
```

This is inefficient becauseProfilePageand its children will first render with the stale value, and then render again. It is also complicated because you’d need to do this ineverycomponent that has some state insideProfilePage. For example, if the comment UI is nested, you’d want to clear out nested comment state too.

Instead, you can tell React that each user’s profile is conceptually adifferentprofile by giving it an explicit key. Split your component in two and pass akeyattribute from the outer component to the inner one:

```jsx
export default function ProfilePage({ userId }) {  return (    <Profile      userId={userId}      key={userId}    />  );}function Profile({ userId }) {  // ✅ This and any other state below will reset on key change automatically  const [comment, setComment] = useState('');  // ...}
```

Normally, React preserves the state when the same component is rendered in the same spot.By passinguserIdas akeyto theProfilecomponent, you’re asking React to treat twoProfilecomponents with differentuserIdas two different components that should not share any state.Whenever the key (which you’ve set touserId) changes, React will recreate the DOM andreset the stateof theProfilecomponent and all of its children. Now thecommentfield will clear out automatically when navigating between profiles.

Note that in this example, only the outerProfilePagecomponent is exported and visible to other files in the project. Components renderingProfilePagedon’t need to pass the key to it: they passuserIdas a regular prop. The factProfilePagepasses it as akeyto the innerProfilecomponent is an implementation detail.


### Adjusting some state when a prop changes
Sometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it.

ThisListcomponent receives a list ofitemsas a prop, and maintains the selected item in theselectionstate variable. You want to reset theselectiontonullwhenever theitemsprop receives a different array:

```jsx
function List({ items }) {  const [isReverse, setIsReverse] = useState(false);  const [selection, setSelection] = useState(null);  // 🔴 Avoid: Adjusting state on prop change in an Effect  useEffect(() => {    setSelection(null);  }, [items]);  // ...}
```

This, too, is not ideal. Every time theitemschange, theListand its child components will render with a staleselectionvalue at first. Then React will update the DOM and run the Effects. Finally, thesetSelection(null)call will cause another re-render of theListand its child components, restarting this whole process again.

Start by deleting the Effect. Instead, adjust the state directly during rendering:

```jsx
function List({ items }) {  const [isReverse, setIsReverse] = useState(false);  const [selection, setSelection] = useState(null);  // Better: Adjust the state while rendering  const [prevItems, setPrevItems] = useState(items);  if (items !== prevItems) {    setPrevItems(items);    setSelection(null);  }  // ...}
```

Storing information from previous renderslike this can be hard to understand, but it’s better than updating the same state in an Effect. In the above example,setSelectionis called directly during a render. React will re-render theListimmediatelyafter it exits with areturnstatement. React has not rendered theListchildren or updated the DOM yet, so this lets theListchildren skip rendering the staleselectionvalue.

When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update thesamecomponent’s state during a render. If you update another component’s state during a render, you’ll see an error. A condition likeitems !== prevItemsis necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects tokeep components pure.

Although this pattern is more efficient than an Effect, most components shouldn’t need it either.No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you canreset all state with a keyorcalculate everything during renderinginstead. For example, instead of storing (and resetting) the selecteditem, you can store the selecteditem ID:

```jsx
function List({ items }) {  const [isReverse, setIsReverse] = useState(false);  const [selectedId, setSelectedId] = useState(null);  // ✅ Best: Calculate everything during rendering  const selection = items.find(item => item.id === selectedId) ?? null;  // ...}
```

Now there is no need to “adjust” the state at all. If the item with the selected ID is in the list, it remains selected. If it’s not, theselectioncalculated during rendering will benullbecause no matching item was found. This behavior is different, but arguably better because most changes toitemspreserve the selection.


### Sharing logic between event handlers
Let’s say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. CallingshowNotification()in both buttons’ click handlers feels repetitive so you might be tempted to place this logic in an Effect:

```jsx
function ProductPage({ product, addToCart }) {  // 🔴 Avoid: Event-specific logic inside an Effect  useEffect(() => {    if (product.isInCart) {      showNotification(`Added ${product.name} to the shopping cart!`);    }  }, [product]);  function handleBuyClick() {    addToCart(product);  }  function handleCheckoutClick() {    addToCart(product);    navigateTo('/checkout');  }  // ...}
```

This Effect is unnecessary. It will also most likely cause bugs. For example, let’s say that your app “remembers” the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product’s page. This is becauseproduct.isInCartwill already betrueon the page load, so the Effect above will callshowNotification().

When you’re not sure whether some code should be in an Effect or in an event handler, ask yourselfwhythis code needs to run. Use Effects only for code that should runbecausethe component was displayed to the user.In this example, the notification should appear because the userpressed the button, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:

```jsx
function ProductPage({ product, addToCart }) {  // ✅ Good: Event-specific logic is called from event handlers  function buyProduct() {    addToCart(product);    showNotification(`Added ${product.name} to the shopping cart!`);  }  function handleBuyClick() {    buyProduct();  }  function handleCheckoutClick() {    buyProduct();    navigateTo('/checkout');  }  // ...}
```

This both removes the unnecessary Effect and fixes the bug.


### Sending a POST request
ThisFormcomponent sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the/api/registerendpoint:

```jsx
function Form() {  const [firstName, setFirstName] = useState('');  const [lastName, setLastName] = useState('');  // ✅ Good: This logic should run because the component was displayed  useEffect(() => {    post('/analytics/event', { eventName: 'visit_form' });  }, []);  // 🔴 Avoid: Event-specific logic inside an Effect  const [jsonToSubmit, setJsonToSubmit] = useState(null);  useEffect(() => {    if (jsonToSubmit !== null) {      post('/api/register', jsonToSubmit);    }  }, [jsonToSubmit]);  function handleSubmit(e) {    e.preventDefault();    setJsonToSubmit({ firstName, lastName });  }  // ...}
```

Let’s apply the same criteria as in the example before.

The analytics POST request should remain in an Effect. This is because thereasonto send the analytics event is that the form was displayed. (It would fire twice in development, butsee herefor how to deal with that.)

However, the/api/registerPOST request is not caused by the form beingdisplayed. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happenon that particular interaction. Delete the second Effect and move that POST request into the event handler:

```jsx
function Form() {  const [firstName, setFirstName] = useState('');  const [lastName, setLastName] = useState('');  // ✅ Good: This logic runs because the component was displayed  useEffect(() => {    post('/analytics/event', { eventName: 'visit_form' });  }, []);  function handleSubmit(e) {    e.preventDefault();    // ✅ Good: Event-specific logic is in the event handler    post('/api/register', { firstName, lastName });  }  // ...}
```

When you choose whether to put some logic into an event handler or an Effect, the main question you need to answer iswhat kind of logicit is from the user’s perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it’s caused by the userseeingthe component on the screen, keep it in the Effect.


### Chains of computations
Sometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:

```jsx
function Game() {  const [card, setCard] = useState(null);  const [goldCardCount, setGoldCardCount] = useState(0);  const [round, setRound] = useState(1);  const [isGameOver, setIsGameOver] = useState(false);  // 🔴 Avoid: Chains of Effects that adjust the state solely to trigger each other  useEffect(() => {    if (card !== null && card.gold) {      setGoldCardCount(c => c + 1);    }  }, [card]);  useEffect(() => {    if (goldCardCount > 3) {      setRound(r => r + 1)      setGoldCardCount(0);    }  }, [goldCardCount]);  useEffect(() => {    if (round > 5) {      setIsGameOver(true);    }  }, [round]);  useEffect(() => {    alert('Good game!');  }, [isGameOver]);  function handlePlaceCard(nextCard) {    if (isGameOver) {      throw Error('Game already ended.');    } else {      setCard(nextCard);    }  }  // ...
```

There are two problems with this code.

The first problem is that it is very inefficient: the component (and its children) have to re-render between eachsetcall in the chain. In the example above, in the worst case (setCard→ render →setGoldCardCount→ render →setRound→ render →setIsGameOver→ render) there are three unnecessary re-renders of the tree below.

The second problem is that even if it weren’t slow, as your code evolves, you will run into cases where the “chain” you wrote doesn’t fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You’d do it by updating each state variable to a value from the past. However, setting thecardstate to a value from the past would trigger the Effect chain again and change the data you’re showing. Such code is often rigid and fragile.

In this case, it’s better to calculate what you can during rendering, and adjust the state in the event handler:

```jsx
function Game() {  const [card, setCard] = useState(null);  const [goldCardCount, setGoldCardCount] = useState(0);  const [round, setRound] = useState(1);  // ✅ Calculate what you can during rendering  const isGameOver = round > 5;  function handlePlaceCard(nextCard) {    if (isGameOver) {      throw Error('Game already ended.');    }    // ✅ Calculate all the next state in the event handler    setCard(nextCard);    if (nextCard.gold) {      if (goldCardCount < 3) {        setGoldCardCount(goldCardCount + 1);      } else {        setGoldCardCount(0);        setRound(round + 1);        if (round === 5) {          alert('Good game!');        }      }    }  }  // ...
```

This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you canextract a functionand call it from those handlers.

Remember that inside event handlers,state behaves like a snapshot.For example, even after you callsetRound(round + 1), theroundvariable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually likeconst nextRound = round + 1.

In some cases, youcan’tcalculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.


### Initializing the application
Some logic should only run once when the app loads.

You might be tempted to place it in an Effect in the top-level component:

```jsx
function App() {  // 🔴 Avoid: Effects with logic that should only ever run once  useEffect(() => {    loadDataFromLocalStorage();    checkAuthToken();  }, []);  // ...}
```

However, you’ll quickly discover that itruns twice in development.This can cause issues—for example, maybe it invalidates the authentication token because the function wasn’t designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-levelAppcomponent.

Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must runonce per app loadrather thanonce per component mount, add a top-level variable to track whether it has already executed:

```jsx
let didInit = false;function App() {  useEffect(() => {    if (!didInit) {      didInit = true;      // ✅ Only runs once per app load      loadDataFromLocalStorage();      checkAuthToken();    }  }, []);  // ...}
```

You can also run it during module initialization and before the app renders:

```jsx
if (typeof window !== 'undefined') { // Check if we're running in the browser.   // ✅ Only runs once per app load  checkAuthToken();  loadDataFromLocalStorage();}function App() {  // ...}
```

Code at the top level runs once when your component is imported—even if it doesn’t end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don’t overuse this pattern. Keep app-wide initialization logic to root component modules likeApp.jsor in your application’s entry point.


### Notifying parent components about state changes
Let’s say you’re writing aTogglecomponent with an internalisOnstate which can be eithertrueorfalse. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever theToggleinternal state changes, so you expose anonChangeevent and call it from an Effect:

```jsx
function Toggle({ onChange }) {  const [isOn, setIsOn] = useState(false);  // 🔴 Avoid: The onChange handler runs too late  useEffect(() => {    onChange(isOn);  }, [isOn, onChange])  function handleClick() {    setIsOn(!isOn);  }  function handleDragEnd(e) {    if (isCloserToRightEdge(e)) {      setIsOn(true);    } else {      setIsOn(false);    }  }  // ...}
```

Like earlier, this is not ideal. TheToggleupdates its state first, and React updates the screen. Then React runs the Effect, which calls theonChangefunction passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.

Delete the Effect and instead update the state ofbothcomponents within the same event handler:

```jsx
function Toggle({ onChange }) {  const [isOn, setIsOn] = useState(false);  function updateToggle(nextIsOn) {    // ✅ Good: Perform all updates during the event that caused them    setIsOn(nextIsOn);    onChange(nextIsOn);  }  function handleClick() {    updateToggle(!isOn);  }  function handleDragEnd(e) {    if (isCloserToRightEdge(e)) {      updateToggle(true);    } else {      updateToggle(false);    }  }  // ...}
```

With this approach, both theTogglecomponent and its parent component update their state during the event. Reactbatches updatesfrom different components together, so there will only be one render pass.

You might also be able to remove the state altogether, and instead receiveisOnfrom the parent component:

```jsx
// ✅ Also good: the component is fully controlled by its parentfunction Toggle({ isOn, onChange }) {  function handleClick() {    onChange(!isOn);  }  function handleDragEnd(e) {    if (isCloserToRightEdge(e)) {      onChange(true);    } else {      onChange(false);    }  }  // ...}
```

“Lifting state up”lets the parent component fully control theToggleby toggling the parent’s own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!


### Passing data to the parent
ThisChildcomponent fetches some data and then passes it to theParentcomponent in an Effect:

```jsx
function Parent() {  const [data, setData] = useState(null);  // ...  return <Child onFetched={setData} />;}function Child({ onFetched }) {  const data = useSomeAPI();  // 🔴 Avoid: Passing data to the parent in an Effect  useEffect(() => {    if (data) {      onFetched(data);    }  }, [onFetched, data]);  // ...}
```

In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, andpass it downto the child instead:

```jsx
function Parent() {  const data = useSomeAPI();  // ...  // ✅ Good: Passing data down to the child  return <Child data={data} />;}function Child({ data }) {  // ...}
```

This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.


### Subscribing to an external store
Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React’s knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:

```jsx
function useOnlineStatus() {  // Not ideal: Manual store subscription in an Effect  const [isOnline, setIsOnline] = useState(true);  useEffect(() => {    function updateState() {      setIsOnline(navigator.onLine);    }    updateState();    window.addEventListener('online', updateState);    window.addEventListener('offline', updateState);    return () => {      window.removeEventListener('online', updateState);      window.removeEventListener('offline', updateState);    };  }, []);  return isOnline;}function ChatIndicator() {  const isOnline = useOnlineStatus();  // ...}
```

Here, the component subscribes to an external data store (in this case, the browsernavigator.onLineAPI). Since this API does not exist on the server (so it can’t be used for the initial HTML), initially the state is set totrue. Whenever the value of that data store changes in the browser, the component updates its state.

Although it’s common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call touseSyncExternalStore:

```jsx
function subscribe(callback) {  window.addEventListener('online', callback);  window.addEventListener('offline', callback);  return () => {    window.removeEventListener('online', callback);    window.removeEventListener('offline', callback);  };}function useOnlineStatus() {  // ✅ Good: Subscribing to an external store with a built-in Hook  return useSyncExternalStore(    subscribe, // React won't resubscribe for as long as you pass the same function    () => navigator.onLine, // How to get the value on the client    () => true // How to get the value on the server  );}function ChatIndicator() {  const isOnline = useOnlineStatus();  // ...}
```

This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you’ll write a custom Hook likeuseOnlineStatus()above so that you don’t need to repeat this code in the individual components.Read more about subscribing to external stores from React components.


### Fetching data
Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:

```jsx
function SearchResults({ query }) {  const [results, setResults] = useState([]);  const [page, setPage] = useState(1);  useEffect(() => {    // 🔴 Avoid: Fetching without cleanup logic    fetchResults(query, page).then(json => {      setResults(json);    });  }, [query, page]);  function handleNextPageClick() {    setPage(page + 1);  }  // ...}
```

Youdon’tneed to move this fetch to an event handler.

This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it’s notthe typing eventthat’s the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.

It doesn’t matter wherepageandquerycome from. While this component is visible, you want to keepresultssynchronizedwith data from the network for the currentpageandquery. This is why it’s an Effect.

However, the code above has a bug. Imagine you type"hello"fast. Then thequerywill change from"h", to"he","hel","hell", and"hello". This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the"hell"response may arriveafterthe"hello"response. Since it will callsetResults()last, you will be displaying the wrong search results. This is called a“race condition”: two different requests “raced” against each other and came in a different order than you expected.

To fix the race condition, you need toadd a cleanup functionto ignore stale responses:

```jsx
function SearchResults({ query }) {  const [results, setResults] = useState([]);  const [page, setPage] = useState(1);  useEffect(() => {    let ignore = false;    fetchResults(query, page).then(json => {      if (!ignore) {        setResults(json);      }    });    return () => {      ignore = true;    };  }, [query, page]);  function handleNextPageClick() {    setPage(page + 1);  }  // ...}
```

This ensures that when your Effect fetches data, all responses except the last requested one will be ignored.

Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).

These issues apply to any UI library, not just React. Solving them is not trivial, which is why modernframeworksprovide more efficient built-in data fetching mechanisms than fetching data in Effects.

If you don’t use a framework (and don’t want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:

```jsx
function SearchResults({ query }) {  const [page, setPage] = useState(1);  const params = new URLSearchParams({ query, page });  const results = useData(`/api/search?${params}`);  function handleNextPageClick() {    setPage(page + 1);  }  // ...}function useData(url) {  const [data, setData] = useState(null);  useEffect(() => {    let ignore = false;    fetch(url)      .then(response => response.json())      .then(json => {        if (!ignore) {          setData(json);        }      });    return () => {      ignore = true;    };  }, [url]);  return data;}
```

You’ll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem.Although this alone won’t be as efficient as using a framework’s built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.

In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API likeuseDataabove. The fewer rawuseEffectcalls you have in your components, the easier you will find to maintain your application.


## Recap
- If you can calculate something during render, you don’t need an Effect.
- To cache expensive calculations, adduseMemoinstead ofuseEffect.
- To reset the state of an entire component tree, pass a differentkeyto it.
- To reset a particular bit of state in response to a prop change, set it during rendering.
- Code that runs because a component wasdisplayedshould be in Effects, the rest should be in events.
- If you need to update the state of several components, it’s better to do it during a single event.
- Whenever you try to synchronize state variables in different components, consider lifting state up.
- You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.

## Try out some challenges

#### Challenge1of4:Transform data without Effects
TheTodoListbelow displays a list of todos. When the “Show only active todos” checkbox is ticked, completed todos are not displayed in the list. Regardless of which todos are visible, the footer displays the count of todos that are not yet completed.

Simplify this component by removing all the unnecessary state and Effects.

```jsx
import { useState, useEffect } from 'react';
import { initialTodos, createTodo } from './todos.js';

export default function TodoList() {
  const [todos, setTodos] = useState(initialTodos);
  const [showActive, setShowActive] = useState(false);
  const [activeTodos, setActiveTodos] = useState([]);
  const [visibleTodos, setVisibleTodos] = useState([]);
  const [footer, setFooter] = useState(null);

  useEffect(() => {
    setActiveTodos(todos.filter(todo => !todo.completed));
  }, [todos]);

  useEffect(() => {
    setVisibleTodos(showActive ? activeTodos : todos);
  }, [showActive, todos, activeTodos]);

  useEffect(() => {
    setFooter(
      <footer>
        {activeTodos.length} todos left
      </footer>
    );
  }, [activeTodos]);

  return (
    <>
      <label>
        <input
          type="checkbox"
          checked={showActive}
          onChange={e => setShowActive(e.target.checked)}
        />
        Show only active todos
      </label>
      <NewTodo onAdd={newTodo => setTodos([...todos, newTodo])} />
      <ul>
        {visibleTodos.map(todo => (
          <li key={todo.id}>
            {todo.completed ? <s>{todo.text}</s> : todo.text}
          </li>
        ))}
      </ul>
      {footer}
    </>
  );
}

function NewTodo({ onAdd }) {
  const [text, setText] = useState('');

  function handleAddClick() {
    setText('');
    onAdd(createTodo(text));
  }

  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={handleAddClick}>
        Add
      </button>
    </>
  );
}


```


--------------------------------------------------------------------------------


# Lifecycle of Reactive Effects
Source: https://react.dev/learn/lifecycle-of-reactive-effects

Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. This keeps your Effect synchronized to the latest props and state.


### You will learn
- How an Effect’s lifecycle is different from a component’s lifecycle
- How to think about each individual Effect in isolation
- When your Effect needs to re-synchronize, and why
- How your Effect’s dependencies are determined
- What it means for a value to be reactive
- What an empty dependency array means
- How React verifies your dependencies are correct with a linter
- What to do when you disagree with the linter

## The lifecycle of an Effect
Every React component goes through the same lifecycle:

- A componentmountswhen it’s added to the screen.
- A componentupdateswhen it receives new props or state, usually in response to an interaction.
- A componentunmountswhen it’s removed from the screen.
It’s a good way to think about components, butnotabout Effects.Instead, try to think about each Effect independently from your component’s lifecycle. An Effect describes how tosynchronize an external systemto the current props and state. As your code changes, synchronization will need to happen more or less often.

To illustrate this point, consider this Effect connecting your component to a chat server:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}
```

Your Effect’s body specifies how tostart synchronizing:

```jsx
    // ...    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };    // ...
```

The cleanup function returned by your Effect specifies how tostop synchronizing:

```jsx
    // ...    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };    // ...
```

Intuitively, you might think that React wouldstart synchronizingwhen your component mounts andstop synchronizingwhen your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary tostart and stop synchronizing multiple timeswhile the component remains mounted.

Let’s look atwhythis is necessary,whenit happens, andhowyou can control this behavior.


### Note
Some Effects don’t return a cleanup function at all.More often than not,you’ll want to return one—but if you don’t, React will behave as if you returned an empty cleanup function.


### Why synchronization may need to happen more than once
Imagine thisChatRoomcomponent receives aroomIdprop that the user picks in a dropdown. Let’s say that initially the user picks the"general"room as theroomId. Your app displays the"general"chat room:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId /* "general" */ }) {  // ...  return <h1>Welcome to the {roomId} room!</h1>;}
```

After the UI is displayed, React will run your Effect tostart synchronizing.It connects to the"general"room:

```jsx
function ChatRoom({ roomId /* "general" */ }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room    connection.connect();    return () => {      connection.disconnect(); // Disconnects from the "general" room    };  }, [roomId]);  // ...
```

So far, so good.

Later, the user picks a different room in the dropdown (for example,"travel"). First, React will update the UI:

```jsx
function ChatRoom({ roomId /* "travel" */ }) {  // ...  return <h1>Welcome to the {roomId} room!</h1>;}
```

Think about what should happen next. The user sees that"travel"is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the"general"room.TheroomIdprop has changed, so what your Effect did back then (connecting to the"general"room) no longer matches the UI.

At this point, you want React to do two things:

- Stop synchronizing with the oldroomId(disconnect from the"general"room)
- Start synchronizing with the newroomId(connect to the"travel"room)
Luckily, you’ve already taught React how to do both of these things!Your Effect’s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let’s see how exactly that happens.


### How React re-synchronizes your Effect
Recall that yourChatRoomcomponent has received a new value for itsroomIdprop. It used to be"general", and now it is"travel". React needs to re-synchronize your Effect to re-connect you to a different room.

Tostop synchronizing,React will call the cleanup function that your Effect returned after connecting to the"general"room. SinceroomIdwas"general", the cleanup function disconnects from the"general"room:

```jsx
function ChatRoom({ roomId /* "general" */ }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room    connection.connect();    return () => {      connection.disconnect(); // Disconnects from the "general" room    };    // ...
```

Then React will run the Effect that you’ve provided during this render. This time,roomIdis"travel"so it willstart synchronizingto the"travel"chat room (until its cleanup function is eventually called too):

```jsx
function ChatRoom({ roomId /* "travel" */ }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Connects to the "travel" room    connection.connect();    // ...
```

Thanks to this, you’re now connected to the same room that the user chose in the UI. Disaster averted!

Every time after your component re-renders with a differentroomId, your Effect will re-synchronize. For example, let’s say the user changesroomIdfrom"travel"to"music". React will againstop synchronizingyour Effect by calling its cleanup function (disconnecting you from the"travel"room). Then it willstart synchronizingagain by running its body with the newroomIdprop (connecting you to the"music"room).

Finally, when the user goes to a different screen,ChatRoomunmounts. Now there is no need to stay connected at all. React willstop synchronizingyour Effect one last time and disconnect you from the"music"chat room.


### Thinking from the Effect’s perspective
Let’s recap everything that’s happened from theChatRoomcomponent’s perspective:

- ChatRoommounted withroomIdset to"general"
- ChatRoomupdated withroomIdset to"travel"
- ChatRoomupdated withroomIdset to"music"
- ChatRoomunmounted
During each of these points in the component’s lifecycle, your Effect did different things:

- Your Effect connected to the"general"room
- Your Effect disconnected from the"general"room and connected to the"travel"room
- Your Effect disconnected from the"travel"room and connected to the"music"room
- Your Effect disconnected from the"music"room
Now let’s think about what happened from the perspective of the Effect itself:

```jsx
  useEffect(() => {    // Your Effect connected to the room specified with roomId...    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      // ...until it disconnected      connection.disconnect();    };  }, [roomId]);
```

This code’s structure might inspire you to see what happened as a sequence of non-overlapping time periods:

- Your Effect connected to the"general"room (until it disconnected)
- Your Effect connected to the"travel"room (until it disconnected)
- Your Effect connected to the"music"room (until it disconnected)
Previously, you were thinking from the component’s perspective. When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”. This way of thinking gets complicated very fast, so it’s best to avoid.

Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed.

This might remind you how you don’t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and Reactfigures out the rest.


### How React verifies that your Effect can re-synchronize
Here is a live example that you can play with. Press “Open chat” to mount theChatRoomcomponent:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}


```

Notice that when the component mounts for the first time, you see three logs:

- ✅ Connecting to "general" room at https://localhost:1234...(development-only)
- ❌ Disconnected from "general" room at https://localhost:1234.(development-only)
- ✅ Connecting to "general" room at https://localhost:1234...
The first two logs are development-only. In development, React always remounts each component once.

React verifies that your Effect can re-synchronize by forcing it to do that immediately in development.This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to checkyou’ve implemented its cleanup well.

The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when theroomIdchanges, your Effect re-synchronizes.

However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing theserverUrlin the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization.


### How React knows that it needs to re-synchronize the Effect
You might be wondering how React knew that your Effect needed to re-synchronize afterroomIdchanges. It’s becauseyou told Reactthat its code depends onroomIdby including it in thelist of dependencies:

```jsx
function ChatRoom({ roomId }) { // The roomId prop may change over time  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads roomId     connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]); // So you tell React that this Effect "depends on" roomId  // ...
```

Here’s how this works:

- You knewroomIdis a prop, which means it can change over time.
- You knew that your Effect readsroomId(so its logic depends on a value that may change later).
- This is why you specified it as your Effect’s dependency (so that it re-synchronizes whenroomIdchanges).
Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect.

For example, if you passed["general"]during the initial render, and later you passed["travel"]during the next render, React will compare"general"and"travel". These are different values (compared withObject.is), so React will re-synchronize your Effect. On the other hand, if your component re-renders butroomIdhas not changed, your Effect will remain connected to the same room.


### Each Effect represents a separate synchronization process
Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let’s say you want to send an analytics event when the user visits the room. You already have an Effect that depends onroomId, so you might feel tempted to add the analytics call there:

```jsx
function ChatRoom({ roomId }) {  useEffect(() => {    logVisit(roomId);    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}
```

But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also calllogVisit(roomId)for the same room, which you did not intend. Logging the visitis a separate processfrom connecting. Write them as two separate Effects:

```jsx
function ChatRoom({ roomId }) {  useEffect(() => {    logVisit(roomId);  }, [roomId]);  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    // ...  }, [roomId]);  // ...}
```

Each Effect in your code should represent a separate and independent synchronization process.

In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will bemore difficult to maintain.This is why you should think whether the processes are same or separate, not whether the code looks cleaner.


## Effects “react” to reactive values
Your Effect reads two variables (serverUrlandroomId), but you only specifiedroomIdas a dependency:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}
```

Why doesn’tserverUrlneed to be a dependency?

This is because theserverUrlnever changes due to a re-render. It’s always the same no matter how many times the component re-renders and why. SinceserverUrlnever changes, it wouldn’t make sense to specify it as a dependency. After all, dependencies only do something when they change over time!

On the other hand,roomIdmay be different on a re-render.Props, state, and other values declared inside the component arereactivebecause they’re calculated during rendering and participate in the React data flow.

IfserverUrlwas a state variable, it would be reactive. Reactive values must be included in dependencies:

```jsx
function ChatRoom({ roomId }) { // Props change over time  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // State may change over time  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Your Effect reads props and state    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId, serverUrl]); // So you tell React that this Effect "depends on" on props and state  // ...}
```

By includingserverUrlas a dependency, you ensure that the Effect re-synchronizes after it changes.

Try changing the selected chat room or edit the server URL in this sandbox:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

Whenever you change a reactive value likeroomIdorserverUrl, the Effect re-connects to the chat server.


### What an Effect with empty dependencies means
What happens if you move bothserverUrlandroomIdoutside the component?

```jsx
const serverUrl = 'https://localhost:1234';const roomId = 'general';function ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, []); // ✅ All dependencies declared  // ...}
```

Now your Effect’s code does not useanyreactive values, so its dependencies can be empty ([]).

Thinking from the component’s perspective, the empty[]dependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would stillre-synchronize it an extra timein development to stress-test your logic.)

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom />}
    </>
  );
}


```

However, if youthink from the Effect’s perspective,you don’t need to think about mounting and unmounting at all. What’s important is you’ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to changeroomIdorserverUrlover time (and they would become reactive), your Effect’s code won’t change. You will only need to add them to the dependencies.


### All variables declared in the component body are reactive
Props and state aren’t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list.

Let’s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you’ve already put the settings state in acontextso you read thesettingsfrom that context. Now you calculate theserverUrlbased on the selected server from props and the default server:

```jsx
function ChatRoom({ roomId, selectedServerUrl }) { // roomId is reactive  const settings = useContext(SettingsContext); // settings is reactive  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!  // ...}
```

In this example,serverUrlis not a prop or a state variable. It’s a regular variable that you calculate during rendering. But it’s calculated during rendering, so it can change due to a re-render. This is why it’s reactive.

All values inside the component (including props, state, and variables in your component’s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect’s dependencies.

In other words, Effects “react” to all values from the component body.


#### Can global or mutable values be dependencies?
Mutable values (including global variables) aren’t reactive.

A mutable value likelocation.pathnamecan’t be a dependency.It’s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn’t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, Reactwouldn’t knowto re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breakspurity of rendering.Instead, you should read and subscribe to an external mutable value withuseSyncExternalStore.

A mutable value likeref.currentor things you read from it also can’t be a dependency.The ref object returned byuseRefitself can be a dependency, but itscurrentproperty is intentionally mutable. It lets youkeep track of something without triggering a re-render.But since changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes.

As you’ll learn below on this page, a linter will check for these issues automatically.


### React verifies that you specified every reactive value as a dependency
If your linter isconfigured for React,it will check that every reactive value used by your Effect’s code is declared as its dependency. For example, this is a lint error because bothroomIdandserverUrlare reactive:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) { // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- Something's wrong here!

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

This may look like a React error, but really React is pointing out a bug in your code. BothroomIdandserverUrlmay change over time, but you’re forgetting to re-synchronize your Effect when they change. You will remain connected to the initialroomIdandserverUrleven after the user picks different values in the UI.

To fix the bug, follow the linter’s suggestion to specifyroomIdandserverUrlas dependencies of your Effect:

```jsx
function ChatRoom({ roomId }) { // roomId is reactive  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]); // ✅ All dependencies declared  // ...}
```

Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.


### Note
In some cases, Reactknowsthat a value never changes even though it’s declared inside the component. For example, thesetfunctionreturned fromuseStateand the ref object returned byuseRefarestable—they are guaranteed to not change on a re-render. Stable values aren’t reactive, so you may omit them from the list. Including them is allowed: they won’t change, so it doesn’t matter.


### What to do when you don’t want to re-synchronize
In the previous example, you’ve fixed the lint error by listingroomIdandserverUrlas dependencies.

However, you could instead “prove” to the linter that these values aren’t reactive values,i.e. that theycan’tchange as a result of a re-render. For example, ifserverUrlandroomIddon’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:

```jsx
const serverUrl = 'https://localhost:1234'; // serverUrl is not reactiveconst roomId = 'general'; // roomId is not reactivefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, []); // ✅ All dependencies declared  // ...}
```

You can also move theminside the Effect.They aren’t calculated during rendering, so they’re not reactive:

```jsx
function ChatRoom() {  useEffect(() => {    const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive    const roomId = 'general'; // roomId is not reactive    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, []); // ✅ All dependencies declared  // ...}
```

Effects are reactive blocks of code.They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.

You can’t “choose” your dependencies.Your dependencies must include everyreactive valueyou read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don’t fix these problems by suppressing the linter! Here’s what to try instead:

- Check that your Effect represents an independent synchronization process.If your Effect doesn’t synchronize anything,it might be unnecessary.If it synchronizes several independent things,split it up.
Check that your Effect represents an independent synchronization process.If your Effect doesn’t synchronize anything,it might be unnecessary.If it synchronizes several independent things,split it up.

- If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect,you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called anEffect Event).Read about separating Events from Effects.
If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect,you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called anEffect Event).Read about separating Events from Effects.

- Avoid relying on objects and functions as dependencies.If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time.Read more about removing unnecessary dependencies from Effects.
Avoid relying on objects and functions as dependencies.If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time.Read more about removing unnecessary dependencies from Effects.


### Pitfall
The linter is your friend, but its powers are limited. The linter only knows when the dependencies arewrong. It doesn’t knowthe bestway to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn’t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn’t reactive and doesn’tneedto be a dependency.

If you have an existing codebase, you might have some Effects that suppress the linter like this:

```jsx
useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);
```

On thenextpages, you’ll learn how to fix this code without breaking the rules. It’s always worth fixing!


## Recap
- Components can mount, update, and unmount.
- Each Effect has a separate lifecycle from the surrounding component.
- Each Effect describes a separate synchronization process that canstartandstop.
- When you write and read Effects, think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).
- Values declared inside the component body are “reactive”.
- Reactive values should re-synchronize the Effect because they can change over time.
- The linter verifies that all reactive values used inside the Effect are specified as dependencies.
- All errors flagged by the linter are legitimate. There’s always a way to fix the code to not break the rules.

## Try out some challenges

#### Challenge1of5:Fix reconnecting on every keystroke
In this example, theChatRoomcomponent connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.

However, there is a problem. Whenever you type into the message box input at the bottom,ChatRoomalsoreconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn’t happen.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  });

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```


--------------------------------------------------------------------------------


# Separating Events from Effects
Source: https://react.dev/learn/separating-events-from-effects

Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that.


### You will learn
- How to choose between an event handler and an Effect
- Why Effects are reactive, and event handlers are not
- What to do when you want a part of your Effect’s code to not be reactive
- What Effect Events are, and how to extract them from your Effects
- How to read the latest props and state from Effects using Effect Events

## Choosing between event handlers and Effects
First, let’s recap the difference between event handlers and Effects.

Imagine you’re implementing a chat room component. Your requirements look like this:

- Your component should automatically connect to the selected chat room.
- When you click the “Send” button, it should send a message to the chat.
Let’s say you’ve already implemented the code for them, but you’re not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, considerwhythe code needs to run.


### Event handlers run in response to specific interactions
From the user’s perspective, sending a message should happenbecausethe particular “Send” button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  // ...  function handleSendClick() {    sendMessage(message);  }  // ...  return (    <>      <input value={message} onChange={e => setMessage(e.target.value)} />      <button onClick={handleSendClick}>Send</button>    </>  );}
```

With an event handler, you can be sure thatsendMessage(message)willonlyrun if the user presses the button.


### Effects run whenever synchronization is needed
Recall that you also need to keep the component connected to the chat room. Where does that code go?

Thereasonto run this code is not some particular interaction. It doesn’t matter why or how the user navigated to the chat room screen. Now that they’re looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you wouldstillneed to connect. This is why it’s an Effect:

```jsx
function ChatRoom({ roomId }) {  // ...  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [roomId]);  // ...}
```

With this code, you can be sure that there is always an active connection to the currently selected chat server,regardlessof the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component willremain synchronizedwith the currently selected room, and willre-connect whenever it’s necessary.

```jsx
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  function handleSendClick() {
    sendMessage(message);
  }

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}


```


## Reactive values and reactive logic
Intuitively, you could say that event handlers are always triggered “manually”, for example by clicking a button. Effects, on the other hand, are “automatic”: they run and re-run as often as it’s needed to stay synchronized.

There is a more precise way to think about this.

Props, state, and variables declared inside your component’s body are calledreactive values. In this example,serverUrlis not a reactive value, butroomIdandmessageare. They participate in the rendering data flow:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  // ...}
```

Reactive values like these can change due to a re-render. For example, the user may edit themessageor choose a differentroomIdin a dropdown. Event handlers and Effects respond to changes differently:

- Logic inside event handlers isnot reactive.It will not run again unless the user performs the same interaction (e.g. a click) again. Event handlers can read reactive values without “reacting” to their changes.
- Logic inside Effects isreactive.If your Effect reads a reactive value,you have to specify it as a dependency.Then, if a re-render causes that value to change, React will re-run your Effect’s logic with the new value.
Let’s revisit the previous example to illustrate this difference.


### Logic inside event handlers is not reactive
Take a look at this line of code. Should this logic be reactive or not?

```jsx
    // ...    sendMessage(message);    // ...
```

From the user’s perspective,a change to themessagedoesnotmean that they want to send a message.It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because thereactive valuehas changed. That’s why it belongs in the event handler:

```jsx
  function handleSendClick() {    sendMessage(message);  }
```

Event handlers aren’t reactive, sosendMessage(message)will only run when the user clicks the Send button.


### Logic inside Effects is reactive
Now let’s return to these lines:

```jsx
    // ...    const connection = createConnection(serverUrl, roomId);    connection.connect();    // ...
```

From the user’s perspective,a change to theroomIddoesmean that they want to connect to a different room.In other words, the logic for connecting to the room should be reactive. Youwantthese lines of code to “keep up” with thereactive value, and to run again if that value is different. That’s why it belongs in an Effect:

```jsx
  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect()    };  }, [roomId]);
```

Effects are reactive, socreateConnection(serverUrl, roomId)andconnection.connect()will run for every distinct value ofroomId. Your Effect keeps the chat connection synchronized to the currently selected room.


## Extracting non-reactive logic out of Effects
Things get more tricky when you want to mix reactive logic with non-reactive logic.

For example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:

```jsx
function ChatRoom({ roomId, theme }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.on('connected', () => {      showNotification('Connected!', theme);    });    connection.connect();    // ...
```

However,themeis a reactive value (it can change as a result of re-rendering), andevery reactive value read by an Effect must be declared as its dependency.Now you have to specifythemeas a dependency of your Effect:

```jsx
function ChatRoom({ roomId, theme }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.on('connected', () => {      showNotification('Connected!', theme);    });    connection.connect();    return () => {      connection.disconnect()    };  }, [roomId, theme]); // ✅ All dependencies declared  // ...
```

Play with this example and see if you can spot the problem with this user experience:

```jsx
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}


```

When theroomIdchanges, the chat re-connects as you would expect. But sincethemeis also a dependency, the chatalsore-connects every time you switch between the dark and the light theme. That’s not great!

In other words, youdon’twant this line to be reactive, even though it is inside an Effect (which is reactive):

```jsx
      // ...      showNotification('Connected!', theme);      // ...
```

You need a way to separate this non-reactive logic from the reactive Effect around it.


### Declaring an Effect Event
Use a special Hook calleduseEffectEventto extract this non-reactive logic out of your Effect:

```jsx
import { useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId, theme }) {  const onConnected = useEffectEvent(() => {    showNotification('Connected!', theme);  });  // ...
```

Here,onConnectedis called anEffect Event.It’s a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always “sees” the latest values of your props and state.

Now you can call theonConnectedEffect Event from inside your Effect:

```jsx
function ChatRoom({ roomId, theme }) {  const onConnected = useEffectEvent(() => {    showNotification('Connected!', theme);  });  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.on('connected', () => {      onConnected();    });    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...
```

This solves the problem. Note that you had toremovethemefrom the list of your Effect’s dependencies, because it’s no longer used in the Effect. You also don’t need toaddonConnectedto it, becauseEffect Events are not reactive and must be omitted from dependencies.

Verify that the new behavior works as you would expect:

```jsx
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}


```

You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.


### Reading latest props and state with Effect Events
Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.

For example, say you have an Effect to log the page visits:

```jsx
function Page() {  useEffect(() => {    logVisit();  }, []);  // ...}
```

Later, you add multiple routes to your site. Now yourPagecomponent receives aurlprop with the current path. You want to pass theurlas a part of yourlogVisitcall, but the dependency linter complains:

```jsx
function Page({ url }) {  useEffect(() => {    logVisit(url);  }, []); // 🔴 React Hook useEffect has a missing dependency: 'url'  // ...}
```

Think about what you want the code to do. Youwantto log a separate visit for different URLs since each URL represents a different page. In other words, thislogVisitcallshouldbe reactive with respect to theurl. This is why, in this case, it makes sense to follow the dependency linter, and addurlas a dependency:

```jsx
function Page({ url }) {  useEffect(() => {    logVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}
```

Now let’s say you want to include the number of items in the shopping cart together with every page visit:

```jsx
function Page({ url }) {  const { items } = useContext(ShoppingCartContext);  const numberOfItems = items.length;  useEffect(() => {    logVisit(url, numberOfItems);  }, [url]); // 🔴 React Hook useEffect has a missing dependency: 'numberOfItems'  // ...}
```

You usednumberOfItemsinside the Effect, so the linter asks you to add it as a dependency. However, youdon’twant thelogVisitcall to be reactive with respect tonumberOfItems. If the user puts something into the shopping cart, and thenumberOfItemschanges, thisdoes not meanthat the user visited the page again. In other words,visiting the pageis, in some sense, an “event”. It happens at a precise moment in time.

Split the code in two parts:

```jsx
function Page({ url }) {  const { items } = useContext(ShoppingCartContext);  const numberOfItems = items.length;  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, numberOfItems);  });  useEffect(() => {    onVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}
```

Here,onVisitis an Effect Event. The code inside it isn’t reactive. This is why you can usenumberOfItems(or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes.

On the other hand, the Effect itself remains reactive. Code inside the Effect uses theurlprop, so the Effect will re-run after every re-render with a differenturl. This, in turn, will call theonVisitEffect Event.

As a result, you will calllogVisitfor every change to theurl, and always read the latestnumberOfItems. However, ifnumberOfItemschanges on its own, this will not cause any of the code to re-run.


### Note
You might be wondering if you could callonVisit()with no arguments, and read theurlinside it:

```jsx
  const onVisit = useEffectEvent(() => {    logVisit(url, numberOfItems);  });  useEffect(() => {    onVisit();  }, [url]);
```

This would work, but it’s better to pass thisurlto the Effect Event explicitly.By passingurlas an argument to your Effect Event, you are saying that visiting a page with a differenturlconstitutes a separate “event” from the user’s perspective.ThevisitedUrlis apartof the “event” that happened:

```jsx
  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, numberOfItems);  });  useEffect(() => {    onVisit(url);  }, [url]);
```

Since your Effect Event explicitly “asks” for thevisitedUrl, now you can’t accidentally removeurlfrom the Effect’s dependencies. If you remove theurldependency (causing distinct page visits to be counted as one), the linter will warn you about it. You wantonVisitto be reactive with regards to theurl, so instead of reading theurlinside (where it wouldn’t be reactive), you pass itfromyour Effect.

This becomes especially important if there is some asynchronous logic inside the Effect:

```jsx
  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, numberOfItems);  });  useEffect(() => {    setTimeout(() => {      onVisit(url);    }, 5000); // Delay logging visits  }, [url]);
```

Here,urlinsideonVisitcorresponds to thelatesturl(which could have already changed), butvisitedUrlcorresponds to theurlthat originally caused this Effect (and thisonVisitcall) to run.


#### Is it okay to suppress the dependency linter instead?
In the existing codebases, you may sometimes see the lint rule suppressed like this:

```jsx
function Page({ url }) {  const { items } = useContext(ShoppingCartContext);  const numberOfItems = items.length;  useEffect(() => {    logVisit(url, numberOfItems);    // 🔴 Avoid suppressing the linter like this:    // eslint-disable-next-line react-hooks/exhaustive-deps  }, [url]);  // ...}
```

We recommendnever suppressing the linter.

The first downside of suppressing the rule is that React will no longer warn you when your Effect needs to “react” to a new reactive dependency you’ve introduced to your code. In the earlier example, you addedurlto the dependenciesbecauseReact reminded you to do it. You will no longer get such reminders for any future edits to that Effect if you disable the linter. This leads to bugs.

Here is an example of a confusing bug caused by suppressing the linter. In this example, thehandleMovefunction is supposed to read the currentcanMovestate variable value in order to decide whether the dot should follow the cursor. However,canMoveis alwaystrueinsidehandleMove.

Can you see why?

```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}


```

The problem with this code is in suppressing the dependency linter. If you remove the suppression, you’ll see that this Effect should depend on thehandleMovefunction. This makes sense:handleMoveis declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!

The author of the original code has “lied” to React by saying that the Effect does not depend ([]) on any reactive values. This is why React did not re-synchronize the Effect aftercanMovehas changed (andhandleMovewith it). Because React did not re-synchronize the Effect, thehandleMoveattached as a listener is thehandleMovefunction created during the initial render. During the initial render,canMovewastrue, which is whyhandleMovefrom the initial render will forever see that value.

If you never suppress the linter, you will never see problems with stale values.

WithuseEffectEvent, there is no need to “lie” to the linter, and the code works as you would expect:

```jsx
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  const onMove = useEffectEvent(e => {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener('pointermove', onMove);
    return () => window.removeEventListener('pointermove', onMove);
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}


```

This doesn’t mean thatuseEffectEventisalwaysthe correct solution. You should only apply it to the lines of code that you don’t want to be reactive. In the above sandbox, you didn’t want the Effect’s code to be reactive with regards tocanMove. That’s why it made sense to extract an Effect Event.

ReadRemoving Effect Dependenciesfor other correct alternatives to suppressing the linter.


### Limitations of Effect Events
Effect Events are very limited in how you can use them:

- Only call them from inside Effects.
- Never pass them to other components or Hooks.
For example, don’t declare and pass an Effect Event like this:

```jsx
function Timer() {  const [count, setCount] = useState(0);  const onTick = useEffectEvent(() => {    setCount(count + 1);  });  useTimer(onTick, 1000); // 🔴 Avoid: Passing Effect Events  return <h1>{count}</h1>}function useTimer(callback, delay) {  useEffect(() => {    const id = setInterval(() => {      callback();    }, delay);    return () => {      clearInterval(id);    };  }, [delay, callback]); // Need to specify "callback" in dependencies}
```

Instead, always declare Effect Events directly next to the Effects that use them:

```jsx
function Timer() {  const [count, setCount] = useState(0);  useTimer(() => {    setCount(count + 1);  }, 1000);  return <h1>{count}</h1>}function useTimer(callback, delay) {  const onTick = useEffectEvent(() => {    callback();  });  useEffect(() => {    const id = setInterval(() => {      onTick(); // ✅ Good: Only called locally inside an Effect    }, delay);    return () => {      clearInterval(id);    };  }, [delay]); // No need to specify "onTick" (an Effect Event) as a dependency}
```

Effect Events are non-reactive “pieces” of your Effect code. They should be next to the Effect using them.


## Recap
- Event handlers run in response to specific interactions.
- Effects run whenever synchronization is needed.
- Logic inside event handlers is not reactive.
- Logic inside Effects is reactive.
- You can move non-reactive logic from Effects into Effect Events.
- Only call Effect Events from inside Effects.
- Don’t pass Effect Events to other components or Hooks.

## Try out some challenges

#### Challenge1of4:Fix a variable that doesn’t update
ThisTimercomponent keeps acountstate variable which increases every second. The value by which it’s increasing is stored in theincrementstate variable. You can control theincrementvariable with the plus and minus buttons.

However, no matter how many times you click the plus button, the counter is still incremented by one every second. What’s wrong with this code? Why isincrementalways equal to1inside the Effect’s code? Find the mistake and fix it.

```jsx
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>–</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}


```


--------------------------------------------------------------------------------


# Removing Effect Dependencies
Source: https://react.dev/learn/removing-effect-dependencies

When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects.


### You will learn
- How to fix infinite Effect dependency loops
- What to do when you want to remove a dependency
- How to read a value from your Effect without “reacting” to it
- How and why to avoid object and function dependencies
- Why suppressing the dependency linter is dangerous, and what to do instead

## Dependencies should match the code
When you write an Effect, you first specify how tostart and stopwhatever you want your Effect to be doing:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  	// ...}
```

Then, if you leave the Effect dependencies empty ([]), the linter will suggest the correct dependencies:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- Fix the mistake here!
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

Fill them in according to what the linter says:

```jsx
function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...}
```

Effects “react” to reactive values.SinceroomIdis a reactive value (it can change due to a re-render), the linter verifies that you’ve specified it as a dependency. IfroomIdreceives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and “reacts” to the dropdown:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```


### To remove a dependency, prove that it’s not a dependency
Notice that you can’t “choose” the dependencies of your Effect. Everyreactive valueused by your Effect’s code must be declared in your dependency list. The dependency list is determined by the surrounding code:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) { // This is a reactive value  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ So you must specify that reactive value as a dependency of your Effect  // ...}
```

Reactive valuesinclude props and all variables and functions declared directly inside of your component. SinceroomIdis a reactive value, you can’t remove it from the dependency list. The linter wouldn’t allow it:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // 🔴 React Hook useEffect has a missing dependency: 'roomId'  // ...}
```

And the linter would be right! SinceroomIdmay change over time, this would introduce a bug in your code.

To remove a dependency, “prove” to the linter that itdoesn’t needto be a dependency.For example, you can moveroomIdout of your component to prove that it’s not reactive and won’t change on re-renders:

```jsx
const serverUrl = 'https://localhost:1234';const roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...}
```

Now thatroomIdis not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'music';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the {roomId} room!</h1>;
}


```

This is why you could now specify anempty ([]) dependency list.Your Effectreally doesn’tdepend on any reactive value anymore, so itreally doesn’tneed to re-run when any of the component’s props or state change.


### To change the dependencies, change the code
You might have noticed a pattern in your workflow:

- First, youchange the codeof your Effect or how your reactive values are declared.
- Then, you follow the linter and adjust the dependencies tomatch the code you have changed.
- If you’re not happy with the list of dependencies, yougo back to the first step(and change the code again).
The last part is important.If you want to change the dependencies, change the surrounding code first.You can think of the dependency list asa list of all the reactive values used by your Effect’s code.You don’tchoosewhat to put on that list. The listdescribesyour code. To change the dependency list, change the code.

This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to “find” the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below.


### Pitfall
If you have an existing codebase, you might have some Effects that suppress the linter like this:

```jsx
useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);
```

When dependencies don’t match the code, there is a very high risk of introducing bugs.By suppressing the linter, you “lie” to React about the values your Effect depends on.

Instead, use the techniques below.


#### Why is suppressing the dependency linter so dangerous?
Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Here’s one example:

```jsx
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  function onTick() {
	setCount(count + increment);
  }

  useEffect(() => {
    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>–</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}


```

Let’s say that you wanted to run the Effect “only on mount”. You’ve read thatempty ([]) dependenciesdo that, so you’ve decided to ignore the linter, and forcefully specified[]as the dependencies.

This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you “lied” to React that this Effect doesn’t depend on anything, React forever keeps using theonTickfunction from the initial render.During that render,countwas0andincrementwas1. This is whyonTickfrom that render always callssetCount(0 + 1)every second, and you always see1. Bugs like this are harder to fix when they’re spread across multiple components.

There’s always a better solution than ignoring the linter! To fix this code, you need to addonTickto the dependency list. (To ensure the interval is only setup once,makeonTickan Effect Event.)

We recommend treating the dependency lint error as a compilation error. If you don’t suppress it, you will never see bugs like this.The rest of this page documents the alternatives for this and other cases.


## Removing unnecessary dependencies
Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:

- You might want to re-executedifferent partsof your Effect under different conditions.
- You might want to only read thelatest valueof some dependency instead of “reacting” to its changes.
- A dependency may change too oftenunintentionallybecause it’s an object or a function.
To find the right solution, you’ll need to answer a few questions about your Effect. Let’s walk through them.


### Should this code move to an event handler?
The first thing you should think about is whether this code should be an Effect at all.

Imagine a form. On submit, you set thesubmittedstate variable totrue. You need to send a POST request and show a notification. You’ve put this logic inside an Effect that “reacts” tosubmittedbeingtrue:

```jsx
function Form() {  const [submitted, setSubmitted] = useState(false);  useEffect(() => {    if (submitted) {      // 🔴 Avoid: Event-specific logic inside an Effect      post('/api/register');      showNotification('Successfully registered!');    }  }, [submitted]);  function handleSubmit() {    setSubmitted(true);  }  // ...}
```

Later, you want to style the notification message according to the current theme, so you read the current theme. Sincethemeis declared in the component body, it is a reactive value, so you add it as a dependency:

```jsx
function Form() {  const [submitted, setSubmitted] = useState(false);  const theme = useContext(ThemeContext);  useEffect(() => {    if (submitted) {      // 🔴 Avoid: Event-specific logic inside an Effect      post('/api/register');      showNotification('Successfully registered!', theme);    }  }, [submitted, theme]); // ✅ All dependencies declared  function handleSubmit() {    setSubmitted(true);  }    // ...}
```

By doing this, you’ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. Thethemewill change, the Effect will re-run, and so it will display the same notification again!

The problem here is that this shouldn’t be an Effect in the first place.You want to send this POST request and show the notification in response tosubmitting the form,which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:

```jsx
function Form() {  const theme = useContext(ThemeContext);  function handleSubmit() {    // ✅ Good: Event-specific logic is called from event handlers    post('/api/register');    showNotification('Successfully registered!', theme);  }    // ...}
```

Now that the code is in an event handler, it’s not reactive—so it will only run when the user submits the form. Read more aboutchoosing between event handlers and Effectsandhow to delete unnecessary Effects.


### Is your Effect doing several unrelated things?
The next question you should ask yourself is whether your Effect is doing several unrelated things.

Imagine you’re creating a shipping form where the user needs to choose their city and area. You fetch the list ofcitiesfrom the server according to the selectedcountryto show them in a dropdown:

```jsx
function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  const [city, setCity] = useState(null);  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    return () => {      ignore = true;    };  }, [country]); // ✅ All dependencies declared  // ...
```

This is a good example offetching data in an Effect.You are synchronizing thecitiesstate with the network according to thecountryprop. You can’t do this in an event handler because you need to fetch as soon asShippingFormis displayed and whenever thecountrychanges (no matter which interaction causes it).

Now let’s say you’re adding a second select box for city areas, which should fetch theareasfor the currently selectedcity. You might start by adding a secondfetchcall for the list of areas inside the same Effect:

```jsx
function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  const [city, setCity] = useState(null);  const [areas, setAreas] = useState(null);  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    // 🔴 Avoid: A single Effect synchronizes two independent processes    if (city) {      fetch(`/api/areas?city=${city}`)        .then(response => response.json())        .then(json => {          if (!ignore) {            setAreas(json);          }        });    }    return () => {      ignore = true;    };  }, [country, city]); // ✅ All dependencies declared  // ...
```

However, since the Effect now uses thecitystate variable, you’ve had to addcityto the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and callfetchCities(country). As a result, you will be unnecessarily refetching the list of cities many times.

The problem with this code is that you’re synchronizing two different unrelated things:

- You want to synchronize thecitiesstate to the network based on thecountryprop.
- You want to synchronize theareasstate to the network based on thecitystate.
Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:

```jsx
function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    return () => {      ignore = true;    };  }, [country]); // ✅ All dependencies declared  const [city, setCity] = useState(null);  const [areas, setAreas] = useState(null);  useEffect(() => {    if (city) {      let ignore = false;      fetch(`/api/areas?city=${city}`)        .then(response => response.json())        .then(json => {          if (!ignore) {            setAreas(json);          }        });      return () => {        ignore = true;      };    }  }, [city]); // ✅ All dependencies declared  // ...
```

Now the first Effect only re-runs if thecountrychanges, while the second Effect re-runs when thecitychanges. You’ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they won’t trigger each other unintentionally.

The final code is longer than the original, but splitting these Effects is still correct.Each Effect should represent an independent synchronization process.In this example, deleting one Effect doesn’t break the other Effect’s logic. This means theysynchronize different things,and it’s good to split them up. If you’re concerned about duplication, you can improve this code byextracting repetitive logic into a custom Hook.


### Are you reading some state to calculate the next state?
This Effect updates themessagesstate variable with a newly created array every time a new message arrives:

```jsx
function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages([...messages, receivedMessage]);    });    // ...
```

It uses themessagesvariable tocreate a new arraystarting with all the existing messages and adds the new message at the end. However, sincemessagesis a reactive value read by an Effect, it must be a dependency:

```jsx
function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages([...messages, receivedMessage]);    });    return () => connection.disconnect();  }, [roomId, messages]); // ✅ All dependencies declared  // ...
```

And makingmessagesa dependency introduces a problem.

Every time you receive a message,setMessages()causes the component to re-render with a newmessagesarray that includes the received message. However, since this Effect now depends onmessages, this willalsore-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!

To fix the issue, don’t readmessagesinside the Effect. Instead, pass anupdater functiontosetMessages:

```jsx
function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages(msgs => [...msgs, receivedMessage]);    });    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...
```

Notice how your Effect does not read themessagesvariable at all now.You only need to pass an updater function likemsgs => [...msgs, receivedMessage]. Reactputs your updater function in a queueand will provide themsgsargument to it during the next render. This is why the Effect itself doesn’t need to depend onmessagesanymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect.


### Do you want to read a value without “reacting” to its changes?
Suppose that you want to play a sound when the user receives a new message unlessisMutedistrue:

```jsx
function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  const [isMuted, setIsMuted] = useState(false);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages(msgs => [...msgs, receivedMessage]);      if (!isMuted) {        playSound();      }    });    // ...
```

Since your Effect now usesisMutedin its code, you have to add it to the dependencies:

```jsx
function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  const [isMuted, setIsMuted] = useState(false);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      setMessages(msgs => [...msgs, receivedMessage]);      if (!isMuted) {        playSound();      }    });    return () => connection.disconnect();  }, [roomId, isMuted]); // ✅ All dependencies declared  // ...
```

The problem is that every timeisMutedchanges (for example, when the user presses the “Muted” toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not work—if you do that,isMutedwould get “stuck” with its old value.)

To solve this problem, you need to extract the logic that shouldn’t be reactive out of the Effect. You don’t want this Effect to “react” to the changes inisMuted.Move this non-reactive piece of logic into an Effect Event:

```jsx
import { useState, useEffect, useEffectEvent } from 'react';function ChatRoom({ roomId }) {  const [messages, setMessages] = useState([]);  const [isMuted, setIsMuted] = useState(false);  const onMessage = useEffectEvent(receivedMessage => {    setMessages(msgs => [...msgs, receivedMessage]);    if (!isMuted) {      playSound();    }  });  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      onMessage(receivedMessage);    });    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...
```

Effect Events let you split an Effect into reactive parts (which should “react” to reactive values likeroomIdand their changes) and non-reactive parts (which only read their latest values, likeonMessagereadsisMuted).Now that you readisMutedinside an Effect Event, it doesn’t need to be a dependency of your Effect.As a result, the chat won’t re-connect when you toggle the “Muted” setting on and off, solving the original issue!


#### Wrapping an event handler from the props
You might run into a similar problem when your component receives an event handler as a prop:

```jsx
function ChatRoom({ roomId, onReceiveMessage }) {  const [messages, setMessages] = useState([]);  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      onReceiveMessage(receivedMessage);    });    return () => connection.disconnect();  }, [roomId, onReceiveMessage]); // ✅ All dependencies declared  // ...
```

Suppose that the parent component passes adifferentonReceiveMessagefunction on every render:

```jsx
<ChatRoom  roomId={roomId}  onReceiveMessage={receivedMessage => {    // ...  }}/>
```

SinceonReceiveMessageis a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:

```jsx
function ChatRoom({ roomId, onReceiveMessage }) {  const [messages, setMessages] = useState([]);  const onMessage = useEffectEvent(receivedMessage => {    onReceiveMessage(receivedMessage);  });  useEffect(() => {    const connection = createConnection();    connection.connect();    connection.on('message', (receivedMessage) => {      onMessage(receivedMessage);    });    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...
```

Effect Events aren’t reactive, so you don’t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function that’s different on every re-render.


#### Separating reactive and non-reactive code
In this example, you want to log a visit every timeroomIdchanges. You want to include the currentnotificationCountwith every log, but youdon’twant a change tonotificationCountto trigger a log event.

The solution is again to split out the non-reactive code into an Effect Event:

```jsx
function Chat({ roomId, notificationCount }) {  const onVisit = useEffectEvent(visitedRoomId => {    logVisit(visitedRoomId, notificationCount);  });  useEffect(() => {    onVisit(roomId);  }, [roomId]); // ✅ All dependencies declared  // ...}
```

You want your logic to be reactive with regards toroomId, so you readroomIdinside of your Effect. However, you don’t want a change tonotificationCountto log an extra visit, so you readnotificationCountinside of the Effect Event.Learn more about reading the latest props and state from Effects using Effect Events.


### Does some reactive value change unintentionally?
Sometimes, youdowant your Effect to “react” to a certain value, but that value changes more often than you’d like—and might not reflect any actual change from the user’s perspective. For example, let’s say that you create anoptionsobject in the body of your component, and then read that object from inside of your Effect:

```jsx
function ChatRoom({ roomId }) {  // ...  const options = {    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ...
```

This object is declared in the component body, so it’s areactive value.When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect “reacts” to its changes:

```jsx
  // ...  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ All dependencies declared  // ...
```

It is important to declare it as a dependency! This ensures, for example, that if theroomIdchanges, your Effect will re-connect to the chat with the newoptions. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // Temporarily disable the linter to demonstrate the problem
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

In the sandbox above, the input only updates themessagestate variable. From the user’s perspective, this should not affect the chat connection. However, every time you update themessage, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.

A newoptionsobject is created from scratch on every re-render of theChatRoomcomponent. React sees that theoptionsobject is adifferent objectfrom theoptionsobject created during the last render. This is why it re-synchronizes your Effect (which depends onoptions), and the chat re-connects as you type.

This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!

```jsx
// During the first renderconst options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// During the next renderconst options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };// These are two different objects!console.log(Object.is(options1, options2)); // false
```

Object and function dependencies can make your Effect re-synchronize more often than you need.

This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.


#### Move static objects and functions outside your component
If the object does not depend on any props and state, you can move that object outside your component:

```jsx
const options = {  serverUrl: 'https://localhost:1234',  roomId: 'music'};function ChatRoom() {  const [message, setMessage] = useState('');  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...
```

This way, youproveto the linter that it’s not reactive. It can’t change as a result of a re-render, so it doesn’t need to be a dependency. Now re-renderingChatRoomwon’t cause your Effect to re-synchronize.

This works for functions too:

```jsx
function createOptions() {  return {    serverUrl: 'https://localhost:1234',    roomId: 'music'  };}function ChatRoom() {  const [message, setMessage] = useState('');  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...
```

SincecreateOptionsis declared outside your component, it’s not a reactive value. This is why it doesn’t need to be specified in your Effect’s dependencies, and why it won’t ever cause your Effect to re-synchronize.


#### Move dynamic objects and functions inside your Effect
If your object depends on some reactive value that may change as a result of a re-render, like aroomIdprop, you can’t pull itoutsideyour component. You can, however, move its creationinsideof your Effect’s code:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...
```

Now thatoptionsis declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect isroomId. SinceroomIdis not an object or function, you can be sure that it won’t beunintentionallydifferent. In JavaScript, numbers and strings are compared by their content:

```jsx
// During the first renderconst roomId1 = 'music';// During the next renderconst roomId2 = 'music';// These two strings are the same!console.log(Object.is(roomId1, roomId2)); // true
```

Thanks to this fix, the chat no longer re-connects if you edit the input:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

However, itdoesre-connect when you change theroomIddropdown, as you would expect.

This works for functions, too:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() {      return {        serverUrl: serverUrl,        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...
```

You can write your own functions to group pieces of logic inside your Effect. As long as you also declare theminsideyour Effect, they’re not reactive values, and so they don’t need to be dependencies of your Effect.


#### Read primitive values from objects
Sometimes, you may receive an object from props:

```jsx
function ChatRoom({ options }) {  const [message, setMessage] = useState('');  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ All dependencies declared  // ...
```

The risk here is that the parent component will create the object during rendering:

```jsx
<ChatRoom  roomId={roomId}  options={{    serverUrl: serverUrl,    roomId: roomId  }}/>
```

This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the objectoutsidethe Effect, and avoid having object and function dependencies:

```jsx
function ChatRoom({ options }) {  const [message, setMessage] = useState('');  const { roomId, serverUrl } = options;  useEffect(() => {    const connection = createConnection({      roomId: roomId,      serverUrl: serverUrl    });    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]); // ✅ All dependencies declared  // ...
```

The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effectactuallydepends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, ifoptions.roomIdoroptions.serverUrlreally are different, the chat would re-connect.


#### Calculate primitive values from functions
The same approach can work for functions. For example, suppose the parent component passes a function:

```jsx
<ChatRoom  roomId={roomId}  getOptions={() => {    return {      serverUrl: serverUrl,      roomId: roomId    };  }}/>
```

To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you theroomIdandserverUrlvalues that aren’t objects, and that you can read from inside your Effect:

```jsx
function ChatRoom({ getOptions }) {  const [message, setMessage] = useState('');  const { roomId, serverUrl } = getOptions();  useEffect(() => {    const connection = createConnection({      roomId: roomId,      serverUrl: serverUrl    });    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]); // ✅ All dependencies declared  // ...
```

This only works forpurefunctions because they are safe to call during rendering. If your function is an event handler, but you don’t want its changes to re-synchronize your Effect,wrap it into an Effect Event instead.


## Recap
- Dependencies should always match the code.
- When you’re not happy with your dependencies, what you need to edit is the code.
- Suppressing the linter leads to very confusing bugs, and you should always avoid it.
- To remove a dependency, you need to “prove” to the linter that it’s not necessary.
- If some code should run in response to a specific interaction, move that code to an event handler.
- If different parts of your Effect should re-run for different reasons, split it into several Effects.
- If you want to update some state based on the previous state, pass an updater function.
- If you want to read the latest value without “reacting” it, extract an Effect Event from your Effect.
- In JavaScript, objects and functions are considered different if they were created at different times.
- Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

## Try out some challenges

#### Challenge1of4:Fix a resetting interval
This Effect sets up an interval that ticks every second. You’ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesn’t get constantly re-created.

```jsx
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('✅ Creating an interval');
    const id = setInterval(() => {
      console.log('⏰ Interval tick');
      setCount(count + 1);
    }, 1000);
    return () => {
      console.log('❌ Clearing an interval');
      clearInterval(id);
    };
  }, [count]);

  return <h1>Counter: {count}</h1>
}


```


--------------------------------------------------------------------------------


# Reusing Logic with Custom Hooks
Source: https://react.dev/learn/reusing-logic-with-custom-hooks

React comes with several built-in Hooks likeuseState,useContext, anduseEffect. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. You might not find these Hooks in React, but you can create your own Hooks for your application’s needs.


### You will learn
- What custom Hooks are, and how to write your own
- How to reuse logic between components
- How to name and structure your custom Hooks
- When and why to extract custom Hooks

## Custom Hooks: Sharing logic between components
Imagine you’re developing an app that heavily relies on the network (as most apps do). You want to warn the user if their network connection has accidentally gone off while they were using your app. How would you go about it? It seems like you’ll need two things in your component:

- A piece of state that tracks whether the network is online.
- An Effect that subscribes to the globalonlineandofflineevents, and updates that state.
This will keep your componentsynchronizedwith the network status. You might start with something like this:

```jsx
import { useState, useEffect } from 'react';

export default function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}


```

Try turning your network on and off, and notice how thisStatusBarupdates in response to your actions.

Now imagine youalsowant to use the same logic in a different component. You want to implement a Save button that will become disabled and show “Reconnecting…” instead of “Save” while the network is off.

To start, you can copy and paste theisOnlinestate and the Effect intoSaveButton:

```jsx
import { useState, useEffect } from 'react';

export default function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}


```

Verify that, if you turn off the network, the button will change its appearance.

These two components work fine, but the duplication in logic between them is unfortunate. It seems like even though they have differentvisual appearance,you want to reuse the logic between them.


### Extracting your own custom Hook from a component
Imagine for a moment that, similar touseStateanduseEffect, there was a built-inuseOnlineStatusHook. Then both of these components could be simplified and you could remove the duplication between them:

```jsx
function StatusBar() {  const isOnline = useOnlineStatus();  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;}function SaveButton() {  const isOnline = useOnlineStatus();  function handleSaveClick() {    console.log('✅ Progress saved');  }  return (    <button disabled={!isOnline} onClick={handleSaveClick}>      {isOnline ? 'Save progress' : 'Reconnecting...'}    </button>  );}
```

Although there is no such built-in Hook, you can write it yourself. Declare a function calleduseOnlineStatusand move all the duplicated code into it from the components you wrote earlier:

```jsx
function useOnlineStatus() {  const [isOnline, setIsOnline] = useState(true);  useEffect(() => {    function handleOnline() {      setIsOnline(true);    }    function handleOffline() {      setIsOnline(false);    }    window.addEventListener('online', handleOnline);    window.addEventListener('offline', handleOffline);    return () => {      window.removeEventListener('online', handleOnline);      window.removeEventListener('offline', handleOffline);    };  }, []);  return isOnline;}
```

At the end of the function, returnisOnline. This lets your components read that value:

```jsx
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}


```

Verify that switching the network on and off updates both components.

Now your components don’t have as much repetitive logic.More importantly, the code inside them describeswhat they want to do(use the online status!) rather thanhow to do it(by subscribing to the browser events).

When you extract logic into custom Hooks, you can hide the gnarly details of how you deal with some external system or a browser API. The code of your components expresses your intent, not the implementation.


### Hook names always start withuse
React applications are built from components. Components are built from Hooks, whether built-in or custom. You’ll likely often use custom Hooks created by others, but occasionally you might write one yourself!

You must follow these naming conventions:

- React component names must start with a capital letter,likeStatusBarandSaveButton. React components also need to return something that React knows how to display, like a piece of JSX.
- Hook names must start withusefollowed by a capital letter,likeuseState(built-in) oruseOnlineStatus(custom, like earlier on the page). Hooks may return arbitrary values.
This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see agetColor()function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start withuse. However, a function call likeuseOnlineStatus()will most likely contain calls to other Hooks inside!


### Note
If your linter isconfigured for React,it will enforce this naming convention. Scroll up to the sandbox above and renameuseOnlineStatustogetOnlineStatus. Notice that the linter won’t allow you to calluseStateoruseEffectinside of it anymore. Only Hooks and components can call other Hooks!


#### Should all functions called during rendering start with the use prefix?
No. Functions that don’tcallHooks don’t need tobeHooks.

If your function doesn’t call any Hooks, avoid theuseprefix. Instead, write it as a regular functionwithouttheuseprefix. For example,useSortedbelow doesn’t call Hooks, so call itgetSortedinstead:

```jsx
// 🔴 Avoid: A Hook that doesn't use Hooksfunction useSorted(items) {  return items.slice().sort();}// ✅ Good: A regular function that doesn't use Hooksfunction getSorted(items) {  return items.slice().sort();}
```

This ensures that your code can call this regular function anywhere, including conditions:

```jsx
function List({ items, shouldSort }) {  let displayedItems = items;  if (shouldSort) {    // ✅ It's ok to call getSorted() conditionally because it's not a Hook    displayedItems = getSorted(items);  }  // ...}
```

You should giveuseprefix to a function (and thus make it a Hook) if it uses at least one Hook inside of it:

```jsx
// ✅ Good: A Hook that uses other Hooksfunction useAuth() {  return useContext(Auth);}
```

Technically, this isn’t enforced by React. In principle, you could make a Hook that doesn’t call other Hooks. This is often confusing and limiting so it’s best to avoid that pattern. However, there may be rare cases where it is helpful. For example, maybe your function doesn’t use any Hooks right now, but you plan to add some Hook calls to it in the future. Then it makes sense to name it with theuseprefix:

```jsx
// ✅ Good: A Hook that will likely use some other Hooks laterfunction useAuth() {  // TODO: Replace with this line when authentication is implemented:  // return useContext(Auth);  return TEST_USER;}
```

Then components won’t be able to call it conditionally. This will become important when you actually add Hook calls inside. If you don’t plan to use Hooks inside it (now or later), don’t make it a Hook.


### Custom Hooks let you share stateful logic, not state itself
In the earlier example, when you turned the network on and off, both components updated together. However, it’s wrong to think that a singleisOnlinestate variable is shared between them. Look at this code:

```jsx
function StatusBar() {  const isOnline = useOnlineStatus();  // ...}function SaveButton() {  const isOnline = useOnlineStatus();  // ...}
```

It works the same way as before you extracted the duplication:

```jsx
function StatusBar() {  const [isOnline, setIsOnline] = useState(true);  useEffect(() => {    // ...  }, []);  // ...}function SaveButton() {  const [isOnline, setIsOnline] = useState(true);  useEffect(() => {    // ...  }, []);  // ...}
```

These are two completely independent state variables and Effects! They happened to have the same value at the same time because you synchronized them with the same external value (whether the network is on).

To better illustrate this, we’ll need a different example. Consider thisFormcomponent:

```jsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('Mary');
  const [lastName, setLastName] = useState('Poppins');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <label>
        First name:
        <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p><b>Good morning, {firstName} {lastName}.</b></p>
    </>
  );
}


```

There’s some repetitive logic for each form field:

- There’s a piece of state (firstNameandlastName).
- There’s a change handler (handleFirstNameChangeandhandleLastNameChange).
- There’s a piece of JSX that specifies thevalueandonChangeattributes for that input.
You can extract the repetitive logic into thisuseFormInputcustom Hook:

```jsx
import { useState } from 'react';

export function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);

  function handleChange(e) {
    setValue(e.target.value);
  }

  const inputProps = {
    value: value,
    onChange: handleChange
  };

  return inputProps;
}


```

Notice that it only declaresonestate variable calledvalue.

However, theFormcomponent callsuseFormInputtwo times:

```jsx
function Form() {  const firstNameProps = useFormInput('Mary');  const lastNameProps = useFormInput('Poppins');  // ...
```

This is why it works like declaring two separate state variables!

Custom Hooks let you sharestateful logicbut notstate itself.Each call to a Hook is completely independent from every other call to the same Hook.This is why the two sandboxes above are completely equivalent. If you’d like, scroll back up and compare them. The behavior before and after extracting a custom Hook is identical.

When you need to share the state itself between multiple components,lift it up and pass it downinstead.


## Passing reactive values between Hooks
The code inside your custom Hooks will re-run during every re-render of your component. This is why, like components, custom Hooksneed to be pure.Think of custom Hooks’ code as part of your component’s body!

Because custom Hooks re-render together with your component, they always receive the latest props and state. To see what this means, consider this chat room example. Change the server URL or the chat room:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:
        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}


```

When you changeserverUrlorroomId, the Effect“reacts” to your changesand re-synchronizes. You can tell by the console messages that the chat re-connects every time that you change your Effect’s dependencies.

Now move the Effect’s code into a custom Hook:

```jsx
export function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    connection.on('message', (msg) => {      showNotification('New message: ' + msg);    });    return () => connection.disconnect();  }, [roomId, serverUrl]);}
```

This lets yourChatRoomcomponent call your custom Hook without worrying about how it works inside:

```jsx
export default function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  return (    <>      <label>        Server URL:        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />      </label>      <h1>Welcome to the {roomId} room!</h1>    </>  );}
```

This looks much simpler! (But it does the same thing.)

Notice that the logicstill respondsto prop and state changes. Try editing the server URL or the selected room:

```jsx
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl
  });

  return (
    <>
      <label>
        Server URL:
        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}


```

Notice how you’re taking the return value of one Hook:

```jsx
export default function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ...
```

and passing it as an input to another Hook:

```jsx
export default function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ...
```

Every time yourChatRoomcomponent re-renders, it passes the latestroomIdandserverUrlto your Hook. This is why your Effect re-connects to the chat whenever their values are different after a re-render. (If you ever worked with audio or video processing software, chaining Hooks like this might remind you of chaining visual or audio effects. It’s as if the output ofuseState“feeds into” the input of theuseChatRoom.)


### Passing event handlers to custom Hooks
As you start usinguseChatRoomin more components, you might want to let components customize its behavior. For example, currently, the logic for what to do when a message arrives is hardcoded inside the Hook:

```jsx
export function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    connection.on('message', (msg) => {      showNotification('New message: ' + msg);    });    return () => connection.disconnect();  }, [roomId, serverUrl]);}
```

Let’s say you want to move this logic back to your component:

```jsx
export default function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl,    onReceiveMessage(msg) {      showNotification('New message: ' + msg);    }  });  // ...
```

To make this work, change your custom Hook to takeonReceiveMessageas one of its named options:

```jsx
export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    connection.on('message', (msg) => {      onReceiveMessage(msg);    });    return () => connection.disconnect();  }, [roomId, serverUrl, onReceiveMessage]); // ✅ All dependencies declared}
```

This will work, but there’s one more improvement you can do when your custom Hook accepts event handlers.

Adding a dependency ononReceiveMessageis not ideal because it will cause the chat to re-connect every time the component re-renders.Wrap this event handler into an Effect Event to remove it from the dependencies:

```jsx
import { useEffect, useEffectEvent } from 'react';// ...export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {  const onMessage = useEffectEvent(onReceiveMessage);  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    connection.on('message', (msg) => {      onMessage(msg);    });    return () => connection.disconnect();  }, [roomId, serverUrl]); // ✅ All dependencies declared}
```

Now the chat won’t re-connect every time that theChatRoomcomponent re-renders. Here is a fully working demo of passing an event handler to a custom Hook that you can play with:

```jsx
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';
import { showNotification } from './notifications.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
    onReceiveMessage(msg) {
      showNotification('New message: ' + msg);
    }
  });

  return (
    <>
      <label>
        Server URL:
        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}


```

Notice how you no longer need to knowhowuseChatRoomworks in order to use it. You could add it to any other component, pass any other options, and it would work the same way. That’s the power of custom Hooks.


## When to use custom Hooks
You don’t need to extract a custom Hook for every little duplicated bit of code. Some duplication is fine. For example, extracting auseFormInputHook to wrap a singleuseStatecall like earlier is probably unnecessary.

However, whenever you write an Effect, consider whether it would be clearer to also wrap it in a custom Hook.You shouldn’t need Effects very often,so if you’re writing one, it means that you need to “step outside React” to synchronize with some external system or to do something that React doesn’t have a built-in API for. Wrapping it into a custom Hook lets you precisely communicate your intent and how the data flows through it.

For example, consider aShippingFormcomponent that displays two dropdowns: one shows the list of cities, and another shows the list of areas in the selected city. You might start with some code that looks like this:

```jsx
function ShippingForm({ country }) {  const [cities, setCities] = useState(null);  // This Effect fetches cities for a country  useEffect(() => {    let ignore = false;    fetch(`/api/cities?country=${country}`)      .then(response => response.json())      .then(json => {        if (!ignore) {          setCities(json);        }      });    return () => {      ignore = true;    };  }, [country]);  const [city, setCity] = useState(null);  const [areas, setAreas] = useState(null);  // This Effect fetches areas for the selected city  useEffect(() => {    if (city) {      let ignore = false;      fetch(`/api/areas?city=${city}`)        .then(response => response.json())        .then(json => {          if (!ignore) {            setAreas(json);          }        });      return () => {        ignore = true;      };    }  }, [city]);  // ...
```

Although this code is quite repetitive,it’s correct to keep these Effects separate from each other.They synchronize two different things, so you shouldn’t merge them into one Effect. Instead, you can simplify theShippingFormcomponent above by extracting the common logic between them into your ownuseDataHook:

```jsx
function useData(url) {  const [data, setData] = useState(null);  useEffect(() => {    if (url) {      let ignore = false;      fetch(url)        .then(response => response.json())        .then(json => {          if (!ignore) {            setData(json);          }        });      return () => {        ignore = true;      };    }  }, [url]);  return data;}
```

Now you can replace both Effects in theShippingFormcomponents with calls touseData:

```jsx
function ShippingForm({ country }) {  const cities = useData(`/api/cities?country=${country}`);  const [city, setCity] = useState(null);  const areas = useData(city ? `/api/areas?city=${city}` : null);  // ...
```

Extracting a custom Hook makes the data flow explicit. You feed theurlin and you get thedataout. By “hiding” your Effect insideuseData, you also prevent someone working on theShippingFormcomponent from addingunnecessary dependenciesto it. With time, most of your app’s Effects will be in custom Hooks.


#### Keep your custom Hooks focused on concrete high-level use cases
Start by choosing your custom Hook’s name. If you struggle to pick a clear name, it might mean that your Effect is too coupled to the rest of your component’s logic, and is not yet ready to be extracted.

Ideally, your custom Hook’s name should be clear enough that even a person who doesn’t write code often could have a good guess about what your custom Hook does, what it takes, and what it returns:

- ✅useData(url)
- ✅useImpressionLog(eventName, extraData)
- ✅useChatRoom(options)
When you synchronize with an external system, your custom Hook name may be more technical and use jargon specific to that system. It’s good as long as it would be clear to a person familiar with that system:

- ✅useMediaQuery(query)
- ✅useSocket(url)
- ✅useIntersectionObserver(ref, options)
Keep custom Hooks focused on concrete high-level use cases.Avoid creating and using custom “lifecycle” Hooks that act as alternatives and convenience wrappers for theuseEffectAPI itself:

- 🔴useMount(fn)
- 🔴useEffectOnce(fn)
- 🔴useUpdateEffect(fn)
For example, thisuseMountHook tries to ensure some code only runs “on mount”:

```jsx
function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  // 🔴 Avoid: using custom "lifecycle" Hooks  useMount(() => {    const connection = createConnection({ roomId, serverUrl });    connection.connect();    post('/analytics/event', { eventName: 'visit_chat' });  });  // ...}// 🔴 Avoid: creating custom "lifecycle" Hooksfunction useMount(fn) {  useEffect(() => {    fn();  }, []); // 🔴 React Hook useEffect has a missing dependency: 'fn'}
```

Custom “lifecycle” Hooks likeuseMountdon’t fit well into the React paradigm.For example, this code example has a mistake (it doesn’t “react” toroomIdorserverUrlchanges), but the linter won’t warn you about it because the linter only checks directuseEffectcalls. It won’t know about your Hook.

If you’re writing an Effect, start by using the React API directly:

```jsx
function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  // ✅ Good: two raw Effects separated by purpose  useEffect(() => {    const connection = createConnection({ serverUrl, roomId });    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]);  useEffect(() => {    post('/analytics/event', { eventName: 'visit_chat', roomId });  }, [roomId]);  // ...}
```

Then, you can (but don’t have to) extract custom Hooks for different high-level use cases:

```jsx
function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  // ✅ Great: custom Hooks named after their purpose  useChatRoom({ serverUrl, roomId });  useImpressionLog('visit_chat', { roomId });  // ...}
```

A good custom Hook makes the calling code more declarative by constraining what it does.For example,useChatRoom(options)can only connect to the chat room, whileuseImpressionLog(eventName, extraData)can only send an impression log to the analytics. If your custom Hook API doesn’t constrain the use cases and is very abstract, in the long run it’s likely to introduce more problems than it solves.


### Custom Hooks help you migrate to better patterns
Effects are an“escape hatch”: you use them when you need to “step outside React” and when there is no better built-in solution for your use case. With time, the React team’s goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. Wrapping your Effects in custom Hooks makes it easier to upgrade your code when these solutions become available.

Let’s return to this example:

```jsx
import { useState, useEffect } from 'react';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}


```

In the above example,useOnlineStatusis implemented with a pair ofuseStateanduseEffect.However, this isn’t the best possible solution. There is a number of edge cases it doesn’t consider. For example, it assumes that when the component mounts,isOnlineis alreadytrue, but this may be wrong if the network already went offline. You can use the browsernavigator.onLineAPI to check for that, but using it directly would not work on the server for generating the initial HTML. In short, this code could be improved.

React includes a dedicated API calleduseSyncExternalStorewhich takes care of all of these problems for you. Here is youruseOnlineStatusHook, rewritten to take advantage of this new API:

```jsx
import { useSyncExternalStore } from 'react';

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

export function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe,
    () => navigator.onLine, // How to get the value on the client
    () => true // How to get the value on the server
  );
}


```

Notice howyou didn’t need to change any of the componentsto make this migration:

```jsx
function StatusBar() {  const isOnline = useOnlineStatus();  // ...}function SaveButton() {  const isOnline = useOnlineStatus();  // ...}
```

This is another reason for why wrapping Effects in custom Hooks is often beneficial:

- You make the data flow to and from your Effects very explicit.
- You let your components focus on the intent rather than on the exact implementation of your Effects.
- When React adds new features, you can remove those Effects without changing any of your components.
Similar to adesign system,you might find it helpful to start extracting common idioms from your app’s components into custom Hooks. This will keep your components’ code focused on the intent, and let you avoid writing raw Effects very often. Many excellent custom Hooks are maintained by the React community.


#### Will React provide any built-in solution for data fetching?
Today, with theuseAPI, data can be read in render by passing aPromisetouse:

```jsx
import { use, Suspense } from "react";function Message({ messagePromise }) {  const messageContent = use(messagePromise);  return <p>Here is the message: {messageContent}</p>;}export function MessageContainer({ messagePromise }) {  return (    <Suspense fallback={<p>⌛Downloading message...</p>}>      <Message messagePromise={messagePromise} />    </Suspense>  );}
```

We’re still working out the details, but we expect that in the future, you’ll write data fetching like this:

```jsx
import { use } from 'react';function ShippingForm({ country }) {  const cities = use(fetch(`/api/cities?country=${country}`));  const [city, setCity] = useState(null);  const areas = city ? use(fetch(`/api/areas?city=${city}`)) : null;  // ...
```

If you use custom Hooks likeuseDataabove in your app, it will require fewer changes to migrate to the eventually recommended approach than if you write raw Effects in every component manually. However, the old approach will still work fine, so if you feel happy writing raw Effects, you can continue to do that.


### There is more than one way to do it
Let’s say you want to implement a fade-in animationfrom scratchusing the browserrequestAnimationFrameAPI. You might start with an Effect that sets up an animation loop. During each frame of the animation, you could change the opacity of the DOM node youhold in a refuntil it reaches1. Your code might start like this:

```jsx
import { useState, useEffect, useRef } from 'react';

function Welcome() {
  const ref = useRef(null);

  useEffect(() => {
    const duration = 1000;
    const node = ref.current;

    let startTime = performance.now();
    let frameId = null;

    function onFrame(now) {
      const timePassed = now - startTime;
      const progress = Math.min(timePassed / duration, 1);
      onProgress(progress);
      if (progress < 1) {
        // We still have more frames to paint
        frameId = requestAnimationFrame(onFrame);
      }
    }

    function onProgress(progress) {
      node.style.opacity = progress;
    }

    function start() {
      onProgress(0);
      startTime = performance.now();
      frameId = requestAnimationFrame(onFrame);
    }

    function stop() {
      cancelAnimationFrame(frameId);
      startTime = null;
      frameId = null;
    }

    start();
    return () => stop();
  }, []);

  return (
    <h1 className="welcome" ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Remove' : 'Show'}
      </button>
      <hr />
      {show && <Welcome />}
    </>
  );
}


```

To make the component more readable, you might extract the logic into auseFadeIncustom Hook:

```jsx
import { useState, useEffect, useRef } from 'react';
import { useFadeIn } from './useFadeIn.js';

function Welcome() {
  const ref = useRef(null);

  useFadeIn(ref, 1000);

  return (
    <h1 className="welcome" ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Remove' : 'Show'}
      </button>
      <hr />
      {show && <Welcome />}
    </>
  );
}


```

You could keep theuseFadeIncode as is, but you could also refactor it more. For example, you could extract the logic for setting up the animation loop out ofuseFadeIninto a customuseAnimationLoopHook:

```jsx
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';

export function useFadeIn(ref, duration) {
  const [isRunning, setIsRunning] = useState(true);

  useAnimationLoop(isRunning, (timePassed) => {
    const progress = Math.min(timePassed / duration, 1);
    ref.current.style.opacity = progress;
    if (progress === 1) {
      setIsRunning(false);
    }
  });
}

function useAnimationLoop(isRunning, drawFrame) {
  const onFrame = useEffectEvent(drawFrame);

  useEffect(() => {
    if (!isRunning) {
      return;
    }

    const startTime = performance.now();
    let frameId = null;

    function tick(now) {
      const timePassed = now - startTime;
      onFrame(timePassed);
      frameId = requestAnimationFrame(tick);
    }

    tick();
    return () => cancelAnimationFrame(frameId);
  }, [isRunning]);
}


```

However, you didn’thave todo that. As with regular functions, ultimately you decide where to draw the boundaries between different parts of your code. You could also take a very different approach. Instead of keeping the logic in the Effect, you could move most of the imperative logic inside a JavaScriptclass:

```jsx
import { useState, useEffect } from 'react';
import { FadeInAnimation } from './animation.js';

export function useFadeIn(ref, duration) {
  useEffect(() => {
    const animation = new FadeInAnimation(ref.current);
    animation.start(duration);
    return () => {
      animation.stop();
    };
  }, [ref, duration]);
}


```

Effects let you connect React to external systems. The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hookscompletelylike in the sandbox above. Then, the code you extractedbecomesthe “external system”. This lets your Effects stay simple because they only need to send messages to the system you’ve moved outside React.

The examples above assume that the fade-in logic needs to be written in JavaScript. However, this particular fade-in animation is both simpler and much more efficient to implement with a plainCSS Animation:

```jsx
.welcome {
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%);

  animation: fadeIn 1000ms;
}

@keyframes fadeIn {
  0% { opacity: 0; }
  100% { opacity: 1; }
}


```

Sometimes, you don’t even need a Hook!


## Recap
- Custom Hooks let you share logic between components.
- Custom Hooks must be named starting withusefollowed by a capital letter.
- Custom Hooks only share stateful logic, not state itself.
- You can pass reactive values from one Hook to another, and they stay up-to-date.
- All Hooks re-run every time your component re-renders.
- The code of your custom Hooks should be pure, like your component’s code.
- Wrap event handlers received by custom Hooks into Effect Events.
- Don’t create custom Hooks likeuseMount. Keep their purpose specific.
- It’s up to you how and where to choose the boundaries of your code.

## Try out some challenges

#### Challenge1of5:Extract auseCounterHook
This component uses a state variable and an Effect to display a number that increments every second. Extract this logic into a custom Hook calleduseCounter. Your goal is to make theCountercomponent implementation look exactly like this:

```jsx
export default function Counter() {  const count = useCounter();  return <h1>Seconds passed: {count}</h1>;}
```

You’ll need to write your custom Hook inuseCounter.jsand import it into theApp.jsfile.

```jsx
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1);
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return <h1>Seconds passed: {count}</h1>;
}


```


--------------------------------------------------------------------------------
