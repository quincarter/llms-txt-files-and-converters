# React API Reference
Scraped from https://react.dev/reference/react
Date: 2026-02-17



# React Performance tracks
Source: https://react.dev/reference/dev-tools/react-performance-tracks

React Performance tracks are specialized custom entries that appear on the Performance panel’s timeline in your browser developer tools.

These tracks are designed to provide developers with comprehensive insights into their React application’s performance by visualizing React-specific events and metrics alongside other critical data sources such as network requests, JavaScript execution, and event loop activity, all synchronized on a unified timeline within the Performance panel for a complete understanding of application behavior.

- UsageUsing profiling builds
- Using profiling builds
- TracksSchedulerComponentsServer
- Scheduler
- Components
- Server

## Usage
React Performance tracks are only available in development and profiling builds of React:

- Development: enabled by default.
- Profiling: Only Scheduler tracks are enabled by default. The Components track only lists Components that are in subtrees wrapped with<Profiler>. If you haveReact Developer Tools extensionenabled, all Components are included in the Components track even if they’re not wrapped in<Profiler>. Server tracks are not available in profiling builds.
If enabled, tracks should appear automatically in the traces you record with the Performance panel of browsers that provideextensibility APIs.


### Pitfall
The profiling instrumentation that powers React Performance tracks adds some additional overhead, so it is disabled in production builds by default.
Server Components and Server Requests tracks are only available in development builds.


### Using profiling builds
In addition to production and development builds, React also includes a special profiling build.
To use profiling builds, you have to usereact-dom/profilinginstead ofreact-dom/client.
We recommend that you aliasreact-dom/clienttoreact-dom/profilingat build time via bundler aliases instead of manually updating eachreact-dom/clientimport.
Your framework might have built-in support for enabling React’s profiling build.


## Tracks

### Scheduler
The Scheduler is an internal React concept used for managing tasks with different priorities. This track consists of 4 subtracks, each representing work of a specific priority:

- Blocking- The synchronous updates, which could’ve been initiated by user interactions.
- Transition- Non-blocking work that happens in the background, usually initiated viastartTransition.
- Suspense- Work related to Suspense boundaries, such as displaying fallbacks or revealing content.
- Idle- The lowest priority work that is done when there are no other tasks with higher priority.

#### Renders
Every render pass consists of multiple phases that you can see on a timeline:

- Update- this is what caused a new render pass.
- Render- React renders the updated subtree by calling render functions of components. You can see the rendered components subtree onComponents track, which follows the same color scheme.
- Commit- After rendering components, React will submit the changes to the DOM and run layout effects, likeuseLayoutEffect.
- Remaining Effects- React runs passive effects of a rendered subtree. This usually happens after the paint, and this is when React runs hooks likeuseEffect. One known exception is user interactions, like clicks, or other discrete events. In this scenario, this phase could run before the paint.
Learn more about renders and commits.


#### Cascading updates
Cascading updates is one of the patterns for performance regressions. If an update was scheduled during a render pass, React could discard completed work and start a new pass.

In development builds, React can show you which Component scheduled a new update. This includes both general updates and cascading ones. You can see the enhanced stack trace by clicking on the “Cascading update” entry, which should also display the name of the method that scheduled an update.

Learn more about Effects.


### Components
The Components track visualizes the durations of React components. They are displayed as a flamegraph, where each entry represents the duration of the corresponding component render and all its descendant children components.

Similar to render durations, effect durations are also represented as a flamegraph, but with a different color scheme that aligns with the corresponding phase on the Scheduler track.


### Note
Unlike renders, not all effects are shown on the Components track by default.

To maintain performance and prevent UI clutter, React will only display those effects, which had a duration of 0.05ms or longer, or triggered an update.

Additional events may be displayed during the render and effects phases:

- Mount- A corresponding subtree of component renders or effects was mounted.
- Unmount- A corresponding subtree of component renders or effects was unmounted.
- Reconnect- Similar to Mount, but limited to cases when<Activity>is used.
- Disconnect- Similar to Unmount, but limited to cases when<Activity>is used.

#### Changed props
In development builds, when you click on a component render entry, you can inspect potential changes in props. You can use this information to identify unnecessary renders.


### Server

#### Server Requests
The Server Requests track visualized all Promises that eventually end up in a React Server Component. This includes anyasyncoperations like callingfetchor async Node.js file operations.

React will try to combine Promises that are started from inside third-party code into a single span representing the the duration of the entire operation blocking 1st party code.
For example, a third party library method calledgetUserthat callsfetchinternally multiple times will be represented as a single span calledgetUser, instead of showing multiplefetchspans.

Clicking on spans will show you a stack trace of where the Promise was created as well as a view of the value that the Promise resolved to, if available.

Rejected Promises are displayed as red with their rejected value.


#### Server Components
The Server Components tracks visualize the durations of React Server Components Promises they awaited. Timings are displayed as a flamegraph, where each entry represents the duration of the corresponding component render and all its descendant children components.

If you await a Promise, React will display duration of that Promise. To see all I/O operations, use the Server Requests track.

Different colors are used to indicate the duration of the component render. The darker the color, the longer the duration.

The Server Components track group will always contain a “Primary” track. If React is able to render Server Components concurrently, it will display addititional “Parallel” tracks.
If more than 8 Server Components are rendered concurrently, React will associate them with the last “Parallel” track instead of adding more tracks.


--------------------------------------------------------------------------------


# eslint-plugin-react-hooks- This feature is available in the latest RC version
Source: https://react.dev/reference/eslint-plugin-react-hooks

eslint-plugin-react-hooksprovides ESLint rules to enforce theRules of React.

This plugin helps you catch violations of React’s rules at build time, ensuring your components and hooks follow React’s rules for correctness and performance. The lints cover both fundamental React patterns (exhaustive-deps and rules-of-hooks) and issues flagged by React Compiler. React Compiler diagnostics are automatically surfaced by this ESLint plugin, and can be used even if your app hasn’t adopted the compiler yet.


### Note
When the compiler reports a diagnostic, it means that the compiler was able to statically detect a pattern that is not supported or breaks the Rules of React. When it detects this, itautomaticallyskips over those components and hooks, while keeping the rest of your app compiled. This ensures optimal coverage of safe optimizations that won’t break your app.

What this means for linting, is that you don’t need to fix all violations immediately. Address them at your own pace to gradually increase the number of optimized components.


## Recommended Rules
These rules are included in therecommendedpreset ineslint-plugin-react-hooks:

- exhaustive-deps- Validates that dependency arrays for React hooks contain all necessary dependencies
- rules-of-hooks- Validates that components and hooks follow the Rules of Hooks
- component-hook-factories- Validates higher order functions defining nested components or hooks
- config- Validates the compiler configuration options
- error-boundaries- Validates usage of Error Boundaries instead of try/catch for child errors
- gating- Validates configuration of gating mode
- globals- Validates against assignment/mutation of globals during render
- immutability- Validates against mutating props, state, and other immutable values
- incompatible-library- Validates against usage of libraries which are incompatible with memoization
- preserve-manual-memoization- Validates that existing manual memoization is preserved by the compiler
- purity- Validates that components/hooks are pure by checking known-impure functions
- refs- Validates correct usage of refs, not reading/writing during render
- set-state-in-effect- Validates against calling setState synchronously in an effect
- set-state-in-render- Validates against setting state during render
- static-components- Validates that components are static, not recreated every render
- unsupported-syntax- Validates against syntax that React Compiler does not support
- use-memo- Validates usage of theuseMemohook without a return value

--------------------------------------------------------------------------------


# component-hook-factories
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories

Validates against higher order functions defining nested components or hooks. Components and hooks should be defined at the module level.


## Rule Details
Defining components or hooks inside other functions creates new instances on every call. React treats each as a completely different component, destroying and recreating the entire component tree, losing all state, and causing performance problems.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Factory function creating componentsfunction createComponent(defaultValue) {  return function Component() {    // ...  };}// ❌ Component defined inside componentfunction Parent() {  function Child() {    // ...  }  return <Child />;}// ❌ Hook factory functionfunction createCustomHook(endpoint) {  return function useData() {    // ...  };}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Component defined at module levelfunction Component({ defaultValue }) {  // ...}// ✅ Custom hook at module levelfunction useData(endpoint) {  // ...}
```


## Troubleshooting

### I need dynamic component behavior
You might think you need a factory to create customized components:

```jsx
// ❌ Wrong: Factory patternfunction makeButton(color) {  return function Button({children}) {    return (      <button style={{backgroundColor: color}}>        {children}      </button>    );  };}const RedButton = makeButton('red');const BlueButton = makeButton('blue');
```

PassJSX as childreninstead:

```jsx
// ✅ Better: Pass JSX as childrenfunction Button({color, children}) {  return (    <button style={{backgroundColor: color}}>      {children}    </button>  );}function App() {  return (    <>      <Button color="red">Red</Button>      <Button color="blue">Blue</Button>    </>  );}
```


--------------------------------------------------------------------------------


# config
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/config

Validates the compilerconfiguration options.


## Rule Details
React Compiler accepts variousconfiguration optionsto control its behavior. This rule validates that your configuration uses correct option names and value types, preventing silent failures from typos or incorrect settings.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Unknown option namemodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      compileMode: 'all' // Typo: should be compilationMode    }]  ]};// ❌ Invalid option valuemodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      compilationMode: 'everything' // Invalid: use 'all' or 'infer'    }]  ]};
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Valid compiler configurationmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      compilationMode: 'infer',      panicThreshold: 'critical_errors'    }]  ]};
```


## Troubleshooting

### Configuration not working as expected
Your compiler configuration might have typos or incorrect values:

```jsx
// ❌ Wrong: Common configuration mistakesmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      // Typo in option name      compilationMod: 'all',      // Wrong value type      panicThreshold: true,      // Unknown option      optimizationLevel: 'max'    }]  ]};
```

Check theconfiguration documentationfor valid options:

```jsx
// ✅ Better: Valid configurationmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      compilationMode: 'all', // or 'infer'      panicThreshold: 'none', // or 'critical_errors', 'all_errors'      // Only use documented options    }]  ]};
```


--------------------------------------------------------------------------------


# error-boundaries
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries

Validates usage of Error Boundaries instead of try/catch for errors in child components.


## Rule Details
Try/catch blocks can’t catch errors that happen during React’s rendering process. Errors thrown in rendering methods or hooks bubble up through the component tree. OnlyError Boundariescan catch these errors.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Try/catch won't catch render errorsfunction Parent() {  try {    return <ChildComponent />; // If this throws, catch won't help  } catch (error) {    return <div>Error occurred</div>;  }}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Using error boundaryfunction Parent() {  return (    <ErrorBoundary>      <ChildComponent />    </ErrorBoundary>  );}
```


## Troubleshooting

### Why is the linter telling me not to wrapuseintry/catch?
Theusehook doesn’t throw errors in the traditional sense, it suspends component execution. Whenuseencounters a pending promise, it suspends the component and lets React show a fallback. Only Suspense and Error Boundaries can handle these cases. The linter warns againsttry/catcharounduseto prevent confusion as thecatchblock would never run.

```jsx
// ❌ Try/catch around `use` hookfunction Component({promise}) {  try {    const data = use(promise); // Won't catch - `use` suspends, not throws    return <div>{data}</div>;  } catch (error) {    return <div>Failed to load</div>; // Unreachable  }}// ✅ Error boundary catches `use` errorsfunction App() {  return (    <ErrorBoundary fallback={<div>Failed to load</div>}>      <Suspense fallback={<div>Loading...</div>}>        <DataComponent promise={fetchData()} />      </Suspense>    </ErrorBoundary>  );}
```


--------------------------------------------------------------------------------


# exhaustive-deps
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps

Validates that dependency arrays for React hooks contain all necessary dependencies.


## Rule Details
React hooks likeuseEffect,useMemo, anduseCallbackaccept dependency arrays. When a value referenced inside these hooks isn’t included in the dependency array, React won’t re-run the effect or recalculate the value when that dependency changes. This causes stale closures where the hook uses outdated values.


## Common Violations
This error often happens when you try to “trick” React about dependencies to control when an effect runs. Effects should synchronize your component with external systems. The dependency array tells React which values the effect uses, so React knows when to re-synchronize.

If you find yourself fighting with the linter, you likely need to restructure your code. SeeRemoving Effect Dependenciesto learn how.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Missing dependencyuseEffect(() => {  console.log(count);}, []); // Missing 'count'// ❌ Missing propuseEffect(() => {  fetchUser(userId);}, []); // Missing 'userId'// ❌ Incomplete dependenciesuseMemo(() => {  return items.sort(sortOrder);}, [items]); // Missing 'sortOrder'
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ All dependencies includeduseEffect(() => {  console.log(count);}, [count]);// ✅ All dependencies includeduseEffect(() => {  fetchUser(userId);}, [userId]);
```


## Troubleshooting

### Adding a function dependency causes infinite loops
You have an effect, but you’re creating a new function on every render:

```jsx
// ❌ Causes infinite loopconst logItems = () => {  console.log(items);};useEffect(() => {  logItems();}, [logItems]); // Infinite loop!
```

In most cases, you don’t need the effect. Call the function where the action happens instead:

```jsx
// ✅ Call it from the event handlerconst logItems = () => {  console.log(items);};return <button onClick={logItems}>Log</button>;// ✅ Or derive during render if there's no side effectitems.forEach(item => {  console.log(item);});
```

If you genuinely need the effect (for example, to subscribe to something external), make the dependency stable:

```jsx
// ✅ useCallback keeps the function reference stableconst logItems = useCallback(() => {  console.log(items);}, [items]);useEffect(() => {  logItems();}, [logItems]);// ✅ Or move the logic straight into the effectuseEffect(() => {  console.log(items);}, [items]);
```


### Running an effect only once
You want to run an effect once on mount, but the linter complains about missing dependencies:

```jsx
// ❌ Missing dependencyuseEffect(() => {  sendAnalytics(userId);}, []); // Missing 'userId'
```

Either include the dependency (recommended) or use a ref if you truly need to run once:

```jsx
// ✅ Include dependencyuseEffect(() => {  sendAnalytics(userId);}, [userId]);// ✅ Or use a ref guard inside an effectconst sent = useRef(false);useEffect(() => {  if (sent.current) {    return;  }  sent.current = true;  sendAnalytics(userId);}, [userId]);
```


## Options
You can configure custom effect hooks using shared ESLint settings (available ineslint-plugin-react-hooks6.1.1 and later):

```jsx
{  "settings": {    "react-hooks": {      "additionalEffectHooks": "(useMyEffect|useCustomEffect)"    }  }}
```

- additionalEffectHooks: Regex pattern matching custom hooks that should be checked for exhaustive dependencies. This configuration is shared across allreact-hooksrules.
For backward compatibility, this rule also accepts a rule-level option:

```jsx
{  "rules": {    "react-hooks/exhaustive-deps": ["warn", {      "additionalHooks": "(useMyCustomHook|useAnotherHook)"    }]  }}
```

- additionalHooks: Regex for hooks that should be checked for exhaustive dependencies.Note:If this rule-level option is specified, it takes precedence over the sharedsettingsconfiguration.

--------------------------------------------------------------------------------


# gating
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/gating

Validates configuration ofgating mode.


## Rule Details
Gating mode lets you gradually adopt React Compiler by marking specific components for optimization. This rule ensures your gating configuration is valid so the compiler knows which components to process.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Missing required fieldsmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      gating: {        importSpecifierName: '__experimental_useCompiler'        // Missing 'source' field      }    }]  ]};// ❌ Invalid gating typemodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      gating: '__experimental_useCompiler' // Should be object    }]  ]};
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Complete gating configurationmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      gating: {        importSpecifierName: 'isCompilerEnabled', // exported function name        source: 'featureFlags' // module name      }    }]  ]};// featureFlags.jsexport function isCompilerEnabled() {  // ...}// ✅ No gating (compile everything)module.exports = {  plugins: [    ['babel-plugin-react-compiler', {      // No gating field - compiles all components    }]  ]};
```


--------------------------------------------------------------------------------


# globals
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/globals

Validates against assignment/mutation of globals during render, part of ensuring thatside effects must run outside of render.


## Rule Details
Global variables exist outside React’s control. When you modify them during render, you break React’s assumption that rendering is pure. This can cause components to behave differently in development vs production, break Fast Refresh, and make your app impossible to optimize with features like React Compiler.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Global counterlet renderCount = 0;function Component() {  renderCount++; // Mutating global  return <div>Count: {renderCount}</div>;}// ❌ Modifying window propertiesfunction Component({userId}) {  window.currentUser = userId; // Global mutation  return <div>User: {userId}</div>;}// ❌ Global array pushconst events = [];function Component({event}) {  events.push(event); // Mutating global array  return <div>Events: {events.length}</div>;}// ❌ Cache manipulationconst cache = {};function Component({id}) {  if (!cache[id]) {    cache[id] = fetchData(id); // Modifying cache during render  }  return <div>{cache[id]}</div>;}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Use state for countersfunction Component() {  const [clickCount, setClickCount] = useState(0);  const handleClick = () => {    setClickCount(c => c + 1);  };  return (    <button onClick={handleClick}>      Clicked: {clickCount} times    </button>  );}// ✅ Use context for global valuesfunction Component() {  const user = useContext(UserContext);  return <div>User: {user.id}</div>;}// ✅ Synchronize external state with Reactfunction Component({title}) {  useEffect(() => {    document.title = title; // OK in effect  }, [title]);  return <div>Page: {title}</div>;}
```


--------------------------------------------------------------------------------


# immutability
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability

Validates against mutating props, state, and other values thatare immutable.


## Rule Details
A component’s props and state are immutable snapshots. Never mutate them directly. Instead, pass new props down, and use the setter function fromuseState.


## Common Violations

### Invalid
```jsx
// ❌ Array push mutationfunction Component() {  const [items, setItems] = useState([1, 2, 3]);  const addItem = () => {    items.push(4); // Mutating!    setItems(items); // Same reference, no re-render  };}// ❌ Object property assignmentfunction Component() {  const [user, setUser] = useState({name: 'Alice'});  const updateName = () => {    user.name = 'Bob'; // Mutating!    setUser(user); // Same reference  };}// ❌ Sort without spreadingfunction Component() {  const [items, setItems] = useState([3, 1, 2]);  const sortItems = () => {    setItems(items.sort()); // sort mutates!  };}
```


### Valid
```jsx
// ✅ Create new arrayfunction Component() {  const [items, setItems] = useState([1, 2, 3]);  const addItem = () => {    setItems([...items, 4]); // New array  };}// ✅ Create new objectfunction Component() {  const [user, setUser] = useState({name: 'Alice'});  const updateName = () => {    setUser({...user, name: 'Bob'}); // New object  };}
```


## Troubleshooting

### I need to add items to an array
Mutating arrays with methods likepush()won’t trigger re-renders:

```jsx
// ❌ Wrong: Mutating the arrayfunction TodoList() {  const [todos, setTodos] = useState([]);  const addTodo = (id, text) => {    todos.push({id, text});    setTodos(todos); // Same array reference!  };  return (    <ul>      {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}    </ul>  );}
```

Create a new array instead:

```jsx
// ✅ Better: Create a new arrayfunction TodoList() {  const [todos, setTodos] = useState([]);  const addTodo = (id, text) => {    setTodos([...todos, {id, text}]);    // Or: setTodos(todos => [...todos, {id: Date.now(), text}])  };  return (    <ul>      {todos.map(todo => <li key={todo.id}>{todo.text}</li>)}    </ul>  );}
```


### I need to update nested objects
Mutating nested properties doesn’t trigger re-renders:

```jsx
// ❌ Wrong: Mutating nested objectfunction UserProfile() {  const [user, setUser] = useState({    name: 'Alice',    settings: {      theme: 'light',      notifications: true    }  });  const toggleTheme = () => {    user.settings.theme = 'dark'; // Mutation!    setUser(user); // Same object reference  };}
```

Spread at each level that needs updating:

```jsx
// ✅ Better: Create new objects at each levelfunction UserProfile() {  const [user, setUser] = useState({    name: 'Alice',    settings: {      theme: 'light',      notifications: true    }  });  const toggleTheme = () => {    setUser({      ...user,      settings: {        ...user.settings,        theme: 'dark'      }    });  };}
```


--------------------------------------------------------------------------------


# incompatible-library
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library

Validates against usage of libraries which are incompatible with memoization (manual or automatic).


### Note
These libraries were designed before React’s memoization rules were fully documented. They made the correct choices at the time to optimize for ergonomic ways to keep components just the right amount of reactive as app state changes. While these legacy patterns worked, we have since discovered that it’s incompatible with React’s programming model. We will continue working with library authors to migrate these libraries to use patterns that follow the Rules of React.


## Rule Details
Some libraries use patterns that aren’t supported by React. When the linter detects usages of these APIs from aknown list, it flags them under this rule. This means that React Compiler can automatically skip over components that use these incompatible APIs, in order to avoid breaking your app.

```jsx
// Example of how memoization breaks with these librariesfunction Form() {  const { watch } = useForm();  // ❌ This value will never update, even when 'name' field changes  const name = useMemo(() => watch('name'), [watch]);  return <div>Name: {name}</div>; // UI appears "frozen"}
```

React Compiler automatically memoizes values following the Rules of React. If something breaks with manualuseMemo, it will also break the compiler’s automatic optimization. This rule helps identify these problematic patterns.


#### Designing APIs that follow the Rules of React
One question to think about when designing a library API or hook is whether calling the API can be safely memoized withuseMemo. If it can’t, then both manual and React Compiler memoizations will break your user’s code.

For example, one such incompatible pattern is “interior mutability”. Interior mutability is when an object or function keeps its own hidden state that changes over time, even though the reference to it stays the same. Think of it like a box that looks the same on the outside but secretly rearranges its contents. React can’t tell anything changed because it only checks if you gave it a different box, not what’s inside. This breaks memoization, since React relies on the outer object (or function) changing if part of its value has changed.

As a rule of thumb, when designing React APIs, think about whetheruseMemowould break it:

```jsx
function Component() {  const { someFunction } = useLibrary();  // it should always be safe to memoize functions like this  const result = useMemo(() => someFunction(), [someFunction]);}
```

Instead, design APIs that return immutable state and use explicit update functions:

```jsx
// ✅ Good: Return immutable state that changes reference when updatedfunction Component() {  const { field, updateField } = useLibrary();  // this is always safe to memo  const greeting = useMemo(() => `Hello, ${field.name}!`, [field.name]);  return (    <div>      <input        value={field.name}        onChange={(e) => updateField('name', e.target.value)}      />      <p>{greeting}</p>    </div>  );}
```


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ react-hook-form `watch`function Component() {  const {watch} = useForm();  const value = watch('field'); // Interior mutability  return <div>{value}</div>;}// ❌ TanStack Table `useReactTable`function Component({data}) {  const table = useReactTable({    data,    columns,    getCoreRowModel: getCoreRowModel(),  });  // table instance uses interior mutability  return <Table table={table} />;}
```


### Pitfall

#### MobX
MobX patterns likeobserveralso break memoization assumptions, but the linter does not yet detect them. If you rely on MobX and find that your app doesn’t work with React Compiler, you may need to use the"use no memo" directive.

```jsx
// ❌ MobX `observer`const Component = observer(() => {  const [timer] = useState(() => new Timer());  return <span>Seconds passed: {timer.secondsPassed}</span>;});
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ For react-hook-form, use `useWatch`:function Component() {  const {register, control} = useForm();  const watchedValue = useWatch({    control,    name: 'field'  });  return (    <>      <input {...register('field')} />      <div>Current value: {watchedValue}</div>    </>  );}
```

Some other libraries do not yet have alternative APIs that are compatible with React’s memoization model. If the linter doesn’t automatically skip over your components or hooks that call these APIs, pleasefile an issueso we can add it to the linter.


--------------------------------------------------------------------------------


# preserve-manual-memoization
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization

Validates that existing manual memoization is preserved by the compiler. React Compiler will only compile components and hooks if its inferencematches or exceeds the existing manual memoization.


## Rule Details
React Compiler preserves your existinguseMemo,useCallback, andReact.memocalls. If you’ve manually memoized something, the compiler assumes you had a good reason and won’t remove it. However, incomplete dependencies prevent the compiler from understanding your code’s data flow and applying further optimizations.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Missing dependencies in useMemofunction Component({ data, filter }) {  const filtered = useMemo(    () => data.filter(filter),    [data] // Missing 'filter' dependency  );  return <List items={filtered} />;}// ❌ Missing dependencies in useCallbackfunction Component({ onUpdate, value }) {  const handleClick = useCallback(() => {    onUpdate(value);  }, [onUpdate]); // Missing 'value'  return <button onClick={handleClick}>Update</button>;}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Complete dependenciesfunction Component({ data, filter }) {  const filtered = useMemo(    () => data.filter(filter),    [data, filter] // All dependencies included  );  return <List items={filtered} />;}// ✅ Or let the compiler handle itfunction Component({ data, filter }) {  // No manual memoization needed  const filtered = data.filter(filter);  return <List items={filtered} />;}
```


## Troubleshooting

### Should I remove my manual memoization?
You might wonder if React Compiler makes manual memoization unnecessary:

```jsx
// Do I still need this?function Component({items, sortBy}) {  const sorted = useMemo(() => {    return [...items].sort((a, b) => {      return a[sortBy] - b[sortBy];    });  }, [items, sortBy]);  return <List items={sorted} />;}
```

You can safely remove it if using React Compiler:

```jsx
// ✅ Better: Let the compiler optimizefunction Component({items, sortBy}) {  const sorted = [...items].sort((a, b) => {    return a[sortBy] - b[sortBy];  });  return <List items={sorted} />;}
```


--------------------------------------------------------------------------------


# purity
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/purity

Validates thatcomponents/hooks are pureby checking that they do not call known-impure functions.


## Rule Details
React components must be pure functions - given the same props, they should always return the same JSX. When components use functions likeMath.random()orDate.now()during render, they produce different output each time, breaking React’s assumptions and causing bugs like hydration mismatches, incorrect memoization, and unpredictable behavior.


## Common Violations
In general, any API that returns a different value for the same inputs violates this rule. Usual examples include:

- Math.random()
- Date.now()/new Date()
- crypto.randomUUID()
- performance.now()

### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Math.random() in renderfunction Component() {  const id = Math.random(); // Different every render  return <div key={id}>Content</div>;}// ❌ Date.now() for valuesfunction Component() {  const timestamp = Date.now(); // Changes every render  return <div>Created at: {timestamp}</div>;}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Stable IDs from initial statefunction Component() {  const [id] = useState(() => crypto.randomUUID());  return <div key={id}>Content</div>;}
```


## Troubleshooting

### I need to show the current time
CallingDate.now()during render makes your component impure:

```jsx
// ❌ Wrong: Time changes every renderfunction Clock() {  return <div>Current time: {Date.now()}</div>;}
```

Instead,move the impure function outside of render:

```jsx
function Clock() {  const [time, setTime] = useState(() => Date.now());  useEffect(() => {    const interval = setInterval(() => {      setTime(Date.now());    }, 1000);    return () => clearInterval(interval);  }, []);  return <div>Current time: {time}</div>;}
```


--------------------------------------------------------------------------------


# refs
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/refs

Validates correct usage of refs, not reading/writing during render. See the “pitfalls” section inuseRef()usage.


## Rule Details
Refs hold values that aren’t used for rendering. Unlike state, changing a ref doesn’t trigger a re-render. Reading or writingref.currentduring render breaks React’s expectations. Refs might not be initialized when you try to read them, and their values can be stale or inconsistent.


## How It Detects Refs
The lint only applies these rules to values it knows are refs. A value is inferred as a ref when the compiler sees any of the following patterns:

- Returned fromuseRef()orReact.createRef().constscrollRef=useRef(null);
Returned fromuseRef()orReact.createRef().

```jsx
const scrollRef = useRef(null);
```

- An identifier namedrefor ending inRefthat reads from or writes to.current.buttonRef.current=node;
An identifier namedrefor ending inRefthat reads from or writes to.current.

```jsx
buttonRef.current = node;
```

- Passed through a JSXrefprop (for example<div ref={someRef} />).<inputref={inputRef}/>
Passed through a JSXrefprop (for example<div ref={someRef} />).

```jsx
<input ref={inputRef} />
```

Once something is marked as a ref, that inference follows the value through assignments, destructuring, or helper calls. This lets the lint surface violations even whenref.currentis accessed inside another function that received the ref as an argument.


## Common Violations
- Readingref.currentduring render
- Updatingrefsduring render
- Usingrefsfor values that should be state

### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Reading ref during renderfunction Component() {  const ref = useRef(0);  const value = ref.current; // Don't read during render  return <div>{value}</div>;}// ❌ Modifying ref during renderfunction Component({value}) {  const ref = useRef(null);  ref.current = value; // Don't modify during render  return <div />;}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Read ref in effects/handlersfunction Component() {  const ref = useRef(null);  useEffect(() => {    if (ref.current) {      console.log(ref.current.offsetWidth); // OK in effect    }  });  return <div ref={ref} />;}// ✅ Use state for UI valuesfunction Component() {  const [count, setCount] = useState(0);  return (    <button onClick={() => setCount(count + 1)}>      {count}    </button>  );}// ✅ Lazy initialization of ref valuefunction Component() {  const ref = useRef(null);  // Initialize only once on first use  if (ref.current === null) {    ref.current = expensiveComputation(); // OK - lazy initialization  }  const handleClick = () => {    console.log(ref.current); // Use the initialized value  };  return <button onClick={handleClick}>Click</button>;}
```


## Troubleshooting

### The lint flagged my plain object with.current
The name heuristic intentionally treatsref.currentandfooRef.currentas real refs. If you’re modeling a custom container object, pick a different name (for example,box) or move the mutable value into state. Renaming avoids the lint because the compiler stops inferring it as a ref.


--------------------------------------------------------------------------------


# rules-of-hooks
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks

Validates that components and hooks follow theRules of Hooks.


## Rule Details
React relies on the order in which hooks are called to correctly preserve state between renders. Each time your component renders, React expects the exact same hooks to be called in the exact same order. When hooks are called conditionally or in loops, React loses track of which state corresponds to which hook call, leading to bugs like state mismatches and “Rendered fewer/more hooks than expected” errors.


## Common Violations
These patterns violate the Rules of Hooks:

- Hooks in conditions(if/else, ternary,&&/||)
- Hooks in loops(for,while,do-while)
- Hooks after early returns
- Hooks in callbacks/event handlers
- Hooks in async functions
- Hooks in class methods
- Hooks at module level

### Note

### usehook
Theusehook is different from other React hooks. You can call it conditionally and in loops:

```jsx
// ✅ `use` can be conditionalif (shouldFetch) {  const data = use(fetchPromise);}// ✅ `use` can be in loopsfor (const promise of promises) {  results.push(use(promise));}
```

However,usestill has restrictions:

- Can’t be wrapped in try/catch
- Must be called inside a component or hook
Learn more:useAPI Reference


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Hook in conditionif (isLoggedIn) {  const [user, setUser] = useState(null);}// ❌ Hook after early returnif (!data) return <Loading />;const [processed, setProcessed] = useState(data);// ❌ Hook in callback<button onClick={() => {  const [clicked, setClicked] = useState(false);}}/>// ❌ `use` in try/catchtry {  const data = use(promise);} catch (e) {  // error handling}// ❌ Hook at module levelconst globalState = useState(0); // Outside component
```


### Valid
Examples of correct code for this rule:

```jsx
function Component({ isSpecial, shouldFetch, fetchPromise }) {  // ✅ Hooks at top level  const [count, setCount] = useState(0);  const [name, setName] = useState('');  if (!isSpecial) {    return null;  }  if (shouldFetch) {    // ✅ `use` can be conditional    const data = use(fetchPromise);    return <div>{data}</div>;  }  return <div>{name}: {count}</div>;}
```


## Troubleshooting

### I want to fetch data based on some condition
You’re trying to conditionally call useEffect:

```jsx
// ❌ Conditional hookif (isLoggedIn) {  useEffect(() => {    fetchUserData();  }, []);}
```

Call the hook unconditionally, check condition inside:

```jsx
// ✅ Condition inside hookuseEffect(() => {  if (isLoggedIn) {    fetchUserData();  }}, [isLoggedIn]);
```


### Note
There are better ways to fetch data rather than in a useEffect. Consider using TanStack Query, useSWR, or React Router 6.4+ for data fetching. These solutions handle deduplicating requests, caching responses, and avoiding network waterfalls.

Learn more:Fetching Data


### I need different state for different scenarios
You’re trying to conditionally initialize state:

```jsx
// ❌ Conditional stateif (userType === 'admin') {  const [permissions, setPermissions] = useState(adminPerms);} else {  const [permissions, setPermissions] = useState(userPerms);}
```

Always call useState, conditionally set the initial value:

```jsx
// ✅ Conditional initial valueconst [permissions, setPermissions] = useState(  userType === 'admin' ? adminPerms : userPerms);
```


## Options
You can configure custom effect hooks using shared ESLint settings (available ineslint-plugin-react-hooks6.1.1 and later):

```jsx
{  "settings": {    "react-hooks": {      "additionalEffectHooks": "(useMyEffect|useCustomEffect)"    }  }}
```

- additionalEffectHooks: Regex pattern matching custom hooks that should be treated as effects. This allowsuseEffectEventand similar event functions to be called from your custom effect hooks.
This shared configuration is used by bothrules-of-hooksandexhaustive-depsrules, ensuring consistent behavior across all hook-related linting.


--------------------------------------------------------------------------------


# set-state-in-effect
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect

Validates against calling setState synchronously in an effect, which can lead to re-renders that degrade performance.


## Rule Details
Setting state immediately inside an effect forces React to restart the entire render cycle. When you update state in an effect, React must re-render your component, apply changes to the DOM, and then run effects again. This creates an extra render pass that could have been avoided by transforming data directly during render or deriving state from props. Transform data at the top level of your component instead. This code will naturally re-run when props or state change without triggering additional render cycles.

SynchronoussetStatecalls in effects trigger immediate re-renders before the browser can paint, causing performance issues and visual jank. React has to render twice: once to apply the state update, then again after effects run. This double rendering is wasteful when the same result could be achieved with a single render.

In many cases, you may also not need an effect at all. Please seeYou Might Not Need an Effectfor more information.


## Common Violations
This rule catches several patterns where synchronous setState is used unnecessarily:

- Setting loading state synchronously
- Deriving state from props in effects
- Transforming data in effects instead of render

### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Synchronous setState in effectfunction Component({data}) {  const [items, setItems] = useState([]);  useEffect(() => {    setItems(data); // Extra render, use initial state instead  }, [data]);}// ❌ Setting loading state synchronouslyfunction Component() {  const [loading, setLoading] = useState(false);  useEffect(() => {    setLoading(true); // Synchronous, causes extra render    fetchData().then(() => setLoading(false));  }, []);}// ❌ Transforming data in effectfunction Component({rawData}) {  const [processed, setProcessed] = useState([]);  useEffect(() => {    setProcessed(rawData.map(transform)); // Should derive in render  }, [rawData]);}// ❌ Deriving state from propsfunction Component({selectedId, items}) {  const [selected, setSelected] = useState(null);  useEffect(() => {    setSelected(items.find(i => i.id === selectedId));  }, [selectedId, items]);}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ setState in an effect is fine if the value comes from a reffunction Tooltip() {  const ref = useRef(null);  const [tooltipHeight, setTooltipHeight] = useState(0);  useLayoutEffect(() => {    const { height } = ref.current.getBoundingClientRect();    setTooltipHeight(height);  }, []);}// ✅ Calculate during renderfunction Component({selectedId, items}) {  const selected = items.find(i => i.id === selectedId);  return <div>{selected?.name}</div>;}
```

When something can be calculated from the existing props or state, don’t put it in state.Instead, calculate it during rendering. This makes your code faster, simpler, and less error-prone. Learn more inYou Might Not Need an Effect.


--------------------------------------------------------------------------------


# set-state-in-render
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render

Validates against unconditionally setting state during render, which can trigger additional renders and potential infinite render loops.


## Rule Details
CallingsetStateduring render unconditionally triggers another render before the current one finishes. This creates an infinite loop that crashes your app.


## Common Violations

### Invalid
```jsx
// ❌ Unconditional setState directly in renderfunction Component({value}) {  const [count, setCount] = useState(0);  setCount(value); // Infinite loop!  return <div>{count}</div>;}
```


### Valid
```jsx
// ✅ Derive during renderfunction Component({items}) {  const sorted = [...items].sort(); // Just calculate it in render  return <ul>{sorted.map(/*...*/)}</ul>;}// ✅ Set state in event handlerfunction Component() {  const [count, setCount] = useState(0);  return (    <button onClick={() => setCount(count + 1)}>      {count}    </button>  );}// ✅ Derive from props instead of setting statefunction Component({user}) {  const name = user?.name || '';  const email = user?.email || '';  return <div>{name}</div>;}// ✅ Conditionally derive state from props and state from previous rendersfunction Component({ items }) {  const [isReverse, setIsReverse] = useState(false);  const [selection, setSelection] = useState(null);  const [prevItems, setPrevItems] = useState(items);  if (items !== prevItems) { // This condition makes it valid    setPrevItems(items);    setSelection(null);  }  // ...}
```


## Troubleshooting

### I want to sync state to a prop
A common problem is trying to “fix” state after it renders. Suppose you want to keep a counter from exceeding amaxprop:

```jsx
// ❌ Wrong: clamps during renderfunction Counter({max}) {  const [count, setCount] = useState(0);  if (count > max) {    setCount(max);  }  return (    <button onClick={() => setCount(count + 1)}>      {count}    </button>  );}
```

As soon ascountexceedsmax, an infinite loop is triggered.

Instead, it’s often better to move this logic to the event (the place where the state is first set). For example, you can enforce the maximum at the moment you update state:

```jsx
// ✅ Clamp when updatingfunction Counter({max}) {  const [count, setCount] = useState(0);  const increment = () => {    setCount(current => Math.min(current + 1, max));  };  return <button onClick={increment}>{count}</button>;}
```

Now the setter only runs in response to the click, React finishes the render normally, andcountnever crossesmax.

In rare cases, you may need to adjust state based on information from previous renders. For those, followthis patternof setting state conditionally.


--------------------------------------------------------------------------------


# static-components
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components

Validates that components are static, not recreated every render. Components that are recreated dynamically can reset state and trigger excessive re-rendering.


## Rule Details
Components defined inside other components are recreated on every render. React sees each as a brand new component type, unmounting the old one and mounting the new one, destroying all state and DOM nodes in the process.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Component defined inside componentfunction Parent() {  const ChildComponent = () => { // New component every render!    const [count, setCount] = useState(0);    return <button onClick={() => setCount(count + 1)}>{count}</button>;  };  return <ChildComponent />; // State resets every render}// ❌ Dynamic component creationfunction Parent({type}) {  const Component = type === 'button'    ? () => <button>Click</button>    : () => <div>Text</div>;  return <Component />;}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Components at module levelconst ButtonComponent = () => <button>Click</button>;const TextComponent = () => <div>Text</div>;function Parent({type}) {  const Component = type === 'button'    ? ButtonComponent  // Reference existing component    : TextComponent;  return <Component />;}
```


## Troubleshooting

### I need to render different components conditionally
You might define components inside to access local state:

```jsx
// ❌ Wrong: Inner component to access parent statefunction Parent() {  const [theme, setTheme] = useState('light');  function ThemedButton() { // Recreated every render!    return (      <button className={theme}>        Click me      </button>    );  }  return <ThemedButton />;}
```

Pass data as props instead:

```jsx
// ✅ Better: Pass props to static componentfunction ThemedButton({theme}) {  return (    <button className={theme}>      Click me    </button>  );}function Parent() {  const [theme, setTheme] = useState('light');  return <ThemedButton theme={theme} />;}
```


### Note
If you find yourself wanting to define components inside other components to access local variables, that’s a sign you should be passing props instead. This makes components more reusable and testable.


--------------------------------------------------------------------------------


# unsupported-syntax
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax

Validates against syntax that React Compiler does not support. If you need to, you can still use this syntax outside of React, such as in a standalone utility function.


## Rule Details
React Compiler needs to statically analyze your code to apply optimizations. Features likeevalandwithmake it impossible to statically understand what the code does at compile time, so the compiler can’t optimize components that use them.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ Using eval in componentfunction Component({ code }) {  const result = eval(code); // Can't be analyzed  return <div>{result}</div>;}// ❌ Using with statementfunction Component() {  with (Math) { // Changes scope dynamically    return <div>{sin(PI / 2)}</div>;  }}// ❌ Dynamic property access with evalfunction Component({propName}) {  const value = eval(`props.${propName}`);  return <div>{value}</div>;}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Use normal property accessfunction Component({propName, props}) {  const value = props[propName]; // Analyzable  return <div>{value}</div>;}// ✅ Use standard Math methodsfunction Component() {  return <div>{Math.sin(Math.PI / 2)}</div>;}
```


## Troubleshooting

### I need to evaluate dynamic code
You might need to evaluate user-provided code:

```jsx
// ❌ Wrong: eval in componentfunction Calculator({expression}) {  const result = eval(expression); // Unsafe and unoptimizable  return <div>Result: {result}</div>;}
```

Use a safe expression parser instead:

```jsx
// ✅ Better: Use a safe parserimport {evaluate} from 'mathjs'; // or similar libraryfunction Calculator({expression}) {  const [result, setResult] = useState(null);  const calculate = () => {    try {      // Safe mathematical expression evaluation      setResult(evaluate(expression));    } catch (error) {      setResult('Invalid expression');    }  };  return (    <div>      <button onClick={calculate}>Calculate</button>      {result && <div>Result: {result}</div>}    </div>  );}
```


### Note
Never useevalwith user input - it’s a security risk. Use dedicated parsing libraries for specific use cases like mathematical expressions, JSON parsing, or template evaluation.


--------------------------------------------------------------------------------


# use-memo
Source: https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo

Validates that theuseMemohook is used with a return value. SeeuseMemodocsfor more information.


## Rule Details
useMemois for computing and caching expensive values, not for side effects. Without a return value,useMemoreturnsundefined, which defeats its purpose and likely indicates you’re using the wrong hook.


### Invalid
Examples of incorrect code for this rule:

```jsx
// ❌ No return valuefunction Component({ data }) {  const processed = useMemo(() => {    data.forEach(item => console.log(item));    // Missing return!  }, [data]);  return <div>{processed}</div>; // Always undefined}
```


### Valid
Examples of correct code for this rule:

```jsx
// ✅ Returns computed valuefunction Component({ data }) {  const processed = useMemo(() => {    return data.map(item => item * 2);  }, [data]);  return <div>{processed}</div>;}
```


## Troubleshooting

### I need to run side effects when dependencies change
You might try to useuseMemofor side effects:

```jsx
// ❌ Wrong: Side effects in useMemofunction Component({user}) {  // No return value, just side effect  useMemo(() => {    analytics.track('UserViewed', {userId: user.id});  }, [user.id]);  // Not assigned to a variable  useMemo(() => {    return analytics.track('UserViewed', {userId: user.id});  }, [user.id]);}
```

If the side effect needs to happen in response to user interaction, it’s best to colocate the side effect with the event:

```jsx
// ✅ Good: Side effects in event handlersfunction Component({user}) {  const handleClick = () => {    analytics.track('ButtonClicked', {userId: user.id});    // Other click logic...  };  return <button onClick={handleClick}>Click me</button>;}
```

If the side effect sychronizes React state with some external state (or vice versa), useuseEffect:

```jsx
// ✅ Good: Synchronization in useEffectfunction Component({theme}) {  useEffect(() => {    localStorage.setItem('preferredTheme', theme);    document.body.className = theme;  }, [theme]);  return <div>Current theme: {theme}</div>;}
```


--------------------------------------------------------------------------------


# React Reference Overview
Source: https://react.dev/reference/react

This section provides detailed reference documentation for working with React. For an introduction to React, please visit theLearnsection.

The React reference documentation is broken down into functional subsections:


## React
Programmatic React features:

- Hooks- Use different React features from your components.
- Components- Built-in components that you can use in your JSX.
- APIs- APIs that are useful for defining components.
- Directives- Provide instructions to bundlers compatible with React Server Components.

## React DOM
React DOM contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:

- Hooks- Hooks for web applications which run in the browser DOM environment.
- Components- React supports all of the browser built-in HTML and SVG components.
- APIs- Thereact-dompackage contains methods supported only in web applications.
- Client APIs- Thereact-dom/clientAPIs let you render React components on the client (in the browser).
- Server APIs- Thereact-dom/serverAPIs let you render React components to HTML on the server.
- Static APIs- Thereact-dom/staticAPIs let you generate static HTML for React components.

## React Compiler
The React Compiler is a build-time optimization tool that automatically memoizes your React components and values:

- Configuration- Configuration options for React Compiler.
- Directives- Function-level directives to control compilation.
- Compiling Libraries- Guide for shipping pre-compiled library code.

## ESLint Plugin React Hooks
TheESLint plugin for React Hookshelps enforce the Rules of React:

- Lints- Detailed documentation for each lint with examples.

## Rules of React
React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications:

- Components and Hooks must be pure– Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.
- React calls Components and Hooks– React is responsible for rendering components and hooks when necessary to optimize the user experience.
- Rules of Hooks– Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.

## Legacy APIs
- Legacy APIs- Exported from thereactpackage, but not recommended for use in newly written code.

--------------------------------------------------------------------------------


# compilationMode
Source: https://react.dev/reference/react-compiler/compilationMode

ThecompilationModeoption controls how the React Compiler selects which functions to compile.

```jsx
{  compilationMode: 'infer' // or 'annotation', 'syntax', 'all'}
```

- ReferencecompilationMode
- compilationMode
- UsageDefault inference modeIncremental adoption with annotation modeUsing Flow syntax modeOpting out specific functions
- Default inference mode
- Incremental adoption with annotation mode
- Using Flow syntax mode
- Opting out specific functions
- TroubleshootingComponent not being compiled in infer mode
- Component not being compiled in infer mode

## Reference

### compilationMode
Controls the strategy for determining which functions the React Compiler will optimize.


#### Type
```jsx
'infer' | 'syntax' | 'annotation' | 'all'
```


#### Default value
'infer'


#### Options
- 'infer'(default): The compiler uses intelligent heuristics to identify React components and hooks:Functions explicitly annotated with"use memo"directiveFunctions that are named like components (PascalCase) or hooks (useprefix) AND create JSX and/or call other hooks
'infer'(default): The compiler uses intelligent heuristics to identify React components and hooks:

- Functions explicitly annotated with"use memo"directive
- Functions that are named like components (PascalCase) or hooks (useprefix) AND create JSX and/or call other hooks
- 'annotation': Only compile functions explicitly marked with the"use memo"directive. Ideal for incremental adoption.
'annotation': Only compile functions explicitly marked with the"use memo"directive. Ideal for incremental adoption.

- 'syntax': Only compile components and hooks that use Flow’scomponentandhooksyntax.
'syntax': Only compile components and hooks that use Flow’scomponentandhooksyntax.

- 'all': Compile all top-level functions. Not recommended as it may compile non-React functions.
'all': Compile all top-level functions. Not recommended as it may compile non-React functions.


#### Caveats
- The'infer'mode requires functions to follow React naming conventions to be detected
- Using'all'mode may negatively impact performance by compiling utility functions
- The'syntax'mode requires Flow and won’t work with TypeScript
- Regardless of mode, functions with"use no memo"directive are always skipped

## Usage

### Default inference mode
The default'infer'mode works well for most codebases that follow React conventions:

```jsx
{  compilationMode: 'infer'}
```

With this mode, these functions will be compiled:

```jsx
// ✅ Compiled: Named like a component + returns JSXfunction Button(props) {  return <button>{props.label}</button>;}// ✅ Compiled: Named like a hook + calls hooksfunction useCounter() {  const [count, setCount] = useState(0);  return [count, setCount];}// ✅ Compiled: Explicit directivefunction expensiveCalculation(data) {  "use memo";  return data.reduce(/* ... */);}// ❌ Not compiled: Not a component/hook patternfunction calculateTotal(items) {  return items.reduce((a, b) => a + b, 0);}
```


### Incremental adoption with annotation mode
For gradual migration, use'annotation'mode to only compile marked functions:

```jsx
{  compilationMode: 'annotation'}
```

Then explicitly mark functions to compile:

```jsx
// Only this function will be compiledfunction ExpensiveList(props) {  "use memo";  return (    <ul>      {props.items.map(item => (        <li key={item.id}>{item.name}</li>      ))}    </ul>  );}// This won't be compiled without the directivefunction NormalComponent(props) {  return <div>{props.content}</div>;}
```


### Using Flow syntax mode
If your codebase uses Flow instead of TypeScript:

```jsx
{  compilationMode: 'syntax'}
```

Then use Flow’s component syntax:

```jsx
// Compiled: Flow component syntaxcomponent Button(label: string) {  return <button>{label}</button>;}// Compiled: Flow hook syntaxhook useCounter(initial: number) {  const [count, setCount] = useState(initial);  return [count, setCount];}// Not compiled: Regular function syntaxfunction helper(data) {  return process(data);}
```


### Opting out specific functions
Regardless of compilation mode, use"use no memo"to skip compilation:

```jsx
function ComponentWithSideEffects() {  "use no memo"; // Prevent compilation  // This component has side effects that shouldn't be memoized  logToAnalytics('component_rendered');  return <div>Content</div>;}
```


## Troubleshooting

### Component not being compiled in infer mode
In'infer'mode, ensure your component follows React conventions:

```jsx
// ❌ Won't be compiled: lowercase namefunction button(props) {  return <button>{props.label}</button>;}// ✅ Will be compiled: PascalCase namefunction Button(props) {  return <button>{props.label}</button>;}// ❌ Won't be compiled: doesn't create JSX or call hooksfunction useData() {  return window.localStorage.getItem('data');}// ✅ Will be compiled: calls a hookfunction useData() {  const [data] = useState(() => window.localStorage.getItem('data'));  return data;}
```


--------------------------------------------------------------------------------


# Compiling Libraries
Source: https://react.dev/reference/react-compiler/compiling-libraries

This guide helps library authors understand how to use React Compiler to ship optimized library code to their users.

- Why Ship Compiled Code?
- Setting Up Compilation
- Backwards Compatibility1. Install the runtime package2. Configure the target version
- 1. Install the runtime package
- 2. Configure the target version
- Testing Strategy
- TroubleshootingLibrary doesn’t work with older React versionsCompilation conflicts with other Babel pluginsRuntime module not found
- Library doesn’t work with older React versions
- Compilation conflicts with other Babel plugins
- Runtime module not found
- Next Steps

## Why Ship Compiled Code?
As a library author, you can compile your library code before publishing to npm. This provides several benefits:

- Performance improvements for all users- Your library users get optimized code even if they aren’t using React Compiler yet
- No configuration required by users- The optimizations work out of the box
- Consistent behavior- All users get the same optimized version regardless of their build setup

## Setting Up Compilation
Add React Compiler to your library’s build process:

```jsx
npm install -D babel-plugin-react-compiler@latest
```

Configure your build tool to compile your library. For example, with Babel:

```jsx
// babel.config.jsmodule.exports = {  plugins: [    'babel-plugin-react-compiler',  ],  // ... other config};
```


## Backwards Compatibility
If your library supports React versions below 19, you’ll need additional configuration:


### 1. Install the runtime package
We recommend installing react-compiler-runtime as a direct dependency:

```jsx
npm install react-compiler-runtime@latest
```

```jsx
{  "dependencies": {    "react-compiler-runtime": "^1.0.0"  },  "peerDependencies": {    "react": "^17.0.0 || ^18.0.0 || ^19.0.0"  }}
```


### 2. Configure the target version
Set the minimum React version your library supports:

```jsx
{  target: '17', // Minimum supported React version}
```


## Testing Strategy
Test your library both with and without compilation to ensure compatibility. Run your existing test suite against the compiled code, and also create a separate test configuration that bypasses the compiler. This helps catch any issues that might arise from the compilation process and ensures your library works correctly in all scenarios.


## Troubleshooting

### Library doesn’t work with older React versions
If your compiled library throws errors in React 17 or 18:

1. Verify you’ve installedreact-compiler-runtimeas a dependency
1. Check that yourtargetconfiguration matches your minimum supported React version
1. Ensure the runtime package is included in your published bundle

### Compilation conflicts with other Babel plugins
Some Babel plugins may conflict with React Compiler:

1. Placebabel-plugin-react-compilerearly in your plugin list
1. Disable conflicting optimizations in other plugins
1. Test your build output thoroughly

### Runtime module not found
If users see “Cannot find module ‘react-compiler-runtime’“:

1. Ensure the runtime is listed independencies, notdevDependencies
1. Check that your bundler includes the runtime in the output
1. Verify the package is published to npm with your library

## Next Steps
- Learn aboutdebugging techniquesfor compiled code
- Check theconfiguration optionsfor all compiler options
- Explorecompilation modesfor selective optimization

--------------------------------------------------------------------------------


# Configuration
Source: https://react.dev/reference/react-compiler/configuration

This page lists all configuration options available in React Compiler.


### Note
For most apps, the default options should work out of the box. If you have a special need, you can use these advanced options.

```jsx
// babel.config.jsmodule.exports = {  plugins: [    [      'babel-plugin-react-compiler', {        // compiler options      }    ]  ]};
```


## Compilation Control
These options controlwhatthe compiler optimizes andhowit selects components and hooks to compile.

- compilationModecontrols the strategy for selecting functions to compile (e.g., all functions, only annotated ones, or intelligent detection).
```jsx
{  compilationMode: 'annotation' // Only compile "use memo" functions}
```


## Version Compatibility
React version configuration ensures the compiler generates code compatible with your React version.

targetspecifies which React version you’re using (17, 18, or 19).

```jsx
// For React 18 projects{  target: '18' // Also requires react-compiler-runtime package}
```


## Error Handling
These options control how the compiler responds to code that doesn’t follow theRules of React.

panicThresholddetermines whether to fail the build or skip problematic components.

```jsx
// Recommended for production{  panicThreshold: 'none' // Skip components with errors instead of failing the build}
```


## Debugging
Logging and analysis options help you understand what the compiler is doing.

loggerprovides custom logging for compilation events.

```jsx
{  logger: {    logEvent(filename, event) {      if (event.kind === 'CompileSuccess') {        console.log('Compiled:', filename);      }    }  }}
```


## Feature Flags
Conditional compilation lets you control when optimized code is used.

gatingenables runtime feature flags for A/B testing or gradual rollouts.

```jsx
{  gating: {    source: 'my-feature-flags',    importSpecifierName: 'isCompilerEnabled'  }}
```


## Common Configuration Patterns

### Default configuration
For most React 19 applications, the compiler works without configuration:

```jsx
// babel.config.jsmodule.exports = {  plugins: [    'babel-plugin-react-compiler'  ]};
```


### React 17/18 projects
Older React versions need the runtime package and target configuration:

```jsx
npm install react-compiler-runtime@latest
```

```jsx
{  target: '18' // or '17'}
```


### Incremental adoption
Start with specific directories and expand gradually:

```jsx
{  compilationMode: 'annotation' // Only compile "use memo" functions}
```


--------------------------------------------------------------------------------


# Directives
Source: https://react.dev/reference/react-compiler/directives

React Compiler directives are special string literals that control whether specific functions are compiled.

```jsx
function MyComponent() {  "use memo"; // Opt this component into compilation  return <div>{/* ... */}</div>;}
```

- OverviewAvailable directivesQuick comparison
- Available directives
- Quick comparison
- UsageFunction-level directivesModule-level directivesCompilation modes interaction
- Function-level directives
- Module-level directives
- Compilation modes interaction
- Best practicesUse directives sparinglyDocument directive usagePlan for removal
- Use directives sparingly
- Document directive usage
- Plan for removal
- Common patternsGradual adoption
- Gradual adoption
- TroubleshootingCommon issues
- Common issues
- See also

## Overview
React Compiler directives provide fine-grained control over which functions are optimized by the compiler. They are string literals placed at the beginning of a function body or at the top of a module.


### Available directives
- "use memo"- Opts a function into compilation
- "use no memo"- Opts a function out of compilation

### Quick comparison

## Usage

### Function-level directives
Place directives at the beginning of a function to control its compilation:

```jsx
// Opt into compilationfunction OptimizedComponent() {  "use memo";  return <div>This will be optimized</div>;}// Opt out of compilationfunction UnoptimizedComponent() {  "use no memo";  return <div>This won't be optimized</div>;}
```


### Module-level directives
Place directives at the top of a file to affect all functions in that module:

```jsx
// At the very top of the file"use memo";// All functions in this file will be compiledfunction Component1() {  return <div>Compiled</div>;}function Component2() {  return <div>Also compiled</div>;}// Can be overridden at function levelfunction Component3() {  "use no memo"; // This overrides the module directive  return <div>Not compiled</div>;}
```


### Compilation modes interaction
Directives behave differently depending on yourcompilationMode:

- annotationmode: Only functions with"use memo"are compiled
- infermode: Compiler decides what to compile, directives override decisions
- allmode: Everything is compiled,"use no memo"can exclude specific functions

## Best practices

### Use directives sparingly
Directives are escape hatches. Prefer configuring the compiler at the project level:

```jsx
// ✅ Good - project-wide configuration{  plugins: [    ['babel-plugin-react-compiler', {      compilationMode: 'infer'    }]  ]}// ⚠️ Use directives only when neededfunction SpecialCase() {  "use no memo"; // Document why this is needed  // ...}
```


### Document directive usage
Always explain why a directive is used:

```jsx
// ✅ Good - clear explanationfunction DataGrid() {  "use no memo"; // TODO: Remove after fixing issue with dynamic row heights (JIRA-123)  // Complex grid implementation}// ❌ Bad - no explanationfunction Mystery() {  "use no memo";  // ...}
```


### Plan for removal
Opt-out directives should be temporary:

1. Add the directive with a TODO comment
1. Create a tracking issue
1. Fix the underlying problem
1. Remove the directive
```jsx
function TemporaryWorkaround() {  "use no memo"; // TODO: Remove after upgrading ThirdPartyLib to v2.0  return <ThirdPartyComponent />;}
```


## Common patterns

### Gradual adoption
When adopting the React Compiler in a large codebase:

```jsx
// Start with annotation mode{  compilationMode: 'annotation'}// Opt in stable componentsfunction StableComponent() {  "use memo";  // Well-tested component}// Later, switch to infer mode and opt out problematic onesfunction ProblematicComponent() {  "use no memo"; // Fix issues before removing  // ...}
```


## Troubleshooting
For specific issues with directives, see the troubleshooting sections in:

- "use memo"troubleshooting
- "use no memo"troubleshooting

### Common issues
1. Directive ignored: Check placement (must be first) and spelling
1. Compilation still happens: CheckignoreUseNoForgetsetting
1. Module directive not working: Ensure it’s before all imports

## See also
- compilationMode- Configure how the compiler chooses what to optimize
- Configuration- Full compiler configuration options
- React Compiler documentation- Getting started guide

--------------------------------------------------------------------------------


# use memo
Source: https://react.dev/reference/react-compiler/directives/use-memo

"use memo"marks a function for React Compiler optimization.


### Note
In most cases, you don’t need"use memo". It’s primarily needed inannotationmode where you must explicitly mark functions for optimization. Ininfermode, the compiler automatically detects components and hooks by their naming patterns (PascalCase for components,useprefix for hooks). If a component or hook isn’t being compiled ininfermode, you should fix its naming convention rather than forcing compilation with"use memo".

- Reference"use memo"How"use memo"marks functions for optimizationWhen to use"use memo"
- "use memo"
- How"use memo"marks functions for optimization
- When to use"use memo"
- UsageWorking with different compilation modes
- Working with different compilation modes
- TroubleshootingVerifying optimizationSee also
- Verifying optimization
- See also

## Reference

### "use memo"
Add"use memo"at the beginning of a function to mark it for React Compiler optimization.

```jsx
function MyComponent() {  "use memo";  // ...}
```

When a function contains"use memo", the React Compiler will analyze and optimize it during build time. The compiler will automatically memoize values and components to prevent unnecessary re-computations and re-renders.


#### Caveats
- "use memo"must be at the very beginning of a function body, before any imports or other code (comments are OK).
- The directive must be written with double or single quotes, not backticks.
- The directive must exactly match"use memo".
- Only the first directive in a function is processed; additional directives are ignored.
- The effect of the directive depends on yourcompilationModesetting.

### How"use memo"marks functions for optimization
In a React app that uses the React Compiler, functions are analyzed at build time to determine if they can be optimized. By default, the compiler automatically infers which components to memoize, but this can depend on yourcompilationModesetting if you’ve set it.

"use memo"explicitly marks a function for optimization, overriding the default behavior:

- Inannotationmode: Only functions with"use memo"are optimized
- Ininfermode: The compiler uses heuristics, but"use memo"forces optimization
- Inallmode: Everything is optimized by default, making"use memo"redundant
The directive creates a clear boundary in your codebase between optimized and non-optimized code, giving you fine-grained control over the compilation process.


### When to use"use memo"
You should consider using"use memo"when:


#### You’re using annotation mode
IncompilationMode: 'annotation', the directive is required for any function you want optimized:

```jsx
// ✅ This component will be optimizedfunction OptimizedList() {  "use memo";  // ...}// ❌ This component won't be optimizedfunction SimpleWrapper() {  // ...}
```


#### You’re gradually adopting React Compiler
Start withannotationmode and selectively optimize stable components:

```jsx
// Start by optimizing leaf componentsfunction Button({ onClick, children }) {  "use memo";  // ...}// Gradually move up the tree as you verify behaviorfunction ButtonGroup({ buttons }) {  "use memo";  // ...}
```


## Usage

### Working with different compilation modes
The behavior of"use memo"changes based on your compiler configuration:

```jsx
// babel.config.jsmodule.exports = {  plugins: [    ['babel-plugin-react-compiler', {      compilationMode: 'annotation' // or 'infer' or 'all'    }]  ]};
```


#### Annotation mode
```jsx
// ✅ Optimized with "use memo"function ProductCard({ product }) {  "use memo";  // ...}// ❌ Not optimized (no directive)function ProductList({ products }) {  // ...}
```


#### Infer mode (default)
```jsx
// Automatically memoized because this is named like a Componentfunction ComplexDashboard({ data }) {  // ...}// Skipped: Is not named like a Componentfunction simpleDisplay({ text }) {  // ...}
```

Ininfermode, the compiler automatically detects components and hooks by their naming patterns (PascalCase for components,useprefix for hooks). If a component or hook isn’t being compiled ininfermode, you should fix its naming convention rather than forcing compilation with"use memo".


## Troubleshooting

### Verifying optimization
To confirm your component is being optimized:

1. Check the compiled output in your build
1. Use React DevTools to check for Memo ✨ badge

### See also
- "use no memo"- Opt out of compilation
- compilationMode- Configure compilation behavior
- React Compiler- Getting started guide

--------------------------------------------------------------------------------


# use no memo
Source: https://react.dev/reference/react-compiler/directives/use-no-memo

"use no memo"prevents a function from being optimized by React Compiler.

- Reference"use no memo"How"use no memo"opts-out of optimizationWhen to use"use no memo"
- "use no memo"
- How"use no memo"opts-out of optimization
- When to use"use no memo"
- Usage
- TroubleshootingDirective not preventing compilationBest practicesSee also
- Directive not preventing compilation
- Best practices
- See also

## Reference

### "use no memo"
Add"use no memo"at the beginning of a function to prevent React Compiler optimization.

```jsx
function MyComponent() {  "use no memo";  // ...}
```

When a function contains"use no memo", the React Compiler will skip it entirely during optimization. This is useful as a temporary escape hatch when debugging or when dealing with code that doesn’t work correctly with the compiler.


#### Caveats
- "use no memo"must be at the very beginning of a function body, before any imports or other code (comments are OK).
- The directive must be written with double or single quotes, not backticks.
- The directive must exactly match"use no memo"or its alias"use no forget".
- This directive takes precedence over all compilation modes and other directives.
- It’s intended as a temporary debugging tool, not a permanent solution.

### How"use no memo"opts-out of optimization
React Compiler analyzes your code at build time to apply optimizations."use no memo"creates an explicit boundary that tells the compiler to skip a function entirely.

This directive takes precedence over all other settings:

- Inallmode: The function is skipped despite the global setting
- Ininfermode: The function is skipped even if heuristics would optimize it
The compiler treats these functions as if the React Compiler wasn’t enabled, leaving them exactly as written.


### When to use"use no memo"
"use no memo"should be used sparingly and temporarily. Common scenarios include:


#### Debugging compiler issues
When you suspect the compiler is causing issues, temporarily disable optimization to isolate the problem:

```jsx
function ProblematicComponent({ data }) {  "use no memo"; // TODO: Remove after fixing issue #123  // Rules of React violations that weren't statically detected  // ...}
```


#### Third-party library integration
When integrating with libraries that might not be compatible with the compiler:

```jsx
function ThirdPartyWrapper() {  "use no memo";  useThirdPartyHook(); // Has side effects that compiler might optimize incorrectly  // ...}
```


## Usage
The"use no memo"directive is placed at the beginning of a function body to prevent React Compiler from optimizing that function:

```jsx
function MyComponent() {  "use no memo";  // Function body}
```

The directive can also be placed at the top of a file to affect all functions in that module:

```jsx
"use no memo";// All functions in this file will be skipped by the compiler
```

"use no memo"at the function level overrides the module level directive.


## Troubleshooting

### Directive not preventing compilation
If"use no memo"isn’t working:

```jsx
// ❌ Wrong - directive after codefunction Component() {  const data = getData();  "use no memo"; // Too late!}// ✅ Correct - directive firstfunction Component() {  "use no memo";  const data = getData();}
```

Also check:

- Spelling - must be exactly"use no memo"
- Quotes - must use single or double quotes, not backticks

### Best practices
Always document whyyou’re disabling optimization:

```jsx
// ✅ Good - clear explanation and trackingfunction DataProcessor() {  "use no memo"; // TODO: Remove after fixing rule of react violation  // ...}// ❌ Bad - no explanationfunction Mystery() {  "use no memo";  // ...}
```


### See also
- "use memo"- Opt into compilation
- React Compiler- Getting started guide

--------------------------------------------------------------------------------


# gating
Source: https://react.dev/reference/react-compiler/gating

Thegatingoption enables conditional compilation, allowing you to control when optimized code is used at runtime.

```jsx
{  gating: {    source: 'my-feature-flags',    importSpecifierName: 'shouldUseCompiler'  }}
```

- Referencegating
- gating
- UsageBasic feature flag setup
- Basic feature flag setup
- TroubleshootingFeature flag not workingImport errors
- Feature flag not working
- Import errors

## Reference

### gating
Configures runtime feature flag gating for compiled functions.


#### Type
```jsx
{  source: string;  importSpecifierName: string;} | null
```


#### Default value
null


#### Properties
- source: Module path to import the feature flag from
- importSpecifierName: Name of the exported function to import

#### Caveats
- The gating function must return a boolean
- Both compiled and original versions increase bundle size
- The import is added to every file with compiled functions

## Usage

### Basic feature flag setup
1. Create a feature flag module:
```jsx
// src/utils/feature-flags.jsexport function shouldUseCompiler() {  // your logic here  return getFeatureFlag('react-compiler-enabled');}
```

1. Configure the compiler:
```jsx
{  gating: {    source: './src/utils/feature-flags',    importSpecifierName: 'shouldUseCompiler'  }}
```

1. The compiler generates gated code:
```jsx
// Inputfunction Button(props) {  return <button>{props.label}</button>;}// Output (simplified)import { shouldUseCompiler } from './src/utils/feature-flags';const Button = shouldUseCompiler()  ? function Button_optimized(props) { /* compiled version */ }  : function Button_original(props) { /* original version */ };
```

Note that the gating function is evaluated once at module time, so once the JS bundle has been parsed and evaluated the choice of component stays static for the rest of the browser session.


## Troubleshooting

### Feature flag not working
Verify your flag module exports the correct function:

```jsx
// ❌ Wrong: Default exportexport default function shouldUseCompiler() {  return true;}// ✅ Correct: Named export matching importSpecifierNameexport function shouldUseCompiler() {  return true;}
```


### Import errors
Ensure the source path is correct:

```jsx
// ❌ Wrong: Relative to babel.config.js{  source: './src/flags',  importSpecifierName: 'flag'}// ✅ Correct: Module resolution path{  source: '@myapp/feature-flags',  importSpecifierName: 'flag'}// ✅ Also correct: Absolute path from project root{  source: './src/utils/flags',  importSpecifierName: 'flag'}
```


--------------------------------------------------------------------------------


# logger
Source: https://react.dev/reference/react-compiler/logger

Theloggeroption provides custom logging for React Compiler events during compilation.

```jsx
{  logger: {    logEvent(filename, event) {      console.log(`[Compiler] ${event.kind}: ${filename}`);    }  }}
```

- Referencelogger
- logger
- UsageBasic loggingDetailed error logging
- Basic logging
- Detailed error logging

## Reference

### logger
Configures custom logging to track compiler behavior and debug issues.


#### Type
```jsx
{  logEvent: (filename: string | null, event: LoggerEvent) => void;} | null
```


#### Default value
null


#### Methods
- logEvent: Called for each compiler event with the filename and event details

#### Event types
- CompileSuccess: Function successfully compiled
- CompileError: Function skipped due to errors
- CompileDiagnostic: Non-fatal diagnostic information
- CompileSkip: Function skipped for other reasons
- PipelineError: Unexpected compilation error
- Timing: Performance timing information

#### Caveats
- Event structure may change between versions
- Large codebases generate many log entries

## Usage

### Basic logging
Track compilation success and failures:

```jsx
{  logger: {    logEvent(filename, event) {      switch (event.kind) {        case 'CompileSuccess': {          console.log(`✅ Compiled: ${filename}`);          break;        }        case 'CompileError': {          console.log(`❌ Skipped: ${filename}`);          break;        }        default: {}      }    }  }}
```


### Detailed error logging
Get specific information about compilation failures:

```jsx
{  logger: {    logEvent(filename, event) {      if (event.kind === 'CompileError') {        console.error(`\nCompilation failed: ${filename}`);        console.error(`Reason: ${event.detail.reason}`);        if (event.detail.description) {          console.error(`Details: ${event.detail.description}`);        }        if (event.detail.loc) {          const { line, column } = event.detail.loc.start;          console.error(`Location: Line ${line}, Column ${column}`);        }        if (event.detail.suggestions) {          console.error('Suggestions:', event.detail.suggestions);        }      }    }  }}
```


--------------------------------------------------------------------------------


# panicThreshold
Source: https://react.dev/reference/react-compiler/panicThreshold

ThepanicThresholdoption controls how the React Compiler handles errors during compilation.

```jsx
{  panicThreshold: 'none' // Recommended}
```

- ReferencepanicThreshold
- panicThreshold
- UsageProduction configuration (recommended)Development debugging
- Production configuration (recommended)
- Development debugging

## Reference

### panicThreshold
Determines whether compilation errors should fail the build or skip optimization.


#### Type
```jsx
'none' | 'critical_errors' | 'all_errors'
```


#### Default value
'none'


#### Options
- 'none'(default, recommended): Skip components that can’t be compiled and continue building
- 'critical_errors': Fail the build only on critical compiler errors
- 'all_errors': Fail the build on any compiler diagnostic

#### Caveats
- Production builds should always use'none'
- Build failures prevent your application from building
- The compiler automatically detects and skips problematic code with'none'
- Higher thresholds are only useful during development for debugging

## Usage

### Production configuration (recommended)
For production builds, always use'none'. This is the default value:

```jsx
{  panicThreshold: 'none'}
```

This ensures:

- Your build never fails due to compiler issues
- Components that can’t be optimized run normally
- Maximum components get optimized
- Stable production deployments

### Development debugging
Temporarily use stricter thresholds to find issues:

```jsx
const isDevelopment = process.env.NODE_ENV === 'development';{  panicThreshold: isDevelopment ? 'critical_errors' : 'none',  logger: {    logEvent(filename, event) {      if (isDevelopment && event.kind === 'CompileError') {        // ...      }    }  }}
```


--------------------------------------------------------------------------------


# target
Source: https://react.dev/reference/react-compiler/target

Thetargetoption specifies which React version the compiler should generate code for.

```jsx
{  target: '19' // or '18', '17'}
```

- Referencetarget
- target
- UsageTargeting React 19 (default)Targeting React 17 or 18
- Targeting React 19 (default)
- Targeting React 17 or 18
- TroubleshootingRuntime errors about missing compiler runtimeRuntime package not workingChecking compiled output
- Runtime errors about missing compiler runtime
- Runtime package not working
- Checking compiled output

## Reference

### target
Configures the React version compatibility for the compiled output.


#### Type
```jsx
'17' | '18' | '19'
```


#### Default value
'19'


#### Valid values
- '19': Target React 19 (default). No additional runtime required.
- '18': Target React 18. Requiresreact-compiler-runtimepackage.
- '17': Target React 17. Requiresreact-compiler-runtimepackage.

#### Caveats
- Always use string values, not numbers (e.g.,'17'not17)
- Don’t include patch versions (e.g., use'18'not'18.2.0')
- React 19 includes built-in compiler runtime APIs
- React 17 and 18 require installingreact-compiler-runtime@latest

## Usage

### Targeting React 19 (default)
For React 19, no special configuration is needed:

```jsx
{  // defaults to target: '19'}
```

The compiler will use React 19’s built-in runtime APIs:

```jsx
// Compiled output uses React 19's native APIsimport { c as _c } from 'react/compiler-runtime';
```


### Targeting React 17 or 18
For React 17 and React 18 projects, you need two steps:

1. Install the runtime package:
```jsx
npm install react-compiler-runtime@latest
```

1. Configure the target:
```jsx
// For React 18{  target: '18'}// For React 17{  target: '17'}
```

The compiler will use the polyfill runtime for both versions:

```jsx
// Compiled output uses the polyfillimport { c as _c } from 'react-compiler-runtime';
```


## Troubleshooting

### Runtime errors about missing compiler runtime
If you see errors like “Cannot find module ‘react/compiler-runtime’“:

1. Check your React version:npmwhyreact
Check your React version:

```jsx
npm why react
```

1. If using React 17 or 18, install the runtime:npminstallreact-compiler-runtime@latest
If using React 17 or 18, install the runtime:

```jsx
npm install react-compiler-runtime@latest
```

1. Ensure your target matches your React version:{target:'18'// Must match your React major version}
Ensure your target matches your React version:

```jsx
{  target: '18' // Must match your React major version}
```


### Runtime package not working
Ensure the runtime package is:

1. Installed in your project (not globally)
1. Listed in yourpackage.jsondependencies
1. The correct version (@latesttag)
1. Not indevDependencies(it’s needed at runtime)

### Checking compiled output
To verify the correct runtime is being used, note the different import (react/compiler-runtimefor builtin,react-compiler-runtimestandalone package for 17/18):

```jsx
// For React 19 (built-in runtime)import { c } from 'react/compiler-runtime'//                      ^// For React 17/18 (polyfill runtime)import { c } from 'react-compiler-runtime'//                      ^
```


--------------------------------------------------------------------------------


# React DOM APIs
Source: https://react.dev/reference/react-dom

Thereact-dompackage contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.


## APIs
These APIs can be imported from your components. They are rarely used:

- createPortallets you render child components in a different part of the DOM tree.
- flushSynclets you force React to flush a state update and update the DOM synchronously.

## Resource Preloading APIs
These APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used.

React-based frameworksfrequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework’s documentation for details.

- prefetchDNSlets you prefetch the IP address of a DNS domain name that you expect to connect to.
- preconnectlets you connect to a server you expect to request resources from, even if you don’t know what resources you’ll need yet.
- preloadlets you fetch a stylesheet, font, image, or external script that you expect to use.
- preloadModulelets you fetch an ESM module that you expect to use.
- preinitlets you fetch and evaluate an external script or fetch and insert a stylesheet.
- preinitModulelets you fetch and evaluate an ESM module.

## Entry points
Thereact-dompackage provides two additional entry points:

- react-dom/clientcontains APIs to render React components on the client (in the browser).
- react-dom/servercontains APIs to render React components on the server.

## Removed APIs
These APIs were removed in React 19:

- findDOMNode: seealternatives.
- hydrate: usehydrateRootinstead.
- render: usecreateRootinstead.
- unmountComponentAtNode: useroot.unmount()instead.
- renderToNodeStream: usereact-dom/serverAPIs instead.
- renderToStaticNodeStream: usereact-dom/serverAPIs instead.

--------------------------------------------------------------------------------


# Client React DOM APIs
Source: https://react.dev/reference/react-dom/client

Thereact-dom/clientAPIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. Aframeworkmay call them for you. Most of your components don’t need to import or use them.


## Client APIs
- createRootlets you create a root to display React components inside a browser DOM node.
- hydrateRootlets you display React components inside a browser DOM node whose HTML content was previously generated byreact-dom/server.

## Browser support
React supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10.


--------------------------------------------------------------------------------


# createRoot
Source: https://react.dev/reference/react-dom/client/createRoot

createRootlets you create a root to display React components inside a browser DOM node.

```jsx
const root = createRoot(domNode, options?)
```

- ReferencecreateRoot(domNode, options?)root.render(reactNode)root.unmount()
- createRoot(domNode, options?)
- root.render(reactNode)
- root.unmount()
- UsageRendering an app fully built with ReactRendering a page partially built with ReactUpdating a root componentError logging in production
- Rendering an app fully built with React
- Rendering a page partially built with React
- Updating a root component
- Error logging in production
- TroubleshootingI’ve created a root, but nothing is displayedI’m getting an error: “You passed a second argument to root.render”I’m getting an error: “Target container is not a DOM element”I’m getting an error: “Functions are not valid as a React child.”My server-rendered HTML gets re-created from scratch
- I’ve created a root, but nothing is displayed
- I’m getting an error: “You passed a second argument to root.render”
- I’m getting an error: “Target container is not a DOM element”
- I’m getting an error: “Functions are not valid as a React child.”
- My server-rendered HTML gets re-created from scratch

## Reference

### createRoot(domNode, options?)
CallcreateRootto create a React root for displaying content inside a browser DOM element.

```jsx
import { createRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = createRoot(domNode);
```

React will create a root for thedomNode, and take over managing the DOM inside it. After you’ve created a root, you need to callroot.renderto display a React component inside of it:

```jsx
root.render(<App />);
```

An app fully built with React will usually only have onecreateRootcall for its root component. A page that uses “sprinkles” of React for parts of the page may have as many separate roots as needed.

See more examples below.


#### Parameters
- domNode: ADOM element.React will create a root for this DOM element and allow you to call functions on the root, such asrenderto display rendered React content.
domNode: ADOM element.React will create a root for this DOM element and allow you to call functions on the root, such asrenderto display rendered React content.

- optionaloptions: An object with options for this React root.optionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.optionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown, and anerrorInfoobject containing thecomponentStack.optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with anerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.
optionaloptions: An object with options for this React root.

- optionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.
- optionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown, and anerrorInfoobject containing thecomponentStack.
- optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with anerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.

#### Returns
createRootreturns an object with two methods:renderandunmount.


#### Caveats
- If your app is server-rendered, usingcreateRoot()is not supported. UsehydrateRoot()instead.
- You’ll likely have only onecreateRootcall in your app. If you use a framework, it might do this call for you.
- When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), usecreatePortalinstead ofcreateRoot.

### root.render(reactNode)
Callroot.renderto display a piece ofJSX(“React node”) into the React root’s browser DOM node.

```jsx
root.render(<App />);
```

React will display<App />in theroot, and take over managing the DOM inside it.

See more examples below.


#### Parameters
- reactNode: AReact nodethat you want to display. This will usually be a piece of JSX like<App />, but you can also pass a React element constructed withcreateElement(), a string, a number,null, orundefined.

#### Returns
root.renderreturnsundefined.


#### Caveats
- The first time you callroot.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.
The first time you callroot.render, React will clear all the existing HTML content inside the React root before rendering the React component into it.

- If your root’s DOM node contains HTML generated by React on the server or during the build, usehydrateRoot()instead, which attaches the event handlers to the existing HTML.
If your root’s DOM node contains HTML generated by React on the server or during the build, usehydrateRoot()instead, which attaches the event handlers to the existing HTML.

- If you callrenderon the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by“matching it up”with the previously rendered tree. Callingrenderon the same root again is similar to calling thesetfunctionon the root component: React avoids unnecessary DOM updates.
If you callrenderon the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by“matching it up”with the previously rendered tree. Callingrenderon the same root again is similar to calling thesetfunctionon the root component: React avoids unnecessary DOM updates.

- Although rendering is synchronous once it starts,root.render(...)is not. This means code afterroot.render()may run before any effects (useLayoutEffect,useEffect) of that specific render are fired. This is usually fine and rarely needs adjustment. In rare cases where effect timing matters, you can wraproot.render(...)influshSyncto ensure the initial render runs fully synchronously.constroot=createRoot(document.getElementById('root'));root.render(<App/>);// 🚩 The HTML will not include the rendered <App /> yet:console.log(document.body.innerHTML);
Although rendering is synchronous once it starts,root.render(...)is not. This means code afterroot.render()may run before any effects (useLayoutEffect,useEffect) of that specific render are fired. This is usually fine and rarely needs adjustment. In rare cases where effect timing matters, you can wraproot.render(...)influshSyncto ensure the initial render runs fully synchronously.

```jsx
const root = createRoot(document.getElementById('root'));root.render(<App />);// 🚩 The HTML will not include the rendered <App /> yet:console.log(document.body.innerHTML);
```


### root.unmount()
Callroot.unmountto destroy a rendered tree inside a React root.

```jsx
root.unmount();
```

An app fully built with React will usually not have any calls toroot.unmount.

This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to “stop” managing the removed root’s content by callingroot.unmount. Otherwise, the components inside the removed root won’t know to clean up and free up global resources like subscriptions.

Callingroot.unmountwill unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.


#### Parameters
root.unmountdoes not accept any parameters.


#### Returns
root.unmountreturnsundefined.


#### Caveats
- Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node.
Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node.

- Once you callroot.unmountyou cannot callroot.renderagain on the same root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.
Once you callroot.unmountyou cannot callroot.renderagain on the same root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.


## Usage

### Rendering an app fully built with React
If your app is fully built with React, create a single root for your entire app.

```jsx
import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(<App />);
```

Usually, you only need to run this code once at startup. It will:

1. Find thebrowser DOM nodedefined in your HTML.
1. Display theReact componentfor your app inside.
```jsx
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root = createRoot(document.getElementById('root'));
root.render(<App />);


```

If your app is fully built with React, you shouldn’t need to create any more roots, or to callroot.renderagain.

From this point on, React will manage the DOM of your entire app. To add more components,nest them inside theAppcomponent.When you need to update the UI, each of your components can do this byusing state.When you need to display extra content like a modal or a tooltip outside the DOM node,render it with a portal.


### Note
When your HTML is empty, the user sees a blank page until the app’s JavaScript code loads and runs:

```jsx
<div id="root"></div>
```

This can feel very slow! To solve this, you can generate the initial HTML from your componentson the server or during the build.Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommendusing a frameworkthat does this optimization out of the box. Depending on when it runs, this is calledserver-side rendering (SSR)orstatic site generation (SSG).


### Pitfall
Apps using server rendering or static generation must callhydrateRootinstead ofcreateRoot.React will thenhydrate(reuse) the DOM nodes from your HTML instead of destroying and re-creating them.


### Rendering a page partially built with React
If your pageisn’t fully built with React, you can callcreateRootmultiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by callingroot.render.

Here, two different React components are rendered into two DOM nodes defined in theindex.htmlfile:

```jsx
import './styles.css';
import { createRoot } from 'react-dom/client';
import { Comments, Navigation } from './Components.js';

const navDomNode = document.getElementById('navigation');
const navRoot = createRoot(navDomNode); 
navRoot.render(<Navigation />);

const commentDomNode = document.getElementById('comments');
const commentRoot = createRoot(commentDomNode); 
commentRoot.render(<Comments />);


```

You could also create a new DOM node withdocument.createElement()and add it to the document manually.

```jsx
const domNode = document.createElement('div');const root = createRoot(domNode); root.render(<Comment />);document.body.appendChild(domNode); // You can add it anywhere in the document
```

To remove the React tree from the DOM node and clean up all the resources used by it, callroot.unmount.

```jsx
root.unmount();
```

This is mostly useful if your React components are inside an app written in a different framework.


### Updating a root component
You can callrendermore than once on the same root. As long as the component tree structure matches up with what was previously rendered, React willpreserve the state.Notice how you can type in the input, which means that the updates from repeatedrendercalls every second in this example are not destructive:

```jsx
import { createRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = createRoot(document.getElementById('root'));

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);


```

It is uncommon to callrendermultiple times. Usually, your components willupdate stateinstead.


### Error logging in production
By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root optionsonUncaughtError,onCaughtErrorandonRecoverableError:

```jsx
import { createRoot } from "react-dom/client";import { reportCaughtError } from "./reportError";const container = document.getElementById("root");const root = createRoot(container, {  onCaughtError: (error, errorInfo) => {    if (error.message !== "Known error") {      reportCaughtError({        error,        componentStack: errorInfo.componentStack,      });    }  },});
```

TheonCaughtErroroption is a function called with two arguments:

1. Theerrorthat was thrown.
1. AnerrorInfoobject that contains thecomponentStackof the error.
Together withonUncaughtErrorandonRecoverableError, you can can implement your own error reporting system:

```jsx
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
const root = createRoot(container, {
  // Keep in mind to remove these options in development to leverage
  // React's default handlers or implement your own overlay for development.
  // The handlers are only specfied unconditionally here for demonstration purposes.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});
root.render(<App />);


```


## Troubleshooting

### I’ve created a root, but nothing is displayed
Make sure you haven’t forgotten to actuallyrenderyour app into the root:

```jsx
import { createRoot } from 'react-dom/client';import App from './App.js';const root = createRoot(document.getElementById('root'));root.render(<App />);
```

Until you do that, nothing is displayed.


### I’m getting an error: “You passed a second argument to root.render”
A common mistake is to pass the options forcreateRoottoroot.render(...):

To fix, pass the root options tocreateRoot(...), notroot.render(...):

```jsx
// 🚩 Wrong: root.render only takes one argument.root.render(App, {onUncaughtError});// ✅ Correct: pass options to createRoot.const root = createRoot(container, {onUncaughtError}); root.render(<App />);
```


### I’m getting an error: “Target container is not a DOM element”
This error means that whatever you’re passing tocreateRootis not a DOM node.

If you’re not sure what’s happening, try logging it:

```jsx
const domNode = document.getElementById('root');console.log(domNode); // ???const root = createRoot(domNode);root.render(<App />);
```

For example, ifdomNodeisnull, it means thatgetElementByIdreturnednull. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:

1. The ID you’re looking for might differ from the ID you used in the HTML file. Check for typos!
1. Your bundle’s<script>tag cannot “see” any DOM nodes that appearafterit in the HTML.
Another common way to get this error is to writecreateRoot(<App />)instead ofcreateRoot(domNode).


### I’m getting an error: “Functions are not valid as a React child.”
This error means that whatever you’re passing toroot.renderis not a React component.

This may happen if you callroot.renderwithComponentinstead of<Component />:

```jsx
// 🚩 Wrong: App is a function, not a Component.root.render(App);// ✅ Correct: <App /> is a component.root.render(<App />);
```

Or if you pass a function toroot.render, instead of the result of calling it:

```jsx
// 🚩 Wrong: createApp is a function, not a component.root.render(createApp);// ✅ Correct: call createApp to return a component.root.render(createApp());
```


### My server-rendered HTML gets re-created from scratch
If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and callingroot.renderdeletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.

Server-rendered apps must usehydrateRootinstead ofcreateRoot:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(  document.getElementById('root'),  <App />);
```

Note that its API is different. In particular, usually there will be no furtherroot.rendercall.


--------------------------------------------------------------------------------


# hydrateRoot
Source: https://react.dev/reference/react-dom/client/hydrateRoot

hydrateRootlets you display React components inside a browser DOM node whose HTML content was previously generated byreact-dom/server.

```jsx
const root = hydrateRoot(domNode, reactNode, options?)
```

- ReferencehydrateRoot(domNode, reactNode, options?)root.render(reactNode)root.unmount()
- hydrateRoot(domNode, reactNode, options?)
- root.render(reactNode)
- root.unmount()
- UsageHydrating server-rendered HTMLHydrating an entire documentSuppressing unavoidable hydration mismatch errorsHandling different client and server contentUpdating a hydrated root componentError logging in production
- Hydrating server-rendered HTML
- Hydrating an entire document
- Suppressing unavoidable hydration mismatch errors
- Handling different client and server content
- Updating a hydrated root component
- Error logging in production
- TroubleshootingI’m getting an error: “You passed a second argument to root.render”
- I’m getting an error: “You passed a second argument to root.render”

## Reference

### hydrateRoot(domNode, reactNode, options?)
CallhydrateRootto “attach” React to existing HTML that was already rendered by React in a server environment.

```jsx
import { hydrateRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = hydrateRoot(domNode, reactNode);
```

React will attach to the HTML that exists inside thedomNode, and take over managing the DOM inside it. An app fully built with React will usually only have onehydrateRootcall with its root component.

See more examples below.


#### Parameters
- domNode: ADOM elementthat was rendered as the root element on the server.
domNode: ADOM elementthat was rendered as the root element on the server.

- reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like<App />which was rendered with aReactDOM Servermethod such asrenderToPipeableStream(<App />).
reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like<App />which was rendered with aReactDOM Servermethod such asrenderToPipeableStream(<App />).

- optionaloptions: An object with options for this React root.optionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.optionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown and anerrorInfoobject containing thecomponentStack.optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with theerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.
optionaloptions: An object with options for this React root.

- optionalonCaughtError: Callback called when React catches an error in an Error Boundary. Called with theerrorcaught by the Error Boundary, and anerrorInfoobject containing thecomponentStack.
- optionalonUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with theerrorthat was thrown and anerrorInfoobject containing thecomponentStack.
- optionalonRecoverableError: Callback called when React automatically recovers from errors. Called with theerrorReact throws, and anerrorInfoobject containing thecomponentStack. Some recoverable errors may include the original error cause aserror.cause.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.

#### Returns
hydrateRootreturns an object with two methods:renderandunmount.


#### Caveats
- hydrateRoot()expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.
- In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
- You’ll likely have only onehydrateRootcall in your app. If you use a framework, it might do this call for you.
- If your app is client-rendered with no HTML rendered already, usinghydrateRoot()is not supported. UsecreateRoot()instead.

### root.render(reactNode)
Callroot.renderto update a React component inside a hydrated React root for a browser DOM element.

```jsx
root.render(<App />);
```

React will update<App />in the hydratedroot.

See more examples below.


#### Parameters
- reactNode: A “React node” that you want to update. This will usually be a piece of JSX like<App />, but you can also pass a React element constructed withcreateElement(), a string, a number,null, orundefined.

#### Returns
root.renderreturnsundefined.


#### Caveats
- If you callroot.renderbefore the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

### root.unmount()
Callroot.unmountto destroy a rendered tree inside a React root.

```jsx
root.unmount();
```

An app fully built with React will usually not have any calls toroot.unmount.

This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by callingroot.unmount. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions.

Callingroot.unmountwill unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.


#### Parameters
root.unmountdoes not accept any parameters.


#### Returns
root.unmountreturnsundefined.


#### Caveats
- Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node.
Callingroot.unmountwill unmount all the components in the tree and “detach” React from the root DOM node.

- Once you callroot.unmountyou cannot callroot.renderagain on the root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error.
Once you callroot.unmountyou cannot callroot.renderagain on the root. Attempting to callroot.renderon an unmounted root will throw a “Cannot update an unmounted root” error.


## Usage

### Hydrating server-rendered HTML
If your app’s HTML was generated byreact-dom/server, you need tohydrateit on the client.

```jsx
import { hydrateRoot } from 'react-dom/client';hydrateRoot(document.getElementById('root'), <App />);
```

This will hydrate the server HTML inside thebrowser DOM nodewith theReact componentfor your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.

To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.

```jsx
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
  document.getElementById('root'),
  <App />
);


```

You shouldn’t need to callhydrateRootagain or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components willuse stateinstead.


### Pitfall
The React tree you pass tohydrateRootneeds to producethe same outputas it did on the server.

This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.

The most common causes leading to hydration errors include:

- Extra whitespace (like newlines) around the React-generated HTML inside the root node.
- Using checks liketypeof window !== 'undefined'in your rendering logic.
- Using browser-only APIs likewindow.matchMediain your rendering logic.
- Rendering different data on the server and the client.
React recovers from some hydration errors, butyou must fix them like other bugs.In the best case, they’ll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.


### Hydrating an entire document
Apps fully built with React can render the entire document as JSX, including the<html>tag:

```jsx
function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

To hydrate the entire document, pass thedocumentglobal as the first argument tohydrateRoot:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```


### Suppressing unavoidable hydration mismatch errors
If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.

To silence hydration warnings on an element, addsuppressHydrationWarning={true}:

```jsx
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}


```

This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. React willnotattempt to patch mismatched text content.


### Handling different client and server content
If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read astate variablelikeisClient, which you can set totruein anEffect:

```jsx
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <h1>
      {isClient ? 'Is Client' : 'Is Server'}
    </h1>
  );
}


```

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.


### Pitfall
This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.


### Updating a hydrated root component
After the root has finished hydrating, you can callroot.renderto update the root React component.Unlike withcreateRoot, you don’t usually need to do this because the initial content was already rendered as HTML.

If you callroot.renderat some point after hydration, and the component tree structure matches up with what was previously rendered, React willpreserve the state.Notice how you can type in the input, which means that the updates from repeatedrendercalls every second in this example are not destructive:

```jsx
import { hydrateRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
  document.getElementById('root'),
  <App counter={0} />
);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);


```

It is uncommon to callroot.renderon a hydrated root. Usually, you’llupdate stateinside one of the components instead.


### Error logging in production
By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root optionsonUncaughtError,onCaughtErrorandonRecoverableError:

```jsx
import { hydrateRoot } from "react-dom/client";import App from "./App.js";import { reportCaughtError } from "./reportError";const container = document.getElementById("root");const root = hydrateRoot(container, <App />, {  onCaughtError: (error, errorInfo) => {    if (error.message !== "Known error") {      reportCaughtError({        error,        componentStack: errorInfo.componentStack,      });    }  },});
```

TheonCaughtErroroption is a function called with two arguments:

1. Theerrorthat was thrown.
1. AnerrorInfoobject that contains thecomponentStackof the error.
Together withonUncaughtErrorandonRecoverableError, you can implement your own error reporting system:

```jsx
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
hydrateRoot(container, <App />, {
  // Keep in mind to remove these options in development to leverage
  // React's default handlers or implement your own overlay for development.
  // The handlers are only specfied unconditionally here for demonstration purposes.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});


```


## Troubleshooting

### I’m getting an error: “You passed a second argument to root.render”
A common mistake is to pass the options forhydrateRoottoroot.render(...):

To fix, pass the root options tohydrateRoot(...), notroot.render(...):

```jsx
// 🚩 Wrong: root.render only takes one argument.root.render(App, {onUncaughtError});// ✅ Correct: pass options to createRoot.const root = hydrateRoot(container, <App />, {onUncaughtError});
```


--------------------------------------------------------------------------------


# React DOM Components
Source: https://react.dev/reference/react-dom/components

React supports all of the browser built-inHTMLandSVGcomponents.


## Common components
All of the built-in browser components support some props and events.

- Common components (e.g.<div>)
This includes React-specific props likerefanddangerouslySetInnerHTML.


## Form components
These built-in browser components accept user input:

- <input>
- <select>
- <textarea>
They are special in React because passing thevalueprop to them makes themcontrolled.


## Resource and Metadata Components
These built-in browser components let you load external resources or annotate the document with metadata:

- <link>
- <meta>
- <script>
- <style>
- <title>
They are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component.


## All HTML components
React supports all built-in browser HTML components. This includes:

- <aside>
- <audio>
- <b>
- <base>
- <bdi>
- <bdo>
- <blockquote>
- <body>
- <br>
- <button>
- <canvas>
- <caption>
- <cite>
- <code>
- <col>
- <colgroup>
- <data>
- <datalist>
- <dd>
- <del>
- <details>
- <dfn>
- <dialog>
- <div>
- <dl>
- <dt>
- <em>
- <embed>
- <fieldset>
- <figcaption>
- <figure>
- <footer>
- <form>
- <h1>
- <head>
- <header>
- <hgroup>
- <hr>
- <html>
- <i>
- <iframe>
- <img>
- <input>
- <ins>
- <kbd>
- <label>
- <legend>
- <li>
- <link>
- <main>
- <map>
- <mark>
- <menu>
- <meta>
- <meter>
- <nav>
- <noscript>
- <object>
- <ol>
- <optgroup>
- <option>
- <output>
- <p>
- <picture>
- <pre>
- <progress>
- <q>
- <rp>
- <rt>
- <ruby>
- <s>
- <samp>
- <script>
- <section>
- <select>
- <slot>
- <small>
- <source>
- <span>
- <strong>
- <style>
- <sub>
- <summary>
- <sup>
- <table>
- <tbody>
- <td>
- <template>
- <textarea>
- <tfoot>
- <th>
- <thead>
- <time>
- <title>
- <tr>
- <track>
- <u>
- <ul>
- <var>
- <video>
- <wbr>

### Note
Similar to theDOM standard,React uses acamelCaseconvention for prop names. For example, you’ll writetabIndexinstead oftabindex. You can convert existing HTML to JSX with anonline converter.


### Custom HTML elements
If you render a tag with a dash, like<my-element>, React will assume you want to render acustom HTML element.

If you render a built-in browser HTML element with anisattribute, it will also be treated as a custom element.


#### Setting values on custom elements
Custom elements have two methods of passing data into them:

1. Attributes: Which are displayed in markup and can only be set to string values
1. Properties: Which are not displayed in markup and can be set to arbitrary JavaScript values
By default, React will pass values bound in JSX as attributes:

```jsx
<my-element value="Hello, world!"></my-element>
```

Non-string JavaScript values passed to custom elements will be serialized by default:

```jsx
// Will be passed as `"1,2,3"` as the output of `[1,2,3].toString()`<my-element value={[1,2,3]}></my-element>
```

React will, however, recognize an custom element’s property as one that it may pass arbitrary values to if the property name shows up on the class during construction:

```jsx
export class MyElement extends HTMLElement {
  constructor() {
    super();
    // The value here will be overwritten by React 
    // when initialized as an element
    this.value = undefined;
  }

  connectedCallback() {
    this.innerHTML = this.value.join(", ");
  }
}


```


#### Listening for events on custom elements
A common pattern when using custom elements is that they may dispatchCustomEventsrather than accept a function to call when an event occur. You can listen for these events using anonprefix when binding to the event via JSX.

```jsx
export function App() {
  return (
    <my-element
      onspeak={e => console.log(e.detail.message)}
    ></my-element>
  )
}


```


### Note
Events are case-sensitive and support dashes (-). Preserve the casing of the event and include all dashes when listening for custom element’s events:

```jsx
// Listens for `say-hi` events<my-element onsay-hi={console.log}></my-element>// Listens for `sayHi` events<my-element onsayHi={console.log}></my-element>
```


## All SVG components
React supports all built-in browser SVG components. This includes:

- <a>
- <animate>
- <animateMotion>
- <animateTransform>
- <circle>
- <clipPath>
- <defs>
- <desc>
- <discard>
- <ellipse>
- <feBlend>
- <feColorMatrix>
- <feComponentTransfer>
- <feComposite>
- <feConvolveMatrix>
- <feDiffuseLighting>
- <feDisplacementMap>
- <feDistantLight>
- <feDropShadow>
- <feFlood>
- <feFuncA>
- <feFuncB>
- <feFuncG>
- <feFuncR>
- <feGaussianBlur>
- <feImage>
- <feMerge>
- <feMergeNode>
- <feMorphology>
- <feOffset>
- <fePointLight>
- <feSpecularLighting>
- <feSpotLight>
- <feTile>
- <feTurbulence>
- <filter>
- <foreignObject>
- <g>
- <hatch>
- <hatchpath>
- <image>
- <line>
- <linearGradient>
- <marker>
- <mask>
- <metadata>
- <mpath>
- <path>
- <pattern>
- <polygon>
- <polyline>
- <radialGradient>
- <rect>
- <script>
- <set>
- <stop>
- <style>
- <svg>
- <switch>
- <symbol>
- <text>
- <textPath>
- <title>
- <tspan>
- <use>
- <view>

### Note
Similar to theDOM standard,React uses acamelCaseconvention for prop names. For example, you’ll writetabIndexinstead oftabindex. You can convert existing SVG to JSX with anonline converter.

Namespaced attributes also have to be written without the colon:

- xlink:actuatebecomesxlinkActuate.
- xlink:arcrolebecomesxlinkArcrole.
- xlink:hrefbecomesxlinkHref.
- xlink:rolebecomesxlinkRole.
- xlink:showbecomesxlinkShow.
- xlink:titlebecomesxlinkTitle.
- xlink:typebecomesxlinkType.
- xml:basebecomesxmlBase.
- xml:langbecomesxmlLang.
- xml:spacebecomesxmlSpace.
- xmlns:xlinkbecomesxmlnsXlink.

--------------------------------------------------------------------------------


# Common components (e.g. <div>)
Source: https://react.dev/reference/react-dom/components/common

All built-in browser components, such as<div>, support some common props and events.

- ReferenceCommon components (e.g.<div>)refcallback functionReact event objectAnimationEventhandler functionClipboardEventhandler functionCompositionEventhandler functionDragEventhandler functionFocusEventhandler functionEventhandler functionInputEventhandler functionKeyboardEventhandler functionMouseEventhandler functionPointerEventhandler functionTouchEventhandler functionTransitionEventhandler functionUIEventhandler functionWheelEventhandler function
- Common components (e.g.<div>)
- refcallback function
- React event object
- AnimationEventhandler function
- ClipboardEventhandler function
- CompositionEventhandler function
- DragEventhandler function
- FocusEventhandler function
- Eventhandler function
- InputEventhandler function
- KeyboardEventhandler function
- MouseEventhandler function
- PointerEventhandler function
- TouchEventhandler function
- TransitionEventhandler function
- UIEventhandler function
- WheelEventhandler function
- UsageApplying CSS stylesManipulating a DOM node with a refDangerously setting the inner HTMLHandling mouse eventsHandling pointer eventsHandling focus eventsHandling keyboard events
- Applying CSS styles
- Manipulating a DOM node with a ref
- Dangerously setting the inner HTML
- Handling mouse events
- Handling pointer events
- Handling focus events
- Handling keyboard events

## Reference

### Common components (e.g.<div>)
```jsx
<div className="wrapper">Some content</div>
```

See more examples below.


#### Props
These special React props are supported for all built-in components:

- children: A React node (an element, a string, a number,a portal,an empty node likenull,undefinedand booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify thechildrenprop implicitly by nesting tags like<div><span /></div>.
children: A React node (an element, a string, a number,a portal,an empty node likenull,undefinedand booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify thechildrenprop implicitly by nesting tags like<div><span /></div>.

- dangerouslySetInnerHTML: An object of the form{ __html: '<p>some html</p>' }with a raw HTML string inside. Overrides theinnerHTMLproperty of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing anXSSvulnerability.Read more about usingdangerouslySetInnerHTML.
dangerouslySetInnerHTML: An object of the form{ __html: '<p>some html</p>' }with a raw HTML string inside. Overrides theinnerHTMLproperty of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing anXSSvulnerability.Read more about usingdangerouslySetInnerHTML.

- ref: A ref object fromuseReforcreateRef, or arefcallback function,or a string forlegacy refs.Your ref will be filled with the DOM element for this node.Read more about manipulating the DOM with refs.
ref: A ref object fromuseReforcreateRef, or arefcallback function,or a string forlegacy refs.Your ref will be filled with the DOM element for this node.Read more about manipulating the DOM with refs.

- suppressContentEditableWarning: A boolean. Iftrue, suppresses the warning that React shows for elements that both havechildrenandcontentEditable={true}(which normally do not work together). Use this if you’re building a text input library that manages thecontentEditablecontent manually.
suppressContentEditableWarning: A boolean. Iftrue, suppresses the warning that React shows for elements that both havechildrenandcontentEditable={true}(which normally do not work together). Use this if you’re building a text input library that manages thecontentEditablecontent manually.

- suppressHydrationWarning: A boolean. If you useserver rendering,normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you setsuppressHydrationWarningtotrue, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it.Read about suppressing hydration errors.
suppressHydrationWarning: A boolean. If you useserver rendering,normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you setsuppressHydrationWarningtotrue, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it.Read about suppressing hydration errors.

- style: An object with CSS styles, for example{ fontWeight: 'bold', margin: 20 }. Similarly to the DOMstyleproperty, the CSS property names need to be written ascamelCase, for examplefontWeightinstead offont-weight. You can pass strings or numbers as values. If you pass a number, likewidth: 100, React will automatically appendpx(“pixels”) to the value unless it’s aunitless property.We recommend usingstyleonly for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes withclassNameis more efficient.Read more aboutclassNameandstyle.
style: An object with CSS styles, for example{ fontWeight: 'bold', margin: 20 }. Similarly to the DOMstyleproperty, the CSS property names need to be written ascamelCase, for examplefontWeightinstead offont-weight. You can pass strings or numbers as values. If you pass a number, likewidth: 100, React will automatically appendpx(“pixels”) to the value unless it’s aunitless property.We recommend usingstyleonly for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes withclassNameis more efficient.Read more aboutclassNameandstyle.

These standard DOM props are also supported for all built-in components:

- accessKey: A string. Specifies a keyboard shortcut for the element.Not generally recommended.
- aria-*: ARIA attributes let you specify the accessibility tree information for this element. SeeARIA attributesfor a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.
- autoCapitalize: A string. Specifies whether and how the user input should be capitalized.
- className: A string. Specifies the element’s CSS class name.Read more about applying CSS styles.
- contentEditable: A boolean. Iftrue, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries likeLexical.React warns if you try to pass React children to an element withcontentEditable={true}because React will not be able to update its content after user edits.
- data-*: Data attributes let you attach some string data to the element, for exampledata-fruit="banana". In React, they are not commonly used because you would usually read data from props or state instead.
- dir: Either'ltr'or'rtl'. Specifies the text direction of the element.
- draggable: A boolean. Specifies whether the element is draggable. Part ofHTML Drag and Drop API.
- enterKeyHint: A string. Specifies which action to present for the enter key on virtual keyboards.
- htmlFor: A string. For<label>and<output>, lets youassociate the label with some control.Same asforHTML attribute.React uses the standard DOM property names (htmlFor) instead of HTML attribute names.
- hidden: A boolean or a string. Specifies whether the element should be hidden.
- id: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it withuseIdto avoid clashes between multiple instances of the same component.
- is: A string. If specified, the component will behave like acustom element.
- inputMode: A string. Specifies what kind of keyboard to display (for example, text, number or telephone).
- itemProp: A string. Specifies which property the element represents for structured data crawlers.
- lang: A string. Specifies the language of the element.
- onAnimationEnd: AnAnimationEventhandlerfunction. Fires when a CSS animation completes.
- onAnimationEndCapture: A version ofonAnimationEndthat fires in thecapture phase.
- onAnimationIteration: AnAnimationEventhandlerfunction. Fires when an iteration of a CSS animation ends, and another one begins.
- onAnimationIterationCapture: A version ofonAnimationIterationthat fires in thecapture phase.
- onAnimationStart: AnAnimationEventhandlerfunction. Fires when a CSS animation starts.
- onAnimationStartCapture:onAnimationStart, but fires in thecapture phase.
- onAuxClick: AMouseEventhandlerfunction. Fires when a non-primary pointer button was clicked.
- onAuxClickCapture: A version ofonAuxClickthat fires in thecapture phase.
- onBeforeInput: AnInputEventhandlerfunction. Fires before the value of an editable element is modified. React doesnotyet use the nativebeforeinputevent, and instead attempts to polyfill it using other events.
- onBeforeInputCapture: A version ofonBeforeInputthat fires in thecapture phase.
- onBlur: AFocusEventhandlerfunction. Fires when an element lost focus. Unlike the built-in browserblurevent, in React theonBlurevent bubbles.
- onBlurCapture: A version ofonBlurthat fires in thecapture phase.
- onClick: AMouseEventhandlerfunction. Fires when the primary button was clicked on the pointing device.
- onClickCapture: A version ofonClickthat fires in thecapture phase.
- onCompositionStart: ACompositionEventhandlerfunction. Fires when aninput method editorstarts a new composition session.
- onCompositionStartCapture: A version ofonCompositionStartthat fires in thecapture phase.
- onCompositionEnd: ACompositionEventhandlerfunction. Fires when aninput method editorcompletes or cancels a composition session.
- onCompositionEndCapture: A version ofonCompositionEndthat fires in thecapture phase.
- onCompositionUpdate: ACompositionEventhandlerfunction. Fires when aninput method editorreceives a new character.
- onCompositionUpdateCapture: A version ofonCompositionUpdatethat fires in thecapture phase.
- onContextMenu: AMouseEventhandlerfunction. Fires when the user tries to open a context menu.
- onContextMenuCapture: A version ofonContextMenuthat fires in thecapture phase.
- onCopy: AClipboardEventhandlerfunction. Fires when the user tries to copy something into the clipboard.
- onCopyCapture: A version ofonCopythat fires in thecapture phase.
- onCut: AClipboardEventhandlerfunction. Fires when the user tries to cut something into the clipboard.
- onCutCapture: A version ofonCutthat fires in thecapture phase.
- onDoubleClick: AMouseEventhandlerfunction. Fires when the user clicks twice. Corresponds to the browserdblclickevent.
- onDoubleClickCapture: A version ofonDoubleClickthat fires in thecapture phase.
- onDrag: ADragEventhandlerfunction. Fires while the user is dragging something.
- onDragCapture: A version ofonDragthat fires in thecapture phase.
- onDragEnd: ADragEventhandlerfunction. Fires when the user stops dragging something.
- onDragEndCapture: A version ofonDragEndthat fires in thecapture phase.
- onDragEnter: ADragEventhandlerfunction. Fires when the dragged content enters a valid drop target.
- onDragEnterCapture: A version ofonDragEnterthat fires in thecapture phase.
- onDragOver: ADragEventhandlerfunction. Fires on a valid drop target while the dragged content is dragged over it. You must calle.preventDefault()here to allow dropping.
- onDragOverCapture: A version ofonDragOverthat fires in thecapture phase.
- onDragStart: ADragEventhandlerfunction. Fires when the user starts dragging an element.
- onDragStartCapture: A version ofonDragStartthat fires in thecapture phase.
- onDrop: ADragEventhandlerfunction. Fires when something is dropped on a valid drop target.
- onDropCapture: A version ofonDropthat fires in thecapture phase.
- onFocus: AFocusEventhandlerfunction. Fires when an element receives focus. Unlike the built-in browserfocusevent, in React theonFocusevent bubbles.
- onFocusCapture: A version ofonFocusthat fires in thecapture phase.
- onGotPointerCapture: APointerEventhandlerfunction. Fires when an element programmatically captures a pointer.
- onGotPointerCaptureCapture: A version ofonGotPointerCapturethat fires in thecapture phase.
- onKeyDown: AKeyboardEventhandlerfunction. Fires when a key is pressed.
- onKeyDownCapture: A version ofonKeyDownthat fires in thecapture phase.
- onKeyPress: AKeyboardEventhandlerfunction. Deprecated. UseonKeyDownoronBeforeInputinstead.
- onKeyPressCapture: A version ofonKeyPressthat fires in thecapture phase.
- onKeyUp: AKeyboardEventhandlerfunction. Fires when a key is released.
- onKeyUpCapture: A version ofonKeyUpthat fires in thecapture phase.
- onLostPointerCapture: APointerEventhandlerfunction. Fires when an element stops capturing a pointer.
- onLostPointerCaptureCapture: A version ofonLostPointerCapturethat fires in thecapture phase.
- onMouseDown: AMouseEventhandlerfunction. Fires when the pointer is pressed down.
- onMouseDownCapture: A version ofonMouseDownthat fires in thecapture phase.
- onMouseEnter: AMouseEventhandlerfunction. Fires when the pointer moves inside an element. Does not have a capture phase. Instead,onMouseLeaveandonMouseEnterpropagate from the element being left to the one being entered.
- onMouseLeave: AMouseEventhandlerfunction. Fires when the pointer moves outside an element. Does not have a capture phase. Instead,onMouseLeaveandonMouseEnterpropagate from the element being left to the one being entered.
- onMouseMove: AMouseEventhandlerfunction. Fires when the pointer changes coordinates.
- onMouseMoveCapture: A version ofonMouseMovethat fires in thecapture phase.
- onMouseOut: AMouseEventhandlerfunction. Fires when the pointer moves outside an element, or if it moves into a child element.
- onMouseOutCapture: A version ofonMouseOutthat fires in thecapture phase.
- onMouseUp: AMouseEventhandlerfunction. Fires when the pointer is released.
- onMouseUpCapture: A version ofonMouseUpthat fires in thecapture phase.
- onPointerCancel: APointerEventhandlerfunction. Fires when the browser cancels a pointer interaction.
- onPointerCancelCapture: A version ofonPointerCancelthat fires in thecapture phase.
- onPointerDown: APointerEventhandlerfunction. Fires when a pointer becomes active.
- onPointerDownCapture: A version ofonPointerDownthat fires in thecapture phase.
- onPointerEnter: APointerEventhandlerfunction. Fires when a pointer moves inside an element. Does not have a capture phase. Instead,onPointerLeaveandonPointerEnterpropagate from the element being left to the one being entered.
- onPointerLeave: APointerEventhandlerfunction. Fires when a pointer moves outside an element. Does not have a capture phase. Instead,onPointerLeaveandonPointerEnterpropagate from the element being left to the one being entered.
- onPointerMove: APointerEventhandlerfunction. Fires when a pointer changes coordinates.
- onPointerMoveCapture: A version ofonPointerMovethat fires in thecapture phase.
- onPointerOut: APointerEventhandlerfunction. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, anda few other reasons.
- onPointerOutCapture: A version ofonPointerOutthat fires in thecapture phase.
- onPointerUp: APointerEventhandlerfunction. Fires when a pointer is no longer active.
- onPointerUpCapture: A version ofonPointerUpthat fires in thecapture phase.
- onPaste: AClipboardEventhandlerfunction. Fires when the user tries to paste something from the clipboard.
- onPasteCapture: A version ofonPastethat fires in thecapture phase.
- onScroll: AnEventhandlerfunction. Fires when an element has been scrolled. This event does not bubble.
- onScrollCapture: A version ofonScrollthat fires in thecapture phase.
- onSelect: AnEventhandlerfunction. Fires after the selection inside an editable element like an input changes. React extends theonSelectevent to work forcontentEditable={true}elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).
- onSelectCapture: A version ofonSelectthat fires in thecapture phase.
- onTouchCancel: ATouchEventhandlerfunction. Fires when the browser cancels a touch interaction.
- onTouchCancelCapture: A version ofonTouchCancelthat fires in thecapture phase.
- onTouchEnd: ATouchEventhandlerfunction. Fires when one or more touch points are removed.
- onTouchEndCapture: A version ofonTouchEndthat fires in thecapture phase.
- onTouchMove: ATouchEventhandlerfunction. Fires one or more touch points are moved.
- onTouchMoveCapture: A version ofonTouchMovethat fires in thecapture phase.
- onTouchStart: ATouchEventhandlerfunction. Fires when one or more touch points are placed.
- onTouchStartCapture: A version ofonTouchStartthat fires in thecapture phase.
- onTransitionEnd: ATransitionEventhandlerfunction. Fires when a CSS transition completes.
- onTransitionEndCapture: A version ofonTransitionEndthat fires in thecapture phase.
- onWheel: AWheelEventhandlerfunction. Fires when the user rotates a wheel button.
- onWheelCapture: A version ofonWheelthat fires in thecapture phase.
- role: A string. Specifies the element role explicitly for assistive technologies.
- slot: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example<Layout left={<Sidebar />} right={<Content />} />.
- spellCheck: A boolean or null. If explicitly set totrueorfalse, enables or disables spellchecking.
- tabIndex: A number. Overrides the default Tab button behavior.Avoid using values other than-1and0.
- title: A string. Specifies the tooltip text for the element.
- translate: Either'yes'or'no'. Passing'no'excludes the element content from being translated.
You can also pass custom attributes as props, for examplemycustomprop="someValue". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start withon. The value will be converted to a string. If you passnullorundefined, the custom attribute will be removed.

These events fire only for the<form>elements:

- onReset: AnEventhandlerfunction. Fires when a form gets reset.
- onResetCapture: A version ofonResetthat fires in thecapture phase.
- onSubmit: AnEventhandlerfunction. Fires when a form gets submitted.
- onSubmitCapture: A version ofonSubmitthat fires in thecapture phase.
These events fire only for the<dialog>elements. Unlike browser events, they bubble in React:

- onCancel: AnEventhandlerfunction. Fires when the user tries to dismiss the dialog.
- onCancelCapture: A version ofonCancelthat fires in thecapture phase.
- onClose: AnEventhandlerfunction. Fires when a dialog has been closed.
- onCloseCapture: A version ofonClosethat fires in thecapture phase.
These events fire only for the<details>elements. Unlike browser events, they bubble in React:

- onToggle: AnEventhandlerfunction. Fires when the user toggles the details.
- onToggleCapture: A version ofonTogglethat fires in thecapture phase.
These events fire for<img>,<iframe>,<object>,<embed>,<link>, andSVG<image>elements. Unlike browser events, they bubble in React:

- onLoad: AnEventhandlerfunction. Fires when the resource has loaded.
- onLoadCapture: A version ofonLoadthat fires in thecapture phase.
- onError: AnEventhandlerfunction. Fires when the resource could not be loaded.
- onErrorCapture: A version ofonErrorthat fires in thecapture phase.
These events fire for resources like<audio>and<video>. Unlike browser events, they bubble in React:

- onAbort: AnEventhandlerfunction. Fires when the resource has not fully loaded, but not due to an error.
- onAbortCapture: A version ofonAbortthat fires in thecapture phase.
- onCanPlay: AnEventhandlerfunction. Fires when there’s enough data to start playing, but not enough to play to the end without buffering.
- onCanPlayCapture: A version ofonCanPlaythat fires in thecapture phase.
- onCanPlayThrough: AnEventhandlerfunction. Fires when there’s enough data that it’s likely possible to start playing without buffering until the end.
- onCanPlayThroughCapture: A version ofonCanPlayThroughthat fires in thecapture phase.
- onDurationChange: AnEventhandlerfunction. Fires when the media duration has updated.
- onDurationChangeCapture: A version ofonDurationChangethat fires in thecapture phase.
- onEmptied: AnEventhandlerfunction. Fires when the media has become empty.
- onEmptiedCapture: A version ofonEmptiedthat fires in thecapture phase.
- onEncrypted: AnEventhandlerfunction. Fires when the browser encounters encrypted media.
- onEncryptedCapture: A version ofonEncryptedthat fires in thecapture phase.
- onEnded: AnEventhandlerfunction. Fires when the playback stops because there’s nothing left to play.
- onEndedCapture: A version ofonEndedthat fires in thecapture phase.
- onError: AnEventhandlerfunction. Fires when the resource could not be loaded.
- onErrorCapture: A version ofonErrorthat fires in thecapture phase.
- onLoadedData: AnEventhandlerfunction. Fires when the current playback frame has loaded.
- onLoadedDataCapture: A version ofonLoadedDatathat fires in thecapture phase.
- onLoadedMetadata: AnEventhandlerfunction. Fires when metadata has loaded.
- onLoadedMetadataCapture: A version ofonLoadedMetadatathat fires in thecapture phase.
- onLoadStart: AnEventhandlerfunction. Fires when the browser started loading the resource.
- onLoadStartCapture: A version ofonLoadStartthat fires in thecapture phase.
- onPause: AnEventhandlerfunction. Fires when the media was paused.
- onPauseCapture: A version ofonPausethat fires in thecapture phase.
- onPlay: AnEventhandlerfunction. Fires when the media is no longer paused.
- onPlayCapture: A version ofonPlaythat fires in thecapture phase.
- onPlaying: AnEventhandlerfunction. Fires when the media starts or restarts playing.
- onPlayingCapture: A version ofonPlayingthat fires in thecapture phase.
- onProgress: AnEventhandlerfunction. Fires periodically while the resource is loading.
- onProgressCapture: A version ofonProgressthat fires in thecapture phase.
- onRateChange: AnEventhandlerfunction. Fires when playback rate changes.
- onRateChangeCapture: A version ofonRateChangethat fires in thecapture phase.
- onResize: AnEventhandlerfunction. Fires when video changes size.
- onResizeCapture: A version ofonResizethat fires in thecapture phase.
- onSeeked: AnEventhandlerfunction. Fires when a seek operation completes.
- onSeekedCapture: A version ofonSeekedthat fires in thecapture phase.
- onSeeking: AnEventhandlerfunction. Fires when a seek operation starts.
- onSeekingCapture: A version ofonSeekingthat fires in thecapture phase.
- onStalled: AnEventhandlerfunction. Fires when the browser is waiting for data but it keeps not loading.
- onStalledCapture: A version ofonStalledthat fires in thecapture phase.
- onSuspend: AnEventhandlerfunction. Fires when loading the resource was suspended.
- onSuspendCapture: A version ofonSuspendthat fires in thecapture phase.
- onTimeUpdate: AnEventhandlerfunction. Fires when the current playback time updates.
- onTimeUpdateCapture: A version ofonTimeUpdatethat fires in thecapture phase.
- onVolumeChange: AnEventhandlerfunction. Fires when the volume has changed.
- onVolumeChangeCapture: A version ofonVolumeChangethat fires in thecapture phase.
- onWaiting: AnEventhandlerfunction. Fires when the playback stopped due to temporary lack of data.
- onWaitingCapture: A version ofonWaitingthat fires in thecapture phase.

#### Caveats
- You cannot pass bothchildrenanddangerouslySetInnerHTMLat the same time.
- Some events (likeonAbortandonLoad) don’t bubble in the browser, but bubble in React.

### refcallback function
Instead of a ref object (like the one returned byuseRef), you may pass a function to therefattribute.

```jsx
<div ref={(node) => {  console.log('Attached', node);  return () => {    console.log('Clean up', node)  }}}>
```

See an example of using therefcallback.

When the<div>DOM node is added to the screen, React will call yourrefcallback with the DOMnodeas the argument. When that<div>DOM node is removed, React will call your the cleanup function returned from the callback.

React will also call yourrefcallback whenever you pass adifferentrefcallback. In the above example,(node) => { ... }is a different function on every render. When your component re-renders, thepreviousfunction will be called withnullas the argument, and thenextfunction will be called with the DOM node.


#### Parameters
- node: A DOM node. React will pass you the DOM node when the ref gets attached. Unless you pass the same function reference for therefcallback on every render, the callback will get temporarily cleanup and re-create during every re-render of the component.

### Note

#### React 19 added cleanup functions forrefcallbacks.
To support backwards compatibility, if a cleanup function is not returned from therefcallback,nodewill be called withnullwhen therefis detached. This behavior will be removed in a future version.


#### Returns
- optionalcleanup function: When therefis detached, React will call the cleanup function. If a function is not returned by therefcallback, React will call the callback again withnullas the argument when therefgets detached. This behavior will be removed in a future version.

#### Caveats
- When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.
- When you pass adifferentrefcallback, React will call thepreviouscallback’s cleanup function if provided. If no cleanup function is defined, therefcallback will be called withnullas the argument. Thenextfunction will be called with the DOM node.

### React event object
Your event handlers will receive aReact event object.It is also sometimes known as a “synthetic event”.

```jsx
<button onClick={e => {  console.log(e); // React event object}} />
```

It conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.

Some React events do not map directly to the browser’s native events. For example inonMouseLeave,e.nativeEventwill point to amouseoutevent. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it frome.nativeEvent.


#### Properties
React event objects implement some of the standardEventproperties:

- bubbles: A boolean. Returns whether the event bubbles through the DOM.
- cancelable: A boolean. Returns whether the event can be canceled.
- currentTarget: A DOM node. Returns the node to which the current handler is attached in the React tree.
- defaultPrevented: A boolean. Returns whetherpreventDefaultwas called.
- eventPhase: A number. Returns which phase the event is currently in.
- isTrusted: A boolean. Returns whether the event was initiated by user.
- target: A DOM node. Returns the node on which the event has occurred (which could be a distant child).
- timeStamp: A number. Returns the time when the event occurred.
Additionally, React event objects provide these properties:

- nativeEvent: A DOMEvent. The original browser event object.

#### Methods
React event objects implement some of the standardEventmethods:

- preventDefault(): Prevents the default browser action for the event.
- stopPropagation(): Stops the event propagation through the React tree.
Additionally, React event objects provide these methods:

- isDefaultPrevented(): Returns a boolean value indicating whetherpreventDefaultwas called.
- isPropagationStopped(): Returns a boolean value indicating whetherstopPropagationwas called.
- persist(): Not used with React DOM. With React Native, call this to read event’s properties after the event.
- isPersistent(): Not used with React DOM. With React Native, returns whetherpersisthas been called.

#### Caveats
- The values ofcurrentTarget,eventPhase,target, andtypereflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example,e.currentTargetmay not be the same as the underlyinge.nativeEvent.currentTarget. For polyfilled events,e.type(React event type) may differ frome.nativeEvent.type(underlying type).

### AnimationEventhandler function
An event handler type for theCSS animationevents.

```jsx
<div  onAnimationStart={e => console.log('onAnimationStart')}  onAnimationIteration={e => console.log('onAnimationIteration')}  onAnimationEnd={e => console.log('onAnimationEnd')}/>
```


#### Parameters
- e: AReact event objectwith these extraAnimationEventproperties:animationNameelapsedTimepseudoElement
- animationName
- elapsedTime
- pseudoElement

### ClipboardEventhandler function
An event handler type for theClipboard APIevents.

```jsx
<input  onCopy={e => console.log('onCopy')}  onCut={e => console.log('onCut')}  onPaste={e => console.log('onPaste')}/>
```


#### Parameters
- e: AReact event objectwith these extraClipboardEventproperties:clipboardData
e: AReact event objectwith these extraClipboardEventproperties:

- clipboardData

### CompositionEventhandler function
An event handler type for theinput method editor (IME)events.

```jsx
<input  onCompositionStart={e => console.log('onCompositionStart')}  onCompositionUpdate={e => console.log('onCompositionUpdate')}  onCompositionEnd={e => console.log('onCompositionEnd')}/>
```


#### Parameters
- e: AReact event objectwith these extraCompositionEventproperties:data
- data

### DragEventhandler function
An event handler type for theHTML Drag and Drop APIevents.

```jsx
<>  <div    draggable={true}    onDragStart={e => console.log('onDragStart')}    onDragEnd={e => console.log('onDragEnd')}  >    Drag source  </div>  <div    onDragEnter={e => console.log('onDragEnter')}    onDragLeave={e => console.log('onDragLeave')}    onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}    onDrop={e => console.log('onDrop')}  >    Drop target  </div></>
```


#### Parameters
- e: AReact event objectwith these extraDragEventproperties:dataTransferIt also includes the inheritedMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraDragEventproperties:

- dataTransfer
It also includes the inheritedMouseEventproperties:

- altKey
- button
- buttons
- ctrlKey
- clientX
- clientY
- getModifierState(key)
- metaKey
- movementX
- movementY
- pageX
- pageY
- relatedTarget
- screenX
- screenY
- shiftKey
It also includes the inheritedUIEventproperties:

- detail
- view

### FocusEventhandler function
An event handler type for the focus events.

```jsx
<input  onFocus={e => console.log('onFocus')}  onBlur={e => console.log('onBlur')}/>
```

See an example.


#### Parameters
- e: AReact event objectwith these extraFocusEventproperties:relatedTargetIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraFocusEventproperties:

- relatedTarget
It also includes the inheritedUIEventproperties:

- detail
- view

### Eventhandler function
An event handler type for generic events.


#### Parameters
- e: AReact event objectwith no additional properties.

### InputEventhandler function
An event handler type for theonBeforeInputevent.

```jsx
<input onBeforeInput={e => console.log('onBeforeInput')} />
```


#### Parameters
- e: AReact event objectwith these extraInputEventproperties:data
- data

### KeyboardEventhandler function
An event handler type for keyboard events.

```jsx
<input  onKeyDown={e => console.log('onKeyDown')}  onKeyUp={e => console.log('onKeyUp')}/>
```

See an example.


#### Parameters
- e: AReact event objectwith these extraKeyboardEventproperties:altKeycharCodecodectrlKeygetModifierState(key)keykeyCodelocalemetaKeylocationrepeatshiftKeywhichIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraKeyboardEventproperties:

- altKey
- charCode
- code
- ctrlKey
- getModifierState(key)
- key
- keyCode
- locale
- metaKey
- location
- repeat
- shiftKey
- which
It also includes the inheritedUIEventproperties:

- detail
- view

### MouseEventhandler function
An event handler type for mouse events.

```jsx
<div  onClick={e => console.log('onClick')}  onMouseEnter={e => console.log('onMouseEnter')}  onMouseOver={e => console.log('onMouseOver')}  onMouseDown={e => console.log('onMouseDown')}  onMouseUp={e => console.log('onMouseUp')}  onMouseLeave={e => console.log('onMouseLeave')}/>
```

See an example.


#### Parameters
- e: AReact event objectwith these extraMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraMouseEventproperties:

- altKey
- button
- buttons
- ctrlKey
- clientX
- clientY
- getModifierState(key)
- metaKey
- movementX
- movementY
- pageX
- pageY
- relatedTarget
- screenX
- screenY
- shiftKey
It also includes the inheritedUIEventproperties:

- detail
- view

### PointerEventhandler function
An event handler type forpointer events.

```jsx
<div  onPointerEnter={e => console.log('onPointerEnter')}  onPointerMove={e => console.log('onPointerMove')}  onPointerDown={e => console.log('onPointerDown')}  onPointerUp={e => console.log('onPointerUp')}  onPointerLeave={e => console.log('onPointerLeave')}/>
```

See an example.


#### Parameters
- e: AReact event objectwith these extraPointerEventproperties:heightisPrimarypointerIdpointerTypepressuretangentialPressuretiltXtiltYtwistwidthIt also includes the inheritedMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraPointerEventproperties:

- height
- isPrimary
- pointerId
- pointerType
- pressure
- tangentialPressure
- tiltX
- tiltY
- twist
- width
It also includes the inheritedMouseEventproperties:

- altKey
- button
- buttons
- ctrlKey
- clientX
- clientY
- getModifierState(key)
- metaKey
- movementX
- movementY
- pageX
- pageY
- relatedTarget
- screenX
- screenY
- shiftKey
It also includes the inheritedUIEventproperties:

- detail
- view

### TouchEventhandler function
An event handler type fortouch events.

```jsx
<div  onTouchStart={e => console.log('onTouchStart')}  onTouchMove={e => console.log('onTouchMove')}  onTouchEnd={e => console.log('onTouchEnd')}  onTouchCancel={e => console.log('onTouchCancel')}/>
```


#### Parameters
- e: AReact event objectwith these extraTouchEventproperties:altKeyctrlKeychangedTouchesgetModifierState(key)metaKeyshiftKeytouchestargetTouchesIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraTouchEventproperties:

- altKey
- ctrlKey
- changedTouches
- getModifierState(key)
- metaKey
- shiftKey
- touches
- targetTouches
It also includes the inheritedUIEventproperties:

- detail
- view

### TransitionEventhandler function
An event handler type for the CSS transition events.

```jsx
<div  onTransitionEnd={e => console.log('onTransitionEnd')}/>
```


#### Parameters
- e: AReact event objectwith these extraTransitionEventproperties:elapsedTimepropertyNamepseudoElement
- elapsedTime
- propertyName
- pseudoElement

### UIEventhandler function
An event handler type for generic UI events.

```jsx
<div  onScroll={e => console.log('onScroll')}/>
```


#### Parameters
- e: AReact event objectwith these extraUIEventproperties:detailview
- detail
- view

### WheelEventhandler function
An event handler type for theonWheelevent.

```jsx
<div  onWheel={e => console.log('onWheel')}/>
```


#### Parameters
- e: AReact event objectwith these extraWheelEventproperties:deltaModedeltaXdeltaYdeltaZIt also includes the inheritedMouseEventproperties:altKeybuttonbuttonsctrlKeyclientXclientYgetModifierState(key)metaKeymovementXmovementYpageXpageYrelatedTargetscreenXscreenYshiftKeyIt also includes the inheritedUIEventproperties:detailview
e: AReact event objectwith these extraWheelEventproperties:

- deltaMode
- deltaX
- deltaY
- deltaZ
It also includes the inheritedMouseEventproperties:

- altKey
- button
- buttons
- ctrlKey
- clientX
- clientY
- getModifierState(key)
- metaKey
- movementX
- movementY
- pageX
- pageY
- relatedTarget
- screenX
- screenY
- shiftKey
It also includes the inheritedUIEventproperties:

- detail
- view

## Usage

### Applying CSS styles
In React, you specify a CSS class withclassName.It works like theclassattribute in HTML:

```jsx
<img className="avatar" />
```

Then you write the CSS rules for it in a separate CSS file:

```jsx
/* In your CSS */.avatar {  border-radius: 50%;}
```

React does not prescribe how you add CSS files. In the simplest case, you’ll add a<link>tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.

Sometimes, the style values depend on data. Use thestyleattribute to pass some styles dynamically:

```jsx
<img  className="avatar"  style={{    width: user.imageSize,    height: user.imageSize  }}/>
```

In the above example,style={{}}is not a special syntax, but a regular{}object inside thestyle={ }JSX curly braces.We recommend only using thestyleattribute when your styles depend on JavaScript variables.

```jsx
export default function Avatar({ user }) {
  return (
    <img
      src={user.imageUrl}
      alt={'Photo of ' + user.name}
      className="avatar"
      style={{
        width: user.imageSize,
        height: user.imageSize
      }}
    />
  );
}


```


#### How to apply multiple CSS classes conditionally?
To apply CSS classes conditionally, you need to produce theclassNamestring yourself using JavaScript.

For example,className={'row ' + (isSelected ? 'selected': '')}will produce eitherclassName="row"orclassName="row selected"depending on whetherisSelectedistrue.

To make this more readable, you can use a tiny helper library likeclassnames:

```jsx
import cn from 'classnames';function Row({ isSelected }) {  return (    <div className={cn('row', isSelected && 'selected')}>      ...    </div>  );}
```

It is especially convenient if you have multiple conditional classes:

```jsx
import cn from 'classnames';function Row({ isSelected, size }) {  return (    <div className={cn('row', {      selected: isSelected,      large: size === 'large',      small: size === 'small',    })}>      ...    </div>  );}
```


### Manipulating a DOM node with a ref
Sometimes, you’ll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an<input>when a button is clicked, you need to callfocus()on the browser<input>DOM node.

To obtain the browser DOM node for a tag,declare a refand pass it as therefattribute to that tag:

```jsx
import { useRef } from 'react';export default function Form() {  const inputRef = useRef(null);  // ...  return (    <input ref={inputRef} />    // ...
```

React will put the DOM node intoinputRef.currentafter it’s been rendered to the screen.

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


```

Read more aboutmanipulating DOM with refsandcheck out more examples.

For more advanced use cases, therefattribute also accepts acallback function.


### Dangerously setting the inner HTML
You can pass a raw HTML string to an element like so:

```jsx
const markup = { __html: '<p>some raw html</p>' };return <div dangerouslySetInnerHTML={markup} />;
```

This is dangerous. As with the underlying DOMinnerHTMLproperty, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce anXSSvulnerability this way.

For example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn’t contain bugs, and the user only sees their own input, you can display the resulting HTML like this:

```jsx
import { Remarkable } from 'remarkable';

const md = new Remarkable();

function renderMarkdownToHTML(markdown) {
  // This is ONLY safe because the output HTML
  // is shown to the same user, and because you
  // trust this Markdown parser to not have bugs.
  const renderedHTML = md.render(markdown);
  return {__html: renderedHTML};
}

export default function MarkdownPreview({ markdown }) {
  const markup = renderMarkdownToHTML(markdown);
  return <div dangerouslySetInnerHTML={markup} />;
}


```

The{__html}object should be created as close to where the HTML is generated as possible, like the above example does in therenderMarkdownToHTMLfunction. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed todangerouslySetInnerHTML. It is not recommended to create the object inline like<div dangerouslySetInnerHTML={{__html: markup}} />.

To see why rendering arbitrary HTML is dangerous, replace the code above with this:

```jsx
const post = {  // Imagine this content is stored in the database.  content: `<img src="" onerror='alert("you were hacked")'>`};export default function MarkdownPreview() {  // 🔴 SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTML  const markup = { __html: post.content };  return <div dangerouslySetInnerHTML={markup} />;}
```

The code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf.Only usedangerouslySetInnerHTMLwith trusted and sanitized data.


### Handling mouse events
This example shows some commonmouse eventsand when they fire.

```jsx
export default function MouseExample() {
  return (
    <div
      onMouseEnter={e => console.log('onMouseEnter (parent)')}
      onMouseLeave={e => console.log('onMouseLeave (parent)')}
    >
      <button
        onClick={e => console.log('onClick (first button)')}
        onMouseDown={e => console.log('onMouseDown (first button)')}
        onMouseEnter={e => console.log('onMouseEnter (first button)')}
        onMouseLeave={e => console.log('onMouseLeave (first button)')}
        onMouseOver={e => console.log('onMouseOver (first button)')}
        onMouseUp={e => console.log('onMouseUp (first button)')}
      >
        First button
      </button>
      <button
        onClick={e => console.log('onClick (second button)')}
        onMouseDown={e => console.log('onMouseDown (second button)')}
        onMouseEnter={e => console.log('onMouseEnter (second button)')}
        onMouseLeave={e => console.log('onMouseLeave (second button)')}
        onMouseOver={e => console.log('onMouseOver (second button)')}
        onMouseUp={e => console.log('onMouseUp (second button)')}
      >
        Second button
      </button>
    </div>
  );
}


```


### Handling pointer events
This example shows some commonpointer eventsand when they fire.

```jsx
export default function PointerExample() {
  return (
    <div
      onPointerEnter={e => console.log('onPointerEnter (parent)')}
      onPointerLeave={e => console.log('onPointerLeave (parent)')}
      style={{ padding: 20, backgroundColor: '#ddd' }}
    >
      <div
        onPointerDown={e => console.log('onPointerDown (first child)')}
        onPointerEnter={e => console.log('onPointerEnter (first child)')}
        onPointerLeave={e => console.log('onPointerLeave (first child)')}
        onPointerMove={e => console.log('onPointerMove (first child)')}
        onPointerUp={e => console.log('onPointerUp (first child)')}
        style={{ padding: 20, backgroundColor: 'lightyellow' }}
      >
        First child
      </div>
      <div
        onPointerDown={e => console.log('onPointerDown (second child)')}
        onPointerEnter={e => console.log('onPointerEnter (second child)')}
        onPointerLeave={e => console.log('onPointerLeave (second child)')}
        onPointerMove={e => console.log('onPointerMove (second child)')}
        onPointerUp={e => console.log('onPointerUp (second child)')}
        style={{ padding: 20, backgroundColor: 'lightblue' }}
      >
        Second child
      </div>
    </div>
  );
}


```


### Handling focus events
In React,focus eventsbubble. You can use thecurrentTargetandrelatedTargetto differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.

```jsx
export default function FocusExample() {
  return (
    <div
      tabIndex={1}
      onFocus={(e) => {
        if (e.currentTarget === e.target) {
          console.log('focused parent');
        } else {
          console.log('focused child', e.target.name);
        }
        if (!e.currentTarget.contains(e.relatedTarget)) {
          // Not triggered when swapping focus between children
          console.log('focus entered parent');
        }
      }}
      onBlur={(e) => {
        if (e.currentTarget === e.target) {
          console.log('unfocused parent');
        } else {
          console.log('unfocused child', e.target.name);
        }
        if (!e.currentTarget.contains(e.relatedTarget)) {
          // Not triggered when swapping focus between children
          console.log('focus left parent');
        }
      }}
    >
      <label>
        First name:
        <input name="firstName" />
      </label>
      <label>
        Last name:
        <input name="lastName" />
      </label>
    </div>
  );
}


```


### Handling keyboard events
This example shows some commonkeyboard eventsand when they fire.

```jsx
export default function KeyboardExample() {
  return (
    <label>
      First name:
      <input
        name="firstName"
        onKeyDown={e => console.log('onKeyDown:', e.key, e.code)}
        onKeyUp={e => console.log('onKeyUp:', e.key, e.code)}
      />
    </label>
  );
}


```


--------------------------------------------------------------------------------


# <form>
Source: https://react.dev/reference/react-dom/components/form

Thebuilt-in browser<form>componentlets you create interactive controls for submitting information.

```jsx
<form action={search}>    <input name="query" />    <button type="submit">Search</button></form>
```

- Reference<form>
- <form>
- UsageHandle form submission on the clientHandle form submission with a Server FunctionDisplay a pending state during form submissionOptimistically updating form dataHandling form submission errorsDisplay a form submission error without JavaScriptHandling multiple submission types
- Handle form submission on the client
- Handle form submission with a Server Function
- Display a pending state during form submission
- Optimistically updating form data
- Handling form submission errors
- Display a form submission error without JavaScript
- Handling multiple submission types

## Reference

### <form>
To create interactive controls for submitting information, render thebuilt-in browser<form>component.

```jsx
<form action={search}>    <input name="query" />    <button type="submit">Search</button></form>
```

See more examples below.


#### Props
<form>supports allcommon element props.

action: a URL or function. When a URL is passed toactionthe form will behave like the HTML form component. When a function is passed toactionthe function will handle the form submission in a Transition followingthe Action prop pattern. The function passed toactionmay be async and will be called with a single argument containing theform dataof the submitted form. Theactionprop can be overridden by aformActionattribute on a<button>,<input type="submit">, or<input type="image">component.


#### Caveats
- When a function is passed toactionorformActionthe HTTP method will be POST regardless of value of themethodprop.

## Usage

### Handle form submission on the client
Pass a function to theactionprop of form to run the function when the form is submitted.formDatawill be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventionalHTML action, which only accepts URLs. After theactionfunction succeeds, all uncontrolled field elements in the form are reset.

```jsx
export default function Search() {
  function search(formData) {
    const query = formData.get("query");
    alert(`You searched for '${query}'`);
  }
  return (
    <form action={search}>
      <input name="query" />
      <button type="submit">Search</button>
    </form>
  );
}


```


### Handle form submission with a Server Function
Render a<form>with an input and submit button. Pass a Server Function (a function marked with'use server') to theactionprop of form to run the function when the form is submitted.

Passing a Server Function to<form action>allow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to theactionprop.

You can use hidden form fields to provide data to the<form>’s action. The Server Function will be called with the hidden form field data as an instance ofFormData.

```jsx
import { updateCart } from './lib.js';function AddToCart({productId}) {  async function addToCart(formData) {    'use server'    const productId = formData.get('productId')    await updateCart(productId)  }  return (    <form action={addToCart}>        <input type="hidden" name="productId" value={productId} />        <button type="submit">Add to Cart</button>    </form>  );}
```

In lieu of using hidden form fields to provide data to the<form>’s action, you can call thebindmethod to supply it with extra arguments. This will bind a new argument (productId) to the function in addition to theformDatathat is passed as an argument to the function.

```jsx
import { updateCart } from './lib.js';function AddToCart({productId}) {  async function addToCart(productId, formData) {    "use server";    await updateCart(productId)  }  const addProductToCart = addToCart.bind(null, productId);  return (    <form action={addProductToCart}>      <button type="submit">Add to Cart</button>    </form>  );}
```

When<form>is rendered by aServer Component, and aServer Functionis passed to the<form>’sactionprop, the form isprogressively enhanced.


### Display a pending state during form submission
To display a pending state when a form is being submitted, you can call theuseFormStatusHook in a component rendered in a<form>and read thependingproperty returned.

Here, we use thependingproperty to indicate the form is submitting.

```jsx
import { useFormStatus } from "react-dom";
import { submitForm } from "./actions.js";

function Submit() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </button>
  );
}

function Form({ action }) {
  return (
    <form action={action}>
      <Submit />
    </form>
  );
}

export default function App() {
  return <Form action={submitForm} />;
}


```

To learn more about theuseFormStatusHook see thereference documentation.


### Optimistically updating form data
TheuseOptimisticHook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome.

For example, when a user types a message into the form and hits the “Send” button, theuseOptimisticHook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed.

```jsx
import { useOptimistic, useState, useRef } from "react";
import { deliverMessage } from "./actions.js";

function Thread({ messages, sendMessage }) {
  const formRef = useRef();
  async function formAction(formData) {
    addOptimisticMessage(formData.get("message"));
    formRef.current.reset();
    await sendMessage(formData);
  }
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [
      ...state,
      {
        text: newMessage,
        sending: true
      }
    ]
  );

  return (
    <>
      {optimisticMessages.map((message, index) => (
        <div key={index}>
          {message.text}
          {!!message.sending && <small> (Sending...)</small>}
        </div>
      ))}
      <form action={formAction} ref={formRef}>
        <input type="text" name="message" placeholder="Hello!" />
        <button type="submit">Send</button>
      </form>
    </>
  );
}

export default function App() {
  const [messages, setMessages] = useState([
    { text: "Hello there!", sending: false, key: 1 }
  ]);
  async function sendMessage(formData) {
    const sentMessage = await deliverMessage(formData.get("message"));
    setMessages((messages) => [...messages, { text: sentMessage }]);
  }
  return <Thread messages={messages} sendMessage={sendMessage} />;
}


```


### Handling form submission errors
In some cases the function called by a<form>’sactionprop throws an error. You can handle these errors by wrapping<form>in an Error Boundary. If the function called by a<form>’sactionprop throws an error, the fallback for the error boundary will be displayed.

```jsx
import { ErrorBoundary } from "react-error-boundary";

export default function Search() {
  function search() {
    throw new Error("search error");
  }
  return (
    <ErrorBoundary
      fallback={<p>There was an error while submitting the form</p>}
    >
      <form action={search}>
        <input name="query" />
        <button type="submit">Search</button>
      </form>
    </ErrorBoundary>
  );
}


```


### Display a form submission error without JavaScript
Displaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:

1. <form>be rendered by aClient Component
1. the function passed to the<form>’sactionprop be aServer Function
1. theuseActionStateHook be used to display the error message
useActionStatetakes two parameters: aServer Functionand an initial state.useActionStatereturns two values, a state variable and an action. The action returned byuseActionStateshould be passed to theactionprop of the form. The state variable returned byuseActionStatecan be used to display an error message. The value returned by the Server Function passed touseActionStatewill be used to update the state variable.

```jsx
import { useActionState } from "react";
import { signUpNewUser } from "./api";

export default function Page() {
  async function signup(prevState, formData) {
    "use server";
    const email = formData.get("email");
    try {
      await signUpNewUser(email);
      alert(`Added "${email}"`);
    } catch (err) {
      return err.toString();
    }
  }
  const [message, signupAction] = useActionState(signup, null);
  return (
    <>
      <h1>Signup for my newsletter</h1>
      <p>Signup with the same email twice to see an error</p>
      <form action={signupAction} id="signup-form">
        <label htmlFor="email">Email: </label>
        <input name="email" id="email" placeholder="react@example.com" />
        <button>Sign up</button>
        {!!message && <p>{message}</p>}
      </form>
    </>
  );
}


```

Learn more about updating state from a form action with theuseActionStatedocs


### Handling multiple submission types
Forms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting theformActionprop.

When a user taps a specific button, the form is submitted, and a corresponding action, defined by that button’s attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button withformActionset to save the article as a draft.

```jsx
export default function Search() {
  function publish(formData) {
    const content = formData.get("content");
    const button = formData.get("button");
    alert(`'${content}' was published with the '${button}' button`);
  }

  function save(formData) {
    const content = formData.get("content");
    alert(`Your draft of '${content}' has been saved!`);
  }

  return (
    <form action={publish}>
      <textarea name="content" rows={4} cols={40} />
      <br />
      <button type="submit" name="button" value="submit">Publish</button>
      <button formAction={save}>Save draft</button>
    </form>
  );
}


```


--------------------------------------------------------------------------------


# <input>
Source: https://react.dev/reference/react-dom/components/input

Thebuilt-in browser<input>componentlets you render different kinds of form inputs.

```jsx
<input />
```

- Reference<input>
- <input>
- UsageDisplaying inputs of different typesProviding a label for an inputProviding an initial value for an inputReading the input values when submitting a formControlling an input with a state variableOptimizing re-rendering on every keystroke
- Displaying inputs of different types
- Providing a label for an input
- Providing an initial value for an input
- Reading the input values when submitting a form
- Controlling an input with a state variable
- Optimizing re-rendering on every keystroke
- TroubleshootingMy text input doesn’t update when I type into itMy checkbox doesn’t update when I click on itMy input caret jumps to the beginning on every keystrokeI’m getting an error: “A component is changing an uncontrolled input to be controlled”
- My text input doesn’t update when I type into it
- My checkbox doesn’t update when I click on it
- My input caret jumps to the beginning on every keystroke
- I’m getting an error: “A component is changing an uncontrolled input to be controlled”

## Reference

### <input>
To display an input, render thebuilt-in browser<input>component.

```jsx
<input name="myInput" />
```

See more examples below.


#### Props
<input>supports allcommon element props.

- formAction: A string or function. Overrides the parent<form action>fortype="submit"andtype="image". When a URL is passed toactionthe form will behave like a standard HTML form. When a function is passed toformActionthe function will handle the form submission. See<form action>.
You canmake an input controlledby passing one of these props:

- checked: A boolean. For a checkbox input or a radio button, controls whether it is selected.
- value: A string. For a text input, controls its text. (For a radio button, specifies its form data.)
When you pass either of them, you must also pass anonChangehandler that updates the passed value.

These<input>props are only relevant for uncontrolled inputs:

- defaultChecked: A boolean. Specifiesthe initial valuefortype="checkbox"andtype="radio"inputs.
- defaultValue: A string. Specifiesthe initial valuefor a text input.
These<input>props are relevant both for uncontrolled and controlled inputs:

- accept: A string. Specifies which filetypes are accepted by atype="file"input.
- alt: A string. Specifies the alternative image text for atype="image"input.
- capture: A string. Specifies the media (microphone, video, or camera) captured by atype="file"input.
- autoComplete: A string. Specifies one of the possibleautocomplete behaviors.
- autoFocus: A boolean. Iftrue, React will focus the element on mount.
- dirname: A string. Specifies the form field name for the element’s directionality.
- disabled: A boolean. Iftrue, the input will not be interactive and will appear dimmed.
- children:<input>does not accept children.
- form: A string. Specifies theidof the<form>this input belongs to. If omitted, it’s the closest parent form.
- formAction: A string. Overrides the parent<form action>fortype="submit"andtype="image".
- formEnctype: A string. Overrides the parent<form enctype>fortype="submit"andtype="image".
- formMethod: A string. Overrides the parent<form method>fortype="submit"andtype="image".
- formNoValidate: A string. Overrides the parent<form noValidate>fortype="submit"andtype="image".
- formTarget: A string. Overrides the parent<form target>fortype="submit"andtype="image".
- height: A string. Specifies the image height fortype="image".
- list: A string. Specifies theidof the<datalist>with the autocomplete options.
- max: A number. Specifies the maximum value of numerical and datetime inputs.
- maxLength: A number. Specifies the maximum length of text and other inputs.
- min: A number. Specifies the minimum value of numerical and datetime inputs.
- minLength: A number. Specifies the minimum length of text and other inputs.
- multiple: A boolean. Specifies whether multiple values are allowed for<type="file"andtype="email".
- name: A string. Specifies the name for this input that’ssubmitted with the form.
- onChange: AnEventhandlerfunction. Required forcontrolled inputs.Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browserinputevent.
- onChangeCapture: A version ofonChangethat fires in thecapture phase.
- onInput: AnEventhandlerfunction. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChangeinstead which works similarly.
- onInputCapture: A version ofonInputthat fires in thecapture phase.
- onInvalid: AnEventhandlerfunction. Fires if an input fails validation on form submit. Unlike the built-ininvalidevent, the ReactonInvalidevent bubbles.
- onInvalidCapture: A version ofonInvalidthat fires in thecapture phase.
- onSelect: AnEventhandlerfunction. Fires after the selection inside the<input>changes. React extends theonSelectevent to also fire for empty selection and on edits (which may affect the selection).
- onSelectCapture: A version ofonSelectthat fires in thecapture phase.
- pattern: A string. Specifies the pattern that thevaluemust match.
- placeholder: A string. Displayed in a dimmed color when the input value is empty.
- readOnly: A boolean. Iftrue, the input is not editable by the user.
- required: A boolean. Iftrue, the value must be provided for the form to submit.
- size: A number. Similar to setting width, but the unit depends on the control.
- src: A string. Specifies the image source for atype="image"input.
- step: A positive number or an'any'string. Specifies the distance between valid values.
- type: A string. One of theinput types.
- width:  A string. Specifies the image width for atype="image"input.

#### Caveats
- Checkboxes needchecked(ordefaultChecked), notvalue(ordefaultValue).
- If a text input receives a stringvalueprop, it will betreated as controlled.
- If a checkbox or a radio button receives a booleancheckedprop, it will betreated as controlled.
- An input can’t be both controlled and uncontrolled at the same time.
- An input cannot switch between being controlled or uncontrolled over its lifetime.
- Every controlled input needs anonChangeevent handler that synchronously updates its backing value.

## Usage

### Displaying inputs of different types
To display an input, render an<input>component. By default, it will be a text input. You can passtype="checkbox"for a checkbox,type="radio"for a radio button,or one of the other input types.

```jsx
export default function MyForm() {
  return (
    <>
      <label>
        Text input: <input name="myInput" />
      </label>
      <hr />
      <label>
        Checkbox: <input type="checkbox" name="myCheckbox" />
      </label>
      <hr />
      <p>
        Radio buttons:
        <label>
          <input type="radio" name="myRadio" value="option1" />
          Option 1
        </label>
        <label>
          <input type="radio" name="myRadio" value="option2" />
          Option 2
        </label>
        <label>
          <input type="radio" name="myRadio" value="option3" />
          Option 3
        </label>
      </p>
    </>
  );
}


```


### Providing a label for an input
Typically, you will place every<input>inside a<label>tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.

If you can’t nest<input>into a<label>, associate them by passing the same ID to<input id>and<label htmlFor>.To avoid conflicts between multiple instances of one component, generate such an ID withuseId.

```jsx
import { useId } from 'react';

export default function Form() {
  const ageInputId = useId();
  return (
    <>
      <label>
        Your first name:
        <input name="firstName" />
      </label>
      <hr />
      <label htmlFor={ageInputId}>Your age:</label>
      <input id={ageInputId} name="age" type="number" />
    </>
  );
}


```


### Providing an initial value for an input
You can optionally specify the initial value for any input. Pass it as thedefaultValuestring for text inputs. Checkboxes and radio buttons should specify the initial value with thedefaultCheckedboolean instead.

```jsx
export default function MyForm() {
  return (
    <>
      <label>
        Text input: <input name="myInput" defaultValue="Some initial value" />
      </label>
      <hr />
      <label>
        Checkbox: <input type="checkbox" name="myCheckbox" defaultChecked={true} />
      </label>
      <hr />
      <p>
        Radio buttons:
        <label>
          <input type="radio" name="myRadio" value="option1" />
          Option 1
        </label>
        <label>
          <input
            type="radio"
            name="myRadio"
            value="option2"
            defaultChecked={true} 
          />
          Option 2
        </label>
        <label>
          <input type="radio" name="myRadio" value="option3" />
          Option 3
        </label>
      </p>
    </>
  );
}


```


### Reading the input values when submitting a form
Add a<form>around your inputs with a<button type="submit">inside. It will call your<form onSubmit>event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by callinge.preventDefault(). Read the form data withnew FormData(e.target).

```jsx
export default function MyForm() {
  function handleSubmit(e) {
    // Prevent the browser from reloading the page
    e.preventDefault();

    // Read the form data
    const form = e.target;
    const formData = new FormData(form);

    // You can pass formData as a fetch body directly:
    fetch('/some-api', { method: form.method, body: formData });

    // Or you can work with it as a plain object:
    const formJson = Object.fromEntries(formData.entries());
    console.log(formJson);
  }

  return (
    <form method="post" onSubmit={handleSubmit}>
      <label>
        Text input: <input name="myInput" defaultValue="Some initial value" />
      </label>
      <hr />
      <label>
        Checkbox: <input type="checkbox" name="myCheckbox" defaultChecked={true} />
      </label>
      <hr />
      <p>
        Radio buttons:
        <label><input type="radio" name="myRadio" value="option1" /> Option 1</label>
        <label><input type="radio" name="myRadio" value="option2" defaultChecked={true} /> Option 2</label>
        <label><input type="radio" name="myRadio" value="option3" /> Option 3</label>
      </p>
      <hr />
      <button type="reset">Reset form</button>
      <button type="submit">Submit form</button>
    </form>
  );
}


```


### Note
Give anameto every<input>, for example<input name="firstName" defaultValue="Taylor" />. Thenameyou specified will be used as a key in the form data, for example{ firstName: "Taylor" }.


### Pitfall
By default, a<button>inside a<form>without atypeattribute will submit it. This can be surprising! If you have your own customButtonReact component, consider using<button type="button">instead of<button>(with no type). Then, to be explicit, use<button type="submit">for buttons thataresupposed to submit the form.


### Controlling an input with a state variable
An input like<input />isuncontrolled.Even if youpass an initial valuelike<input defaultValue="Initial text" />, your JSX only specifies the initial value. It does not control what the value should be right now.

To render acontrolledinput, pass thevalueprop to it (orcheckedfor checkboxes and radios).React will force the input to always have thevalueyou passed. Usually, you would do this by declaring astate variable:

```jsx
function Form() {  const [firstName, setFirstName] = useState(''); // Declare a state variable...  // ...  return (    <input      value={firstName} // ...force the input's value to match the state variable...      onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!    />  );}
```

A controlled input makes sense if you needed state anyway—for example, to re-render your UI on every edit:

```jsx
function Form() {  const [firstName, setFirstName] = useState('');  return (    <>      <label>        First name:        <input value={firstName} onChange={e => setFirstName(e.target.value)} />      </label>      {firstName !== '' && <p>Your name is {firstName}.</p>}      ...
```

It’s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):

```jsx
function Form() {  // ...  const [age, setAge] = useState('');  const ageAsNumber = Number(age);  return (    <>      <label>        Age:        <input          value={age}          onChange={e => setAge(e.target.value)}          type="number"        />        <button onClick={() => setAge(ageAsNumber + 10)}>          Add 10 years        </button>
```

Thevalueyou pass to controlled components should not beundefinedornull. If you need the initial value to be empty (such as with thefirstNamefield below), initialize your state variable to an empty string ('').

```jsx
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [age, setAge] = useState('20');
  const ageAsNumber = Number(age);
  return (
    <>
      <label>
        First name:
        <input
          value={firstName}
          onChange={e => setFirstName(e.target.value)}
        />
      </label>
      <label>
        Age:
        <input
          value={age}
          onChange={e => setAge(e.target.value)}
          type="number"
        />
        <button onClick={() => setAge(ageAsNumber + 10)}>
          Add 10 years
        </button>
      </label>
      {firstName !== '' &&
        <p>Your name is {firstName}.</p>
      }
      {ageAsNumber > 0 &&
        <p>Your age is {ageAsNumber}.</p>
      }
    </>
  );
}


```


### Pitfall
If you passvaluewithoutonChange, it will be impossible to type into the input.When you control an input by passing somevalueto it, youforceit to always have the value you passed. So if you pass a state variable as avaluebut forget to update that state variable synchronously during theonChangeevent handler, React will revert the input after every keystroke back to thevaluethat you specified.


### Optimizing re-rendering on every keystroke
When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There’s a few ways you can optimize re-rendering performance.

For example, suppose you start with a form that re-renders all page content on every keystroke:

```jsx
function App() {  const [firstName, setFirstName] = useState('');  return (    <>      <form>        <input value={firstName} onChange={e => setFirstName(e.target.value)} />      </form>      <PageContent />    </>  );}
```

Since<PageContent />doesn’t rely on the input state, you can move the input state into its own component:

```jsx
function App() {  return (    <>      <SignupForm />      <PageContent />    </>  );}function SignupForm() {  const [firstName, setFirstName] = useState('');  return (    <form>      <input value={firstName} onChange={e => setFirstName(e.target.value)} />    </form>  );}
```

This significantly improves performance because now onlySignupFormre-renders on every keystroke.

If there is no way to avoid re-rendering (for example, ifPageContentdepends on the search input’s value),useDeferredValuelets you keep the controlled input responsive even in the middle of a large re-render.


## Troubleshooting

### My text input doesn’t update when I type into it
If you render an input withvaluebut noonChange, you will see an error in the console:

```jsx
// 🔴 Bug: controlled text input with no onChange handler<input value={something} />
```

As the error message suggests, if you only wanted tospecify theinitialvalue,passdefaultValueinstead:

```jsx
// ✅ Good: uncontrolled input with an initial value<input defaultValue={something} />
```

If you wantto control this input with a state variable,specify anonChangehandler:

```jsx
// ✅ Good: controlled input with onChange<input value={something} onChange={e => setSomething(e.target.value)} />
```

If the value is intentionally read-only, add areadOnlyprop to suppress the error:

```jsx
// ✅ Good: readonly controlled input without on change<input value={something} readOnly={true} />
```


### My checkbox doesn’t update when I click on it
If you render a checkbox withcheckedbut noonChange, you will see an error in the console:

```jsx
// 🔴 Bug: controlled checkbox with no onChange handler<input type="checkbox" checked={something} />
```

As the error message suggests, if you only wanted tospecify theinitialvalue,passdefaultCheckedinstead:

```jsx
// ✅ Good: uncontrolled checkbox with an initial value<input type="checkbox" defaultChecked={something} />
```

If you wantto control this checkbox with a state variable,specify anonChangehandler:

```jsx
// ✅ Good: controlled checkbox with onChange<input type="checkbox" checked={something} onChange={e => setSomething(e.target.checked)} />
```


### Pitfall
You need to reade.target.checkedrather thane.target.valuefor checkboxes.

If the checkbox is intentionally read-only, add areadOnlyprop to suppress the error:

```jsx
// ✅ Good: readonly controlled input without on change<input type="checkbox" checked={something} readOnly={true} />
```


### My input caret jumps to the beginning on every keystroke
If youcontrol an input,you must update its state variable to the input’s value from the DOM duringonChange.

You can’t update it to something other thane.target.value(ore.target.checkedfor checkboxes):

```jsx
function handleChange(e) {  // 🔴 Bug: updating an input to something other than e.target.value  setFirstName(e.target.value.toUpperCase());}
```

You also can’t update it asynchronously:

```jsx
function handleChange(e) {  // 🔴 Bug: updating an input asynchronously  setTimeout(() => {    setFirstName(e.target.value);  }, 100);}
```

To fix your code, update it synchronously toe.target.value:

```jsx
function handleChange(e) {  // ✅ Updating a controlled input to e.target.value synchronously  setFirstName(e.target.value);}
```

If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentallyresetting stateon every re-render, for example if the input or one of its parents always receives a differentkeyattribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree).


### I’m getting an error: “A component is changing an uncontrolled input to be controlled”
If you provide avalueto the component, it must remain a string throughout its lifetime.

You cannot passvalue={undefined}first and later passvalue="some string"because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a stringvalue, notnullorundefined.

If yourvalueis coming from an API or a state variable, it might be initialized tonullorundefined. In that case, either set it to an empty string ('') initially, or passvalue={someValue ?? ''}to ensurevalueis a string.

Similarly, if you passcheckedto a checkbox, ensure it’s always a boolean.


--------------------------------------------------------------------------------


# <link>
Source: https://react.dev/reference/react-dom/components/link

Thebuilt-in browser<link>componentlets you use external resources such as stylesheets or annotate the document with link metadata.

```jsx
<link rel="icon" href="favicon.ico" />
```

- Reference<link>
- <link>
- UsageLinking to related resourcesLinking to a stylesheetControlling stylesheet precedenceDeduplicated stylesheet renderingAnnotating specific items within the document with links
- Linking to related resources
- Linking to a stylesheet
- Controlling stylesheet precedence
- Deduplicated stylesheet rendering
- Annotating specific items within the document with links

## Reference

### <link>
To link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render thebuilt-in browser<link>component. You can render<link>from any component and React willin most casesplace the corresponding DOM element in the document head.

```jsx
<link rel="icon" href="favicon.ico" />
```

See more examples below.


#### Props
<link>supports allcommon element props.

- rel: a string, required. Specifies therelationship to the resource. Reacttreats links withrel="stylesheet"differentlyfrom other links.
These props apply whenrel="stylesheet":

- precedence: a string. Tells React where to rank the<link>DOM node relative to others in the document<head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are<link>or inline<style>tags or loaded usingpreinitfunctions.
- media: a string. Restricts the stylesheet to a certainmedia query.
- title: a string. Specifies the name of analternative stylesheet.
These props apply whenrel="stylesheet"but disable React’sspecial treatment of stylesheets:

- disabled: a boolean. Disables the stylesheet.
- onError: a function. Called when the stylesheet fails to load.
- onLoad: a function. Called when the stylesheet finishes being loaded.
These props apply whenrel="preload"orrel="modulepreload":

- as: a string. The type of resource. Its possible values areaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.
- imageSrcSet: a string. Applicable only whenas="image". Specifies thesource set of the image.
- imageSizes: a string. Applicable only whenas="image". Specifies thesizes of the image.
These props apply whenrel="icon"orrel="apple-touch-icon":

- sizes: a string. Thesizes of the icon.
These props apply in all cases:

- href: a string. The URL of the linked resource.
- crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to"fetch".
- referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.
- fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.
- hrefLang: a string. The language of the linked resource.
- integrity: a string. A cryptographic hash of the resource, toverify its authenticity.
- type: a string. The MIME type of the linked resource.
Props that arenot recommendedfor use with React:

- blocking: a string. If set to"render", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.

#### Special rendering behavior
React will always place the DOM element corresponding to the<link>component within the document’s<head>, regardless of where in the React tree it is rendered. The<head>is the only valid place for<link>to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render<link>components itself.

There are a few exceptions to this:

- If the<link>has arel="stylesheet"prop, then it has to also have aprecedenceprop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using theprecedenceprop. If theprecedenceprop is omitted, there is no special behavior.
- If the<link>has anitemPropprop, there is no special behavior, because in this case it doesn’t apply to the document but instead represents metadata about a specific part of the page.
- If the<link>has anonLoadoronErrorprop, because in that case you are managing the loading of the linked resource manually within your React component.

#### Special behavior for stylesheets
In addition, if the<link>is to a stylesheet (namely, it hasrel="stylesheet"in its props), React treats it specially in the following ways:

- The component that renders<link>willsuspendwhile the stylesheet is loading.
- If multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the samehrefprop.
There are two exception to this special behavior:

- If the link doesn’t have aprecedenceprop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using theprecedenceprop.
- If you supply any of theonLoad,onError, ordisabledprops, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component.
This special treatment comes with two caveats:

- React will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)
- React may leave the link in the DOM even after the component that rendered it has been unmounted.

## Usage

### Linking to related resources
You can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document<head>regardless of where in the React tree it is rendered.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function BlogPage() {
  return (
    <ShowRenderedHTML>
      <link rel="icon" href="favicon.ico" />
      <link rel="pingback" href="http://www.example.com/xmlrpc.php" />
      <h1>My Blog</h1>
      <p>...</p>
    </ShowRenderedHTML>
  );
}


```


### Linking to a stylesheet
If a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component willsuspendwhile the stylesheet is loading. You must supply theprecedenceprop, which tells React where to place this stylesheet relative to others — stylesheets with higher precedence can override those with lower precedence.


### Note
When you want to use a stylesheet, it can be beneficial to call thepreinitfunction. Calling this function may allow the browser to start fetching the stylesheet earlier than if you just render a<link>component, for example by sending anHTTP Early Hints response.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function SiteMapPage() {
  return (
    <ShowRenderedHTML>
      <link rel="stylesheet" href="sitemap.css" precedence="medium" />
      <p>...</p>
    </ShowRenderedHTML>
  );
}


```


### Controlling stylesheet precedence
Stylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with theprecedenceprop. In this example, three components render stylesheets, and the ones with the same precedence are grouped together in the<head>.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function HomePage() {
  return (
    <ShowRenderedHTML>
      <FirstComponent />
      <SecondComponent />
      <ThirdComponent/>
      ...
    </ShowRenderedHTML>
  );
}

function FirstComponent() {
  return <link rel="stylesheet" href="first.css" precedence="first" />;
}

function SecondComponent() {
  return <link rel="stylesheet" href="second.css" precedence="second" />;
}

function ThirdComponent() {
  return <link rel="stylesheet" href="third.css" precedence="first" />;
}


```

Note theprecedencevalues themselves are arbitrary and their naming is up to you. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”.


### Deduplicated stylesheet rendering
If you render the same stylesheet from multiple components, React will place only a single<link>in the document head.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function HomePage() {
  return (
    <ShowRenderedHTML>
      <Component />
      <Component />
      ...
    </ShowRenderedHTML>
  );
}

function Component() {
  return <link rel="stylesheet" href="styles.css" precedence="medium" />;
}


```


### Annotating specific items within the document with links
You can use the<link>component with theitemPropprop to annotate specific items within the document with links to related resources. In this case, React willnotplace these annotations within the document<head>but will place them like any other React component.

```jsx
<section itemScope>  <h3>Annotating specific items</h3>  <link itemProp="author" href="http://example.com/" />  <p>...</p></section>
```


--------------------------------------------------------------------------------


# <meta>
Source: https://react.dev/reference/react-dom/components/meta

Thebuilt-in browser<meta>componentlets you add metadata to the document.

```jsx
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
```

- Reference<meta>
- <meta>
- UsageAnnotating the document with metadataAnnotating specific items within the document with metadata
- Annotating the document with metadata
- Annotating specific items within the document with metadata

## Reference

### <meta>
To add document metadata, render thebuilt-in browser<meta>component. You can render<meta>from any component and React will always place the corresponding DOM element in the document head.

```jsx
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
```

See more examples below.


#### Props
<meta>supports allcommon element props.

It should haveexactly oneof the following props:name,httpEquiv,charset,itemProp. The<meta>component does something different depending on which of these props is specified.

- name: a string. Specifies thekind of metadatato be attached to the document.
- charset: a string. Specifies the character set used by the document. The only valid value is"utf-8".
- httpEquiv: a string. Specifies a directive for processing the document.
- itemProp: a string. Specifies metadata about a particular item within the document rather than the document as a whole.
- content: a string. Specifies the metadata to be attached when used with thenameoritemPropprops or the behavior of the directive when used with thehttpEquivprop.

#### Special rendering behavior
React will always place the DOM element corresponding to the<meta>component within the document’s<head>, regardless of where in the React tree it is rendered. The<head>is the only valid place for<meta>to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render<meta>components itself.

There is one exception to this: if<meta>has anitemPropprop, there is no special behavior, because in this case it doesn’t represent metadata about the document but rather metadata about a specific part of the page.


## Usage

### Annotating the document with metadata
You can annotate the document with metadata such as keywords, a summary, or the author’s name. React will place this metadata within the document<head>regardless of where in the React tree it is rendered.

```jsx
<meta name="author" content="John Smith" /><meta name="keywords" content="React, JavaScript, semantic markup, html" /><meta name="description" content="API reference for the <meta> component in React DOM" />
```

You can render the<meta>component from any component. React will put a<meta>DOM node in the document<head>.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function SiteMapPage() {
  return (
    <ShowRenderedHTML>
      <meta name="keywords" content="React" />
      <meta name="description" content="A site map for the React website" />
      <h1>Site Map</h1>
      <p>...</p>
    </ShowRenderedHTML>
  );
}


```


### Annotating specific items within the document with metadata
You can use the<meta>component with theitemPropprop to annotate specific items within the document with metadata. In this case, React willnotplace these annotations within the document<head>but will place them like any other React component.

```jsx
<section itemScope>  <h3>Annotating specific items</h3>  <meta itemProp="description" content="API reference for using <meta> with itemProp" />  <p>...</p></section>
```


--------------------------------------------------------------------------------


# <option>
Source: https://react.dev/reference/react-dom/components/option

Thebuilt-in browser<option>componentlets you render an option inside a<select>box.

```jsx
<select>  <option value="someOption">Some option</option>  <option value="otherOption">Other option</option></select>
```

- Reference<option>
- <option>
- UsageDisplaying a select box with options
- Displaying a select box with options

## Reference

### <option>
Thebuilt-in browser<option>componentlets you render an option inside a<select>box.

```jsx
<select>  <option value="someOption">Some option</option>  <option value="otherOption">Other option</option></select>
```

See more examples below.


#### Props
<option>supports allcommon element props.

Additionally,<option>supports these props:

- disabled: A boolean. Iftrue, the option will not be selectable and will appear dimmed.
- label: A string. Specifies the meaning of the option. If not specified, the text inside the option is used.
- value: The value to be usedwhen submitting the parent<select>in a formif this option is selected.

#### Caveats
- React does not support theselectedattribute on<option>. Instead, pass this option’svalueto the parent<select defaultValue>for an uncontrolled select box, or<select value>for a controlled select.

## Usage

### Displaying a select box with options
Render a<select>with a list of<option>components inside to display a select box. Give each<option>avaluerepresenting the data to be submitted with the form.

Read more about displaying a<select>with a list of<option>components.

```jsx
export default function FruitPicker() {
  return (
    <label>
      Pick a fruit:
      <select name="selectedFruit">
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}


```


--------------------------------------------------------------------------------


# <progress>
Source: https://react.dev/reference/react-dom/components/progress

Thebuilt-in browser<progress>componentlets you render a progress indicator.

```jsx
<progress value={0.5} />
```

- Reference<progress>
- <progress>
- UsageControlling a progress indicator
- Controlling a progress indicator

## Reference

### <progress>
To display a progress indicator, render thebuilt-in browser<progress>component.

```jsx
<progress value={0.5} />
```

See more examples below.


#### Props
<progress>supports allcommon element props.

Additionally,<progress>supports these props:

- max: A number. Specifies the maximumvalue. Defaults to1.
- value: A number between0andmax, ornullfor indeterminate progress. Specifies how much was done.

## Usage

### Controlling a progress indicator
To display a progress indicator, render a<progress>component. You can pass a numbervaluebetween0and themaxvalue you specify. If you don’t pass amaxvalue, it will assumed to be1by default.

If the operation is not ongoing, passvalue={null}to put the progress indicator into an indeterminate state.

```jsx
export default function App() {
  return (
    <>
      <progress value={0} />
      <progress value={0.5} />
      <progress value={0.7} />
      <progress value={75} max={100} />
      <progress value={1} />
      <progress value={null} />
    </>
  );
}


```


--------------------------------------------------------------------------------


# <script>
Source: https://react.dev/reference/react-dom/components/script

Thebuilt-in browser<script>componentlets you add a script to your document.

```jsx
<script> alert("hi!") </script>
```

- Reference<script>
- <script>
- UsageRendering an external scriptRendering an inline script
- Rendering an external script
- Rendering an inline script

## Reference

### <script>
To add inline or external scripts to your document, render thebuilt-in browser<script>component. You can render<script>from any component and React willin certain casesplace the corresponding DOM element in the document head and de-duplicate identical scripts.

```jsx
<script> alert("hi!") </script><script src="script.js" />
```

See more examples below.


#### Props
<script>supports allcommon element props.

It should haveeitherchildrenor asrcprop.

- children: a string. The source code of an inline script.
- src: a string. The URL of an external script.
Other supported props:

- async: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed — the preferred behavior for performance.
- crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.
- fetchPriority: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be"high","low", or"auto"(the default).
- integrity: a string. A cryptographic hash of the script, toverify its authenticity.
- noModule: a boolean. Disables the script in browsers that support ES modules — allowing for a fallback script for browsers that do not.
- nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.
- referrer: a string. Sayswhat Referer header to sendwhen fetching the script and any resources that the script fetches in turn.
- type: a string. Says whether the script is aclassic script, ES module, or import map.
Props that disable React’sspecial treatment of scripts:

- onError: a function. Called when the script fails to load.
- onLoad: a function. Called when the script finishes being loaded.
Props that arenot recommendedfor use with React:

- blocking: a string. If set to"render", instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.
- defer: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use theasyncprop instead.

#### Special rendering behavior
React can move<script>components to the document’s<head>and de-duplicate identical scripts.

To opt into this behavior, provide thesrcandasync={true}props. React will de-duplicate scripts if they have the samesrc. Theasyncprop must be true to allow scripts to be safely moved.

This special treatment comes with two caveats:

- React will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)
- React may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)

## Usage

### Rendering an external script
If a component depends on certain scripts in order to be displayed correctly, you can render a<script>within the component.
However, the component might be committed before the script has finished loading.
You can start depending on the script content once theloadevent is fired e.g. by using theonLoadprop.

React will de-duplicate scripts that have the samesrc, inserting only one of them into the DOM even if multiple components render it.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

function Map({lat, long}) {
  return (
    <>
      <script async src="map-api.js" onLoad={() => console.log('script loaded')} />
      <div id="map" data-lat={lat} data-long={long} />
    </>
  );
}

export default function Page() {
  return (
    <ShowRenderedHTML>
      <Map />
    </ShowRenderedHTML>
  );
}


```


### Note
When you want to use a script, it can be beneficial to call thepreinitfunction. Calling this function may allow the browser to start fetching the script earlier than if you just render a<script>component, for example by sending anHTTP Early Hints response.


### Rendering an inline script
To include an inline script, render the<script>component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document<head>.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

function Tracking() {
  return (
    <script>
      ga('send', 'pageview');
    </script>
  );
}

export default function Page() {
  return (
    <ShowRenderedHTML>
      <h1>My Website</h1>
      <Tracking />
      <p>Welcome</p>
    </ShowRenderedHTML>
  );
}


```


--------------------------------------------------------------------------------


# <select>
Source: https://react.dev/reference/react-dom/components/select

Thebuilt-in browser<select>componentlets you render a select box with options.

```jsx
<select>  <option value="someOption">Some option</option>  <option value="otherOption">Other option</option></select>
```

- Reference<select>
- <select>
- UsageDisplaying a select box with optionsProviding a label for a select boxProviding an initially selected optionEnabling multiple selectionReading the select box value when submitting a formControlling a select box with a state variable
- Displaying a select box with options
- Providing a label for a select box
- Providing an initially selected option
- Enabling multiple selection
- Reading the select box value when submitting a form
- Controlling a select box with a state variable

## Reference

### <select>
To display a select box, render thebuilt-in browser<select>component.

```jsx
<select>  <option value="someOption">Some option</option>  <option value="otherOption">Other option</option></select>
```

See more examples below.


#### Props
<select>supports allcommon element props.

You canmake a select box controlledby passing avalueprop:

- value: A string (or an array of strings formultiple={true}). Controls which option is selected. Every value string match thevalueof some<option>nested inside the<select>.
When you passvalue, you must also pass anonChangehandler that updates the passed value.

If your<select>is uncontrolled, you may pass thedefaultValueprop instead:

- defaultValue: A string (or an array of strings formultiple={true}). Specifiesthe initially selected option.
These<select>props are relevant both for uncontrolled and controlled select boxes:

- autoComplete: A string. Specifies one of the possibleautocomplete behaviors.
- autoFocus: A boolean. Iftrue, React will focus the element on mount.
- children:<select>accepts<option>,<optgroup>, and<datalist>components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render<option>tags, each<option>you render must have avalue.
- disabled: A boolean. Iftrue, the select box will not be interactive and will appear dimmed.
- form: A string. Specifies theidof the<form>this select box belongs to. If omitted, it’s the closest parent form.
- multiple: A boolean. Iftrue, the browser allowsmultiple selection.
- name: A string. Specifies the name for this select box that’ssubmitted with the form.
- onChange: AnEventhandlerfunction. Required forcontrolled select boxes.Fires immediately when the user picks a different option. Behaves like the browserinputevent.
- onChangeCapture: A version ofonChangethat fires in thecapture phase.
- onInput: AnEventhandlerfunction. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChangeinstead which works similarly.
- onInputCapture: A version ofonInputthat fires in thecapture phase.
- onInvalid: AnEventhandlerfunction. Fires if an input fails validation on form submit. Unlike the built-ininvalidevent, the ReactonInvalidevent bubbles.
- onInvalidCapture: A version ofonInvalidthat fires in thecapture phase.
- required: A boolean. Iftrue, the value must be provided for the form to submit.
- size: A number. Formultiple={true}selects, specifies the preferred number of initially visible items.

#### Caveats
- Unlike in HTML, passing aselectedattribute to<option>is not supported. Instead, use<select defaultValue>for uncontrolled select boxes and<select value>for controlled select boxes.
- If a select box receives avalueprop, it will betreated as controlled.
- A select box can’t be both controlled and uncontrolled at the same time.
- A select box cannot switch between being controlled or uncontrolled over its lifetime.
- Every controlled select box needs anonChangeevent handler that synchronously updates its backing value.

## Usage

### Displaying a select box with options
Render a<select>with a list of<option>components inside to display a select box. Give each<option>avaluerepresenting the data to be submitted with the form.

```jsx
export default function FruitPicker() {
  return (
    <label>
      Pick a fruit:
      <select name="selectedFruit">
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}


```


### Providing a label for a select box
Typically, you will place every<select>inside a<label>tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.

If you can’t nest<select>into a<label>, associate them by passing the same ID to<select id>and<label htmlFor>.To avoid conflicts between multiple instances of one component, generate such an ID withuseId.

```jsx
import { useId } from 'react';

export default function Form() {
  const vegetableSelectId = useId();
  return (
    <>
      <label>
        Pick a fruit:
        <select name="selectedFruit">
          <option value="apple">Apple</option>
          <option value="banana">Banana</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <hr />
      <label htmlFor={vegetableSelectId}>
        Pick a vegetable:
      </label>
      <select id={vegetableSelectId} name="selectedVegetable">
        <option value="cucumber">Cucumber</option>
        <option value="corn">Corn</option>
        <option value="tomato">Tomato</option>
      </select>
    </>
  );
}


```


### Providing an initially selected option
By default, the browser will select the first<option>in the list. To select a different option by default, pass that<option>’svalueas thedefaultValueto the<select>element.

```jsx
export default function FruitPicker() {
  return (
    <label>
      Pick a fruit:
      <select name="selectedFruit" defaultValue="orange">
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}


```


### Pitfall
Unlike in HTML, passing aselectedattribute to an individual<option>is not supported.


### Enabling multiple selection
Passmultiple={true}to the<select>to let the user select multiple options. In that case, if you also specifydefaultValueto choose the initially selected options, it must be an array.

```jsx
export default function FruitPicker() {
  return (
    <label>
      Pick some fruits:
      <select
        name="selectedFruit"
        defaultValue={['orange', 'banana']}
        multiple={true}
      >
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}


```


### Reading the select box value when submitting a form
Add a<form>around your select box with a<button type="submit">inside. It will call your<form onSubmit>event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by callinge.preventDefault(). Read the form data withnew FormData(e.target).

```jsx
export default function EditPost() {
  function handleSubmit(e) {
    // Prevent the browser from reloading the page
    e.preventDefault();
    // Read the form data
    const form = e.target;
    const formData = new FormData(form);
    // You can pass formData as a fetch body directly:
    fetch('/some-api', { method: form.method, body: formData });
    // You can generate a URL out of it, as the browser does by default:
    console.log(new URLSearchParams(formData).toString());
    // You can work with it as a plain object.
    const formJson = Object.fromEntries(formData.entries());
    console.log(formJson); // (!) This doesn't include multiple select values
    // Or you can get an array of name-value pairs.
    console.log([...formData.entries()]);
  }

  return (
    <form method="post" onSubmit={handleSubmit}>
      <label>
        Pick your favorite fruit:
        <select name="selectedFruit" defaultValue="orange">
          <option value="apple">Apple</option>
          <option value="banana">Banana</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <label>
        Pick all your favorite vegetables:
        <select
          name="selectedVegetables"
          multiple={true}
          defaultValue={['corn', 'tomato']}
        >
          <option value="cucumber">Cucumber</option>
          <option value="corn">Corn</option>
          <option value="tomato">Tomato</option>
        </select>
      </label>
      <hr />
      <button type="reset">Reset</button>
      <button type="submit">Submit</button>
    </form>
  );
}


```


### Note
Give anameto your<select>, for example<select name="selectedFruit" />. Thenameyou specified will be used as a key in the form data, for example{ selectedFruit: "orange" }.

If you use<select multiple={true}>, theFormDatayou’ll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above.


### Pitfall
By default,any<button>inside a<form>will submit it. This can be surprising! If you have your own customButtonReact component, consider returning<button type="button">instead of<button>. Then, to be explicit, use<button type="submit">for buttons thataresupposed to submit the form.


### Controlling a select box with a state variable
A select box like<select />isuncontrolled.Even if youpass an initially selected valuelike<select defaultValue="orange" />, your JSX only specifies the initial value, not the value right now.

To render acontrolledselect box, pass thevalueprop to it.React will force the select box to always have thevalueyou passed. Typically, you will control a select box by declaring astate variable:

```jsx
function FruitPicker() {  const [selectedFruit, setSelectedFruit] = useState('orange'); // Declare a state variable...  // ...  return (    <select      value={selectedFruit} // ...force the select's value to match the state variable...      onChange={e => setSelectedFruit(e.target.value)} // ... and update the state variable on any change!    >      <option value="apple">Apple</option>      <option value="banana">Banana</option>      <option value="orange">Orange</option>    </select>  );}
```

This is useful if you want to re-render some part of the UI in response to every selection.

```jsx
import { useState } from 'react';

export default function FruitPicker() {
  const [selectedFruit, setSelectedFruit] = useState('orange');
  const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']);
  return (
    <>
      <label>
        Pick a fruit:
        <select
          value={selectedFruit}
          onChange={e => setSelectedFruit(e.target.value)}
        >
          <option value="apple">Apple</option>
          <option value="banana">Banana</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <hr />
      <label>
        Pick all your favorite vegetables:
        <select
          multiple={true}
          value={selectedVegs}
          onChange={e => {
            const options = [...e.target.selectedOptions];
            const values = options.map(option => option.value);
            setSelectedVegs(values);
          }}
        >
          <option value="cucumber">Cucumber</option>
          <option value="corn">Corn</option>
          <option value="tomato">Tomato</option>
        </select>
      </label>
      <hr />
      <p>Your favorite fruit: {selectedFruit}</p>
      <p>Your favorite vegetables: {selectedVegs.join(', ')}</p>
    </>
  );
}


```


### Pitfall
If you passvaluewithoutonChange, it will be impossible to select an option.When you control a select box by passing somevalueto it, youforceit to always have the value you passed. So if you pass a state variable as avaluebut forget to update that state variable synchronously during theonChangeevent handler, React will revert the select box after every keystroke back to thevaluethat you specified.

Unlike in HTML, passing aselectedattribute to an individual<option>is not supported.


--------------------------------------------------------------------------------


# <style>
Source: https://react.dev/reference/react-dom/components/style

Thebuilt-in browser<style>componentlets you add inline CSS stylesheets to your document.

```jsx
<style>{` p { color: red; } `}</style>
```

- Reference<style>
- <style>
- UsageRendering an inline CSS stylesheet
- Rendering an inline CSS stylesheet

## Reference

### <style>
To add inline styles to your document, render thebuilt-in browser<style>component. You can render<style>from any component and React willin certain casesplace the corresponding DOM element in the document head and de-duplicate identical styles.

```jsx
<style>{` p { color: red; } `}</style>
```

See more examples below.


#### Props
<style>supports allcommon element props.

- children: a string, required. The contents of the stylesheet.
- precedence: a string. Tells React where to rank the<style>DOM node relative to others in the document<head>, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are<link>or inline<style>tags or loaded usingpreinitfunctions.
- href: a string. Allows React tode-duplicate stylesthat have the samehref.
- media: a string. Restricts the stylesheet to a certainmedia query.
- nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.
- title: a string. Specifies the name of analternative stylesheet.
Props that arenot recommendedfor use with React:

- blocking: a string. If set to"render", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.

#### Special rendering behavior
React can move<style>components to the document’s<head>, de-duplicate identical stylesheets, andsuspendwhile the stylesheet is loading.

To opt into this behavior, provide thehrefandprecedenceprops. React will de-duplicate styles if they have the samehref. The precedence prop tells React where to rank the<style>DOM node relative to others in the document<head>, which determines which stylesheet can override the other.

This special treatment comes with three caveats:

- React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)
- React will drop all extraneous props when using theprecedenceprop (beyondhrefandprecedence).
- React may leave the style in the DOM even after the component that rendered it has been unmounted.

## Usage

### Rendering an inline CSS stylesheet
If a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.

Thehrefprop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the samehref.
If you supply aprecedenceprop, React will reorder inline stylesheets based on the order these values appear in the component tree.

Inline stylesheets will not trigger Suspense boundaries while they’re loading.
Even if they load async resources like fonts or images.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';
import { useId } from 'react';

function PieChart({data, colors}) {
  const id = useId();
  const stylesheet = colors.map((color, index) =>
    `#${id} .color-${index}: \{ color: "${color}"; \}`
  ).join();
  return (
    <>
      <style href={"PieChart-" + JSON.stringify(colors)} precedence="medium">
        {stylesheet}
      </style>
      <svg id={id}>
        …
      </svg>
    </>
  );
}

export default function App() {
  return (
    <ShowRenderedHTML>
      <PieChart data="..." colors={['red', 'green', 'blue']} />
    </ShowRenderedHTML>
  );
}


```


--------------------------------------------------------------------------------


# <textarea>
Source: https://react.dev/reference/react-dom/components/textarea

Thebuilt-in browser<textarea>componentlets you render a multiline text input.

```jsx
<textarea />
```

- Reference<textarea>
- <textarea>
- UsageDisplaying a text areaProviding a label for a text areaProviding an initial value for a text areaReading the text area value when submitting a formControlling a text area with a state variable
- Displaying a text area
- Providing a label for a text area
- Providing an initial value for a text area
- Reading the text area value when submitting a form
- Controlling a text area with a state variable
- TroubleshootingMy text area doesn’t update when I type into itMy text area caret jumps to the beginning on every keystrokeI’m getting an error: “A component is changing an uncontrolled input to be controlled”
- My text area doesn’t update when I type into it
- My text area caret jumps to the beginning on every keystroke
- I’m getting an error: “A component is changing an uncontrolled input to be controlled”

## Reference

### <textarea>
To display a text area, render thebuilt-in browser<textarea>component.

```jsx
<textarea name="postContent" />
```

See more examples below.


#### Props
<textarea>supports allcommon element props.

You canmake a text area controlledby passing avalueprop:

- value: A string. Controls the text inside the text area.
When you passvalue, you must also pass anonChangehandler that updates the passed value.

If your<textarea>is uncontrolled, you may pass thedefaultValueprop instead:

- defaultValue: A string. Specifiesthe initial valuefor a text area.
These<textarea>props are relevant both for uncontrolled and controlled text areas:

- autoComplete: Either'on'or'off'. Specifies the autocomplete behavior.
- autoFocus: A boolean. Iftrue, React will focus the element on mount.
- children:<textarea>does not accept children. To set the initial value, usedefaultValue.
- cols: A number. Specifies the default width in average character widths. Defaults to20.
- disabled: A boolean. Iftrue, the input will not be interactive and will appear dimmed.
- form: A string. Specifies theidof the<form>this input belongs to. If omitted, it’s the closest parent form.
- maxLength: A number. Specifies the maximum length of text.
- minLength: A number. Specifies the minimum length of text.
- name: A string. Specifies the name for this input that’ssubmitted with the form.
- onChange: AnEventhandlerfunction. Required forcontrolled text areas.Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browserinputevent.
- onChangeCapture: A version ofonChangethat fires in thecapture phase.
- onInput: AnEventhandlerfunction. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to useonChangeinstead which works similarly.
- onInputCapture: A version ofonInputthat fires in thecapture phase.
- onInvalid: AnEventhandlerfunction. Fires if an input fails validation on form submit. Unlike the built-ininvalidevent, the ReactonInvalidevent bubbles.
- onInvalidCapture: A version ofonInvalidthat fires in thecapture phase.
- onSelect: AnEventhandlerfunction. Fires after the selection inside the<textarea>changes. React extends theonSelectevent to also fire for empty selection and on edits (which may affect the selection).
- onSelectCapture: A version ofonSelectthat fires in thecapture phase.
- placeholder: A string. Displayed in a dimmed color when the text area value is empty.
- readOnly: A boolean. Iftrue, the text area is not editable by the user.
- required: A boolean. Iftrue, the value must be provided for the form to submit.
- rows: A number. Specifies the default height in average character heights. Defaults to2.
- wrap: Either'hard','soft', or'off'. Specifies how the text should be wrapped when submitting a form.

#### Caveats
- Passing children like<textarea>something</textarea>is not allowed.UsedefaultValuefor initial content.
- If a text area receives a stringvalueprop, it will betreated as controlled.
- A text area can’t be both controlled and uncontrolled at the same time.
- A text area cannot switch between being controlled or uncontrolled over its lifetime.
- Every controlled text area needs anonChangeevent handler that synchronously updates its backing value.

## Usage

### Displaying a text area
Render<textarea>to display a text area. You can specify its default size with therowsandcolsattributes, but by default the user will be able to resize it. To disable resizing, you can specifyresize: nonein the CSS.

```jsx
export default function NewPost() {
  return (
    <label>
      Write your post:
      <textarea name="postContent" rows={4} cols={40} />
    </label>
  );
}


```


### Providing a label for a text area
Typically, you will place every<textarea>inside a<label>tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.

If you can’t nest<textarea>into a<label>, associate them by passing the same ID to<textarea id>and<label htmlFor>.To avoid conflicts between instances of one component, generate such an ID withuseId.

```jsx
import { useId } from 'react';

export default function Form() {
  const postTextAreaId = useId();
  return (
    <>
      <label htmlFor={postTextAreaId}>
        Write your post:
      </label>
      <textarea
        id={postTextAreaId}
        name="postContent"
        rows={4}
        cols={40}
      />
    </>
  );
}


```


### Providing an initial value for a text area
You can optionally specify the initial value for the text area. Pass it as thedefaultValuestring.

```jsx
export default function EditPost() {
  return (
    <label>
      Edit your post:
      <textarea
        name="postContent"
        defaultValue="I really enjoyed biking yesterday!"
        rows={4}
        cols={40}
      />
    </label>
  );
}


```


### Pitfall
Unlike in HTML, passing initial text like<textarea>Some content</textarea>is not supported.


### Reading the text area value when submitting a form
Add a<form>around your textarea with a<button type="submit">inside. It will call your<form onSubmit>event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by callinge.preventDefault(). Read the form data withnew FormData(e.target).

```jsx
export default function EditPost() {
  function handleSubmit(e) {
    // Prevent the browser from reloading the page
    e.preventDefault();

    // Read the form data
    const form = e.target;
    const formData = new FormData(form);

    // You can pass formData as a fetch body directly:
    fetch('/some-api', { method: form.method, body: formData });

    // Or you can work with it as a plain object:
    const formJson = Object.fromEntries(formData.entries());
    console.log(formJson);
  }

  return (
    <form method="post" onSubmit={handleSubmit}>
      <label>
        Post title: <input name="postTitle" defaultValue="Biking" />
      </label>
      <label>
        Edit your post:
        <textarea
          name="postContent"
          defaultValue="I really enjoyed biking yesterday!"
          rows={4}
          cols={40}
        />
      </label>
      <hr />
      <button type="reset">Reset edits</button>
      <button type="submit">Save post</button>
    </form>
  );
}


```


### Note
Give anameto your<textarea>, for example<textarea name="postContent" />. Thenameyou specified will be used as a key in the form data, for example{ postContent: "Your post" }.


### Pitfall
By default,any<button>inside a<form>will submit it. This can be surprising! If you have your own customButtonReact component, consider returning<button type="button">instead of<button>. Then, to be explicit, use<button type="submit">for buttons thataresupposed to submit the form.


### Controlling a text area with a state variable
A text area like<textarea />isuncontrolled.Even if youpass an initial valuelike<textarea defaultValue="Initial text" />, your JSX only specifies the initial value, not the value right now.

To render acontrolledtext area, pass thevalueprop to it.React will force the text area to always have thevalueyou passed. Typically, you will control a text area by declaring astate variable:

```jsx
function NewPost() {  const [postContent, setPostContent] = useState(''); // Declare a state variable...  // ...  return (    <textarea      value={postContent} // ...force the input's value to match the state variable...      onChange={e => setPostContent(e.target.value)} // ... and update the state variable on any edits!    />  );}
```

This is useful if you want to re-render some part of the UI in response to every keystroke.

```jsx
{
  "dependencies": {
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "remarkable": "2.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```


### Pitfall
If you passvaluewithoutonChange, it will be impossible to type into the text area.When you control a text area by passing somevalueto it, youforceit to always have the value you passed. So if you pass a state variable as avaluebut forget to update that state variable synchronously during theonChangeevent handler, React will revert the text area after every keystroke back to thevaluethat you specified.


## Troubleshooting

### My text area doesn’t update when I type into it
If you render a text area withvaluebut noonChange, you will see an error in the console:

```jsx
// 🔴 Bug: controlled text area with no onChange handler<textarea value={something} />
```

As the error message suggests, if you only wanted tospecify theinitialvalue,passdefaultValueinstead:

```jsx
// ✅ Good: uncontrolled text area with an initial value<textarea defaultValue={something} />
```

If you wantto control this text area with a state variable,specify anonChangehandler:

```jsx
// ✅ Good: controlled text area with onChange<textarea value={something} onChange={e => setSomething(e.target.value)} />
```

If the value is intentionally read-only, add areadOnlyprop to suppress the error:

```jsx
// ✅ Good: readonly controlled text area without on change<textarea value={something} readOnly={true} />
```


### My text area caret jumps to the beginning on every keystroke
If youcontrol a text area,you must update its state variable to the text area’s value from the DOM duringonChange.

You can’t update it to something other thane.target.value:

```jsx
function handleChange(e) {  // 🔴 Bug: updating an input to something other than e.target.value  setFirstName(e.target.value.toUpperCase());}
```

You also can’t update it asynchronously:

```jsx
function handleChange(e) {  // 🔴 Bug: updating an input asynchronously  setTimeout(() => {    setFirstName(e.target.value);  }, 100);}
```

To fix your code, update it synchronously toe.target.value:

```jsx
function handleChange(e) {  // ✅ Updating a controlled input to e.target.value synchronously  setFirstName(e.target.value);}
```

If this doesn’t fix the problem, it’s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentallyresetting stateon every re-render. For example, this can happen if the text area or one of its parents always receives a differentkeyattribute, or if you nest component definitions (which is not allowed in React and causes the “inner” component to remount on every render).


### I’m getting an error: “A component is changing an uncontrolled input to be controlled”
If you provide avalueto the component, it must remain a string throughout its lifetime.

You cannot passvalue={undefined}first and later passvalue="some string"because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a stringvalue, notnullorundefined.

If yourvalueis coming from an API or a state variable, it might be initialized tonullorundefined. In that case, either set it to an empty string ('') initially, or passvalue={someValue ?? ''}to ensurevalueis a string.


--------------------------------------------------------------------------------


# <title>
Source: https://react.dev/reference/react-dom/components/title

Thebuilt-in browser<title>componentlets you specify the title of the document.

```jsx
<title>My Blog</title>
```

- Reference<title>
- <title>
- UsageSet the document titleUse variables in the title
- Set the document title
- Use variables in the title

## Reference

### <title>
To specify the title of the document, render thebuilt-in browser<title>component. You can render<title>from any component and React will always place the corresponding DOM element in the document head.

```jsx
<title>My Blog</title>
```

See more examples below.


#### Props
<title>supports allcommon element props.

- children:<title>accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text.

#### Special rendering behavior
React will always place the DOM element corresponding to the<title>component within the document’s<head>, regardless of where in the React tree it is rendered. The<head>is the only valid place for<title>to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render its<title>itself.

There are two exception to this:

- If<title>is within an<svg>component, then there is no special behavior, because in this context it doesn’t represent the document’s title but rather is anaccessibility annotation for that SVG graphic.
- If the<title>has anitemPropprop, there is no special behavior, because in this case it doesn’t represent the document’s title but rather metadata about a specific part of the page.

### Pitfall
Only render a single<title>at a time. If more than one component renders a<title>tag at the same time, React will place all of those titles in the document head. When this happens, the behavior of browsers and search engines is undefined.


## Usage

### Set the document title
Render the<title>component from any component with text as its children. React will put a<title>DOM node in the document<head>.

```jsx
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function ContactUsPage() {
  return (
    <ShowRenderedHTML>
      <title>My Site: Contact Us</title>
      <h1>Contact Us</h1>
      <p>Email us at support@example.com</p>
    </ShowRenderedHTML>
  );
}


```


### Use variables in the title
The children of the<title>component must be a single string of text. (Or a single number or a single object with atoStringmethod.) It might not be obvious, but using JSX curly braces like this:

```jsx
<title>Results page {pageNumber}</title> // 🔴 Problem: This is not a single string
```

… actually causes the<title>component to get a two-element array as its children (the string"Results page"and the value ofpageNumber). This will cause an error. Instead, use string interpolation to pass<title>a single string:

```jsx
<title>{`Results page ${pageNumber}`}</title>
```


--------------------------------------------------------------------------------


# createPortal
Source: https://react.dev/reference/react-dom/createPortal

createPortallets you render some children into a different part of the DOM.

```jsx
<div>  <SomeComponent />  {createPortal(children, domNode, key?)}</div>
```

- ReferencecreatePortal(children, domNode, key?)
- createPortal(children, domNode, key?)
- UsageRendering to a different part of the DOMRendering a modal dialog with a portalRendering React components into non-React server markupRendering React components into non-React DOM nodes
- Rendering to a different part of the DOM
- Rendering a modal dialog with a portal
- Rendering React components into non-React server markup
- Rendering React components into non-React DOM nodes

## Reference

### createPortal(children, domNode, key?)
To create a portal, callcreatePortal, passing some JSX, and the DOM node where it should be rendered:

```jsx
import { createPortal } from 'react-dom';// ...<div>  <p>This child is placed in the parent div.</p>  {createPortal(    <p>This child is placed in the document body.</p>,    document.body  )}</div>
```

See more examples below.

A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.


#### Parameters
- children: Anything that can be rendered with React, such as a piece of JSX (e.g.<div />or<SomeComponent />), aFragment(<>...</>), a string or a number, or an array of these.
children: Anything that can be rendered with React, such as a piece of JSX (e.g.<div />or<SomeComponent />), aFragment(<>...</>), a string or a number, or an array of these.

- domNode: Some DOM node, such as those returned bydocument.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.
domNode: Some DOM node, such as those returned bydocument.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.

- optionalkey: A unique string or number to be used as the portal’skey.
optionalkey: A unique string or number to be used as the portal’skey.


#### Returns
createPortalreturns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the providedchildreninside the provideddomNode.


#### Caveats
- Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in<div onClick>, thatonClickhandler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.

## Usage

### Rendering to a different part of the DOM
Portalslet your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.

To create a portal, render the result ofcreatePortalwithsome JSXand theDOM node where it should go:

```jsx
import { createPortal } from 'react-dom';function MyComponent() {  return (    <div style={{ border: '2px solid black' }}>      <p>This child is placed in the parent div.</p>      {createPortal(        <p>This child is placed in the document body.</p>,        document.body      )}    </div>  );}
```

React will put the DOM nodes forthe JSX you passedinside of theDOM node you provided.

Without a portal, the second<p>would be placed inside the parent<div>, but the portal “teleported” it into thedocument.body:

```jsx
import { createPortal } from 'react-dom';

export default function MyComponent() {
  return (
    <div style={{ border: '2px solid black' }}>
      <p>This child is placed in the parent div.</p>
      {createPortal(
        <p>This child is placed in the document body.</p>,
        document.body
      )}
    </div>
  );
}


```

Notice how the second paragraph visually appears outside the parent<div>with the border. If you inspect the DOM structure with developer tools, you’ll see that the second<p>got placed directly into the<body>:

```jsx
<body>  <div id="root">    ...      <div style="border: 2px solid black">        <p>This child is placed inside the parent div.</p>      </div>    ...  </div>  <p>This child is placed in the document body.</p></body>
```

A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.


### Rendering a modal dialog with a portal
You can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container withoverflow: hiddenor other styles that interfere with the dialog.

In this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.

```jsx
import NoPortalExample from './NoPortalExample';
import PortalExample from './PortalExample';

export default function App() {
  return (
    <>
      <div className="clipping-container">
        <NoPortalExample  />
      </div>
      <div className="clipping-container">
        <PortalExample />
      </div>
    </>
  );
}


```


### Pitfall
It’s important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.

Follow theWAI-ARIA Modal Authoring Practiceswhen creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.


### Rendering React components into non-React server markup
Portals can be useful if your React root is only part of a static or server-rendered page that isn’t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with havingmultiple separate React roots,portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.

```jsx
import { createPortal } from 'react-dom';

const sidebarContentEl = document.getElementById('sidebar-content');

export default function App() {
  return (
    <>
      <MainContent />
      {createPortal(
        <SidebarContent />,
        sidebarContentEl
      )}
    </>
  );
}

function MainContent() {
  return <p>This part is rendered by React</p>;
}

function SidebarContent() {
  return <p>This part is also rendered by React!</p>;
}


```


### Rendering React components into non-React DOM nodes
You can also use a portal to manage the content of a DOM node that’s managed outside of React. For example, suppose you’re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare apopupContainerstate variable to store the DOM node you’re going to render into:

```jsx
const [popupContainer, setPopupContainer] = useState(null);
```

When you create the third-party widget, store the DOM node returned by the widget so you can render into it:

```jsx
useEffect(() => {  if (mapRef.current === null) {    const map = createMapWidget(containerRef.current);    mapRef.current = map;    const popupDiv = addPopupToMapWidget(map);    setPopupContainer(popupDiv);  }}, []);
```

This lets you usecreatePortalto render React content intopopupContaineronce it becomes available:

```jsx
return (  <div style={{ width: 250, height: 250 }} ref={containerRef}>    {popupContainer !== null && createPortal(      <p>Hello from React!</p>,      popupContainer    )}  </div>);
```

Here is a complete example you can play with:

```jsx
import { useRef, useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { createMapWidget, addPopupToMapWidget } from './map-widget.js';

export default function Map() {
  const containerRef = useRef(null);
  const mapRef = useRef(null);
  const [popupContainer, setPopupContainer] = useState(null);

  useEffect(() => {
    if (mapRef.current === null) {
      const map = createMapWidget(containerRef.current);
      mapRef.current = map;
      const popupDiv = addPopupToMapWidget(map);
      setPopupContainer(popupDiv);
    }
  }, []);

  return (
    <div style={{ width: 250, height: 250 }} ref={containerRef}>
      {popupContainer !== null && createPortal(
        <p>Hello from React!</p>,
        popupContainer
      )}
    </div>
  );
}


```


--------------------------------------------------------------------------------


# flushSync
Source: https://react.dev/reference/react-dom/flushSync


### Pitfall
UsingflushSyncis uncommon and can hurt the performance of your app.

flushSynclets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.

```jsx
flushSync(callback)
```

- ReferenceflushSync(callback)
- flushSync(callback)
- UsageFlushing updates for third-party integrations
- Flushing updates for third-party integrations
- TroubleshootingI’m getting an error: “flushSync was called from inside a lifecycle method”
- I’m getting an error: “flushSync was called from inside a lifecycle method”

## Reference

### flushSync(callback)
CallflushSyncto force React to flush any pending work and update the DOM synchronously.

```jsx
import { flushSync } from 'react-dom';flushSync(() => {  setSomething(123);});
```

Most of the time,flushSynccan be avoided. UseflushSyncas last resort.

See more examples below.


#### Parameters
- callback: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of thisflushSynccall, the fallbacks may be re-shown.

#### Returns
flushSyncreturnsundefined.


#### Caveats
- flushSynccan significantly hurt performance. Use sparingly.
- flushSyncmay force pending Suspense boundaries to show theirfallbackstate.
- flushSyncmay run pending Effects and synchronously apply any updates they contain before returning.
- flushSyncmay flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback.

## Usage

### Flushing updates for third-party integrations
When integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. UseflushSyncto force React to flush anystate updatesinside the callback synchronously:

```jsx
flushSync(() => {  setSomething(123);});// By this line, the DOM is updated.
```

This ensures that, by the time the next line of code runs, React has already updated the DOM.

UsingflushSyncis uncommon, and using it often can significantly hurt the performance of your app.If your app only uses React APIs, and does not integrate with third-party libraries,flushSyncshould be unnecessary.

However, it can be helpful for integrating with third-party code like browser APIs.

Some browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.

For example, the browseronbeforeprintAPI allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you useflushSyncinside of theonbeforeprintcallback to immediately “flush” the React state to the DOM. Then, by the time the print dialog opens,isPrintingdisplays “yes”:

```jsx
import { useState, useEffect } from 'react';
import { flushSync } from 'react-dom';

export default function PrintApp() {
  const [isPrinting, setIsPrinting] = useState(false);

  useEffect(() => {
    function handleBeforePrint() {
      flushSync(() => {
        setIsPrinting(true);
      })
    }

    function handleAfterPrint() {
      setIsPrinting(false);
    }

    window.addEventListener('beforeprint', handleBeforePrint);
    window.addEventListener('afterprint', handleAfterPrint);
    return () => {
      window.removeEventListener('beforeprint', handleBeforePrint);
      window.removeEventListener('afterprint', handleAfterPrint);
    }
  }, []);

  return (
    <>
      <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1>
      <button onClick={() => window.print()}>
        Print
      </button>
    </>
  );
}


```

WithoutflushSync, the print dialog will displayisPrintingas “no”. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated.


### Pitfall
flushSynccan significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state.

Most of the time,flushSynccan be avoided, so useflushSyncas a last resort.


## Troubleshooting

### I’m getting an error: “flushSync was called from inside a lifecycle method”
React cannotflushSyncin the middle of a render. If you do, it will noop and warn:

This includes callingflushSyncinside:

- rendering a component.
- useLayoutEffectoruseEffecthooks.
- Class component lifecycle methods.
For example, callingflushSyncin an Effect will noop and warn:

```jsx
import { useEffect } from 'react';import { flushSync } from 'react-dom';function MyComponent() {  useEffect(() => {    // 🚩 Wrong: calling flushSync inside an effect    flushSync(() => {      setSomething(newValue);    });  }, []);  return <div>{/* ... */}</div>;}
```

To fix this, you usually want to move theflushSynccall to an event:

```jsx
function handleClick() {  // ✅ Correct: flushSync in event handlers is safe  flushSync(() => {    setSomething(newValue);  });}
```

If it’s difficult to move to an event, you can deferflushSyncin a microtask:

```jsx
useEffect(() => {  // ✅ Correct: defer flushSync to a microtask  queueMicrotask(() => {    flushSync(() => {      setSomething(newValue);    });  });}, []);
```

This will allow the current render to finish and schedule another syncronous render to flush the updates.


### Pitfall
flushSynccan significantly hurt performance, but this particular pattern is even worse for performance. Exhaust all other options before callingflushSyncin a microtask as an escape hatch.


--------------------------------------------------------------------------------


# Built-in React DOM Hooks
Source: https://react.dev/reference/react-dom/hooks

Thereact-dompackage contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsersand other environmentsseethe React Hooks page. This page lists all the Hooks in thereact-dompackage.


## Form Hooks
Formslet you create interactive controls for submitting information.  To manage forms in your components, use one of these Hooks:

- useFormStatusallows you to make updates to the UI based on the status of a form.
```jsx
function Form({ action }) {  async function increment(n) {    return n + 1;  }  const [count, incrementFormAction] = useActionState(increment, 0);  return (    <form action={action}>      <button formAction={incrementFormAction}>Count: {count}</button>      <Button />    </form>  );}function Button() {  const { pending } = useFormStatus();  return (    <button disabled={pending} type="submit">      Submit    </button>  );}
```


--------------------------------------------------------------------------------


# useFormStatus
Source: https://react.dev/reference/react-dom/hooks/useFormStatus

useFormStatusis a Hook that gives you status information of the last form submission.

```jsx
const { pending, data, method, action } = useFormStatus();
```

- ReferenceuseFormStatus()
- useFormStatus()
- UsageDisplay a pending state during form submissionRead the form data being submitted
- Display a pending state during form submission
- Read the form data being submitted
- Troubleshootingstatus.pendingis nevertrue
- status.pendingis nevertrue

## Reference

### useFormStatus()
TheuseFormStatusHook provides status information of the last form submission.

```jsx
import { useFormStatus } from "react-dom";import action from './actions';function Submit() {  const status = useFormStatus();  return <button disabled={status.pending}>Submit</button>}export default function App() {  return (    <form action={action}>      <Submit />    </form>  );}
```

To get status information, theSubmitcomponent must be rendered within a<form>. The Hook returns information like thependingproperty which tells you if the form is actively submitting.

In the above example,Submituses this information to disable<button>presses while the form is submitting.

See more examples below.


#### Parameters
useFormStatusdoes not take any parameters.


#### Returns
Astatusobject with the following properties:

- pending: A boolean. Iftrue, this means the parent<form>is pending submission. Otherwise,false.
pending: A boolean. Iftrue, this means the parent<form>is pending submission. Otherwise,false.

- data: An object implementing theFormData interfacethat contains the data the parent<form>is submitting. If there is no active submission or no parent<form>, it will benull.
data: An object implementing theFormData interfacethat contains the data the parent<form>is submitting. If there is no active submission or no parent<form>, it will benull.

- method: A string value of either'get'or'post'. This represents whether the parent<form>is submitting with either aGETorPOSTHTTP method. By default, a<form>will use theGETmethod and can be specified by themethodproperty.
method: A string value of either'get'or'post'. This represents whether the parent<form>is submitting with either aGETorPOSTHTTP method. By default, a<form>will use theGETmethod and can be specified by themethodproperty.

- action: A reference to the function passed to theactionprop on the parent<form>. If there is no parent<form>, the property isnull. If there is a URI value provided to theactionprop, or noactionprop specified,status.actionwill benull.

#### Caveats
- TheuseFormStatusHook must be called from a component that is rendered inside a<form>.
- useFormStatuswill only return status information for a parent<form>. It will not return status information for any<form>rendered in that same component or children components.

## Usage

### Display a pending state during form submission
To display a pending state while a form is submitting, you can call theuseFormStatusHook in a component rendered in a<form>and read thependingproperty returned.

Here, we use thependingproperty to indicate the form is submitting.

```jsx
import { useFormStatus } from "react-dom";
import { submitForm } from "./actions.js";

function Submit() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </button>
  );
}

function Form({ action }) {
  return (
    <form action={action}>
      <Submit />
    </form>
  );
}

export default function App() {
  return <Form action={submitForm} />;
}


```


### Pitfall
TheuseFormStatusHook only returns status information for a parent<form>and not for any<form>rendered in the same component calling the Hook, or child components.

```jsx
function Form() {  // 🚩 `pending` will never be true  // useFormStatus does not track the form rendered in this component  const { pending } = useFormStatus();  return <form action={submit}></form>;}
```

Instead calluseFormStatusfrom inside a component that is located inside<form>.

```jsx
function Submit() {  // ✅ `pending` will be derived from the form that wraps the Submit component  const { pending } = useFormStatus();   return <button disabled={pending}>...</button>;}function Form() {  // This is the <form> `useFormStatus` tracks  return (    <form action={submit}>      <Submit />    </form>  );}
```


### Read the form data being submitted
You can use thedataproperty of the status information returned fromuseFormStatusto display what data is being submitted by the user.

Here, we have a form where users can request a username. We can useuseFormStatusto display a temporary status message confirming what username they have requested.

```jsx
import {useState, useMemo, useRef} from 'react';
import {useFormStatus} from 'react-dom';

export default function UsernameForm() {
  const {pending, data} = useFormStatus();

  return (
    <div>
      <h3>Request a Username: </h3>
      <input type="text" name="username" disabled={pending}/>
      <button type="submit" disabled={pending}>
        Submit
      </button>
      <br />
      <p>{data ? `Requesting ${data?.get("username")}...`: ''}</p>
    </div>
  );
}


```


## Troubleshooting

### status.pendingis nevertrue
useFormStatuswill only return status information for a parent<form>.

If the component that callsuseFormStatusis not nested in a<form>,status.pendingwill always returnfalse. VerifyuseFormStatusis called in a component that is a child of a<form>element.

useFormStatuswill not track the status of a<form>rendered in the same component. SeePitfallfor more details.


--------------------------------------------------------------------------------


# preconnect
Source: https://react.dev/reference/react-dom/preconnect

preconnectlets you eagerly connect to a server that you expect to load resources from.

```jsx
preconnect("https://example.com");
```

- Referencepreconnect(href)
- preconnect(href)
- UsagePreconnecting when renderingPreconnecting in an event handler
- Preconnecting when rendering
- Preconnecting in an event handler

## Reference

### preconnect(href)
To preconnect to a host, call thepreconnectfunction fromreact-dom.

```jsx
import { preconnect } from 'react-dom';function AppRoot() {  preconnect("https://example.com");  // ...}
```

See more examples below.

Thepreconnectfunction provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server.


#### Parameters
- href: a string. The URL of the server you want to connect to.

#### Returns
preconnectreturns nothing.


#### Caveats
- Multiple calls topreconnectwith the same server have the same effect as a single call.
- In the browser, you can callpreconnectin any situation: while rendering a component, in an Effect, in an event handler, and so on.
- In server-side rendering or when rendering Server Components,preconnectonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.
- If you know the specific resources you’ll need, you can callother functionsinstead that will start loading the resources right away.
- There is no benefit to preconnecting to the same server the webpage itself is hosted from because it’s already been connected to by the time the hint would be given.

## Usage

### Preconnecting when rendering
Callpreconnectwhen rendering a component if you know that its children will load external resources from that host.

```jsx
import { preconnect } from 'react-dom';function AppRoot() {  preconnect("https://example.com");  return ...;}
```


### Preconnecting in an event handler
Callpreconnectin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```jsx
import { preconnect } from 'react-dom';function CallToAction() {  const onClick = () => {    preconnect('http://example.com');    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
```


--------------------------------------------------------------------------------


# prefetchDNS
Source: https://react.dev/reference/react-dom/prefetchDNS

prefetchDNSlets you eagerly look up the IP of a server that you expect to load resources from.

```jsx
prefetchDNS("https://example.com");
```

- ReferenceprefetchDNS(href)
- prefetchDNS(href)
- UsagePrefetching DNS when renderingPrefetching DNS in an event handler
- Prefetching DNS when rendering
- Prefetching DNS in an event handler

## Reference

### prefetchDNS(href)
To look up a host, call theprefetchDNSfunction fromreact-dom.

```jsx
import { prefetchDNS } from 'react-dom';function AppRoot() {  prefetchDNS("https://example.com");  // ...}
```

See more examples below.

The prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server.


#### Parameters
- href: a string. The URL of the server you want to connect to.

#### Returns
prefetchDNSreturns nothing.


#### Caveats
- Multiple calls toprefetchDNSwith the same server have the same effect as a single call.
- In the browser, you can callprefetchDNSin any situation: while rendering a component, in an Effect, in an event handler, and so on.
- In server-side rendering or when rendering Server Components,prefetchDNSonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.
- If you know the specific resources you’ll need, you can callother functionsinstead that will start loading the resources right away.
- There is no benefit to prefetching the same server the webpage itself is hosted from because it’s already been looked up by the time the hint would be given.
- Compared withpreconnect,prefetchDNSmay be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit.

## Usage

### Prefetching DNS when rendering
CallprefetchDNSwhen rendering a component if you know that its children will load external resources from that host.

```jsx
import { prefetchDNS } from 'react-dom';function AppRoot() {  prefetchDNS("https://example.com");  return ...;}
```


### Prefetching DNS in an event handler
CallprefetchDNSin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```jsx
import { prefetchDNS } from 'react-dom';function CallToAction() {  const onClick = () => {    prefetchDNS('http://example.com');    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
```


--------------------------------------------------------------------------------


# preinit
Source: https://react.dev/reference/react-dom/preinit


### Note
React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

preinitlets you eagerly fetch and evaluate a stylesheet or external script.

```jsx
preinit("https://example.com/script.js", {as: "script"});
```

- Referencepreinit(href, options)
- preinit(href, options)
- UsagePreiniting when renderingPreiniting in an event handler
- Preiniting when rendering
- Preiniting in an event handler

## Reference

### preinit(href, options)
To preinit a script or stylesheet, call thepreinitfunction fromreact-dom.

```jsx
import { preinit } from 'react-dom';function AppRoot() {  preinit("https://example.com/script.js", {as: "script"});  // ...}
```

See more examples below.

Thepreinitfunction provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that youpreinitare executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away.


#### Parameters
- href: a string. The URL of the resource you want to download and execute.
- options: an object. It contains the following properties:as: a required string. The type of resource. Its possible values arescriptandstyle.precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values arereset,low,medium,high.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.integrity: a string. A cryptographic hash of the resource, toverify its authenticity.nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.
- as: a required string. The type of resource. Its possible values arescriptandstyle.
- precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values arereset,low,medium,high.
- crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.
- integrity: a string. A cryptographic hash of the resource, toverify its authenticity.
- nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.
- fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.

#### Returns
preinitreturns nothing.


#### Caveats
- Multiple calls topreinitwith the samehrefhave the same effect as a single call.
- In the browser, you can callpreinitin any situation: while rendering a component, in an Effect, in an event handler, and so on.
- In server-side rendering or when rendering Server Components,preinitonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

## Usage

### Preiniting when rendering
Callpreinitwhen rendering a component if you know that it or its children will use a specific resource, and you’re OK with the resource being evaluated and thereby taking effect immediately upon being downloaded.


#### Examples of preiniting

#### Example1of2:Preiniting an external script
```jsx
import { preinit } from 'react-dom';function AppRoot() {  preinit("https://example.com/script.js", {as: "script"});  return ...;}
```

If you want the browser to download the script but not to execute it right away, usepreloadinstead. If you want to load an ESM module, usepreinitModule.


### Preiniting in an event handler
Callpreinitin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```jsx
import { preinit } from 'react-dom';function CallToAction() {  const onClick = () => {    preinit("https://example.com/wizardStyles.css", {as: "style"});    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
```


--------------------------------------------------------------------------------


# preinitModule
Source: https://react.dev/reference/react-dom/preinitModule


### Note
React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

preinitModulelets you eagerly fetch and evaluate an ESM module.

```jsx
preinitModule("https://example.com/module.js", {as: "script"});
```

- ReferencepreinitModule(href, options)
- preinitModule(href, options)
- UsagePreloading when renderingPreloading in an event handler
- Preloading when rendering
- Preloading in an event handler

## Reference

### preinitModule(href, options)
To preinit an ESM module, call thepreinitModulefunction fromreact-dom.

```jsx
import { preinitModule } from 'react-dom';function AppRoot() {  preinitModule("https://example.com/module.js", {as: "script"});  // ...}
```

See more examples below.

ThepreinitModulefunction provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that youpreinitare executed when they finish downloading.


#### Parameters
- href: a string. The URL of the module you want to download and execute.
- options: an object. It contains the following properties:as: a required string. It must be'script'.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.integrity: a string. A cryptographic hash of the module, toverify its authenticity.nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy.
- as: a required string. It must be'script'.
- crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.
- integrity: a string. A cryptographic hash of the module, toverify its authenticity.
- nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy.

#### Returns
preinitModulereturns nothing.


#### Caveats
- Multiple calls topreinitModulewith the samehrefhave the same effect as a single call.
- In the browser, you can callpreinitModulein any situation: while rendering a component, in an Effect, in an event handler, and so on.
- In server-side rendering or when rendering Server Components,preinitModuleonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

## Usage

### Preloading when rendering
CallpreinitModulewhen rendering a component if you know that it or its children will use a specific module and you’re OK with the module being evaluated and thereby taking effect immediately upon being downloaded.

```jsx
import { preinitModule } from 'react-dom';function AppRoot() {  preinitModule("https://example.com/module.js", {as: "script"});  return ...;}
```

If you want the browser to download the module but not to execute it right away, usepreloadModuleinstead. If you want to preinit a script that isn’t an ESM module, usepreinit.


### Preloading in an event handler
CallpreinitModulein an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```jsx
import { preinitModule } from 'react-dom';function CallToAction() {  const onClick = () => {    preinitModule("https://example.com/module.js", {as: "script"});    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
```


--------------------------------------------------------------------------------


# preload
Source: https://react.dev/reference/react-dom/preload


### Note
React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

preloadlets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use.

```jsx
preload("https://example.com/font.woff2", {as: "font"});
```

- Referencepreload(href, options)
- preload(href, options)
- UsagePreloading when renderingPreloading in an event handler
- Preloading when rendering
- Preloading in an event handler

## Reference

### preload(href, options)
To preload a resource, call thepreloadfunction fromreact-dom.

```jsx
import { preload } from 'react-dom';function AppRoot() {  preload("https://example.com/font.woff2", {as: "font"});  // ...}
```

See more examples below.

Thepreloadfunction provides the browser with a hint that it should start downloading the given resource, which can save time.


#### Parameters
- href: a string. The URL of the resource you want to download.
- options: an object. It contains the following properties:as: a required string. The type of resource. Itspossible valuesareaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to"fetch".referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.integrity: a string. A cryptographic hash of the resource, toverify its authenticity.type: a string. The MIME type of the resource.nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.imageSrcSet: a string. For use only withas: "image". Specifies thesource set of the image.imageSizes: a string. For use only withas: "image". Specifies thesizes of the image.
- as: a required string. The type of resource. Itspossible valuesareaudio,document,embed,fetch,font,image,object,script,style,track,video,worker.
- crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials. It is required whenasis set to"fetch".
- referrerPolicy: a string. TheReferrer headerto send when fetching. Its possible values areno-referrer-when-downgrade(the default),no-referrer,origin,origin-when-cross-origin, andunsafe-url.
- integrity: a string. A cryptographic hash of the resource, toverify its authenticity.
- type: a string. The MIME type of the resource.
- nonce: a string. A cryptographicnonce to allow the resourcewhen using a strict Content Security Policy.
- fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values areauto(the default),high, andlow.
- imageSrcSet: a string. For use only withas: "image". Specifies thesource set of the image.
- imageSizes: a string. For use only withas: "image". Specifies thesizes of the image.

#### Returns
preloadreturns nothing.


#### Caveats
- Multiple equivalent calls topreloadhave the same effect as a single call. Calls topreloadare considered equivalent according to the following rules:Two calls are equivalent if they have the samehref, except:Ifasis set toimage, two calls are equivalent if they have the samehref,imageSrcSet, andimageSizes.
- Two calls are equivalent if they have the samehref, except:
- Ifasis set toimage, two calls are equivalent if they have the samehref,imageSrcSet, andimageSizes.
- In the browser, you can callpreloadin any situation: while rendering a component, in an Effect, in an event handler, and so on.
- In server-side rendering or when rendering Server Components,preloadonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

## Usage

### Preloading when rendering
Callpreloadwhen rendering a component if you know that it or its children will use a specific resource.


#### Examples of preloading

#### Example1of4:Preloading an external script
```jsx
import { preload } from 'react-dom';function AppRoot() {  preload("https://example.com/script.js", {as: "script"});  return ...;}
```

If you want the browser to start executing the script immediately (rather than just downloading it), usepreinitinstead. If you want to load an ESM module, usepreloadModule.


### Preloading in an event handler
Callpreloadin an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```jsx
import { preload } from 'react-dom';function CallToAction() {  const onClick = () => {    preload("https://example.com/wizardStyles.css", {as: "style"});    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
```


--------------------------------------------------------------------------------


# preloadModule
Source: https://react.dev/reference/react-dom/preloadModule


### Note
React-based frameworksfrequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

preloadModulelets you eagerly fetch an ESM module that you expect to use.

```jsx
preloadModule("https://example.com/module.js", {as: "script"});
```

- ReferencepreloadModule(href, options)
- preloadModule(href, options)
- UsagePreloading when renderingPreloading in an event handler
- Preloading when rendering
- Preloading in an event handler

## Reference

### preloadModule(href, options)
To preload an ESM module, call thepreloadModulefunction fromreact-dom.

```jsx
import { preloadModule } from 'react-dom';function AppRoot() {  preloadModule("https://example.com/module.js", {as: "script"});  // ...}
```

See more examples below.

ThepreloadModulefunction provides the browser with a hint that it should start downloading the given module, which can save time.


#### Parameters
- href: a string. The URL of the module you want to download.
- options: an object. It contains the following properties:as: a required string. It must be'script'.crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.integrity: a string. A cryptographic hash of the module, toverify its authenticity.nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy.
- as: a required string. It must be'script'.
- crossOrigin: a string. TheCORS policyto use. Its possible values areanonymousanduse-credentials.
- integrity: a string. A cryptographic hash of the module, toverify its authenticity.
- nonce: a string. A cryptographicnonce to allow the modulewhen using a strict Content Security Policy.

#### Returns
preloadModulereturns nothing.


#### Caveats
- Multiple calls topreloadModulewith the samehrefhave the same effect as a single call.
- In the browser, you can callpreloadModulein any situation: while rendering a component, in an Effect, in an event handler, and so on.
- In server-side rendering or when rendering Server Components,preloadModuleonly has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

## Usage

### Preloading when rendering
CallpreloadModulewhen rendering a component if you know that it or its children will use a specific module.

```jsx
import { preloadModule } from 'react-dom';function AppRoot() {  preloadModule("https://example.com/module.js", {as: "script"});  return ...;}
```

If you want the browser to start executing the module immediately (rather than just downloading it), usepreinitModuleinstead. If you want to load a script that isn’t an ESM module, usepreload.


### Preloading in an event handler
CallpreloadModulein an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```jsx
import { preloadModule } from 'react-dom';function CallToAction() {  const onClick = () => {    preloadModule("https://example.com/module.js", {as: "script"});    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
```


--------------------------------------------------------------------------------


# Server React DOM APIs
Source: https://react.dev/reference/react-dom/server

Thereact-dom/serverAPIs let you server-side render React components to HTML. These APIs are only used on the server at the top level of your app to generate the initial HTML. Aframeworkmay call them for you. Most of your components don’t need to import or use them.


## Server APIs for Web Streams
These methods are only available in the environments withWeb Streams, which includes browsers, Deno, and some modern edge runtimes:

- renderToReadableStreamrenders a React tree to aReadable Web Stream.
- resumeresumesprerenderto aReadable Web Stream.

### Note
Node.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use thededicated Node.js APIsinstead.


## Server APIs for Node.js Streams
These methods are only available in the environments withNode.js Streams:

- renderToPipeableStreamrenders a React tree to a pipeableNode.js Stream.
- resumeToPipeableStreamresumesprerenderToNodeStreamto a pipeableNode.js Stream.

## Legacy Server APIs for non-streaming environments
These methods can be used in the environments that don’t support streams:

- renderToStringrenders a React tree to a string.
- renderToStaticMarkuprenders a non-interactive React tree to a string.
They have limited functionality compared to the streaming APIs.


--------------------------------------------------------------------------------


# renderToPipeableStream
Source: https://react.dev/reference/react-dom/server/renderToPipeableStream

renderToPipeableStreamrenders a React tree to a pipeableNode.js Stream.

```jsx
const { pipe, abort } = renderToPipeableStream(reactNode, options?)
```

- ReferencerenderToPipeableStream(reactNode, options?)
- renderToPipeableStream(reactNode, options?)
- UsageRendering a React tree as HTML to a Node.js StreamStreaming more content as it loadsSpecifying what goes into the shellLogging crashes on the serverRecovering from errors inside the shellRecovering from errors outside the shellSetting the status codeHandling different errors in different waysWaiting for all content to load for crawlers and static generationAborting server rendering
- Rendering a React tree as HTML to a Node.js Stream
- Streaming more content as it loads
- Specifying what goes into the shell
- Logging crashes on the server
- Recovering from errors inside the shell
- Recovering from errors outside the shell
- Setting the status code
- Handling different errors in different ways
- Waiting for all content to load for crawlers and static generation
- Aborting server rendering

### Note
This API is specific to Node.js. Environments withWeb Streams,like Deno and modern edge runtimes, should userenderToReadableStreaminstead.


## Reference

### renderToPipeableStream(reactNode, options?)
CallrenderToPipeableStreamto render your React tree as HTML into aNode.js Stream.

```jsx
import { renderToPipeableStream } from 'react-dom/server';const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  }});
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.
reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.

- optionaloptions: An object with streaming options.optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.optionalonAllReady: A callback that fires when all rendering is complete, including both theshelland all additionalcontent.You can use this instead ofonShellReadyfor crawlers and static generation.If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.optionalonShellReady: A callback that fires right after theinitial shellhas been rendered. You canset the status codeand callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.optionalonShellError: A callback that fires if there was an error rendering the initial shell.  It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shell.optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.
optionaloptions: An object with streaming options.

- optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.
- optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.
- optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.
- optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.
- optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.
- optionalonAllReady: A callback that fires when all rendering is complete, including both theshelland all additionalcontent.You can use this instead ofonShellReadyfor crawlers and static generation.If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.
- optionalonShellReady: A callback that fires right after theinitial shellhas been rendered. You canset the status codeand callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.
- optionalonShellError: A callback that fires if there was an error rendering the initial shell.  It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shell.
- optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.

#### Returns
renderToPipeableStreamreturns an object with two methods:

- pipeoutputs the HTML into the providedWritable Node.js Stream.CallpipeinonShellReadyif you want to enable streaming, or inonAllReadyfor crawlers and static generation.
- abortlets youabort server renderingand render the rest on the client.

## Usage

### Rendering a React tree as HTML to a Node.js Stream
CallrenderToPipeableStreamto render your React tree as HTML into aNode.js Stream:

```jsx
import { renderToPipeableStream } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const { pipe } = renderToPipeableStream(<App />, {    bootstrapScripts: ['/main.js'],    onShellReady() {      response.setHeader('content-type', 'text/html');      pipe(response);    }  });});
```

Along with theroot component, you need to provide a list ofbootstrap<script>paths. Your root component should returnthe entire document including the root<html>tag.

For example, it might look like this:

```jsx
export default function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

React will inject thedoctypeand yourbootstrap<script>tagsinto the resulting HTML stream:

```jsx
<!DOCTYPE html><html>  <!-- ... HTML from your components ... --></html><script src="/main.js" async=""></script>
```

On the client, your bootstrap script shouldhydrate the entiredocumentwith a call tohydrateRoot:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```

This will attach event listeners to the server-generated HTML and make it interactive.


#### Reading CSS and JS asset paths from the build output
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead ofstyles.cssyou might end up withstyles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding"/styles.css"into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```jsx
export default function App({ assetMap }) {  return (    <html>      <head>        ...        <link rel="stylesheet" href={assetMap['styles.css']}></link>        ...      </head>      ...    </html>  );}
```

On the server, render<App assetMap={assetMap} />and pass yourassetMapwith the asset URLs:

```jsx
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};app.use('/', (request, response) => {  const { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, {    bootstrapScripts: [assetMap['main.js']],    onShellReady() {      response.setHeader('content-type', 'text/html');      pipe(response);    }  });});
```

Since your server is now rendering<App assetMap={assetMap} />, you need to render it withassetMapon the client too to avoid hydration errors. You can serialize and passassetMapto the client like this:

```jsx
// You'd need to get this JSON from your build tooling.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};app.use('/', (request, response) => {  const { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, {    // Careful: It's safe to stringify() this because this data isn't user-generated.    bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,    bootstrapScripts: [assetMap['main.js']],    onShellReady() {      response.setHeader('content-type', 'text/html');      pipe(response);    }  });});
```

In the example above, thebootstrapScriptContentoption adds an extra inline<script>tag that sets the globalwindow.assetMapvariable on the client. This lets the client code read the sameassetMap:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server renderAppwith the sameassetMapprop, so there are no hydration errors.


### Streaming more content as it loads
Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Posts />    </ProfileLayout>  );}
```

Imagine that loading data for<Posts />takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this,wrapPostsin a<Suspense>boundary:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

This tells React to start streaming the HTML beforePostsloads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, whenPostsfinishes loading its data, React will send the remaining HTML along with an inline<script>tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with thePostsGlimmer, later replaced by thePosts.

You can furthernest<Suspense>boundariesto create a more granular loading sequence:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
```

In this example, React can start streaming the page even earlier. OnlyProfileLayoutandProfileCovermust finish rendering first because they are not wrapped in any<Suspense>boundary. However, ifSidebar,Friends, orPhotosneed to load some data, React will send the HTML for theBigSpinnerfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.

Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the<script>tags load.

Read more about how streaming HTML works.


### Note
Only Suspense-enabled data sources will activate the Suspense component.They include:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a Promise withuse
Suspensedoes notdetect when data is fetched inside an Effect or event handler.

The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.


### Specifying what goes into the shell
The part of your app outside of any<Suspense>boundaries is calledthe shell:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
```

It determines the earliest loading state that the user may see:

```jsx
<ProfileLayout>  <ProfileCover />  <BigSpinner /></ProfileLayout>
```

If you wrap the whole app into a<Suspense>boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the<Suspense>boundaries so that the shell feelsminimal but complete—like a skeleton of the entire page layout.

TheonShellReadycallback fires when the entire shell has been rendered. Usually, you’ll start streaming then:

```jsx
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  }});
```

By the timeonShellReadyfires, components in nested<Suspense>boundaries might still be loading data.


### Logging crashes on the server
By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

```jsx
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  },  onError(error) {    console.error(error);    logServerCrashReport(error);  }});
```

If you provide a customonErrorimplementation, don’t forget to also log errors to the console like above.


### Recovering from errors inside the shell
In this example, the shell containsProfileLayout,ProfileCover, andPostsGlimmer:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. OverrideonShellErrorto send a fallback HTML that doesn’t rely on server rendering as the last resort:

```jsx
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onError(error) {    console.error(error);    logServerCrashReport(error);  }});
```

If there is an error while generating the shell, bothonErrorandonShellErrorwill fire. UseonErrorfor error reporting and useonShellErrorto send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.


### Recovering from errors outside the shell
In this example, the<Posts />component is wrapped in<Suspense>so it isnota part of the shell:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

If an error happens in thePostscomponent or somewhere inside it, React willtry to recover from it:

1. It will emit the loading fallback for the closest<Suspense>boundary (PostsGlimmer) into the HTML.
1. It will “give up” on trying to render thePostscontent on the server anymore.
1. When the JavaScript code loads on the client, React willretryrenderingPostson the client.
If retrying renderingPostson the clientalsofails, React will throw the error on the client. As with all the errors thrown during rendering, theclosest parent error boundarydetermines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.

If retrying renderingPostson the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the serveronErrorcallback and the clientonRecoverableErrorcallbacks will fire so that you can get notified about the error.


### Setting the status code
Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.

Bydividing your appinto the shell (above all<Suspense>boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, you’ll get theonShellErrorcallback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.

```jsx
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.statusCode = 200;    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onError(error) {    console.error(error);    logServerCrashReport(error);  }});
```

If a componentoutsidethe shell (i.e. inside a<Suspense>boundary) throws an error, React will not stop rendering. This means that theonErrorcallback will fire, but you will still getonShellReadyinstead ofonShellError. This is because React will try to recover from that error on the client,as described above.

However, if you’d like, you can use the fact that something has errored to set the status code:

```jsx
let didError = false;const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.statusCode = didError ? 500 : 200;    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onError(error) {    didError = true;    console.error(error);    logServerCrashReport(error);  }});
```

This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.


### Handling different errors in different ways
You cancreate your ownErrorsubclassesand use theinstanceofoperator to check which error is thrown. For example, you can define a customNotFoundErrorand throw it from your component. Then youronError,onShellReady, andonShellErrorcallbacks can do something different depending on the error type:

```jsx
let didError = false;let caughtError = null;function getStatusCode() {  if (didError) {    if (caughtError instanceof NotFoundError) {      return 404;    } else {      return 500;    }  } else {    return 200;  }}const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.statusCode = getStatusCode();    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {   response.statusCode = getStatusCode();   response.setHeader('content-type', 'text/html');   response.send('<h1>Something went wrong</h1>');   },  onError(error) {    didError = true;    caughtError = error;    console.error(error);    logServerCrashReport(error);  }});
```

Keep in mind that once you emit the shell and start streaming, you can’t change the status code.


### Waiting for all content to load for crawlers and static generation
Streaming offers a better user experience because the user can see the content as it becomes available.

However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.

You can wait for all the content to load using theonAllReadycallback:

```jsx
let didError = false;let isCrawler = // ... depends on your bot detection strategy ...const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    if (!isCrawler) {      response.statusCode = didError ? 500 : 200;      response.setHeader('content-type', 'text/html');      pipe(response);    }  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onAllReady() {    if (isCrawler) {      response.statusCode = didError ? 500 : 200;      response.setHeader('content-type', 'text/html');      pipe(response);          }  },  onError(error) {    didError = true;    console.error(error);    logServerCrashReport(error);  }});
```

A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait foralldata, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.


### Aborting server rendering
You can force the server rendering to “give up” after a timeout:

```jsx
const { pipe, abort } = renderToPipeableStream(<App />, {  // ...});setTimeout(() => {  abort();}, 10000);
```

React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.


--------------------------------------------------------------------------------


# renderToReadableStream
Source: https://react.dev/reference/react-dom/server/renderToReadableStream

renderToReadableStreamrenders a React tree to aReadable Web Stream.

```jsx
const stream = await renderToReadableStream(reactNode, options?)
```

- ReferencerenderToReadableStream(reactNode, options?)
- renderToReadableStream(reactNode, options?)
- UsageRendering a React tree as HTML to a Readable Web StreamStreaming more content as it loadsSpecifying what goes into the shellLogging crashes on the serverRecovering from errors inside the shellRecovering from errors outside the shellSetting the status codeHandling different errors in different waysWaiting for all content to load for crawlers and static generationAborting server rendering
- Rendering a React tree as HTML to a Readable Web Stream
- Streaming more content as it loads
- Specifying what goes into the shell
- Logging crashes on the server
- Recovering from errors inside the shell
- Recovering from errors outside the shell
- Setting the status code
- Handling different errors in different ways
- Waiting for all content to load for crawlers and static generation
- Aborting server rendering

### Note
This API depends onWeb Streams.For Node.js, userenderToPipeableStreaminstead.


## Reference

### renderToReadableStream(reactNode, options?)
CallrenderToReadableStreamto render your React tree as HTML into aReadable Web Stream.

```jsx
import { renderToReadableStream } from 'react-dom/server';async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.
reactNode: A React node you want to render to HTML. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.

- optionaloptions: An object with streaming options.optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.
optionaloptions: An object with streaming options.

- optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.
- optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.
- optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.
- optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.
- optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.
- optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.
- optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.

#### Returns
renderToReadableStreamreturns a Promise:

- If rendering theshellis successful, that Promise will resolve to aReadable Web Stream.
- If rendering the shell fails, the Promise will be rejected.Use this to output a fallback shell.
The returned stream has an additional property:

- allReady: A Promise that resolves when all rendering is complete, including both theshelland all additionalcontent.You canawait stream.allReadybefore returning a responsefor crawlers and static generation.If you do that, you won’t get any progressive loading. The stream will contain the final HTML.

## Usage

### Rendering a React tree as HTML to a Readable Web Stream
CallrenderToReadableStreamto render your React tree as HTML into aReadable Web Stream:

```jsx
import { renderToReadableStream } from 'react-dom/server';async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

Along with theroot component, you need to provide a list ofbootstrap<script>paths. Your root component should returnthe entire document including the root<html>tag.

For example, it might look like this:

```jsx
export default function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

React will inject thedoctypeand yourbootstrap<script>tagsinto the resulting HTML stream:

```jsx
<!DOCTYPE html><html>  <!-- ... HTML from your components ... --></html><script src="/main.js" async=""></script>
```

On the client, your bootstrap script shouldhydrate the entiredocumentwith a call tohydrateRoot:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```

This will attach event listeners to the server-generated HTML and make it interactive.


#### Reading CSS and JS asset paths from the build output
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead ofstyles.cssyou might end up withstyles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding"/styles.css"into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```jsx
export default function App({ assetMap }) {  return (    <html>      <head>        <title>My app</title>        <link rel="stylesheet" href={assetMap['styles.css']}></link>      </head>      ...    </html>  );}
```

On the server, render<App assetMap={assetMap} />and pass yourassetMapwith the asset URLs:

```jsx
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};async function handler(request) {  const stream = await renderToReadableStream(<App assetMap={assetMap} />, {    bootstrapScripts: [assetMap['/main.js']]  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

Since your server is now rendering<App assetMap={assetMap} />, you need to render it withassetMapon the client too to avoid hydration errors. You can serialize and passassetMapto the client like this:

```jsx
// You'd need to get this JSON from your build tooling.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};async function handler(request) {  const stream = await renderToReadableStream(<App assetMap={assetMap} />, {    // Careful: It's safe to stringify() this because this data isn't user-generated.    bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,    bootstrapScripts: [assetMap['/main.js']],  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

In the example above, thebootstrapScriptContentoption adds an extra inline<script>tag that sets the globalwindow.assetMapvariable on the client. This lets the client code read the sameassetMap:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server renderAppwith the sameassetMapprop, so there are no hydration errors.


### Streaming more content as it loads
Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Posts />    </ProfileLayout>  );}
```

Imagine that loading data for<Posts />takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this,wrapPostsin a<Suspense>boundary:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

This tells React to start streaming the HTML beforePostsloads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, whenPostsfinishes loading its data, React will send the remaining HTML along with an inline<script>tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with thePostsGlimmer, later replaced by thePosts.

You can furthernest<Suspense>boundariesto create a more granular loading sequence:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
```

In this example, React can start streaming the page even earlier. OnlyProfileLayoutandProfileCovermust finish rendering first because they are not wrapped in any<Suspense>boundary. However, ifSidebar,Friends, orPhotosneed to load some data, React will send the HTML for theBigSpinnerfallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.

Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the<script>tags load.

Read more about how streaming HTML works.


### Note
Only Suspense-enabled data sources will activate the Suspense component.They include:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a Promise withuse
Suspensedoes notdetect when data is fetched inside an Effect or event handler.

The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.


### Specifying what goes into the shell
The part of your app outside of any<Suspense>boundaries is calledthe shell:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
```

It determines the earliest loading state that the user may see:

```jsx
<ProfileLayout>  <ProfileCover />  <BigSpinner /></ProfileLayout>
```

If you wrap the whole app into a<Suspense>boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the<Suspense>boundaries so that the shell feelsminimal but complete—like a skeleton of the entire page layout.

The async call torenderToReadableStreamwill resolve to astreamas soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with thatstream:

```jsx
async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

By the time thestreamis returned, components in nested<Suspense>boundaries might still be loading data.


### Logging crashes on the server
By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

```jsx
async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js'],    onError(error) {      console.error(error);      logServerCrashReport(error);    }  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
```

If you provide a customonErrorimplementation, don’t forget to also log errors to the console like above.


### Recovering from errors inside the shell
In this example, the shell containsProfileLayout,ProfileCover, andPostsGlimmer:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap yourrenderToReadableStreamcall in atry...catchto send a fallback HTML that doesn’t rely on server rendering as the last resort:

```jsx
async function handler(request) {  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

If there is an error while generating the shell, bothonErrorand yourcatchblock will fire. UseonErrorfor error reporting and use thecatchblock to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.


### Recovering from errors outside the shell
In this example, the<Posts />component is wrapped in<Suspense>so it isnota part of the shell:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

If an error happens in thePostscomponent or somewhere inside it, React willtry to recover from it:

1. It will emit the loading fallback for the closest<Suspense>boundary (PostsGlimmer) into the HTML.
1. It will “give up” on trying to render thePostscontent on the server anymore.
1. When the JavaScript code loads on the client, React willretryrenderingPostson the client.
If retrying renderingPostson the clientalsofails, React will throw the error on the client. As with all the errors thrown during rendering, theclosest parent error boundarydetermines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.

If retrying renderingPostson the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the serveronErrorcallback and the clientonRecoverableErrorcallbacks will fire so that you can get notified about the error.


### Setting the status code
Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.

Bydividing your appinto the shell (above all<Suspense>boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, yourcatchblock will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.

```jsx
async function handler(request) {  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

If a componentoutsidethe shell (i.e. inside a<Suspense>boundary) throws an error, React will not stop rendering. This means that theonErrorcallback will fire, but your code will continue running without getting into thecatchblock. This is because React will try to recover from that error on the client,as described above.

However, if you’d like, you can use the fact that something has errored to set the status code:

```jsx
async function handler(request) {  try {    let didError = false;    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: didError ? 500 : 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.


### Handling different errors in different ways
You cancreate your ownErrorsubclassesand use theinstanceofoperator to check which error is thrown. For example, you can define a customNotFoundErrorand throw it from your component. Then you can save the error inonErrorand do something different before returning the response depending on the error type:

```jsx
async function handler(request) {  let didError = false;  let caughtError = null;  function getStatusCode() {    if (didError) {      if (caughtError instanceof NotFoundError) {        return 404;      } else {        return 500;      }    } else {      return 200;    }  }  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        caughtError = error;        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: getStatusCode(),      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: getStatusCode(),      headers: { 'content-type': 'text/html' },    });  }}
```

Keep in mind that once you emit the shell and start streaming, you can’t change the status code.


### Waiting for all content to load for crawlers and static generation
Streaming offers a better user experience because the user can see the content as it becomes available.

However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.

You can wait for all the content to load by awaiting thestream.allReadyPromise:

```jsx
async function handler(request) {  try {    let didError = false;    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    let isCrawler = // ... depends on your bot detection strategy ...    if (isCrawler) {      await stream.allReady;    }    return new Response(stream, {      status: didError ? 500 : 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
```

A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait foralldata, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.


### Aborting server rendering
You can force the server rendering to “give up” after a timeout:

```jsx
async function handler(request) {  try {    const controller = new AbortController();    setTimeout(() => {      controller.abort();    }, 10000);    const stream = await renderToReadableStream(<App />, {      signal: controller.signal,      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    // ...
```

React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.


--------------------------------------------------------------------------------


# renderToStaticMarkup
Source: https://react.dev/reference/react-dom/server/renderToStaticMarkup

renderToStaticMarkuprenders a non-interactive React tree to an HTML string.

```jsx
const html = renderToStaticMarkup(reactNode, options?)
```

- ReferencerenderToStaticMarkup(reactNode, options?)
- renderToStaticMarkup(reactNode, options?)
- UsageRendering a non-interactive React tree as HTML to a string
- Rendering a non-interactive React tree as HTML to a string

## Reference

### renderToStaticMarkup(reactNode, options?)
On the server, callrenderToStaticMarkupto render your app to HTML.

```jsx
import { renderToStaticMarkup } from 'react-dom/server';const html = renderToStaticMarkup(<Page />);
```

It will produce non-interactive HTML output of your React components.

See more examples below.


#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX node like<Page />.
- optionaloptions: An object for server render.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page.

#### Returns
An HTML string.


#### Caveats
- renderToStaticMarkupoutput cannot be hydrated.
renderToStaticMarkupoutput cannot be hydrated.

- renderToStaticMarkuphas limited Suspense support. If a component suspends,renderToStaticMarkupimmediately sends its fallback as HTML.
renderToStaticMarkuphas limited Suspense support. If a component suspends,renderToStaticMarkupimmediately sends its fallback as HTML.

- renderToStaticMarkupworks in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser,get the HTML by rendering it into a DOM node.
renderToStaticMarkupworks in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser,get the HTML by rendering it into a DOM node.


## Usage

### Rendering a non-interactive React tree as HTML to a string
CallrenderToStaticMarkupto render your app to an HTML string which you can send with your server response:

```jsx
import { renderToStaticMarkup } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const html = renderToStaticMarkup(<Page />);  response.send(html);});
```

This will produce the initial non-interactive HTML output of your React components.


### Pitfall
This method rendersnon-interactive HTML that cannot be hydrated.This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails.

Interactive apps should userenderToStringon the server andhydrateRooton the client.


--------------------------------------------------------------------------------


# renderToString
Source: https://react.dev/reference/react-dom/server/renderToString


### Pitfall
renderToStringdoes not support streaming or waiting for data.See the alternatives.

renderToStringrenders a React tree to an HTML string.

```jsx
const html = renderToString(reactNode, options?)
```

- ReferencerenderToString(reactNode, options?)
- renderToString(reactNode, options?)
- UsageRendering a React tree as HTML to a string
- Rendering a React tree as HTML to a string
- AlternativesMigrating fromrenderToStringto a streaming render on the serverMigrating fromrenderToStringto a static prerender on the serverRemovingrenderToStringfrom the client code
- Migrating fromrenderToStringto a streaming render on the server
- Migrating fromrenderToStringto a static prerender on the server
- RemovingrenderToStringfrom the client code
- TroubleshootingWhen a component suspends, the HTML always contains a fallback
- When a component suspends, the HTML always contains a fallback

## Reference

### renderToString(reactNode, options?)
On the server, callrenderToStringto render your app to HTML.

```jsx
import { renderToString } from 'react-dom/server';const html = renderToString(<App />);
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX node like<App />.
reactNode: A React node you want to render to HTML. For example, a JSX node like<App />.

- optionaloptions: An object for server render.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.
optionaloptions: An object for server render.

- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.

#### Returns
An HTML string.


#### Caveats
- renderToStringhas limited Suspense support. If a component suspends,renderToStringimmediately sends its fallback as HTML.
renderToStringhas limited Suspense support. If a component suspends,renderToStringimmediately sends its fallback as HTML.

- renderToStringworks in the browser, but using it in the client code isnot recommended.
renderToStringworks in the browser, but using it in the client code isnot recommended.


## Usage

### Rendering a React tree as HTML to a string
CallrenderToStringto render your app to an HTML string which you can send with your server response:

```jsx
import { renderToString } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const html = renderToString(<App />);  response.send(html);});
```

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to callhydrateRoottohydratethat server-generated HTML and make it interactive.


### Pitfall
renderToStringdoes not support streaming or waiting for data.See the alternatives.


## Alternatives

### Migrating fromrenderToStringto a streaming render on the server
renderToStringreturns a string immediately, so it does not support streaming content as it loads.

When possible, we recommend using these fully-featured alternatives:

- If you use Node.js, userenderToPipeableStream.
- If you use Deno or a modern edge runtime withWeb Streams, userenderToReadableStream.
You can continue usingrenderToStringif your server environment does not support streams.


### Migrating fromrenderToStringto a static prerender on the server
renderToStringreturns a string immediately, so it does not support waiting for data to load for static HTML generation.

We recommend using these fully-featured alternatives:

- If you use Node.js, useprerenderToNodeStream.
- If you use Deno or a modern edge runtime withWeb Streams, useprerender.
You can continue usingrenderToStringif your static site generation environment does not support streams.


### RemovingrenderToStringfrom the client code
Sometimes,renderToStringis used on the client to convert some component to HTML.

```jsx
// 🚩 Unnecessary: using renderToString on the clientimport { renderToString } from 'react-dom/server';const html = renderToString(<MyIcon />);console.log(html); // For example, "<svg>...</svg>"
```

Importingreact-dom/serveron the clientunnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, usecreateRootand read HTML from the DOM:

```jsx
import { createRoot } from 'react-dom/client';import { flushSync } from 'react-dom';const div = document.createElement('div');const root = createRoot(div);flushSync(() => {  root.render(<MyIcon />);});console.log(div.innerHTML); // For example, "<svg>...</svg>"
```

TheflushSynccall is necessary so that the DOM is updated before reading itsinnerHTMLproperty.


## Troubleshooting

### When a component suspends, the HTML always contains a fallback
renderToStringdoes not fully support Suspense.

If some component suspends (for example, because it’s defined withlazyor fetches data),renderToStringwill not wait for its content to resolve. Instead,renderToStringwill find the closest<Suspense>boundary above it and render itsfallbackprop in the HTML. The content will not appear until the client code loads.

To solve this, use one of therecommended streaming solutions.For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML.


--------------------------------------------------------------------------------


# resume
Source: https://react.dev/reference/react-dom/server/resume

resumestreams a pre-rendered React tree to aReadable Web Stream.

```jsx
const stream = await resume(reactNode, postponedState, options?)
```

- Referenceresume(node, postponedState, options?)
- resume(node, postponedState, options?)
- UsageResuming a prerenderFurther reading
- Resuming a prerender
- Further reading

### Note
This API depends onWeb Streams.For Node.js, useresumeToNodeStreaminstead.


## Reference

### resume(node, postponedState, options?)
Callresumeto resume rendering a pre-rendered React tree as HTML into aReadable Web Stream.

```jsx
import { resume } from 'react-dom/server';import {getPostponedState} from './storage';async function handler(request, writable) {  const postponed = await getPostponedState(request);  const resumeStream = await resume(<App />, postponed);  return resumeStream.pipeTo(writable)}
```

See more examples below.


#### Parameters
- reactNode: The React node you calledprerenderwith. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.
- postponedState: The opaquepostponeobject returned from aprerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).
- optionaloptions: An object with streaming options.optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.
- optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.
- optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.

#### Returns
resumereturns a Promise:

- Ifresumesuccessfully produced ashell, that Promise will resolve to aReadable Web Stream.that can be piped to aWritable Web Stream..
- If an error happens in the shell, the Promise will reject with that error.
The returned stream has an additional property:

- allReady: A Promise that resolves when all rendering is complete. You canawait stream.allReadybefore returning a responsefor crawlers and static generation.If you do that, you won’t get any progressive loading. The stream will contain the final HTML.

#### Caveats
- resumedoes not accept options forbootstrapScripts,bootstrapScriptContent, orbootstrapModules. Instead, you need to pass these options to theprerendercall that generates thepostponedState. You can also inject bootstrap content into the writable stream manually.
- resumedoes not acceptidentifierPrefixsince the prefix needs to be the same in bothprerenderandresume.
- Sincenoncecannot be provided to prerender, you should only providenoncetoresumeif you’re not providing scripts to prerender.
- resumere-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.

## Usage

### Resuming a prerender
```jsx
import {
  flushReadableStreamToFrame,
  getUser,
  Postponed,
  sleep,
} from "./demo-helpers";
import { StrictMode, Suspense, use, useEffect } from "react";
import { prerender } from "react-dom/static";
import { resume } from "react-dom/server";
import { hydrateRoot } from "react-dom/client";

function Header() {
  return <header>Me and my descendants can be prerendered</header>;
}

const { promise: cookies, resolve: resolveCookies } = Promise.withResolvers();

function Main() {
  const { sessionID } = use(cookies);
  const user = getUser(sessionID);

  useEffect(() => {
    console.log("reached interactivity!");
  }, []);

  return (
    <main>
      Hello, {user.name}!
      <button onClick={() => console.log("hydrated!")}>
        Clicking me requires hydration.
      </button>
    </main>
  );
}

function Shell({ children }) {
  // In a real app, this is where you would put your html and body.
  // We're just using tags here we can include in an existing body for demonstration purposes
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}

function App() {
  return (
    <Shell>
      <Suspense fallback="loading header">
        <Header />
      </Suspense>
      <Suspense fallback="loading main">
        <Main />
      </Suspense>
    </Shell>
  );
}

async function main(frame) {
  // Layer 1
  const controller = new AbortController();
  const prerenderedApp = prerender(<App />, {
    signal: controller.signal,
    onError(error) {
      if (error instanceof Postponed) {
      } else {
        console.error(error);
      }
    },
  });
  // We're immediately aborting in a macrotask.
  // Any data fetching that's not available synchronously, or in a microtask, will not have finished.
  setTimeout(() => {
    controller.abort(new Postponed());
  });

  const { prelude, postponed } = await prerenderedApp;
  await flushReadableStreamToFrame(prelude, frame);

  // Layer 2
  // Just waiting here for demonstration purposes.
  // In a real app, the prelude and postponed state would've been serialized in Layer 1 and Layer would deserialize them.
  // The prelude content could be flushed immediated as plain HTML while
  // React is continuing to render from where the prerender left off.
  await sleep(2000);

  // You would get the cookies from the incoming HTTP request
  resolveCookies({ sessionID: "abc" });

  const stream = await resume(<App />, postponed);

  await flushReadableStreamToFrame(stream, frame);

  // Layer 3
  // Just waiting here for demonstration purposes.
  await sleep(2000);

  hydrateRoot(frame.contentWindow.document, <App />);
}

main(document.getElementById("container"));


```


### Further reading
Resuming behaves likerenderToReadableStream. For more examples, check out theusage section ofrenderToReadableStream.
Theusage section ofprerenderincludes examples of how to useprerenderspecifically.


--------------------------------------------------------------------------------


# resumeToPipeableStream
Source: https://react.dev/reference/react-dom/server/resumeToPipeableStream

resumeToPipeableStreamstreams a pre-rendered React tree  to a pipeableNode.js Stream.

```jsx
const {pipe, abort} = await resumeToPipeableStream(reactNode, postponedState, options?)
```

- ReferenceresumeToPipeableStream(node, postponed, options?)
- resumeToPipeableStream(node, postponed, options?)
- UsageFurther reading
- Further reading

### Note
This API is specific to Node.js. Environments withWeb Streams,like Deno and modern edge runtimes, should useresumeinstead.


## Reference

### resumeToPipeableStream(node, postponed, options?)
Callresumeto resume rendering a pre-rendered React tree as HTML into aNode.js Stream.

```jsx
import { resume } from 'react-dom/server';import {getPostponedState} from './storage';async function handler(request, response) {  const postponed = await getPostponedState(request);  const {pipe} = resumeToPipeableStream(<App />, postponed, {    onShellReady: () => {      pipe(response);    }  });}
```

See more examples below.


#### Parameters
- reactNode: The React node you calledprerenderwith. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.
- postponedState: The opaquepostponeobject returned from aprerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).
- optionaloptions: An object with streaming options.optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.optionalonShellReady: A callback that fires right after theshellhas finished. You can callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.optionalonShellError: A callback that fires if there was an error rendering the shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shellor use the prelude.
- optionalnonce: Anoncestring to allow scripts forscript-srcContent-Security-Policy.
- optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.
- optionalonShellReady: A callback that fires right after theshellhas finished. You can callpipehere to start streaming. React willstream the additional contentafter the shell along with the inline<script>tags that replace the HTML loading fallbacks with the content.
- optionalonShellError: A callback that fires if there was an error rendering the shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neitheronShellReadynoronAllReadywill get called, so you canoutput a fallback HTML shellor use the prelude.

#### Returns
resumereturns an object with two methods:

- pipeoutputs the HTML into the providedWritable Node.js Stream.CallpipeinonShellReadyif you want to enable streaming, or inonAllReadyfor crawlers and static generation.
- abortlets youabort server renderingand render the rest on the client.

#### Caveats
- resumeToPipeableStreamdoes not accept options forbootstrapScripts,bootstrapScriptContent, orbootstrapModules. Instead, you need to pass these options to theprerendercall that generates thepostponedState. You can also inject bootstrap content into the writable stream manually.
- resumeToPipeableStreamdoes not acceptidentifierPrefixsince the prefix needs to be the same in bothprerenderandresumeToPipeableStream.
- Sincenoncecannot be provided to prerender, you should only providenoncetoresumeToPipeableStreamif you’re not providing scripts to prerender.
- resumeToPipeableStreamre-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.

## Usage

### Further reading
Resuming behaves likerenderToReadableStream. For more examples, check out theusage section ofrenderToReadableStream.
Theusage section ofprerenderincludes examples of how to useprerenderToNodeStreamspecifically.


--------------------------------------------------------------------------------


# Static React DOM APIs
Source: https://react.dev/reference/react-dom/static

Thereact-dom/staticAPIs let you generate static HTML for React components. They have limited functionality compared to the streaming APIs. Aframeworkmay call them for you. Most of your components don’t need to import or use them.


## Static APIs for Web Streams
These methods are only available in the environments withWeb Streams, which includes browsers, Deno, and some modern edge runtimes:

- prerenderrenders a React tree to static HTML with aReadable Web Stream.
- Experimental onlyresumeAndPrerendercontinues a prerendered React tree to static HTML with aReadable Web Stream.
Node.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use thededicated Node.js APIsinstead.


## Static APIs for Node.js Streams
These methods are only available in the environments withNode.js Streams:

- prerenderToNodeStreamrenders a React tree to static HTML with aNode.js Stream.
- Experimental onlyresumeAndPrerenderToNodeStreamcontinues a prerendered React tree to static HTML with aNode.js Stream.

--------------------------------------------------------------------------------


# prerender
Source: https://react.dev/reference/react-dom/static/prerender

prerenderrenders a React tree to a static HTML string using aWeb Stream.

```jsx
const {prelude, postponed} = await prerender(reactNode, options?)
```

- Referenceprerender(reactNode, options?)
- prerender(reactNode, options?)
- UsageRendering a React tree to a stream of static HTMLRendering a React tree to a string of static HTMLWaiting for all data to loadAborting prerendering
- Rendering a React tree to a stream of static HTML
- Rendering a React tree to a string of static HTML
- Waiting for all data to load
- Aborting prerendering
- TroubleshootingMy stream doesn’t start until the entire app is rendered
- My stream doesn’t start until the entire app is rendered

### Note
This API depends onWeb Streams.For Node.js, useprerenderToNodeStreaminstead.


## Reference

### prerender(reactNode, options?)
Callprerenderto render your app to static HTML.

```jsx
import { prerender } from 'react-dom/static';async function handler(request, response) {  const {prelude} = await prerender(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(prelude, {    headers: { 'content-type': 'text/html' },  });}
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX node like<App />. It is expected to represent the entire document, so the App component should render the<html>tag.
reactNode: A React node you want to render to HTML. For example, a JSX node like<App />. It is expected to represent the entire document, so the App component should render the<html>tag.

- optionaloptions: An object with static generation options.optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.optionalsignal: Anabort signalthat lets youabort prerenderingand render the rest on the client.
optionaloptions: An object with static generation options.

- optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.
- optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.
- optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.
- optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.
- optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.
- optionalsignal: Anabort signalthat lets youabort prerenderingand render the rest on the client.

#### Returns
prerenderreturns a Promise:

- If rendering the is successful, the Promise will resolve to an object containing:prelude: aWeb Streamof HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.postponed: a JSON-serializeable, opaque object that can be passed toresumeifprerenderdid not finish. Otherwisenullindicating that thepreludecontains all the content and no resume is necessary.
- prelude: aWeb Streamof HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
- postponed: a JSON-serializeable, opaque object that can be passed toresumeifprerenderdid not finish. Otherwisenullindicating that thepreludecontains all the content and no resume is necessary.
- If rendering fails, the Promise will be rejected.Use this to output a fallback shell.

#### Caveats
nonceis not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application withCSPit would be inappropriate and insecure to include the nonce value in the prerender itself.


### Note

### When should I useprerender?
The staticprerenderAPI is used for static server-side generation (SSG). UnlikerenderToString,prerenderwaits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API likerenderToReadableStream.

prerendercan be aborted and later either continued withresumeAndPrerenderor resumed withresumeto support partial pre-rendering.


## Usage

### Rendering a React tree to a stream of static HTML
Callprerenderto render your React tree to static HTML into aReadable Web Stream::

```jsx
import { prerender } from 'react-dom/static';async function handler(request) {  const {prelude} = await prerender(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(prelude, {    headers: { 'content-type': 'text/html' },  });}
```

Along with theroot component, you need to provide a list ofbootstrap<script>paths. Your root component should returnthe entire document including the root<html>tag.

For example, it might look like this:

```jsx
export default function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

React will inject thedoctypeand yourbootstrap<script>tagsinto the resulting HTML stream:

```jsx
<!DOCTYPE html><html>  <!-- ... HTML from your components ... --></html><script src="/main.js" async=""></script>
```

On the client, your bootstrap script shouldhydrate the entiredocumentwith a call tohydrateRoot:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```

This will attach event listeners to the static server-generated HTML and make it interactive.


#### Reading CSS and JS asset paths from the build output
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead ofstyles.cssyou might end up withstyles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding"/styles.css"into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```jsx
export default function App({ assetMap }) {  return (    <html>      <head>        <title>My app</title>        <link rel="stylesheet" href={assetMap['styles.css']}></link>      </head>      ...    </html>  );}
```

On the server, render<App assetMap={assetMap} />and pass yourassetMapwith the asset URLs:

```jsx
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};async function handler(request) {  const {prelude} = await prerender(<App assetMap={assetMap} />, {    bootstrapScripts: [assetMap['/main.js']]  });  return new Response(prelude, {    headers: { 'content-type': 'text/html' },  });}
```

Since your server is now rendering<App assetMap={assetMap} />, you need to render it withassetMapon the client too to avoid hydration errors. You can serialize and passassetMapto the client like this:

```jsx
// You'd need to get this JSON from your build tooling.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};async function handler(request) {  const {prelude} = await prerender(<App assetMap={assetMap} />, {    // Careful: It's safe to stringify() this because this data isn't user-generated.    bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,    bootstrapScripts: [assetMap['/main.js']],  });  return new Response(prelude, {    headers: { 'content-type': 'text/html' },  });}
```

In the example above, thebootstrapScriptContentoption adds an extra inline<script>tag that sets the globalwindow.assetMapvariable on the client. This lets the client code read the sameassetMap:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server renderAppwith the sameassetMapprop, so there are no hydration errors.


### Rendering a React tree to a string of static HTML
Callprerenderto render your app to a static HTML string:

```jsx
import { prerender } from 'react-dom/static';async function renderToString() {  const {prelude} = await prerender(<App />, {    bootstrapScripts: ['/main.js']  });  const reader = prelude.getReader();  let content = '';  while (true) {    const {done, value} = await reader.read();    if (done) {      return content;    }    content += Buffer.from(value).toString('utf8');  }}
```

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to callhydrateRoottohydratethat server-generated HTML and make it interactive.


### Waiting for all data to load
prerenderwaits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

Imagine that<Posts />needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, andprerenderwill wait for the suspended content to finish before resolving to the static HTML.


### Note
Only Suspense-enabled data sources will activate the Suspense component.They include:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a Promise withuse
Suspensedoes notdetect when data is fetched inside an Effect or event handler.

The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.


### Aborting prerendering
You can force the prerender to “give up” after a timeout:

```jsx
async function renderToString() {  const controller = new AbortController();  setTimeout(() => {    controller.abort()  }, 10000);  try {    // the prelude will contain all the HTML that was prerendered    // before the controller aborted.    const {prelude} = await prerender(<App />, {      signal: controller.signal,    });    //...
```

Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.

This can be used for partial prerendering together withresumeorresumeAndPrerender.


## Troubleshooting

### My stream doesn’t start until the entire app is rendered
Theprerenderresponse waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.

To stream content as it loads, use a streaming server render API likerenderToReadableStream.


--------------------------------------------------------------------------------


# prerenderToNodeStream
Source: https://react.dev/reference/react-dom/static/prerenderToNodeStream

prerenderToNodeStreamrenders a React tree to a static HTML string using aNode.js Stream.

```jsx
const {prelude, postponed} = await prerenderToNodeStream(reactNode, options?)
```

- ReferenceprerenderToNodeStream(reactNode, options?)
- prerenderToNodeStream(reactNode, options?)
- UsageRendering a React tree to a stream of static HTMLRendering a React tree to a string of static HTMLWaiting for all data to loadAborting prerendering
- Rendering a React tree to a stream of static HTML
- Rendering a React tree to a string of static HTML
- Waiting for all data to load
- Aborting prerendering
- TroubleshootingMy stream doesn’t start until the entire app is rendered
- My stream doesn’t start until the entire app is rendered

### Note
This API is specific to Node.js. Environments withWeb Streams,like Deno and modern edge runtimes, should useprerenderinstead.


## Reference

### prerenderToNodeStream(reactNode, options?)
CallprerenderToNodeStreamto render your app to static HTML.

```jsx
import { prerenderToNodeStream } from 'react-dom/static';// The route handler syntax depends on your backend frameworkapp.use('/', async (request, response) => {  const { prelude } = await prerenderToNodeStream(<App />, {    bootstrapScripts: ['/main.js'],  });  response.setHeader('Content-Type', 'text/plain');  prelude.pipe(response);});
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: A React node you want to render to HTML. For example, a JSX node like<App />. It is expected to represent the entire document, so the App component should render the<html>tag.
reactNode: A React node you want to render to HTML. For example, a JSX node like<App />. It is expected to represent the entire document, so the App component should render the<html>tag.

- optionaloptions: An object with static generation options.optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.optionalsignal: Anabort signalthat lets youabort prerenderingand render the rest on the client.
optionaloptions: An object with static generation options.

- optionalbootstrapScriptContent: If specified, this string will be placed in an inline<script>tag.
- optionalbootstrapScripts: An array of string URLs for the<script>tags to emit on the page. Use this to include the<script>that callshydrateRoot.Omit it if you don’t want to run React on the client at all.
- optionalbootstrapModules: LikebootstrapScripts, but emits<script type="module">instead.
- optionalidentifierPrefix: A string prefix React uses for IDs generated byuseId.Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed tohydrateRoot.
- optionalnamespaceURI: A string with the rootnamespace URIfor the stream. Defaults to regular HTML. Pass'http://www.w3.org/2000/svg'for SVG or'http://www.w3.org/1998/Math/MathML'for MathML.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error. You can also use it toadjust the status codebefore the shell is emitted.
- optionalprogressiveChunkSize: The number of bytes in a chunk.Read more about the default heuristic.
- optionalsignal: Anabort signalthat lets youabort prerenderingand render the rest on the client.

#### Returns
prerenderToNodeStreamreturns a Promise:

- If rendering the is successful, the Promise will resolve to an object containing:prelude: aNode.js Stream.of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.postponed: a JSON-serializeable, opaque object that can be passed toresumeToPipeableStreamifprerenderToNodeStreamdid not finish. Otherwisenullindicating that thepreludecontains all the content and no resume is necessary.
- prelude: aNode.js Stream.of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
- postponed: a JSON-serializeable, opaque object that can be passed toresumeToPipeableStreamifprerenderToNodeStreamdid not finish. Otherwisenullindicating that thepreludecontains all the content and no resume is necessary.
- If rendering fails, the Promise will be rejected.Use this to output a fallback shell.

#### Caveats
nonceis not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application withCSPit would be inappropriate and insecure to include the nonce value in the prerender itself.


### Note

### When should I useprerenderToNodeStream?
The staticprerenderToNodeStreamAPI is used for static server-side generation (SSG). UnlikerenderToString,prerenderToNodeStreamwaits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API likerenderToReadableStream.

prerenderToNodeStreamcan be aborted and resumed later withresumeToPipeableStreamto support partial pre-rendering.


## Usage

### Rendering a React tree to a stream of static HTML
CallprerenderToNodeStreamto render your React tree to static HTML into aNode.js Stream:

```jsx
import { prerenderToNodeStream } from 'react-dom/static';// The route handler syntax depends on your backend frameworkapp.use('/', async (request, response) => {  const { prelude } = await prerenderToNodeStream(<App />, {    bootstrapScripts: ['/main.js'],  });  response.setHeader('Content-Type', 'text/plain');  prelude.pipe(response);});
```

Along with theroot component, you need to provide a list ofbootstrap<script>paths. Your root component should returnthe entire document including the root<html>tag.

For example, it might look like this:

```jsx
export default function App() {  return (    <html>      <head>        <meta charSet="utf-8" />        <meta name="viewport" content="width=device-width, initial-scale=1" />        <link rel="stylesheet" href="/styles.css"></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
```

React will inject thedoctypeand yourbootstrap<script>tagsinto the resulting HTML stream:

```jsx
<!DOCTYPE html><html>  <!-- ... HTML from your components ... --></html><script src="/main.js" async=""></script>
```

On the client, your bootstrap script shouldhydrate the entiredocumentwith a call tohydrateRoot:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
```

This will attach event listeners to the static server-generated HTML and make it interactive.


#### Reading CSS and JS asset paths from the build output
The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead ofstyles.cssyou might end up withstyles.123456.css. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding"/styles.css"into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```jsx
export default function App({ assetMap }) {  return (    <html>      <head>        <title>My app</title>        <link rel="stylesheet" href={assetMap['styles.css']}></link>      </head>      ...    </html>  );}
```

On the server, render<App assetMap={assetMap} />and pass yourassetMapwith the asset URLs:

```jsx
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};app.use('/', async (request, response) => {  const { prelude } = await prerenderToNodeStream(<App />, {    bootstrapScripts: [assetMap['/main.js']]  });  response.setHeader('Content-Type', 'text/html');  prelude.pipe(response);});
```

Since your server is now rendering<App assetMap={assetMap} />, you need to render it withassetMapon the client too to avoid hydration errors. You can serialize and passassetMapto the client like this:

```jsx
// You'd need to get this JSON from your build tooling.const assetMap = {  'styles.css': '/styles.123456.css',  'main.js': '/main.123456.js'};app.use('/', async (request, response) => {  const { prelude } = await prerenderToNodeStream(<App />, {    // Careful: It's safe to stringify() this because this data isn't user-generated.    bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,    bootstrapScripts: [assetMap['/main.js']],  });  response.setHeader('Content-Type', 'text/html');  prelude.pipe(response);});
```

In the example above, thebootstrapScriptContentoption adds an extra inline<script>tag that sets the globalwindow.assetMapvariable on the client. This lets the client code read the sameassetMap:

```jsx
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server renderAppwith the sameassetMapprop, so there are no hydration errors.


### Rendering a React tree to a string of static HTML
CallprerenderToNodeStreamto render your app to a static HTML string:

```jsx
import { prerenderToNodeStream } from 'react-dom/static';async function renderToString() {  const {prelude} = await prerenderToNodeStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Promise((resolve, reject) => {    let data = '';    prelude.on('data', chunk => {      data += chunk;    });    prelude.on('end', () => resolve(data));    prelude.on('error', reject);  });}
```

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to callhydrateRoottohydratethat server-generated HTML and make it interactive.


### Waiting for all data to load
prerenderToNodeStreamwaits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```jsx
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
```

Imagine that<Posts />needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, andprerenderToNodeStreamwill wait for the suspended content to finish before resolving to the static HTML.


### Note
Only Suspense-enabled data sources will activate the Suspense component.They include:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a Promise withuse
Suspensedoes notdetect when data is fetched inside an Effect or event handler.

The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.


### Aborting prerendering
You can force the prerender to “give up” after a timeout:

```jsx
async function renderToString() {  const controller = new AbortController();  setTimeout(() => {    controller.abort()  }, 10000);  try {    // the prelude will contain all the HTML that was prerendered    // before the controller aborted.    const {prelude} = await prerenderToNodeStream(<App />, {      signal: controller.signal,    });    //...
```

Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.

This can be used for partial prerendering together withresumeToPipeableStreamorresumeAndPrerenderToNodeStream.


## Troubleshooting

### My stream doesn’t start until the entire app is rendered
TheprerenderToNodeStreamresponse waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.

To stream content as it loads, use a streaming server render API likerenderToPipeableStream.


--------------------------------------------------------------------------------


# resumeAndPrerender
Source: https://react.dev/reference/react-dom/static/resumeAndPrerender

resumeAndPrerendercontinues a prerendered React tree to a static HTML string using aWeb Stream.

```jsx
const { prelude,postpone } = await resumeAndPrerender(reactNode, postponedState, options?)
```

- ReferenceresumeAndPrerender(reactNode, postponedState, options?)
- resumeAndPrerender(reactNode, postponedState, options?)
- UsageFurther reading
- Further reading

### Note
This API depends onWeb Streams.For Node.js, useresumeAndPrerenderToNodeStreaminstead.


## Reference

### resumeAndPrerender(reactNode, postponedState, options?)
CallresumeAndPrerenderto continue a prerendered React tree to a static HTML string.

```jsx
import { resumeAndPrerender } from 'react-dom/static';import { getPostponedState } from 'storage';async function handler(request, response) {  const postponedState = getPostponedState(request);  const { prelude } = await resumeAndPrerender(<App />, postponedState, {    bootstrapScripts: ['/main.js']  });  return new Response(prelude, {    headers: { 'content-type': 'text/html' },  });}
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: The React node you calledprerender(or a previousresumeAndPrerender) with. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.
- postponedState: The opaquepostponeobject returned from aprerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).
- optionaloptions: An object with streaming options.optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.
- optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.

#### Returns
prerenderreturns a Promise:

- If rendering the is successful, the Promise will resolve to an object containing:prelude: aWeb Streamof HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.postponed: an JSON-serializeable, opaque object that can be passed toresumeorresumeAndPrerenderifprerenderis aborted.
- prelude: aWeb Streamof HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
- postponed: an JSON-serializeable, opaque object that can be passed toresumeorresumeAndPrerenderifprerenderis aborted.
- If rendering fails, the Promise will be rejected.Use this to output a fallback shell.

#### Caveats
nonceis not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application withCSPit would be inappropriate and insecure to include the nonce value in the prerender itself.


### Note

### When should I useresumeAndPrerender?
The staticresumeAndPrerenderAPI is used for static server-side generation (SSG). UnlikerenderToString,resumeAndPrerenderwaits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API likerenderToReadableStream.

resumeAndPrerendercan be aborted and later either continued with anotherresumeAndPrerenderor resumed withresumeto support partial pre-rendering.


## Usage

### Further reading
resumeAndPrerenderbehaves similarly toprerenderbut can be used to continue a previously started prerendering process that was aborted.
For more information about resuming a prerendered tree, see theresume documentation.


--------------------------------------------------------------------------------


# resumeAndPrerenderToNodeStream
Source: https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream

resumeAndPrerenderToNodeStreamcontinues a prerendered React tree to a static HTML string using a aNode.js Stream..

```jsx
const {prelude, postponed} = await resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)
```

- ReferenceresumeAndPrerenderToNodeStream(reactNode, postponedState, options?)
- resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)
- UsageFurther reading
- Further reading

### Note
This API is specific to Node.js. Environments withWeb Streams,like Deno and modern edge runtimes, should useprerenderinstead.


## Reference

### resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)
CallresumeAndPrerenderToNodeStreamto continue a prerendered React tree to a static HTML string.

```jsx
import { resumeAndPrerenderToNodeStream } from 'react-dom/static';import { getPostponedState } from 'storage';async function handler(request, writable) {  const postponedState = getPostponedState(request);  const { prelude } = await resumeAndPrerenderToNodeStream(<App />, JSON.parse(postponedState));  prelude.pipe(writable);}
```

On the client, callhydrateRootto make the server-generated HTML interactive.

See more examples below.


#### Parameters
- reactNode: The React node you calledprerender(or a previousresumeAndPrerenderToNodeStream) with. For example, a JSX element like<App />. It is expected to represent the entire document, so theAppcomponent should render the<html>tag.
- postponedState: The opaquepostponeobject returned from aprerender API, loaded from wherever you stored it (e.g. redis, a file, or S3).
- optionaloptions: An object with streaming options.optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.
- optionalsignal: Anabort signalthat lets youabort server renderingand render the rest on the client.
- optionalonError: A callback that fires whenever there is a server error, whetherrecoverableornot.By default, this only callsconsole.error. If you override it tolog crash reports,make sure that you still callconsole.error.

#### Returns
resumeAndPrerenderToNodeStreamreturns a Promise:

- If rendering the is successful, the Promise will resolve to an object containing:prelude: aWeb Streamof HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.postponed: an JSON-serializeable, opaque object that can be passed toresumeToNodeStreamorresumeAndPrerenderToNodeStreamifresumeAndPrerenderToNodeStreamis aborted.
- prelude: aWeb Streamof HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
- postponed: an JSON-serializeable, opaque object that can be passed toresumeToNodeStreamorresumeAndPrerenderToNodeStreamifresumeAndPrerenderToNodeStreamis aborted.
- If rendering fails, the Promise will be rejected.Use this to output a fallback shell.

#### Caveats
nonceis not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application withCSPit would be inappropriate and insecure to include the nonce value in the prerender itself.


### Note

### When should I useresumeAndPrerenderToNodeStream?
The staticresumeAndPrerenderToNodeStreamAPI is used for static server-side generation (SSG). UnlikerenderToString,resumeAndPrerenderToNodeStreamwaits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API likerenderToReadableStream.

resumeAndPrerenderToNodeStreamcan be aborted and later either continued with anotherresumeAndPrerenderToNodeStreamor resumed withresumeto support partial pre-rendering.


## Usage

### Further reading
resumeAndPrerenderToNodeStreambehaves similarly toprerenderbut can be used to continue a previously started prerendering process that was aborted.
For more information about resuming a prerendered tree, see theresume documentation.


--------------------------------------------------------------------------------


# <Activity>
Source: https://react.dev/reference/react/Activity

<Activity>lets you hide and restore the UI and internal state of its children.

```jsx
<Activity mode={visibility}>  <Sidebar /></Activity>
```

- Reference<Activity>
- <Activity>
- UsageRestoring the state of hidden componentsRestoring the DOM of hidden componentsPre-rendering content that’s likely to become visibleSpeeding up interactions during page load
- Restoring the state of hidden components
- Restoring the DOM of hidden components
- Pre-rendering content that’s likely to become visible
- Speeding up interactions during page load
- TroubleshootingMy hidden components have unwanted side effectsMy hidden components have Effects that aren’t running
- My hidden components have unwanted side effects
- My hidden components have Effects that aren’t running

## Reference

### <Activity>
You can use Activity to hide part of your application:

```jsx
<Activity mode={isShowingSidebar ? "visible" : "hidden"}>  <Sidebar /></Activity>
```

When an Activity boundary ishidden, React will visually hideits childrenusing thedisplay: "none"CSS property. It will also destroy their Effects, cleaning up any active subscriptions.

While hidden, children still re-render in response to new props, albeit at a lower priority than the rest of the content.

When the boundary becomesvisibleagain, React will reveal the children with their previous state restored, and re-create their Effects.

In this way, Activity can be thought of as a mechanism for rendering “background activity”. Rather than completely discarding content that’s likely to become visible again, you can use Activity to maintain and restore that content’s UI and internal state, while ensuring that your hidden content has no unwanted side effects.

See more examples below.


#### Props
- children: The UI you intend to show and hide.
- mode: A string value of either'visible'or'hidden'. If omitted, defaults to'visible'.

#### Caveats
- If an Activity is rendered inside of aViewTransition, and it becomes visible as a result of an update caused bystartTransition, it will activate the ViewTransition’senteranimation. If it becomes hidden, it will activate itsexitanimation.
- AhiddenActivity that just renders text will not render anything rather than rendering hidden text, because there’s no corresponding DOM element to apply visibility changes to. For example,<Activity mode="hidden"><ComponentThatJustReturnsText /></Activity>will not produce any output in the DOM forconst ComponentThatJustReturnsText = () => "Hello, World!".<Activity mode="visible"><ComponentThatJustReturnsText /></Activity>will render visible text.

## Usage

### Restoring the state of hidden components
In React, when you want to conditionally show or hide a component, you typically mount or unmount it based on that condition:

```jsx
{isShowingSidebar && (  <Sidebar />)}
```

But unmounting a component destroys its internal state, which is not always what you want.

When you hide a component using an Activity boundary instead, React will “save” its state for later:

```jsx
<Activity mode={isShowingSidebar ? "visible" : "hidden"}>  <Sidebar /></Activity>
```

This makes it possible to hide and then later restore components in the state they were previously in.

The following example has a sidebar with an expandable section. You can press “Overview” to reveal the three subitems below it. The main app area also has a button that hides and shows the sidebar.

Try expanding the Overview section, and then toggling the sidebar closed then open:

```jsx
import { useState } from 'react';
import Sidebar from './Sidebar.js';

export default function App() {
  const [isShowingSidebar, setIsShowingSidebar] = useState(true);

  return (
    <>
      {isShowingSidebar && (
        <Sidebar />
      )}

      <main>
        <button onClick={() => setIsShowingSidebar(!isShowingSidebar)}>
          Toggle sidebar
        </button>
        <h1>Main content</h1>
      </main>
    </>
  );
}


```

The Overview section always starts out collapsed. Because we unmount the sidebar whenisShowingSidebarflips tofalse, all its internal state is lost.

This is a perfect use case for Activity. We can preserve the internal state of our sidebar, even when visually hiding it.

Let’s replace the conditional rendering of our sidebar with an Activity boundary:

```jsx
// Before{isShowingSidebar && (  <Sidebar />)}// After<Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>  <Sidebar /></Activity>
```

and check out the new behavior:

```jsx
import { Activity, useState } from 'react';

import Sidebar from './Sidebar.js';

export default function App() {
  const [isShowingSidebar, setIsShowingSidebar] = useState(true);

  return (
    <>
      <Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>
        <Sidebar />
      </Activity>

      <main>
        <button onClick={() => setIsShowingSidebar(!isShowingSidebar)}>
          Toggle sidebar
        </button>
        <h1>Main content</h1>
      </main>
    </>
  );
}


```

Our sidebar’s internal state is now restored, without any changes to its implementation.


### Restoring the DOM of hidden components
Since Activity boundaries hide their children usingdisplay: none, their children’s DOM is also preserved when hidden. This makes them great for maintaining ephemeral state in parts of the UI that the user is likely to interact with again.

In this example, the Contact tab has a<textarea>where the user can enter a message. If you enter some text, change to the Home tab, then change back to the Contact tab, the draft message is lost:

```jsx
export default function Contact() {
  return (
    <div>
      <p>Send me a message!</p>

      <textarea />

      <p>You can find me online here:</p>
      <ul>
        <li>admin@mysite.com</li>
        <li>+123456789</li>
      </ul>
    </div>
  );
}


```

This is because we’re fully unmountingContactinApp. When the Contact tab unmounts, the<textarea>element’s internal DOM state is lost.

If we switch to using an Activity boundary to show and hide the active tab, we can preserve the state of each tab’s DOM. Try entering text and switching tabs again, and you’ll see the draft message is no longer reset:

```jsx
import { Activity, useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Contact from './Contact.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('contact');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'contact'}
        onClick={() => setActiveTab('contact')}
      >
        Contact
      </TabButton>

      <hr />

      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      <Activity mode={activeTab === 'contact' ? 'visible' : 'hidden'}>
        <Contact />
      </Activity>
    </>
  );
}


```

Again, the Activity boundary let us preserve the Contact tab’s internal state without changing its implementation.


### Pre-rendering content that’s likely to become visible
So far, we’ve seen how Activity can hide some content that the user has interacted with, without discarding that content’s ephemeral state.

But Activity boundaries can also be used topreparecontent that the user has yet to see for the first time:

```jsx
<Activity mode="hidden">  <SlowComponent /></Activity>
```

When an Activity boundary ishiddenduring its initial render, its children won’t be visible on the page — but they willstill be rendered, albeit at a lower priority than the visible content, and without mounting their Effects.

Thispre-renderingallows the children to load any code or data they need ahead of time, so that later, when the Activity boundary becomes visible, the children can appear faster with reduced loading times.

Let’s look at an example.

In this demo, the Posts tab loads some data. If you press it, you’ll see a Suspense fallback displayed while the data is being fetched:

```jsx
import { useState, Suspense } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Posts from './Posts.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('home');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'posts'}
        onClick={() => setActiveTab('posts')}
      >
        Posts
      </TabButton>

      <hr />

      <Suspense fallback={<h1>🌀 Loading...</h1>}>
        {activeTab === 'home' && <Home />}
        {activeTab === 'posts' && <Posts />}
      </Suspense>
    </>
  );
}


```

This is becauseAppdoesn’t mountPostsuntil its tab is active.

If we updateAppto use an Activity boundary to show and hide the active tab,Postswill be pre-rendered when the app first loads, allowing it to fetch its data before it becomes visible.

Try clicking the Posts tab now:

```jsx
import { Activity, useState, Suspense } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Posts from './Posts.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('home');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'posts'}
        onClick={() => setActiveTab('posts')}
      >
        Posts
      </TabButton>

      <hr />

      <Suspense fallback={<h1>🌀 Loading...</h1>}>
        <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
          <Home />
        </Activity>
        <Activity mode={activeTab === 'posts' ? 'visible' : 'hidden'}>
          <Posts />
        </Activity>
      </Suspense>
    </>
  );
}


```

Postswas able to prepare itself for a faster render, thanks to the hidden Activity boundary.

Pre-rendering components with hidden Activity boundaries is a powerful way to reduce loading times for parts of the UI that the user is likely to interact with next.


### Note
Only Suspense-enabled data sources will be fetched during pre-rendering.They include:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a cached Promise withuse
Activitydoes notdetect data that is fetched inside an Effect.

The exact way you would load data in thePostscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.


### Speeding up interactions during page load
React includes an under-the-hood performance optimization called Selective Hydration. It works by hydrating your app’s initial HTMLin chunks, enabling some components to become interactive even if other components on the page haven’t loaded their code or data yet.

Suspense boundaries participate in Selective Hydration, because they naturally divide your component tree into units that are independent from one another:

```jsx
function Page() {  return (    <>      <MessageComposer />      <Suspense fallback="Loading chats...">        <Chats />      </Suspense>    </>  )}
```

Here,MessageComposercan be fully hydrated during the initial render of the page, even beforeChatsis mounted and starts to fetch its data.

So by breaking up your component tree into discrete units, Suspense allows React to hydrate your app’s server-rendered HTML in chunks, enabling parts of your app to become interactive as fast as possible.

But what about pages that don’t use Suspense?

Take this tabs example:

```jsx
function Page() {  const [activeTab, setActiveTab] = useState('home');  return (    <>      <TabButton onClick={() => setActiveTab('home')}>        Home      </TabButton>      <TabButton onClick={() => setActiveTab('video')}>        Video      </TabButton>      {activeTab === 'home' && (        <Home />      )}      {activeTab === 'video' && (        <Video />      )}    </>  )}
```

Here, React must hydrate the entire page all at once. IfHomeorVideoare slower to render, they could make the tab buttons feel unresponsive during hydration.

Adding Suspense around the active tab would solve this:

```jsx
function Page() {  const [activeTab, setActiveTab] = useState('home');  return (    <>      <TabButton onClick={() => setActiveTab('home')}>        Home      </TabButton>      <TabButton onClick={() => setActiveTab('video')}>        Video      </TabButton>      <Suspense fallback={<Placeholder />}>        {activeTab === 'home' && (          <Home />        )}        {activeTab === 'video' && (          <Video />        )}      </Suspense>    </>  )}
```

…but it would also change the UI, since thePlaceholderfallback would be displayed on the initial render.

Instead, we can use Activity. Since Activity boundaries show and hide their children, they already naturally divide the component tree into independent units. And just like Suspense, this feature allows them to participate in Selective Hydration.

Let’s update our example to use Activity boundaries around the active tab:

```jsx
function Page() {  const [activeTab, setActiveTab] = useState('home');  return (    <>      <TabButton onClick={() => setActiveTab('home')}>        Home      </TabButton>      <TabButton onClick={() => setActiveTab('video')}>        Video      </TabButton>      <Activity mode={activeTab === "home" ? "visible" : "hidden"}>        <Home />      </Activity>      <Activity mode={activeTab === "video" ? "visible" : "hidden"}>        <Video />      </Activity>    </>  )}
```

Now our initial server-rendered HTML looks the same as it did in the original version, but thanks to Activity, React can hydrate the tab buttons first, before it even mountsHomeorVideo.

Thus, in addition to hiding and showing content, Activity boundaries help improve your app’s performance during hydration by letting React know which parts of your page can become interactive in isolation.

And even if your page doesn’t ever hide part of its content, you can still add always-visible Activity boundaries to improve hydration performance:

```jsx
function Page() {  return (    <>      <Post />      <Activity>        <Comments />      </Activity>    </>  );}
```


## Troubleshooting

### My hidden components have unwanted side effects
An Activity boundary hides its content by settingdisplay: noneon its children and cleaning up any of their Effects. So, most well-behaved React components that properly clean up their side effects will already be robust to being hidden by Activity.

But therearesome situations where a hidden component behaves differently than an unmounted one. Most notably, since a hidden component’s DOM is not destroyed, any side effects from that DOM will persist, even after the component is hidden.

As an example, consider a<video>tag. Typically it doesn’t require any cleanup, because even if you’re playing a video, unmounting the tag stops the video and audio from playing in the browser. Try playing the video and then pressing Home in this demo:

```jsx
import { useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Video from './Video.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('video');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'video'}
        onClick={() => setActiveTab('video')}
      >
        Video
      </TabButton>

      <hr />

      {activeTab === 'home' && <Home />}
      {activeTab === 'video' && <Video />}
    </>
  );
}


```

The video stops playing as expected.

Now, let’s say we wanted to preserve the timecode where the user last watched, so that when they tab back to the video, it doesn’t start over from the beginning again.

This is a great use case for Activity!

Let’s updateAppto hide the inactive tab with a hidden Activity boundary instead of unmounting it, and see how the demo behaves this time:

```jsx
import { Activity, useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Video from './Video.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('video');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'video'}
        onClick={() => setActiveTab('video')}
      >
        Video
      </TabButton>

      <hr />

      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      <Activity mode={activeTab === 'video' ? 'visible' : 'hidden'}>
        <Video />
      </Activity>
    </>
  );
}


```

Whoops! The video and audio continue to play even after it’s been hidden, because the tab’s<video>element is still in the DOM.

To fix this, we can add an Effect with a cleanup function that pauses the video:

```jsx
export default function VideoTab() {  const ref = useRef();  useLayoutEffect(() => {    const videoRef = ref.current;    return () => {      videoRef.pause()    }  }, []);  return (    <video      ref={ref}      controls      playsInline      src="..."    />  );}
```

We calluseLayoutEffectinstead ofuseEffectbecause conceptually the clean-up code is tied to the component’s UI being visually hidden. If we used a regular effect, the code could be delayed by (say) a re-suspending Suspense boundary or a View Transition.

Let’s see the new behavior. Try playing the video, switching to the Home tab, then back to the Video tab:

```jsx
import { Activity, useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Video from './Video.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('video');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'video'}
        onClick={() => setActiveTab('video')}
      >
        Video
      </TabButton>

      <hr />

      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      <Activity mode={activeTab === 'video' ? 'visible' : 'hidden'}>
        <Video />
      </Activity>
    </>
  );
}


```

It works great! Our cleanup function ensures that the video stops playing if it’s ever hidden by an Activity boundary, and even better, because the<video>tag is never destroyed, the timecode is preserved, and the video itself doesn’t need to be initialized or downloaded again when the user switches back to keep watching it.

This is a great example of using Activity to preserve ephemeral DOM state for parts of the UI that become hidden, but the user is likely to interact with again soon.

Our example illustrates that for certain tags like<video>, unmounting and hiding have different behavior. If a component renders DOM that has a side effect, and you want to prevent that side effect when an Activity boundary hides it, add an Effect with a return function to clean it up.

The most common cases of this will be from the following tags:

- <video>
- <audio>
- <iframe>
Typically, though, most of your React components should already be robust to being hidden by an Activity boundary. And conceptually, you should think of “hidden” Activities as being unmounted.

To eagerly discover other Effects that don’t have proper cleanup, which is important not only for Activity boundaries but for many other behaviors in React, we recommend using<StrictMode>.


### My hidden components have Effects that aren’t running
When an<Activity>is “hidden”, all its children’s Effects are cleaned up. Conceptually, the children are unmounted, but React saves their state for later. This is a feature of Activity because it means subscriptions won’t be active for hidden parts of the UI, reducing the amount of work needed for hidden content.

If you’re relying on an Effect mounting to clean up a component’s side effects, refactor the Effect to do the work in the returned cleanup function instead.

To eagerly find problematic Effects, we recommend adding<StrictMode>which will eagerly perform Activity unmounts and mounts to catch any unexpected side-effects.


--------------------------------------------------------------------------------


# Children
Source: https://react.dev/reference/react/Children


### Pitfall
UsingChildrenis uncommon and can lead to fragile code.See common alternatives.

Childrenlets you manipulate and transform the JSX you received as thechildrenprop.

```jsx
const mappedChildren = Children.map(children, child =>  <div className="Row">    {child}  </div>);
```

- ReferenceChildren.count(children)Children.forEach(children, fn, thisArg?)Children.map(children, fn, thisArg?)Children.only(children)Children.toArray(children)
- Children.count(children)
- Children.forEach(children, fn, thisArg?)
- Children.map(children, fn, thisArg?)
- Children.only(children)
- Children.toArray(children)
- UsageTransforming childrenRunning some code for each childCounting childrenConverting children to an array
- Transforming children
- Running some code for each child
- Counting children
- Converting children to an array
- AlternativesExposing multiple componentsAccepting an array of objects as a propCalling a render prop to customize rendering
- Exposing multiple components
- Accepting an array of objects as a prop
- Calling a render prop to customize rendering
- TroubleshootingI pass a custom component, but theChildrenmethods don’t show its render result
- I pass a custom component, but theChildrenmethods don’t show its render result

## Reference

### Children.count(children)
CallChildren.count(children)to count the number of children in thechildrendata structure.

```jsx
import { Children } from 'react';function RowList({ children }) {  return (    <>      <h1>Total rows: {Children.count(children)}</h1>      ...    </>  );}
```

See more examples below.


#### Parameters
- children: The value of thechildrenpropreceived by your component.

#### Returns
The number of nodes inside thesechildren.


#### Caveats
- Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed.

### Children.forEach(children, fn, thisArg?)
CallChildren.forEach(children, fn, thisArg?)to run some code for each child in thechildrendata structure.

```jsx
import { Children } from 'react';function SeparatorList({ children }) {  const result = [];  Children.forEach(children, (child, index) => {    result.push(child);    result.push(<hr key={index} />);  });  // ...
```

See more examples below.


#### Parameters
- children: The value of thechildrenpropreceived by your component.
- fn: The function you want to run for each child, similar to thearrayforEachmethodcallback. It will be called with the child as the first argument and its index as the second argument. The index starts at0and increments on each call.
- optionalthisArg: Thethisvaluewith which thefnfunction should be called. If omitted, it’sundefined.

#### Returns
Children.forEachreturnsundefined.


#### Caveats
- Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed.

### Children.map(children, fn, thisArg?)
CallChildren.map(children, fn, thisArg?)to map or transform each child in thechildrendata structure.

```jsx
import { Children } from 'react';function RowList({ children }) {  return (    <div className="RowList">      {Children.map(children, child =>        <div className="Row">          {child}        </div>      )}    </div>  );}
```

See more examples below.


#### Parameters
- children: The value of thechildrenpropreceived by your component.
- fn: The mapping function, similar to thearraymapmethodcallback. It will be called with the child as the first argument and its index as the second argument. The index starts at0and increments on each call. You need to return a React node from this function. This may be an empty node (null,undefined, or a Boolean), a string, a number, a React element, or an array of other React nodes.
- optionalthisArg: Thethisvaluewith which thefnfunction should be called. If omitted, it’sundefined.

#### Returns
Ifchildrenisnullorundefined, returns the same value.

Otherwise, returns a flat array consisting of the nodes you’ve returned from thefnfunction. The returned array will contain all nodes you returned except fornullandundefined.


#### Caveats
- Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed.
Empty nodes (null,undefined, and Booleans), strings, numbers, andReact elementscount as individual nodes. Arrays don’t count as individual nodes, but their children do.The traversal does not go deeper than React elements:they don’t get rendered, and their children aren’t traversed.Fragmentsdon’t get traversed.

- If you return an element or an array of elements with keys fromfn,the returned elements’ keys will be automatically combined with the key of the corresponding original item fromchildren.When you return multiple elements fromfnin an array, their keys only need to be unique locally amongst each other.
If you return an element or an array of elements with keys fromfn,the returned elements’ keys will be automatically combined with the key of the corresponding original item fromchildren.When you return multiple elements fromfnin an array, their keys only need to be unique locally amongst each other.


### Children.only(children)
CallChildren.only(children)to assert thatchildrenrepresent a single React element.

```jsx
function Box({ children }) {  const element = Children.only(children);  // ...
```


#### Parameters
- children: The value of thechildrenpropreceived by your component.

#### Returns
Ifchildrenis a valid element,returns that element.

Otherwise, throws an error.


#### Caveats
- This method alwaysthrows if you pass an array (such as the return value ofChildren.map) aschildren.In other words, it enforces thatchildrenis a single React element, not that it’s an array with a single element.

### Children.toArray(children)
CallChildren.toArray(children)to create an array out of thechildrendata structure.

```jsx
import { Children } from 'react';export default function ReversedList({ children }) {  const result = Children.toArray(children);  result.reverse();  // ...
```


#### Parameters
- children: The value of thechildrenpropreceived by your component.

#### Returns
Returns a flat array of elements inchildren.


#### Caveats
- Empty nodes (null,undefined, and Booleans) will be omitted in the returned array.The returned elements’ keys will be calculated from the original elements’ keys and their level of nesting and position.This ensures that flattening the array does not introduce changes in behavior.

## Usage

### Transforming children
To transform the children JSX that your componentreceives as thechildrenprop,callChildren.map:

```jsx
import { Children } from 'react';function RowList({ children }) {  return (    <div className="RowList">      {Children.map(children, child =>        <div className="Row">          {child}        </div>      )}    </div>  );}
```

In the example above, theRowListwraps every child it receives into a<div className="Row">container. For example, let’s say the parent component passes three<p>tags as thechildrenprop toRowList:

```jsx
<RowList>  <p>This is the first item.</p>  <p>This is the second item.</p>  <p>This is the third item.</p></RowList>
```

Then, with theRowListimplementation above, the final rendered result will look like this:

```jsx
<div className="RowList">  <div className="Row">    <p>This is the first item.</p>  </div>  <div className="Row">    <p>This is the second item.</p>  </div>  <div className="Row">    <p>This is the third item.</p>  </div></div>
```

Children.mapis similar toto transforming arrays withmap().The difference is that thechildrendata structure is consideredopaque.This means that even if it’s sometimes an array, you should not assume it’s an array or any other particular data type. This is why you should useChildren.mapif you need to transform it.

```jsx
import { Children } from 'react';

export default function RowList({ children }) {
  return (
    <div className="RowList">
      {Children.map(children, child =>
        <div className="Row">
          {child}
        </div>
      )}
    </div>
  );
}


```


#### Why is the children prop not always an array?
In React, thechildrenprop is considered anopaquedata structure. This means that you shouldn’t rely on how it is structured. To transform, filter, or count children, you should use theChildrenmethods.

In practice, thechildrendata structure is often represented as an array internally. However, if there is only a single child, then React won’t create an extra array since this would lead to unnecessary memory overhead. As long as you use theChildrenmethods instead of directly introspecting thechildrenprop, your code will not break even if React changes how the data structure is actually implemented.

Even whenchildrenis an array,Children.maphas useful special behavior. For example,Children.mapcombines thekeyson the returned elements with the keys on thechildrenyou’ve passed to it. This ensures the original JSX children don’t “lose” keys even if they get wrapped like in the example above.


### Pitfall
Thechildrendata structuredoes not include rendered outputof the components you pass as JSX. In the example below, thechildrenreceived by theRowListonly contains two items rather than three:

1. <p>This is the first item.</p>
1. <MoreRows />
This is why only two row wrappers are generated in this example:

```jsx
import RowList from './RowList.js';

export default function App() {
  return (
    <RowList>
      <p>This is the first item.</p>
      <MoreRows />
    </RowList>
  );
}

function MoreRows() {
  return (
    <>
      <p>This is the second item.</p>
      <p>This is the third item.</p>
    </>
  );
}


```

There is no way to get the rendered output of an inner componentlike<MoreRows />when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions.


### Running some code for each child
CallChildren.forEachto iterate over each child in thechildrendata structure. It does not return any value and is similar to thearrayforEachmethod.You can use it to run custom logic like constructing your own array.

```jsx
import { Children } from 'react';

export default function SeparatorList({ children }) {
  const result = [];
  Children.forEach(children, (child, index) => {
    result.push(child);
    result.push(<hr key={index} />);
  });
  result.pop(); // Remove the last separator
  return result;
}


```


### Pitfall
As mentioned earlier, there is no way to get the rendered output of an inner component when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions.


### Counting children
CallChildren.count(children)to calculate the number of children.

```jsx
import { Children } from 'react';

export default function RowList({ children }) {
  return (
    <div className="RowList">
      <h1 className="RowListHeader">
        Total rows: {Children.count(children)}
      </h1>
      {Children.map(children, child =>
        <div className="Row">
          {child}
        </div>
      )}
    </div>
  );
}


```


### Pitfall
As mentioned earlier, there is no way to get the rendered output of an inner component when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions.


### Converting children to an array
CallChildren.toArray(children)to turn thechildrendata structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods likefilter,sort, orreverse.

```jsx
import { Children } from 'react';

export default function ReversedList({ children }) {
  const result = Children.toArray(children);
  result.reverse();
  return result;
}


```


### Pitfall
As mentioned earlier, there is no way to get the rendered output of an inner component when manipulatingchildren. This is whyit’s usually better to use one of the alternative solutions.


## Alternatives

### Note
This section describes alternatives to theChildrenAPI (with capitalC) that’s imported like this:

```jsx
import { Children } from 'react';
```

Don’t confuse it withusing thechildrenprop(lowercasec), which is good and encouraged.


### Exposing multiple components
Manipulating children with theChildrenmethods often leads to fragile code. When you pass children to a component in JSX, you don’t usually expect the component to manipulate or transform the individual children.

When you can, try to avoid using theChildrenmethods. For example, if you want every child ofRowListto be wrapped in<div className="Row">, export aRowcomponent, and manually wrap every row into it like this:

```jsx
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList>
      <Row>
        <p>This is the first item.</p>
      </Row>
      <Row>
        <p>This is the second item.</p>
      </Row>
      <Row>
        <p>This is the third item.</p>
      </Row>
    </RowList>
  );
}


```

Unlike usingChildren.map, this approach does not wrap every child automatically.However, this approach has a significant benefit compared to theearlier example withChildren.mapbecause it works even if you keep extracting more components.For example, it still works if you extract your ownMoreRowscomponent:

```jsx
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList>
      <Row>
        <p>This is the first item.</p>
      </Row>
      <MoreRows />
    </RowList>
  );
}

function MoreRows() {
  return (
    <>
      <Row>
        <p>This is the second item.</p>
      </Row>
      <Row>
        <p>This is the third item.</p>
      </Row>
    </>
  );
}


```

This wouldn’t work withChildren.mapbecause it would “see”<MoreRows />as a single child (and a single row).


### Accepting an array of objects as a prop
You can also explicitly pass an array as a prop. For example, thisRowListaccepts arowsarray as a prop:

```jsx
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList rows={[
      { id: 'first', content: <p>This is the first item.</p> },
      { id: 'second', content: <p>This is the second item.</p> },
      { id: 'third', content: <p>This is the third item.</p> }
    ]} />
  );
}


```

Sincerowsis a regular JavaScript array, theRowListcomponent can use built-in array methods likemapon it.

This pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, theTabSwitchercomponent receives an array of objects as thetabsprop:

```jsx
import TabSwitcher from './TabSwitcher.js';

export default function App() {
  return (
    <TabSwitcher tabs={[
      {
        id: 'first',
        header: 'First',
        content: <p>This is the first item.</p>
      },
      {
        id: 'second',
        header: 'Second',
        content: <p>This is the second item.</p>
      },
      {
        id: 'third',
        header: 'Third',
        content: <p>This is the third item.</p>
      }
    ]} />
  );
}


```

Unlike passing the children as JSX, this approach lets you associate some extra data likeheaderwith each item. Because you are working with thetabsdirectly, and it is an array, you do not need theChildrenmethods.


### Calling a render prop to customize rendering
Instead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, theAppcomponent passes arenderContentfunction to theTabSwitchercomponent. TheTabSwitchercomponent callsrenderContentonly for the selected tab:

```jsx
import TabSwitcher from './TabSwitcher.js';

export default function App() {
  return (
    <TabSwitcher
      tabIds={['first', 'second', 'third']}
      getHeader={tabId => {
        return tabId[0].toUpperCase() + tabId.slice(1);
      }}
      renderContent={tabId => {
        return <p>This is the {tabId} item.</p>;
      }}
    />
  );
}


```

A prop likerenderContentis called arender propbecause it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.

Render props are functions, so you can pass information to them. For example, thisRowListcomponent passes theidand theindexof each row to therenderRowrender prop, which usesindexto highlight even rows:

```jsx
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList
      rowIds={['first', 'second', 'third']}
      renderRow={(id, index) => {
        return (
          <Row isHighlighted={index % 2 === 0}>
            <p>This is the {id} item.</p>
          </Row> 
        );
      }}
    />
  );
}


```

This is another example of how parent and child components can cooperate without manipulating the children.


## Troubleshooting

### I pass a custom component, but theChildrenmethods don’t show its render result
Suppose you pass two children toRowListlike this:

```jsx
<RowList>  <p>First item</p>  <MoreRows /></RowList>
```

If you doChildren.count(children)insideRowList, you will get2. Even ifMoreRowsrenders 10 different items, or if it returnsnull,Children.count(children)will still be2. From theRowList’s perspective, it only “sees” the JSX it has received. It does not “see” the internals of theMoreRowscomponent.

The limitation makes it hard to extract a component. This is whyalternativesare preferred to usingChildren.


--------------------------------------------------------------------------------


# Component
Source: https://react.dev/reference/react/Component


### Pitfall
We recommend defining components as functions instead of classes.See how to migrate.

Componentis the base class for the React components defined asJavaScript classes.Class components are still supported by React, but we don’t recommend using them in new code.

```jsx
class Greeting extends Component {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

- ReferenceComponentcontextpropsstateconstructor(props)componentDidCatch(error, info)componentDidMount()componentDidUpdate(prevProps, prevState, snapshot?)componentWillMount()componentWillReceiveProps(nextProps)componentWillUpdate(nextProps, nextState)componentWillUnmount()forceUpdate(callback?)getSnapshotBeforeUpdate(prevProps, prevState)render()setState(nextState, callback?)shouldComponentUpdate(nextProps, nextState, nextContext)UNSAFE_componentWillMount()UNSAFE_componentWillReceiveProps(nextProps, nextContext)UNSAFE_componentWillUpdate(nextProps, nextState)static contextTypestatic defaultPropsstatic getDerivedStateFromError(error)static getDerivedStateFromProps(props, state)
- Component
- context
- props
- state
- constructor(props)
- componentDidCatch(error, info)
- componentDidMount()
- componentDidUpdate(prevProps, prevState, snapshot?)
- componentWillMount()
- componentWillReceiveProps(nextProps)
- componentWillUpdate(nextProps, nextState)
- componentWillUnmount()
- forceUpdate(callback?)
- getSnapshotBeforeUpdate(prevProps, prevState)
- render()
- setState(nextState, callback?)
- shouldComponentUpdate(nextProps, nextState, nextContext)
- UNSAFE_componentWillMount()
- UNSAFE_componentWillReceiveProps(nextProps, nextContext)
- UNSAFE_componentWillUpdate(nextProps, nextState)
- static contextType
- static defaultProps
- static getDerivedStateFromError(error)
- static getDerivedStateFromProps(props, state)
- UsageDefining a class componentAdding state to a class componentAdding lifecycle methods to a class componentCatching rendering errors with an Error Boundary
- Defining a class component
- Adding state to a class component
- Adding lifecycle methods to a class component
- Catching rendering errors with an Error Boundary
- AlternativesMigrating a simple component from a class to a functionMigrating a component with state from a class to a functionMigrating a component with lifecycle methods from a class to a functionMigrating a component with context from a class to a function
- Migrating a simple component from a class to a function
- Migrating a component with state from a class to a function
- Migrating a component with lifecycle methods from a class to a function
- Migrating a component with context from a class to a function

## Reference

### Component
To define a React component as a class, extend the built-inComponentclass and define arendermethod:

```jsx
import { Component } from 'react';class Greeting extends Component {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

Only therendermethod is required, other methods are optional.

See more examples below.


### context
Thecontextof a class component is available asthis.context. It is only available if you specifywhichcontext you want to receive usingstatic contextType.

A class component can only read one context at a time.

```jsx
class Button extends Component {  static contextType = ThemeContext;  render() {    const theme = this.context;    const className = 'button-' + theme;    return (      <button className={className}>        {this.props.children}      </button>    );  }}
```


### Note
Readingthis.contextin class components is equivalent touseContextin function components.

See how to migrate.


### props
The props passed to a class component are available asthis.props.

```jsx
class Greeting extends Component {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}<Greeting name="Taylor" />
```


### Note
Readingthis.propsin class components is equivalent todeclaring propsin function components.

See how to migrate.


### state
The state of a class component is available asthis.state. Thestatefield must be an object. Do not mutate the state directly. If you wish to change the state, callsetStatewith the new state.

```jsx
class Counter extends Component {  state = {    age: 42,  };  handleAgeChange = () => {    this.setState({      age: this.state.age + 1     });  };  render() {    return (      <>        <button onClick={this.handleAgeChange}>        Increment age        </button>        <p>You are {this.state.age}.</p>      </>    );  }}
```


### Note
Definingstatein class components is equivalent to callinguseStatein function components.

See how to migrate.


### constructor(props)
Theconstructorruns before your class componentmounts(gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state andbindyour class methods to the class instance:

```jsx
class Counter extends Component {  constructor(props) {    super(props);    this.state = { counter: 0 };    this.handleClick = this.handleClick.bind(this);  }  handleClick() {    // ...  }
```

If you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using thepublic class field syntaxwhich is supported both by modern browsers and tools likeBabel:

```jsx
class Counter extends Component {  state = { counter: 0 };  handleClick = () => {    // ...  }
```

A constructor should not contain any side effects or subscriptions.


#### Parameters
- props: The component’s initial props.

#### Returns
constructorshould not return anything.


#### Caveats
- Do not run any side effects or subscriptions in the constructor. Instead, usecomponentDidMountfor that.
Do not run any side effects or subscriptions in the constructor. Instead, usecomponentDidMountfor that.

- Inside a constructor, you need to callsuper(props)before any other statement. If you don’t do that,this.propswill beundefinedwhile the constructor runs, which can be confusing and cause bugs.
Inside a constructor, you need to callsuper(props)before any other statement. If you don’t do that,this.propswill beundefinedwhile the constructor runs, which can be confusing and cause bugs.

- Constructor is the only place where you can assignthis.statedirectly. In all other methods, you need to usethis.setState()instead. Do not callsetStatein the constructor.
Constructor is the only place where you can assignthis.statedirectly. In all other methods, you need to usethis.setState()instead. Do not callsetStatein the constructor.

- When you useserver rendering,the constructor will run on the server too, followed by therendermethod. However, lifecycle methods likecomponentDidMountorcomponentWillUnmountwill not run on the server.
When you useserver rendering,the constructor will run on the server too, followed by therendermethod. However, lifecycle methods likecomponentDidMountorcomponentWillUnmountwill not run on the server.

- WhenStrict Modeis on, React will callconstructortwice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of theconstructor.
WhenStrict Modeis on, React will callconstructortwice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of theconstructor.


### Note
There is no exact equivalent forconstructorin function components. To declare state in a function component, calluseState.To avoid recalculating the initial state,pass a function touseState.


### componentDidCatch(error, info)
If you definecomponentDidCatch, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.

Typically, it is used together withstatic getDerivedStateFromErrorwhich lets you update state in response to an error and display an error message to the user. A component with these methods is called anError Boundary.

See an example.


#### Parameters
- error: The error that was thrown. In practice, it will usually be an instance ofErrorbut this is not guaranteed because JavaScript allows tothrowany value, including strings or evennull.
error: The error that was thrown. In practice, it will usually be an instance ofErrorbut this is not guaranteed because JavaScript allows tothrowany value, including strings or evennull.

- info: An object containing additional information about the error. ItscomponentStackfield contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.
info: An object containing additional information about the error. ItscomponentStackfield contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.


#### Returns
componentDidCatchshould not return anything.


#### Caveats
- In the past, it was common to callsetStateinsidecomponentDidCatchin order to update the UI and display the fallback error message. This is deprecated in favor of definingstatic getDerivedStateFromError.
In the past, it was common to callsetStateinsidecomponentDidCatchin order to update the UI and display the fallback error message. This is deprecated in favor of definingstatic getDerivedStateFromError.

- Production and development builds of React slightly differ in the waycomponentDidCatchhandles errors. In development, the errors will bubble up towindow, which means that anywindow.onerrororwindow.addEventListener('error', callback)will intercept the errors that have been caught bycomponentDidCatch. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught bycomponentDidCatch.
Production and development builds of React slightly differ in the waycomponentDidCatchhandles errors. In development, the errors will bubble up towindow, which means that anywindow.onerrororwindow.addEventListener('error', callback)will intercept the errors that have been caught bycomponentDidCatch. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught bycomponentDidCatch.


### Note
There is no direct equivalent forcomponentDidCatchin function components yet. If you’d like to avoid creating class components, write a singleErrorBoundarycomponent like above and use it throughout your app. Alternatively, you can use thereact-error-boundarypackage which does that for you.


### componentDidMount()
If you define thecomponentDidMountmethod, React will call it when your component is added(mounted)to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.

If you implementcomponentDidMount, you usually need to implement other lifecycle methods to avoid bugs. For example, ifcomponentDidMountreads some state or props, you also have to implementcomponentDidUpdateto handle their changes, andcomponentWillUnmountto clean up whatevercomponentDidMountwas doing.

```jsx
class ChatRoom extends Component {  state = {    serverUrl: 'https://localhost:1234'  };  componentDidMount() {    this.setupConnection();  }  componentDidUpdate(prevProps, prevState) {    if (      this.props.roomId !== prevProps.roomId ||      this.state.serverUrl !== prevState.serverUrl    ) {      this.destroyConnection();      this.setupConnection();    }  }  componentWillUnmount() {    this.destroyConnection();  }  // ...}
```

See more examples.


#### Parameters
componentDidMountdoes not take any parameters.


#### Returns
componentDidMountshould not return anything.


#### Caveats
- WhenStrict Modeis on, in development React will callcomponentDidMount, then immediately callcomponentWillUnmount,and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes.
WhenStrict Modeis on, in development React will callcomponentDidMount, then immediately callcomponentWillUnmount,and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes.

- Although you may callsetStateimmediately incomponentDidMount, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in theconstructorinstead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.
Although you may callsetStateimmediately incomponentDidMount, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in theconstructorinstead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.


### Note
For many use cases, definingcomponentDidMount,componentDidUpdate, andcomponentWillUnmounttogether in class components is equivalent to callinguseEffectin function components. In the rare cases where it’s important for the code to run before browser paint,useLayoutEffectis a closer match.

See how to migrate.


### componentDidUpdate(prevProps, prevState, snapshot?)
If you define thecomponentDidUpdatemethod, React will call it immediately after your component has been re-rendered with updated props or state.  This method is not called for the initial render.

You can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together withcomponentDidMountandcomponentWillUnmount:

```jsx
class ChatRoom extends Component {  state = {    serverUrl: 'https://localhost:1234'  };  componentDidMount() {    this.setupConnection();  }  componentDidUpdate(prevProps, prevState) {    if (      this.props.roomId !== prevProps.roomId ||      this.state.serverUrl !== prevState.serverUrl    ) {      this.destroyConnection();      this.setupConnection();    }  }  componentWillUnmount() {    this.destroyConnection();  }  // ...}
```

See more examples.


#### Parameters
- prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed.
prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed.

- prevState: State before the update. CompareprevStatetothis.stateto determine what changed.
prevState: State before the update. CompareprevStatetothis.stateto determine what changed.

- snapshot: If you implementedgetSnapshotBeforeUpdate,snapshotwill contain the value you returned from that method. Otherwise, it will beundefined.
snapshot: If you implementedgetSnapshotBeforeUpdate,snapshotwill contain the value you returned from that method. Otherwise, it will beundefined.


#### Returns
componentDidUpdateshould not return anything.


#### Caveats
- componentDidUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.
componentDidUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.

- The logic insidecomponentDidUpdateshould usually be wrapped in conditions comparingthis.propswithprevProps, andthis.statewithprevState. Otherwise, there’s a risk of creating infinite loops.
The logic insidecomponentDidUpdateshould usually be wrapped in conditions comparingthis.propswithprevProps, andthis.statewithprevState. Otherwise, there’s a risk of creating infinite loops.

- Although you may callsetStateimmediately incomponentDidUpdate, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.
Although you may callsetStateimmediately incomponentDidUpdate, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though therenderwill be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.


### Note
For many use cases, definingcomponentDidMount,componentDidUpdate, andcomponentWillUnmounttogether in class components is equivalent to callinguseEffectin function components. In the rare cases where it’s important for the code to run before browser paint,useLayoutEffectis a closer match.

See how to migrate.


### componentWillMount()

### Deprecated
This API has been renamed fromcomponentWillMounttoUNSAFE_componentWillMount.The old name has been deprecated. In a future major version of React, only the new name will work.

Run therename-unsafe-lifecyclescodemodto automatically update your components.


### componentWillReceiveProps(nextProps)

### Deprecated
This API has been renamed fromcomponentWillReceivePropstoUNSAFE_componentWillReceiveProps.The old name has been deprecated. In a future major version of React, only the new name will work.

Run therename-unsafe-lifecyclescodemodto automatically update your components.


### componentWillUpdate(nextProps, nextState)

### Deprecated
This API has been renamed fromcomponentWillUpdatetoUNSAFE_componentWillUpdate.The old name has been deprecated. In a future major version of React, only the new name will work.

Run therename-unsafe-lifecyclescodemodto automatically update your components.


### componentWillUnmount()
If you define thecomponentWillUnmountmethod, React will call it before your component is removed(unmounted)from the screen. This is a common place to cancel data fetching or remove subscriptions.

The logic insidecomponentWillUnmountshould “mirror” the logic insidecomponentDidMount.For example, ifcomponentDidMountsets up a subscription,componentWillUnmountshould clean up that subscription. If the cleanup logic in yourcomponentWillUnmountreads some props or state, you will usually also need to implementcomponentDidUpdateto clean up resources (such as subscriptions) corresponding to the old props and state.

```jsx
class ChatRoom extends Component {  state = {    serverUrl: 'https://localhost:1234'  };  componentDidMount() {    this.setupConnection();  }  componentDidUpdate(prevProps, prevState) {    if (      this.props.roomId !== prevProps.roomId ||      this.state.serverUrl !== prevState.serverUrl    ) {      this.destroyConnection();      this.setupConnection();    }  }  componentWillUnmount() {    this.destroyConnection();  }  // ...}
```

See more examples.


#### Parameters
componentWillUnmountdoes not take any parameters.


#### Returns
componentWillUnmountshould not return anything.


#### Caveats
- WhenStrict Modeis on, in development React will callcomponentDidMount,then immediately callcomponentWillUnmount, and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes.

### Note
For many use cases, definingcomponentDidMount,componentDidUpdate, andcomponentWillUnmounttogether in class components is equivalent to callinguseEffectin function components. In the rare cases where it’s important for the code to run before browser paint,useLayoutEffectis a closer match.

See how to migrate.


### forceUpdate(callback?)
Forces a component to re-render.

Usually, this is not necessary. If your component’srendermethod only reads fromthis.props,this.state, orthis.context,it will re-render automatically when you callsetStateinside your component or one of its parents. However, if your component’srendermethod reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s whatforceUpdatelets you do.

Try to avoid all uses offorceUpdateand only read fromthis.propsandthis.stateinrender.


#### Parameters
- optionalcallbackIf specified, React will call thecallbackyou’ve provided after the update is committed.

#### Returns
forceUpdatedoes not return anything.


#### Caveats
- If you callforceUpdate, React will re-render without callingshouldComponentUpdate.

### Note
Reading an external data source and forcing class components to re-render in response to its changes withforceUpdatehas been superseded byuseSyncExternalStorein function components.


### getSnapshotBeforeUpdate(prevProps, prevState)
If you implementgetSnapshotBeforeUpdate, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter tocomponentDidUpdate.

For example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:

```jsx
class ScrollingList extends React.Component {  constructor(props) {    super(props);    this.listRef = React.createRef();  }  getSnapshotBeforeUpdate(prevProps, prevState) {    // Are we adding new items to the list?    // Capture the scroll position so we can adjust scroll later.    if (prevProps.list.length < this.props.list.length) {      const list = this.listRef.current;      return list.scrollHeight - list.scrollTop;    }    return null;  }  componentDidUpdate(prevProps, prevState, snapshot) {    // If we have a snapshot value, we've just added new items.    // Adjust scroll so these new items don't push the old ones out of view.    // (snapshot here is the value returned from getSnapshotBeforeUpdate)    if (snapshot !== null) {      const list = this.listRef.current;      list.scrollTop = list.scrollHeight - snapshot;    }  }  render() {    return (      <div ref={this.listRef}>{/* ...contents... */}</div>    );  }}
```

In the above example, it is important to read thescrollHeightproperty directly ingetSnapshotBeforeUpdate. It is not safe to read it inrender,UNSAFE_componentWillReceiveProps, orUNSAFE_componentWillUpdatebecause there is a potential time gap between these methods getting called and React updating the DOM.


#### Parameters
- prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed.
prevProps: Props before the update. CompareprevPropstothis.propsto determine what changed.

- prevState: State before the update. CompareprevStatetothis.stateto determine what changed.
prevState: State before the update. CompareprevStatetothis.stateto determine what changed.


#### Returns
You should return a snapshot value of any type that you’d like, ornull. The value you returned will be passed as the third argument tocomponentDidUpdate.


#### Caveats
- getSnapshotBeforeUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.

### Note
At the moment, there is no equivalent togetSnapshotBeforeUpdatefor function components. This use case is very uncommon, but if you have the need for it, for now you’ll have to write a class component.


### render()
Therendermethod is the only required method in a class component.

Therendermethod should specify what you want to appear on the screen, for example:

```jsx
import { Component } from 'react';class Greeting extends Component {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

React may callrenderat any moment, so you shouldn’t assume that it runs at a particular time. Usually, therendermethod should return a piece ofJSX, but a fewother return types(like strings) are supported. To calculate the returned JSX, therendermethod can readthis.props,this.state, andthis.context.

You should write therendermethod as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods likecomponentDidMount.


#### Parameters
renderdoes not take any parameters.


#### Returns
rendercan return any valid React node. This includes React elements such as<div />, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes.


#### Caveats
- rendershould be written as a pure function of props, state, and context. It should not have side effects.
rendershould be written as a pure function of props, state, and context. It should not have side effects.

- renderwill not get called ifshouldComponentUpdateis defined and returnsfalse.
renderwill not get called ifshouldComponentUpdateis defined and returnsfalse.

- WhenStrict Modeis on, React will callrendertwice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of therendermethod.
WhenStrict Modeis on, React will callrendertwice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of therendermethod.

- There is no one-to-one correspondence between therendercall and the subsequentcomponentDidMountorcomponentDidUpdatecall. Some of therendercall results may be discarded by React when it’s beneficial.
There is no one-to-one correspondence between therendercall and the subsequentcomponentDidMountorcomponentDidUpdatecall. Some of therendercall results may be discarded by React when it’s beneficial.


### setState(nextState, callback?)
CallsetStateto update the state of your React component.

```jsx
class Form extends Component {  state = {    name: 'Taylor',  };  handleNameChange = (e) => {    const newName = e.target.value;    this.setState({      name: newName    });  }  render() {    return (      <>        <input value={this.state.name} onChange={this.handleNameChange} />        <p>Hello, {this.state.name}.</p>      </>    );  }}
```

setStateenqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.


### Pitfall
CallingsetStatedoes notchange the current state in the already executing code:

```jsx
function handleClick() {  console.log(this.state.name); // "Taylor"  this.setState({    name: 'Robin'  });  console.log(this.state.name); // Still "Taylor"!}
```

It only affects whatthis.statewill return starting from thenextrender.

You can also pass a function tosetState. It lets you update state based on the previous state:

```jsx
  handleIncreaseAge = () => {    this.setState(prevState => {      return {        age: prevState.age + 1      };    });  }
```

You don’t have to do this, but it’s handy if you want to update state multiple times during the same event.


#### Parameters
- nextState: Either an object or a function.If you pass an object asnextState, it will be shallowly merged intothis.state.If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged intothis.state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.
nextState: Either an object or a function.

- If you pass an object asnextState, it will be shallowly merged intothis.state.
- If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged intothis.state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.
- optionalcallback: If specified, React will call thecallbackyou’ve provided after the update is committed.
optionalcallback: If specified, React will call thecallbackyou’ve provided after the update is committed.


#### Returns
setStatedoes not return anything.


#### Caveats
- Think ofsetStateas arequestrather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it influshSync,but this may hurt performance.
Think ofsetStateas arequestrather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it influshSync,but this may hurt performance.

- setStatedoes not updatethis.stateimmediately. This makes readingthis.stateright after callingsetStatea potential pitfall. Instead, usecomponentDidUpdateor the setStatecallbackargument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function tonextStateas described above.
setStatedoes not updatethis.stateimmediately. This makes readingthis.stateright after callingsetStatea potential pitfall. Instead, usecomponentDidUpdateor the setStatecallbackargument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function tonextStateas described above.


### Note
CallingsetStatein class components is similar to calling asetfunctionin function components.

See how to migrate.


### shouldComponentUpdate(nextProps, nextState, nextContext)
If you defineshouldComponentUpdate, React will call it to determine whether a re-render can be skipped.

If you are confident you want to write it by hand, you may comparethis.propswithnextPropsandthis.statewithnextStateand returnfalseto tell React the update can be skipped.

```jsx
class Rectangle extends Component {  state = {    isHovered: false  };  shouldComponentUpdate(nextProps, nextState) {    if (      nextProps.position.x === this.props.position.x &&      nextProps.position.y === this.props.position.y &&      nextProps.size.width === this.props.size.width &&      nextProps.size.height === this.props.size.height &&      nextState.isHovered === this.state.isHovered    ) {      // Nothing has changed, so a re-render is unnecessary      return false;    }    return true;  }  // ...}
```

React callsshouldComponentUpdatebefore rendering when new props or state are being received. Defaults totrue. This method is not called for the initial render or whenforceUpdateis used.


#### Parameters
- nextProps: The next props that the component is about to render with. ComparenextPropstothis.propsto determine what changed.
- nextState: The next state that the component is about to render with. ComparenextStatetothis.stateto determine what changed.
- nextContext: The next context that the component is about to render with. ComparenextContexttothis.contextto determine what changed. Only available if you specifystatic contextType.

#### Returns
Returntrueif you want the component to re-render. That’s the default behavior.

Returnfalseto tell React that re-rendering can be skipped.


#### Caveats
- This methodonlyexists as a performance optimization. If your component breaks without it, fix that first.
This methodonlyexists as a performance optimization. If your component breaks without it, fix that first.

- Consider usingPureComponentinstead of writingshouldComponentUpdateby hand.PureComponentshallowly compares props and state, and reduces the chance that you’ll skip a necessary update.
Consider usingPureComponentinstead of writingshouldComponentUpdateby hand.PureComponentshallowly compares props and state, and reduces the chance that you’ll skip a necessary update.

- We do not recommend doing deep equality checks or usingJSON.stringifyinshouldComponentUpdate. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.
We do not recommend doing deep equality checks or usingJSON.stringifyinshouldComponentUpdate. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.

- Returningfalsedoes not prevent child components from re-rendering whentheirstate changes.
Returningfalsedoes not prevent child components from re-rendering whentheirstate changes.

- Returningfalsedoes notguaranteethat the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.
Returningfalsedoes notguaranteethat the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.


### Note
Optimizing class components withshouldComponentUpdateis similar to optimizing function components withmemo.Function components also offer more granular optimization withuseMemo.


### UNSAFE_componentWillMount()
If you defineUNSAFE_componentWillMount, React will call it immediately after theconstructor.It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:

- To initialize state, declarestateas a class field or setthis.stateinside theconstructor.
- If you need to run a side effect or set up a subscription, move that logic tocomponentDidMountinstead.
See examples of migrating away from unsafe lifecycles.


#### Parameters
UNSAFE_componentWillMountdoes not take any parameters.


#### Returns
UNSAFE_componentWillMountshould not return anything.


#### Caveats
- UNSAFE_componentWillMountwill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.
UNSAFE_componentWillMountwill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.

- Despite its naming,UNSAFE_componentWillMountdoes not guarantee that the componentwillget mounted if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go intocomponentDidMount.
Despite its naming,UNSAFE_componentWillMountdoes not guarantee that the componentwillget mounted if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go intocomponentDidMount.

- UNSAFE_componentWillMountis the only lifecycle method that runs duringserver rendering.For all practical purposes, it is identical toconstructor,so you should use theconstructorfor this type of logic instead.
UNSAFE_componentWillMountis the only lifecycle method that runs duringserver rendering.For all practical purposes, it is identical toconstructor,so you should use theconstructorfor this type of logic instead.


### Note
CallingsetStateinsideUNSAFE_componentWillMountin a class component to initialize state is equivalent to passing that state as the initial state touseStatein a function component.


### UNSAFE_componentWillReceiveProps(nextProps, nextContext)
If you defineUNSAFE_componentWillReceiveProps, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:

- If you need torun a side effect(for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic tocomponentDidUpdateinstead.
- If you need toavoid re-computing some data only when a prop changes,use amemoization helperinstead.
- If you need to“reset” some state when a prop changes,consider either making a componentfully controlledorfully uncontrolled with a keyinstead.
- If you need to“adjust” some state when a prop changes,check whether you can compute all the necessary information from props alone during rendering. If you can’t, usestatic getDerivedStateFromPropsinstead.
See examples of migrating away from unsafe lifecycles.


#### Parameters
- nextProps: The next props that the component is about to receive from its parent component. ComparenextPropstothis.propsto determine what changed.
- nextContext: The next context that the component is about to receive from the closest provider. ComparenextContexttothis.contextto determine what changed. Only available if you specifystatic contextType.

#### Returns
UNSAFE_componentWillReceivePropsshould not return anything.


#### Caveats
- UNSAFE_componentWillReceivePropswill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.
UNSAFE_componentWillReceivePropswill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.

- Despite its naming,UNSAFE_componentWillReceivePropsdoes not guarantee that the componentwillreceive those props if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate.
Despite its naming,UNSAFE_componentWillReceivePropsdoes not guarantee that the componentwillreceive those props if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate.

- UNSAFE_componentWillReceivePropsdoes not mean that the component has receiveddifferentprops than the last time. You need to comparenextPropsandthis.propsyourself to check if something changed.
UNSAFE_componentWillReceivePropsdoes not mean that the component has receiveddifferentprops than the last time. You need to comparenextPropsandthis.propsyourself to check if something changed.

- React doesn’t callUNSAFE_componentWillReceivePropswith initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, callingsetStatedoesn’t generally triggerUNSAFE_componentWillReceivePropsinside the same component.
React doesn’t callUNSAFE_componentWillReceivePropswith initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, callingsetStatedoesn’t generally triggerUNSAFE_componentWillReceivePropsinside the same component.


### Note
CallingsetStateinsideUNSAFE_componentWillReceivePropsin a class component to “adjust” state is equivalent tocalling thesetfunction fromuseStateduring renderingin a function component.


### UNSAFE_componentWillUpdate(nextProps, nextState)
If you defineUNSAFE_componentWillUpdate, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:

- If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic tocomponentDidUpdateinstead.
- If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it incomponentDidUpdatelater, read it insidegetSnapshotBeforeUpdateinstead.
See examples of migrating away from unsafe lifecycles.


#### Parameters
- nextProps: The next props that the component is about to render with. ComparenextPropstothis.propsto determine what changed.
- nextState: The next state that the component is about to render with. ComparenextStatetothis.stateto determine what changed.

#### Returns
UNSAFE_componentWillUpdateshould not return anything.


#### Caveats
- UNSAFE_componentWillUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.
UNSAFE_componentWillUpdatewill not get called ifshouldComponentUpdateis defined and returnsfalse.

- UNSAFE_componentWillUpdatewill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.
UNSAFE_componentWillUpdatewill not get called if the component implementsstatic getDerivedStateFromPropsorgetSnapshotBeforeUpdate.

- It’s not supported to callsetState(or any method that leads tosetStatebeing called, like dispatching a Redux action) duringcomponentWillUpdate.
It’s not supported to callsetState(or any method that leads tosetStatebeing called, like dispatching a Redux action) duringcomponentWillUpdate.

- Despite its naming,UNSAFE_componentWillUpdatedoes not guarantee that the componentwillupdate if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate.
Despite its naming,UNSAFE_componentWillUpdatedoes not guarantee that the componentwillupdate if your app uses modern React features likeSuspense.If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go intocomponentDidUpdate.

- UNSAFE_componentWillUpdatedoes not mean that the component has receiveddifferentprops or state than the last time. You need to comparenextPropswiththis.propsandnextStatewiththis.stateyourself to check if something changed.
UNSAFE_componentWillUpdatedoes not mean that the component has receiveddifferentprops or state than the last time. You need to comparenextPropswiththis.propsandnextStatewiththis.stateyourself to check if something changed.

- React doesn’t callUNSAFE_componentWillUpdatewith initial props and state during mounting.
React doesn’t callUNSAFE_componentWillUpdatewith initial props and state during mounting.


### Note
There is no direct equivalent toUNSAFE_componentWillUpdatein function components.


### static contextType
If you want to readthis.contextfrom your class component, you must specify which context it needs to read. The context you specify as thestatic contextTypemust be a value previously created bycreateContext.

```jsx
class Button extends Component {  static contextType = ThemeContext;  render() {    const theme = this.context;    const className = 'button-' + theme;    return (      <button className={className}>        {this.props.children}      </button>    );  }}
```


### Note
Readingthis.contextin class components is equivalent touseContextin function components.

See how to migrate.


### static defaultProps
You can definestatic defaultPropsto set the default props for the class. They will be used forundefinedand missing props, but not fornullprops.

For example, here is how you define that thecolorprop should default to'blue':

```jsx
class Button extends Component {  static defaultProps = {    color: 'blue'  };  render() {    return <button className={this.props.color}>click me</button>;  }}
```

If thecolorprop is not provided or isundefined, it will be set by default to'blue':

```jsx
<>  {/* this.props.color is "blue" */}  <Button />  {/* this.props.color is "blue" */}  <Button color={undefined} />  {/* this.props.color is null */}  <Button color={null} />  {/* this.props.color is "red" */}  <Button color="red" /></>
```


### Note
DefiningdefaultPropsin class components is similar to usingdefault valuesin function components.


### static getDerivedStateFromError(error)
If you definestatic getDerivedStateFromError, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.

Typically, it is used together withcomponentDidCatchwhich lets you send the error report to some analytics service. A component with these methods is called anError Boundary.

See an example.


#### Parameters
- error: The error that was thrown. In practice, it will usually be an instance ofErrorbut this is not guaranteed because JavaScript allows tothrowany value, including strings or evennull.

#### Returns
static getDerivedStateFromErrorshould return the state telling the component to display the error message.


#### Caveats
- static getDerivedStateFromErrorshould be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implementcomponentDidCatch.

### Note
There is no direct equivalent forstatic getDerivedStateFromErrorin function components yet. If you’d like to avoid creating class components, write a singleErrorBoundarycomponent like above and use it throughout your app. Alternatively, use thereact-error-boundarypackage which does that.


### static getDerivedStateFromProps(props, state)
If you definestatic getDerivedStateFromProps, React will call it right before callingrender,both on the initial mount and on subsequent updates. It should return an object to update the state, ornullto update nothing.

This method exists forrare use caseswhere the state depends on changes in props over time. For example, thisFormcomponent resets theemailstate when theuserIDprop changes:

```jsx
class Form extends Component {  state = {    email: this.props.defaultEmail,    prevUserID: this.props.userID  };  static getDerivedStateFromProps(props, state) {    // Any time the current user changes,    // Reset any parts of state that are tied to that user.    // In this simple example, that's just the email.    if (props.userID !== state.prevUserID) {      return {        prevUserID: props.userID,        email: props.defaultEmail      };    }    return null;  }  // ...}
```

Note that this pattern requires you to keep a previous value of the prop (likeuserID) in state (likeprevUserID).


### Pitfall
Deriving state leads to verbose code and makes your components difficult to think about.Make sure you’re familiar with simpler alternatives:

- If you need toperform a side effect(for example, data fetching or an animation) in response to a change in props, usecomponentDidUpdatemethod instead.
- If you want tore-compute some data only when a prop changes,use a memoization helper instead.
- If you want to“reset” some state when a prop changes,consider either making a componentfully controlledorfully uncontrolled with a keyinstead.

#### Parameters
- props: The next props that the component is about to render with.
- state: The next state that the component is about to render with.

#### Returns
static getDerivedStateFromPropsreturn an object to update the state, ornullto update nothing.


#### Caveats
- This method is fired oneveryrender, regardless of the cause. This is different fromUNSAFE_componentWillReceiveProps, which only fires when the parent causes a re-render and not as a result of a localsetState.
This method is fired oneveryrender, regardless of the cause. This is different fromUNSAFE_componentWillReceiveProps, which only fires when the parent causes a re-render and not as a result of a localsetState.

- This method doesn’t have access to the component instance. If you’d like, you can reuse some code betweenstatic getDerivedStateFromPropsand the other class methods by extracting pure functions of the component props and state outside the class definition.
This method doesn’t have access to the component instance. If you’d like, you can reuse some code betweenstatic getDerivedStateFromPropsand the other class methods by extracting pure functions of the component props and state outside the class definition.


### Note
Implementingstatic getDerivedStateFromPropsin a class component is equivalent tocalling thesetfunction fromuseStateduring renderingin a function component.


## Usage

### Defining a class component
To define a React component as a class, extend the built-inComponentclass and define arendermethod:

```jsx
import { Component } from 'react';class Greeting extends Component {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

React will call yourrendermethod whenever it needs to figure out what to display on the screen. Usually, you will return someJSXfrom it. Yourrendermethod should be apure function:it should only calculate the JSX.

Similarly tofunction components,a class component canreceive information by propsfrom its parent component. However, the syntax for reading props is different. For example, if the parent component renders<Greeting name="Taylor" />, then you can read thenameprop fromthis.props, likethis.props.name:

```jsx
import { Component } from 'react';

class Greeting extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default function App() {
  return (
    <>
      <Greeting name="Sara" />
      <Greeting name="Cahal" />
      <Greeting name="Edite" />
    </>
  );
}


```

Note that Hooks (functions starting withuse, likeuseState) are not supported inside class components.


### Pitfall
We recommend defining components as functions instead of classes.See how to migrate.


### Adding state to a class component
To addstateto a class, assign an object to a property calledstate. To update state, callthis.setState.

```jsx
import { Component } from 'react';

export default class Counter extends Component {
  state = {
    name: 'Taylor',
    age: 42,
  };

  handleNameChange = (e) => {
    this.setState({
      name: e.target.value
    });
  }

  handleAgeChange = () => {
    this.setState({
      age: this.state.age + 1 
    });
  };

  render() {
    return (
      <>
        <input
          value={this.state.name}
          onChange={this.handleNameChange}
        />
        <button onClick={this.handleAgeChange}>
          Increment age
        </button>
        <p>Hello, {this.state.name}. You are {this.state.age}.</p>
      </>
    );
  }
}


```


### Pitfall
We recommend defining components as functions instead of classes.See how to migrate.


### Adding lifecycle methods to a class component
There are a few special methods you can define on your class.

If you define thecomponentDidMountmethod, React will call it when your component is added(mounted)to the screen. React will callcomponentDidUpdateafter your component re-renders due to changed props or state. React will callcomponentWillUnmountafter your component has been removed(unmounted)from the screen.

If you implementcomponentDidMount, you usually need to implement all three lifecycles to avoid bugs. For example, ifcomponentDidMountreads some state or props, you also have to implementcomponentDidUpdateto handle their changes, andcomponentWillUnmountto clean up whatevercomponentDidMountwas doing.

For example, thisChatRoomcomponent keeps a chat connection synchronized with props and state:

```jsx
import { Component } from 'react';
import { createConnection } from './chat.js';

export default class ChatRoom extends Component {
  state = {
    serverUrl: 'https://localhost:1234'
  };

  componentDidMount() {
    this.setupConnection();
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.roomId !== prevProps.roomId ||
      this.state.serverUrl !== prevState.serverUrl
    ) {
      this.destroyConnection();
      this.setupConnection();
    }
  }

  componentWillUnmount() {
    this.destroyConnection();
  }

  setupConnection() {
    this.connection = createConnection(
      this.state.serverUrl,
      this.props.roomId
    );
    this.connection.connect();    
  }

  destroyConnection() {
    this.connection.disconnect();
    this.connection = null;
  }

  render() {
    return (
      <>
        <label>
          Server URL:{' '}
          <input
            value={this.state.serverUrl}
            onChange={e => {
              this.setState({
                serverUrl: e.target.value
              });
            }}
          />
        </label>
        <h1>Welcome to the {this.props.roomId} room!</h1>
      </>
    );
  }
}


```

Note that in development whenStrict Modeis on, React will callcomponentDidMount, immediately callcomponentWillUnmount, and then callcomponentDidMountagain. This helps you notice if you forgot to implementcomponentWillUnmountor if its logic doesn’t fully “mirror” whatcomponentDidMountdoes.


### Pitfall
We recommend defining components as functions instead of classes.See how to migrate.


### Catching rendering errors with an Error Boundary
By default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into anError Boundary. An Error Boundary is a special component that lets you display some fallback UI instead of the part that crashed—for example, an error message.


### Note
Error boundaries do not catch errors for:

- Event handlers(learn more)
- Server side rendering
- Errors thrown in the error boundary itself (rather than its children)
- Asynchronous code (e.g.setTimeoutorrequestAnimationFramecallbacks); an exception is the usage of thestartTransitionfunction returned by theuseTransitionHook. Errors thrown inside the transition function are caught by error boundaries(learn more)
To implement an Error Boundary component, you need to providestatic getDerivedStateFromErrorwhich lets you update state in response to an error and display an error message to the user. You can also optionally implementcomponentDidCatchto add some extra logic, for example, to log the error to an analytics service.

WithcaptureOwnerStackyou can include the Owner Stack during development.

```jsx
import * as React from 'react';class ErrorBoundary extends React.Component {  constructor(props) {    super(props);    this.state = { hasError: false };  }  static getDerivedStateFromError(error) {    // Update state so the next render will show the fallback UI.    return { hasError: true };  }  componentDidCatch(error, info) {    logErrorToMyService(      error,      // Example "componentStack":      //   in ComponentThatThrows (created by App)      //   in ErrorBoundary (created by App)      //   in div (created by App)      //   in App      info.componentStack,      // Warning: `captureOwnerStack` is not available in production.      React.captureOwnerStack(),    );  }  render() {    if (this.state.hasError) {      // You can render any custom fallback UI      return this.props.fallback;    }    return this.props.children;  }}
```

Then you can wrap a part of your component tree with it:

```jsx
<ErrorBoundary fallback={<p>Something went wrong</p>}>  <Profile /></ErrorBoundary>
```

IfProfileor its child component throws an error,ErrorBoundarywill “catch” that error, display a fallback UI with the error message you’ve provided, and send a production error report to your error reporting service.

You don’t need to wrap every component into a separate Error Boundary. When you think about thegranularity of Error Boundaries,consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an Error Boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn’t make sense to place a boundary around every avatar.


### Note
There is currently no way to write an Error Boundary as a function component. However, you don’t have to write the Error Boundary class yourself. For example, you can usereact-error-boundaryinstead.


## Alternatives

### Migrating a simple component from a class to a function
Typically, you willdefine components as functionsinstead.

For example, suppose you’re converting thisGreetingclass component to a function:

```jsx
import { Component } from 'react';

class Greeting extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default function App() {
  return (
    <>
      <Greeting name="Sara" />
      <Greeting name="Cahal" />
      <Greeting name="Edite" />
    </>
  );
}


```

Define a function calledGreeting. This is where you will move the body of yourrenderfunction.

```jsx
function Greeting() {  // ... move the code from the render method here ...}
```

Instead ofthis.props.name, define thenamepropusing the destructuring syntaxand read it directly:

```jsx
function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;}
```

Here is a complete example:

```jsx
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

export default function App() {
  return (
    <>
      <Greeting name="Sara" />
      <Greeting name="Cahal" />
      <Greeting name="Edite" />
    </>
  );
}


```


### Migrating a component with state from a class to a function
Suppose you’re converting thisCounterclass component to a function:

```jsx
import { Component } from 'react';

export default class Counter extends Component {
  state = {
    name: 'Taylor',
    age: 42,
  };

  handleNameChange = (e) => {
    this.setState({
      name: e.target.value
    });
  }

  handleAgeChange = (e) => {
    this.setState({
      age: this.state.age + 1 
    });
  };

  render() {
    return (
      <>
        <input
          value={this.state.name}
          onChange={this.handleNameChange}
        />
        <button onClick={this.handleAgeChange}>
          Increment age
        </button>
        <p>Hello, {this.state.name}. You are {this.state.age}.</p>
      </>
    );
  }
}


```

Start by declaring a function with the necessarystate variables:

```jsx
import { useState } from 'react';function Counter() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  // ...
```

Next, convert the event handlers:

```jsx
function Counter() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  function handleNameChange(e) {    setName(e.target.value);  }  function handleAgeChange() {    setAge(age + 1);  }  // ...
```

Finally, replace all references starting withthiswith the variables and functions you defined in your component. For example, replacethis.state.agewithage, and replacethis.handleNameChangewithhandleNameChange.

Here is a fully converted component:

```jsx
import { useState } from 'react';

export default function Counter() {
  const [name, setName] = useState('Taylor');
  const [age, setAge] = useState(42);

  function handleNameChange(e) {
    setName(e.target.value);
  }

  function handleAgeChange() {
    setAge(age + 1);
  }

  return (
    <>
      <input
        value={name}
        onChange={handleNameChange}
      />
      <button onClick={handleAgeChange}>
        Increment age
      </button>
      <p>Hello, {name}. You are {age}.</p>
    </>
  )
}


```


### Migrating a component with lifecycle methods from a class to a function
Suppose you’re converting thisChatRoomclass component with lifecycle methods to a function:

```jsx
import { Component } from 'react';
import { createConnection } from './chat.js';

export default class ChatRoom extends Component {
  state = {
    serverUrl: 'https://localhost:1234'
  };

  componentDidMount() {
    this.setupConnection();
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.roomId !== prevProps.roomId ||
      this.state.serverUrl !== prevState.serverUrl
    ) {
      this.destroyConnection();
      this.setupConnection();
    }
  }

  componentWillUnmount() {
    this.destroyConnection();
  }

  setupConnection() {
    this.connection = createConnection(
      this.state.serverUrl,
      this.props.roomId
    );
    this.connection.connect();    
  }

  destroyConnection() {
    this.connection.disconnect();
    this.connection = null;
  }

  render() {
    return (
      <>
        <label>
          Server URL:{' '}
          <input
            value={this.state.serverUrl}
            onChange={e => {
              this.setState({
                serverUrl: e.target.value
              });
            }}
          />
        </label>
        <h1>Welcome to the {this.props.roomId} room!</h1>
      </>
    );
  }
}


```

First, verify that yourcomponentWillUnmountdoes the opposite ofcomponentDidMount.In the above example, that’s true: it disconnects the connection thatcomponentDidMountsets up. If such logic is missing, add it first.

Next, verify that yourcomponentDidUpdatemethod handles changes to any props and state you’re using incomponentDidMount. In the above example,componentDidMountcallssetupConnectionwhich readsthis.state.serverUrlandthis.props.roomId. This is whycomponentDidUpdatechecks whetherthis.state.serverUrlandthis.props.roomIdhave changed, and resets the connection if they did. If yourcomponentDidUpdatelogic is missing or doesn’t handle changes to all relevant props and state, fix that first.

In the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system,describe this logic as a single Effect:

```jsx
import { useState, useEffect } from 'react';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}
```

ThisuseEffectcall is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things,split them into multiple independent Effects.Here is a complete example you can play with:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}


```


### Note
If your component does not synchronize with any external systems,you might not need an Effect.


### Migrating a component with context from a class to a function
In this example, thePanelandButtonclass components readcontextfromthis.context:

```jsx
import { createContext, Component } from 'react';

const ThemeContext = createContext(null);

class Panel extends Component {
  static contextType = ThemeContext;

  render() {
    const theme = this.context;
    const className = 'panel-' + theme;
    return (
      <section className={className}>
        <h1>{this.props.title}</h1>
        {this.props.children}
      </section>
    );    
  }
}

class Button extends Component {
  static contextType = ThemeContext;

  render() {
    const theme = this.context;
    const className = 'button-' + theme;
    return (
      <button className={className}>
        {this.props.children}
      </button>
    );
  }
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}


```

When you convert them to function components, replacethis.contextwithuseContextcalls:

```jsx
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}


```


--------------------------------------------------------------------------------


# <Fragment> (<>...</>)
Source: https://react.dev/reference/react/Fragment

<Fragment>, often used via<>...</>syntax, lets you group elements without a wrapper node.


### Canary
```jsx
<>  <OneChild />  <AnotherChild /></>
```

- Reference<Fragment>Canary onlyFragmentInstance
- <Fragment>
- Canary onlyFragmentInstance
- UsageReturning multiple elementsAssigning multiple elements to a variableGrouping elements with textRendering a list of FragmentsCanary onlyUsing Fragment refs for DOM interactionCanary onlyTracking visibility with Fragment refsCanary onlyFocus management with Fragment refs
- Returning multiple elements
- Assigning multiple elements to a variable
- Grouping elements with text
- Rendering a list of Fragments
- Canary onlyUsing Fragment refs for DOM interaction
- Canary onlyTracking visibility with Fragment refs
- Canary onlyFocus management with Fragment refs

## Reference

### <Fragment>
Wrap elements in<Fragment>to group them together in situations where you need a single element. Grouping elements inFragmenthas no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag<></>is shorthand for<Fragment></Fragment>in most cases.


#### Props
- optionalkey: Fragments declared with the explicit<Fragment>syntax may havekeys.
- Canary onlyoptionalref: A ref object (e.g. fromuseRef) orcallback function. React provides aFragmentInstanceas the ref value that implements methods for interacting with the DOM nodes wrapped by the Fragment.

### Canary onlyFragmentInstance
When you pass a ref to a fragment, React provides aFragmentInstanceobject with methods for interacting with the DOM nodes wrapped by the fragment:

Event handling methods:

- addEventListener(type, listener, options?): Adds an event listener to all first-level DOM children of the Fragment.
- removeEventListener(type, listener, options?): Removes an event listener from all first-level DOM children of the Fragment.
- dispatchEvent(event): Dispatches an event to a virtual child of the Fragment to call any added listeners and can bubble to the DOM parent.
Layout methods:

- compareDocumentPosition(otherNode): Compares the document position of the Fragment with another node.If the Fragment has children, the nativecompareDocumentPositionvalue is returned.Empty Fragments will attempt to compare positioning within the React tree and includeNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC.Elements that have a different relationship in the React tree and DOM tree due to portaling or other insertions areNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC.
- If the Fragment has children, the nativecompareDocumentPositionvalue is returned.
- Empty Fragments will attempt to compare positioning within the React tree and includeNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC.
- Elements that have a different relationship in the React tree and DOM tree due to portaling or other insertions areNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC.
- getClientRects(): Returns a flat array ofDOMRectobjects representing the bounding rectangles of all children.
- getRootNode(): Returns the root node containing the Fragment’s parent DOM node.
Focus management methods:

- focus(options?): Focuses the first focusable DOM node in the Fragment. Focus is attempted on nested children depth-first.
- focusLast(options?): Focuses the last focusable DOM node in the Fragment. Focus is attempted on nested children depth-first.
- blur(): Removes focus ifdocument.activeElementis within the Fragment.
Observer methods:

- observeUsing(observer): Starts observing the Fragment’s DOM children with an IntersectionObserver or ResizeObserver.
- unobserveUsing(observer): Stops observing the Fragment’s DOM children with the specified observer.

#### Caveats
- If you want to passkeyto a Fragment, you can’t use the<>...</>syntax. You have to explicitly importFragmentfrom'react'and render<Fragment key={yourKey}>...</Fragment>.
If you want to passkeyto a Fragment, you can’t use the<>...</>syntax. You have to explicitly importFragmentfrom'react'and render<Fragment key={yourKey}>...</Fragment>.

- React does notreset statewhen you go from rendering<><Child /></>to[<Child />]or back, or when you go from rendering<><Child /></>to<Child />and back. This only works a single level deep: for example, going from<><><Child /></></>to<Child />resets the state. See the precise semanticshere.
React does notreset statewhen you go from rendering<><Child /></>to[<Child />]or back, or when you go from rendering<><Child /></>to<Child />and back. This only works a single level deep: for example, going from<><><Child /></></>to<Child />resets the state. See the precise semanticshere.

- Canary onlyIf you want to passrefto a Fragment, you can’t use the<>...</>syntax. You have to explicitly importFragmentfrom'react'and render<Fragment ref={yourRef}>...</Fragment>.
Canary onlyIf you want to passrefto a Fragment, you can’t use the<>...</>syntax. You have to explicitly importFragmentfrom'react'and render<Fragment ref={yourRef}>...</Fragment>.


## Usage

### Returning multiple elements
UseFragment, or the equivalent<>...</>syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:

```jsx
function Post() {  return (    <>      <PostTitle />      <PostBody />    </>  );}
```

Fragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you’ll see that all<h1>and<article>DOM nodes appear as siblings without wrappers around them:

```jsx
export default function Blog() {
  return (
    <>
      <Post title="An update" body="It's been a while since I posted..." />
      <Post title="My new blog" body="I am starting a new blog!" />
    </>
  )
}

function Post({ title, body }) {
  return (
    <>
      <PostTitle title={title} />
      <PostBody body={body} />
    </>
  );
}

function PostTitle({ title }) {
  return <h1>{title}</h1>
}

function PostBody({ body }) {
  return (
    <article>
      <p>{body}</p>
    </article>
  );
}


```


#### How to write a Fragment without the special syntax?
The example above is equivalent to importingFragmentfrom React:

```jsx
import { Fragment } from 'react';function Post() {  return (    <Fragment>      <PostTitle />      <PostBody />    </Fragment>  );}
```

Usually you won’t need this unless you need topass akeyto yourFragment.


### Assigning multiple elements to a variable
Like any other element, you can assign Fragment elements to variables, pass them as props, and so on:

```jsx
function CloseDialog() {  const buttons = (    <>      <OKButton />      <CancelButton />    </>  );  return (    <AlertDialog buttons={buttons}>      Are you sure you want to leave this page?    </AlertDialog>  );}
```


### Grouping elements with text
You can useFragmentto group text together with components:

```jsx
function DateRangePicker({ start, end }) {  return (    <>      From      <DatePicker date={start} />      to      <DatePicker date={end} />    </>  );}
```


### Rendering a list of Fragments
Here’s a situation where you need to writeFragmentexplicitly instead of using the<></>syntax. When yourender multiple elements in a loop, you need to assign akeyto each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide thekeyattribute:

```jsx
function Blog() {  return posts.map(post =>    <Fragment key={post.id}>      <PostTitle title={post.title} />      <PostBody body={post.body} />    </Fragment>  );}
```

You can inspect the DOM to verify that there are no wrapper elements around the Fragment children:

```jsx
import { Fragment } from 'react';

const posts = [
  { id: 1, title: 'An update', body: "It's been a while since I posted..." },
  { id: 2, title: 'My new blog', body: 'I am starting a new blog!' }
];

export default function Blog() {
  return posts.map(post =>
    <Fragment key={post.id}>
      <PostTitle title={post.title} />
      <PostBody body={post.body} />
    </Fragment>
  );
}

function PostTitle({ title }) {
  return <h1>{title}</h1>
}

function PostBody({ body }) {
  return (
    <article>
      <p>{body}</p>
    </article>
  );
}


```


### Canary onlyUsing Fragment refs for DOM interaction
Fragment refs allow you to interact with the DOM nodes wrapped by a Fragment without adding extra wrapper elements. This is useful for event handling, visibility tracking, focus management, and replacing deprecated patterns likeReactDOM.findDOMNode().

```jsx
import { Fragment } from 'react';function ClickableFragment({ children, onClick }) {  return (    <Fragment ref={fragmentInstance => {      fragmentInstance.addEventListener('click', handleClick);      return () => fragmentInstance.removeEventListener('click', handleClick);    }}>      {children}    </Fragment>  );}
```


### Canary onlyTracking visibility with Fragment refs
Fragment refs are useful for visibility tracking and intersection observation. This enables you to monitor when content becomes visible without requiring the child Components to expose refs:

```jsx
import { Fragment, useRef, useLayoutEffect } from 'react';function VisibilityObserverFragment({ threshold = 0.5, onVisibilityChange, children }) {  const fragmentRef = useRef(null);  useLayoutEffect(() => {    const observer = new IntersectionObserver(      (entries) => {        onVisibilityChange(entries.some(entry => entry.isIntersecting))      },      { threshold }    );        fragmentRef.current.observeUsing(observer);    return () => fragmentRef.current.unobserveUsing(observer);  }, [threshold, onVisibilityChange]);  return (    <Fragment ref={fragmentRef}>      {children}    </Fragment>  );}function MyComponent() {  const handleVisibilityChange = (isVisible) => {    console.log('Component is', isVisible ? 'visible' : 'hidden');  };  return (    <VisibilityObserverFragment onVisibilityChange={handleVisibilityChange}>      <SomeThirdPartyComponent />      <AnotherComponent />    </VisibilityObserverFragment>  );}
```

This pattern is an alternative to Effect-based visibility logging, which is an anti-pattern in most cases. Relying on Effects alone does not guarantee that the rendered Component is observable by the user.


### Canary onlyFocus management with Fragment refs
Fragment refs provide focus management methods that work across all DOM nodes within the Fragment:

```jsx
import { Fragment, useRef } from 'react';function FocusFragment({ children }) {  return (    <Fragment ref={(fragmentInstance) => fragmentInstance?.focus()}>      {children}    </Fragment>  );}
```

Thefocus()method focuses the first focusable element within the Fragment, whilefocusLast()focuses the last focusable element.


--------------------------------------------------------------------------------


# <Profiler>
Source: https://react.dev/reference/react/Profiler

<Profiler>lets you measure rendering performance of a React tree programmatically.

```jsx
<Profiler id="App" onRender={onRender}>  <App /></Profiler>
```

- Reference<Profiler>onRendercallback
- <Profiler>
- onRendercallback
- UsageMeasuring rendering performance programmaticallyMeasuring different parts of the application
- Measuring rendering performance programmatically
- Measuring different parts of the application

## Reference

### <Profiler>
Wrap a component tree in a<Profiler>to measure its rendering performance.

```jsx
<Profiler id="App" onRender={onRender}>  <App /></Profiler>
```


#### Props
- id: A string identifying the part of the UI you are measuring.
- onRender: AnonRendercallbackthat React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.

#### Caveats
- Profiling adds some additional overhead, soit is disabled in the production build by default.To opt into production profiling, you need to enable aspecial production build with profiling enabled.

### onRendercallback
React will call youronRendercallback with information about what was rendered.

```jsx
function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {  // Aggregate or log render timings...}
```


#### Parameters
- id: The stringidprop of the<Profiler>tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.
- phase:"mount","update"or"nested-update". This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.
- actualDuration: The number of milliseconds spent rendering the<Profiler>and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g.memoanduseMemo). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.
- baseDuration: The number of milliseconds estimating how much time it would take to re-render the entire<Profiler>subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). CompareactualDurationagainst it to see if memoization is working.
- startTime: A numeric timestamp for when React began rendering the current update.
- commitTime: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.

## Usage

### Measuring rendering performance programmatically
Wrap the<Profiler>component around a React tree to measure its rendering performance.

```jsx
<App>  <Profiler id="Sidebar" onRender={onRender}>    <Sidebar />  </Profiler>  <PageContent /></App>
```

It requires two props: anid(string) and anonRendercallback (function) which React calls any time a component within the tree “commits” an update.


### Pitfall
Profiling adds some additional overhead, soit is disabled in the production build by default.To opt into production profiling, you need to enable aspecial production build with profiling enabled.


### Note
<Profiler>lets you gather measurements programmatically. If you’re looking for an interactive profiler, try the Profiler tab inReact Developer Tools. It exposes similar functionality as a browser extension.

Components wrapped in<Profiler>will also be marked in theComponent tracksof React Performance tracks even in profiling builds.
In development builds, all components are marked in the Components track regardless of whether they’re wrapped in<Profiler>.


### Measuring different parts of the application
You can use multiple<Profiler>components to measure different parts of your application:

```jsx
<App>  <Profiler id="Sidebar" onRender={onRender}>    <Sidebar />  </Profiler>  <Profiler id="Content" onRender={onRender}>    <Content />  </Profiler></App>
```

You can also nest<Profiler>components:

```jsx
<App>  <Profiler id="Sidebar" onRender={onRender}>    <Sidebar />  </Profiler>  <Profiler id="Content" onRender={onRender}>    <Content>      <Profiler id="Editor" onRender={onRender}>        <Editor />      </Profiler>      <Preview />    </Content>  </Profiler></App>
```

Although<Profiler>is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.


--------------------------------------------------------------------------------


# PureComponent
Source: https://react.dev/reference/react/PureComponent


### Pitfall
We recommend defining components as functions instead of classes.See how to migrate.

PureComponentis similar toComponentbut it skips re-renders for same props and state. Class components are still supported by React, but we don’t recommend using them in new code.

```jsx
class Greeting extends PureComponent {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

- ReferencePureComponent
- PureComponent
- UsageSkipping unnecessary re-renders for class components
- Skipping unnecessary re-renders for class components
- AlternativesMigrating from aPureComponentclass component to a function
- Migrating from aPureComponentclass component to a function

## Reference

### PureComponent
To skip re-rendering a class component for same props and state, extendPureComponentinstead ofComponent:

```jsx
import { PureComponent } from 'react';class Greeting extends PureComponent {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

PureComponentis a subclass ofComponentand supportsall theComponentAPIs.ExtendingPureComponentis equivalent to defining a customshouldComponentUpdatemethod that shallowly compares props and state.

See more examples below.


## Usage

### Skipping unnecessary re-renders for class components
React normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state.Class componentscan opt into this behavior by extendingPureComponent:

```jsx
class Greeting extends PureComponent {  render() {    return <h1>Hello, {this.props.name}!</h1>;  }}
```

A React component should always havepure rendering logic.This means that it must return the same output if its props, state, and context haven’t changed. By usingPureComponent, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props and state haven’t changed. However, your component will still re-render if a context that it’s using changes.

In this example, notice that theGreetingcomponent re-renders whenevernameis changed (because that’s one of its props), but not whenaddressis changed (because it’s not passed toGreetingas a prop):

```jsx
import { PureComponent, useState } from 'react';

class Greeting extends PureComponent {
  render() {
    console.log("Greeting was rendered at", new Date().toLocaleTimeString());
    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;
  }
}

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}


```


### Pitfall
We recommend defining components as functions instead of classes.See how to migrate.


## Alternatives

### Migrating from aPureComponentclass component to a function
We recommend using function components instead ofclass componentsin new code. If you have some existing class components usingPureComponent, here is how you can convert them. This is the original code:

```jsx
import { PureComponent, useState } from 'react';

class Greeting extends PureComponent {
  render() {
    console.log("Greeting was rendered at", new Date().toLocaleTimeString());
    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;
  }
}

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}


```

When youconvert this component from a class to a function,wrap it inmemo:

```jsx
import { memo, useState } from 'react';

const Greeting = memo(function Greeting({ name }) {
  console.log("Greeting was rendered at", new Date().toLocaleTimeString());
  return <h3>Hello{name && ', '}{name}!</h3>;
});

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}


```


### Note
UnlikePureComponent,memodoes not compare the new and the old state. In function components, calling thesetfunctionwith the same statealready prevents re-renders by default,even withoutmemo.


--------------------------------------------------------------------------------


# <StrictMode>
Source: https://react.dev/reference/react/StrictMode

<StrictMode>lets you find common bugs in your components early during development.

```jsx
<StrictMode>  <App /></StrictMode>
```

- Reference<StrictMode>
- <StrictMode>
- UsageEnabling Strict Mode for entire appEnabling Strict Mode for a part of the appFixing bugs found by double rendering in developmentFixing bugs found by re-running Effects in developmentFixing bugs found by re-running ref callbacks in developmentFixing deprecation warnings enabled by Strict Mode
- Enabling Strict Mode for entire app
- Enabling Strict Mode for a part of the app
- Fixing bugs found by double rendering in development
- Fixing bugs found by re-running Effects in development
- Fixing bugs found by re-running ref callbacks in development
- Fixing deprecation warnings enabled by Strict Mode

## Reference

### <StrictMode>
UseStrictModeto enable additional development behaviors and warnings for the component tree inside:

```jsx
import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(  <StrictMode>    <App />  </StrictMode>);
```

See more examples below.

Strict Mode enables the following development-only behaviors:

- Your components willre-render an extra timeto find bugs caused by impure rendering.
- Your components willre-run Effects an extra timeto find bugs caused by missing Effect cleanup.
- Your components willre-run refs callbacks an extra timeto find bugs caused by missing ref cleanup.
- Your components willbe checked for usage of deprecated APIs.

#### Props
StrictModeaccepts no props.


#### Caveats
- There is no way to opt out of Strict Mode inside a tree wrapped in<StrictMode>. This gives you confidence that all components inside<StrictMode>are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move<StrictMode>down in the tree.

## Usage

### Enabling Strict Mode for entire app
Strict Mode enables extra development-only checks for the entire component tree inside the<StrictMode>component. These checks help you find common bugs in your components early in the development process.

To enable Strict Mode for your entire app, wrap your root component with<StrictMode>when you render it:

```jsx
import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(  <StrictMode>    <App />  </StrictMode>);
```

We recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that callscreateRootfor you, check its documentation for how to enable Strict Mode.

Although the Strict Mode checksonly run in development,they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.


### Note
Strict Mode enables the following checks in development:

- Your components willre-render an extra timeto find bugs caused by impure rendering.
- Your components willre-run Effects an extra timeto find bugs caused by missing Effect cleanup.
- Your components willre-run ref callbacks an extra timeto find bugs caused by missing ref cleanup.
- Your components willbe checked for usage of deprecated APIs.
All of these checks are development-only and do not impact the production build.


### Enabling Strict Mode for a part of the app
You can also enable Strict Mode for any part of your application:

```jsx
import { StrictMode } from 'react';function App() {  return (    <>      <Header />      <StrictMode>        <main>          <Sidebar />          <Content />        </main>      </StrictMode>      <Footer />    </>  );}
```

In this example, Strict Mode checks will not run against theHeaderandFootercomponents. However, they will run onSidebarandContent, as well as all of the components inside them, no matter how deep.


### Note
WhenStrictModeis enabled for a part of the app, React will only enable behaviors that are possible in production. For example, if<StrictMode>is not enabled at the root of the app, it will notre-run Effects an extra timeon initial mount, since this would cause child effects to double fire without the parent effects, which cannot happen in production.


### Fixing bugs found by double rendering in development
React assumes that every component you write is a pure function.This means that React components you write must always return the same JSX given the same inputs (props, state, and context).

Components breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure)twice in development.This includes:

- Your component function body (only top-level logic, so this doesn’t include code inside event handlers)
- Functions that you pass touseState,setfunctions,useMemo, oruseReducer
- Some class component methods likeconstructor,render,shouldComponentUpdate(see the whole list)
If a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that’s what makes it impure!) This helps you spot and fix the bug early.

Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early.

ThisStoryTraycomponent takes an array ofstoriesand adds one last “Create Story” item at the end:

```jsx
export default function StoryTray({ stories }) {
  const items = stories;
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul>
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}


```

There is a mistake in the code above. However, it is easy to miss because the initial output appears correct.

This mistake will become more noticeable if theStoryTraycomponent re-renders multiple times. For example, let’s make theStoryTrayre-render with a different background color whenever you hover over it:

```jsx
import { useState } from 'react';

export default function StoryTray({ stories }) {
  const [isHover, setIsHover] = useState(false);
  const items = stories;
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul
      onPointerEnter={() => setIsHover(true)}
      onPointerLeave={() => setIsHover(false)}
      style={{
        backgroundColor: isHover ? '#ddd' : '#fff'
      }}
    >
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}


```

Notice how every time you hover over theStoryTraycomponent, “Create Story” gets added to the list again. The intention of the code was to add it once at the end. ButStoryTraydirectly modifies thestoriesarray from the props. Every timeStoryTrayrenders, it adds “Create Story” again at the end of the same array. In other words,StoryTrayis not a pure function—running it multiple times produces different results.

To fix this problem, you can make a copy of the array, and modify that copy instead of the original one:

```jsx
export default function StoryTray({ stories }) {  const items = stories.slice(); // Clone the array  // ✅ Good: Pushing into a new array  items.push({ id: 'create', label: 'Create Story' });
```

This wouldmake theStoryTrayfunction pure.Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.

In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in<StrictMode>:

```jsx
export default function StoryTray({ stories }) {
  const items = stories;
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul>
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}


```

Strict Modealwayscalls your rendering function twice, so you can see the mistake right away(“Create Story” appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, youalsofix many possible future production bugs like the hover functionality from before:

```jsx
import { useState } from 'react';

export default function StoryTray({ stories }) {
  const [isHover, setIsHover] = useState(false);
  const items = stories.slice(); // Clone the array
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul
      onPointerEnter={() => setIsHover(true)}
      onPointerLeave={() => setIsHover(false)}
      style={{
        backgroundColor: isHover ? '#ddd' : '#fff'
      }}
    >
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}


```

Without Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.

Read more about keeping components pure.


### Note
If you haveReact DevToolsinstalled, anyconsole.logcalls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.


### Fixing bugs found by re-running Effects in development
Strict Mode can also help find bugs inEffects.

Every Effect has some setup code and may have some cleanup code. Normally, React calls setup when the componentmounts(is added to the screen) and calls cleanup when the componentunmounts(is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.

When Strict Mode is on, React will also runone extra setup+cleanup cycle in development for every Effect.This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.

Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.

Consider this example that connects a component to a chat:

```jsx
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(<App />);


```

There is an issue with this code, but it might not be immediately clear.

To make the issue more obvious, let’s implement a feature. In the example below,roomIdis not hardcoded. Instead, the user can select theroomIdthat they want to connect to from a dropdown. Click “Open chat” and then select different chat rooms one by one. Keep track of the number of active connections in the console:

```jsx
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(<App />);


```

You’ll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is thatyour Effect is missing a cleanup function:

```jsx
  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);
```

Now that your Effect “cleans up” after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you’ve added more features (the select box).

In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in<StrictMode>:

```jsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);


```

With Strict Mode, you immediately see that there is a problem(the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn’t destroy it. This is a hint that you’re missing a cleanup function.

Strict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, youalsofix many possible future production bugs like the select box from before:

```jsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);


```

Notice how the active connection count in the console doesn’t keep growing anymore.

Without Strict Mode, it was easy to miss that your Effect needed cleanup. By runningsetup → cleanup → setupinstead ofsetupfor your Effect in development, Strict Mode made the missing cleanup logic more noticeable.

Read more about implementing Effect cleanup.


### Fixing bugs found by re-running ref callbacks in development
Strict Mode can also help find bugs incallbacks refs.

Every callbackrefhas some setup code and may have some cleanup code. Normally, React calls setup when the element iscreated(is added to the DOM) and calls cleanup when the element isremoved(is removed from the DOM).

When Strict Mode is on, React will also runone extra setup+cleanup cycle in development for every callbackref.This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.

Consider this example, which allows you to select an animal and then scroll to one of them. Notice when you switch from “Cats” to “Dogs”, the console logs show that the number of animals in the list keeps growing, and the “Scroll to” buttons stop working:

```jsx
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef([]);
  const [catList, setCatList] = useState(setupCatList);
  const [cat, setCat] = useState('neo');

  function scrollToCat(index) {
    const list = itemsRef.current;
    const {node} = list[index];
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  const cats = catList.filter(c => c.type === cat)

  return (
    <>
      <nav>
        <button onClick={() => setCat('neo')}>Neo</button>
        <button onClick={() => setCat('millie')}>Millie</button>
      </nav>
      <hr />
      <nav>
        <span>Scroll to:</span>{cats.map((cat, index) => (
          <button key={cat.src} onClick={() => scrollToCat(index)}>
            {index}
          </button>
        ))}
      </nav>
      <div>
        <ul>
          {cats.map((cat) => (
            <li
              key={cat.src}
              ref={(node) => {
                const list = itemsRef.current;
                const item = {cat: cat, node};
                list.push(item);
                console.log(`✅ Adding cat to the map. Total cats: ${list.length}`);
                if (list.length > 10) {
                  console.log('❌ Too many cats in the list!');
                }
                return () => {
                  // 🚩 No cleanup, this is a bug!
                }
              }}
            >
              <img src={cat.src} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'neo', src: "https://placecats.com/neo/320/240?" + i});
  }
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'millie', src: "https://placecats.com/millie/320/240?" + i});
  }

  return catList;
}


```

This is a production bug!Since the ref callback doesn’t remove animals from the list in the cleanup, the list of animals keeps growing. This is a memory leak that can cause performance problems in a real app, and breaks the behavior of the app.

The issue is the ref callback doesn’t cleanup after itself:

```jsx
<li  ref={node => {    const list = itemsRef.current;    const item = {animal, node};    list.push(item);    return () => {      // 🚩 No cleanup, this is a bug!    }  }}</li>
```

Now let’s wrap the original (buggy) code in<StrictMode>:

```jsx
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef([]);
  const [catList, setCatList] = useState(setupCatList);
  const [cat, setCat] = useState('neo');

  function scrollToCat(index) {
    const list = itemsRef.current;
    const {node} = list[index];
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  const cats = catList.filter(c => c.type === cat)

  return (
    <>
      <nav>
        <button onClick={() => setCat('neo')}>Neo</button>
        <button onClick={() => setCat('millie')}>Millie</button>
      </nav>
      <hr />
      <nav>
        <span>Scroll to:</span>{cats.map((cat, index) => (
          <button key={cat.src} onClick={() => scrollToCat(index)}>
            {index}
          </button>
        ))}
      </nav>
      <div>
        <ul>
          {cats.map((cat) => (
            <li
              key={cat.src}
              ref={(node) => {
                const list = itemsRef.current;
                const item = {cat: cat, node};
                list.push(item);
                console.log(`✅ Adding cat to the map. Total cats: ${list.length}`);
                if (list.length > 10) {
                  console.log('❌ Too many cats in the list!');
                }
                return () => {
                  // 🚩 No cleanup, this is a bug!
                }
              }}
            >
              <img src={cat.src} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'neo', src: "https://placecats.com/neo/320/240?" + i});
  }
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'millie', src: "https://placecats.com/millie/320/240?" + i});
  }

  return catList;
}


```

With Strict Mode, you immediately see that there is a problem. Strict Mode runs an extra setup+cleanup cycle for every callback ref. This callback ref has no cleanup logic, so it adds refs but doesn’t remove them. This is a hint that you’re missing a cleanup function.

Strict Mode lets you eagerly find mistakes in callback refs. When you fix your callback by adding a cleanup function in Strict Mode, youalsofix many possible future production bugs like the “Scroll to” bug from before:

```jsx
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef([]);
  const [catList, setCatList] = useState(setupCatList);
  const [cat, setCat] = useState('neo');

  function scrollToCat(index) {
    const list = itemsRef.current;
    const {node} = list[index];
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  const cats = catList.filter(c => c.type === cat)

  return (
    <>
      <nav>
        <button onClick={() => setCat('neo')}>Neo</button>
        <button onClick={() => setCat('millie')}>Millie</button>
      </nav>
      <hr />
      <nav>
        <span>Scroll to:</span>{cats.map((cat, index) => (
          <button key={cat.src} onClick={() => scrollToCat(index)}>
            {index}
          </button>
        ))}
      </nav>
      <div>
        <ul>
          {cats.map((cat) => (
            <li
              key={cat.src}
              ref={(node) => {
                const list = itemsRef.current;
                const item = {cat: cat, node};
                list.push(item);
                console.log(`✅ Adding cat to the map. Total cats: ${list.length}`);
                if (list.length > 10) {
                  console.log('❌ Too many cats in the list!');
                }
                return () => {
                  list.splice(list.indexOf(item), 1);
                  console.log(`❌ Removing cat from the map. Total cats: ${itemsRef.current.length}`);
                }
              }}
            >
              <img src={cat.src} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'neo', src: "https://placecats.com/neo/320/240?" + i});
  }
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'millie', src: "https://placecats.com/millie/320/240?" + i});
  }

  return catList;
}


```

Now on inital mount in StrictMode, the ref callbacks are all setup, cleaned up, and setup again:

```jsx
...✅ Adding animal to the map. Total animals: 10...❌ Removing animal from the map. Total animals: 0...✅ Adding animal to the map. Total animals: 10
```

This is expected.Strict Mode confirms that the ref callbacks are cleaned up correctly, so the size never grows above the expected amount. After the fix, there are no memory leaks, and all the features work as expected.

Without Strict Mode, it was easy to miss the bug until you clicked around to app to notice broken features. Strict Mode made the bugs appear right away, before you push them to production.


### Fixing deprecation warnings enabled by Strict Mode
React warns if some component anywhere inside a<StrictMode>tree uses one of these deprecated APIs:

- UNSAFE_class lifecycle methods likeUNSAFE_componentWillMount.See alternatives.
These APIs are primarily used in olderclass componentsso they rarely appear in modern apps.


--------------------------------------------------------------------------------


# <Suspense>
Source: https://react.dev/reference/react/Suspense

<Suspense>lets you display a fallback until its children have finished loading.

```jsx
<Suspense fallback={<Loading />}>  <SomeComponent /></Suspense>
```

- Reference<Suspense>
- <Suspense>
- UsageDisplaying a fallback while content is loadingRevealing content together at onceRevealing nested content as it loadsShowing stale content while fresh content is loadingPreventing already revealed content from hidingIndicating that a Transition is happeningResetting Suspense boundaries on navigationProviding a fallback for server errors and client-only content
- Displaying a fallback while content is loading
- Revealing content together at once
- Revealing nested content as it loads
- Showing stale content while fresh content is loading
- Preventing already revealed content from hiding
- Indicating that a Transition is happening
- Resetting Suspense boundaries on navigation
- Providing a fallback for server errors and client-only content
- TroubleshootingHow do I prevent the UI from being replaced by a fallback during an update?
- How do I prevent the UI from being replaced by a fallback during an update?

## Reference

### <Suspense>

#### Props
- children: The actual UI you intend to render. Ifchildrensuspends while rendering, the Suspense boundary will switch to renderingfallback.
- fallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch tofallbackwhenchildrensuspends, and back tochildrenwhen the data is ready. Iffallbacksuspends while rendering, it will activate the closest parent Suspense boundary.

#### Caveats
- React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.
- If Suspense was displaying content for the tree, but then it suspended again, thefallbackwill be shown again unless the update causing it was caused bystartTransitionoruseDeferredValue.
- If React needs to hide the already visible content because it suspended again, it will clean uplayout Effectsin the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don’t try to do this while the content is hidden.
- React includes under-the-hood optimizations likeStreaming Server RenderingandSelective Hydrationthat are integrated with Suspense. Readan architectural overviewand watcha technical talkto learn more.

## Usage

### Displaying a fallback while content is loading
You can wrap any part of your application with a Suspense boundary:

```jsx
<Suspense fallback={<Loading />}>  <Albums /></Suspense>
```

React will display yourloading fallbackuntil all the code and data needed bythe childrenhas been loaded.

In the example below, theAlbumscomponentsuspendswhile fetching the list of albums. Until it’s ready to render, React switches the closest Suspense boundary above to show the fallback—yourLoadingcomponent. Then, when the data loads, React hides theLoadingfallback and renders theAlbumscomponent with data.

```jsx
import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>🌀 Loading...</h2>;
}


```


### Note
Only Suspense-enabled data sources will activate the Suspense component.They include:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a cached Promise withuse
Suspensedoes notdetect when data is fetched inside an Effect or event handler.

The exact way you would load data in theAlbumscomponent above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.


### Revealing content together at once
By default, the whole tree inside Suspense is treated as a single unit. For example, even ifonly oneof these components suspends waiting for some data,allof them together will be replaced by the loading indicator:

```jsx
<Suspense fallback={<Loading />}>  <Biography />  <Panel>    <Albums />  </Panel></Suspense>
```

Then, after all of them are ready to be displayed, they will all appear together at once.

In the example below, bothBiographyandAlbumsfetch some data. However, because they are grouped under a single Suspense boundary, these components always “pop in” together at the same time.

```jsx
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Biography artistId={artist.id} />
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>🌀 Loading...</h2>;
}


```

Components that load data don’t have to be direct children of the Suspense boundary. For example, you can moveBiographyandAlbumsinto a newDetailscomponent. This doesn’t change the behavior.BiographyandAlbumsshare the same closest parent Suspense boundary, so their reveal is coordinated together.

```jsx
<Suspense fallback={<Loading />}>  <Details artistId={artist.id} /></Suspense>function Details({ artistId }) {  return (    <>      <Biography artistId={artistId} />      <Panel>        <Albums artistId={artistId} />      </Panel>    </>  );}
```


### Revealing nested content as it loads
When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary’s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:

```jsx
<Suspense fallback={<BigSpinner />}>  <Biography />  <Suspense fallback={<AlbumsGlimmer />}>    <Panel>      <Albums />    </Panel>  </Suspense></Suspense>
```

With this change, displaying theBiographydoesn’t need to “wait” for theAlbumsto load.

The sequence will be:

1. IfBiographyhasn’t loaded yet,BigSpinneris shown in place of the entire content area.
1. OnceBiographyfinishes loading,BigSpinneris replaced by the content.
1. IfAlbumshasn’t loaded yet,AlbumsGlimmeris shown in place ofAlbumsand its parentPanel.
1. Finally, onceAlbumsfinishes loading, it replacesAlbumsGlimmer.
```jsx
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<BigSpinner />}>
        <Biography artistId={artist.id} />
        <Suspense fallback={<AlbumsGlimmer />}>
          <Panel>
            <Albums artistId={artist.id} />
          </Panel>
        </Suspense>
      </Suspense>
    </>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}

function AlbumsGlimmer() {
  return (
    <div className="glimmer-panel">
      <div className="glimmer-line" />
      <div className="glimmer-line" />
      <div className="glimmer-line" />
    </div>
  );
}


```

Suspense boundaries let you coordinate which parts of your UI should always “pop in” together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app’s behavior.

Don’t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed—it’s likely that they’ve already included them in their design wireframes.


### Showing stale content while fresh content is loading
In this example, theSearchResultscomponent suspends while fetching the search results. Type"a", wait for the results, and then edit it to"ab". The results for"a"will get replaced by the loading fallback.

```jsx
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}


```

A common alternative UI pattern is todeferupdating the list and to keep showing the previous results until the new results are ready. TheuseDeferredValueHook lets you pass a deferred version of the query down:

```jsx
export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}
```

Thequerywill update immediately, so the input will display the new value. However, thedeferredQuerywill keep its previous value until the data has loaded, soSearchResultswill show the stale results for a bit.

To make it more obvious to the user, you can add a visual indication when the stale result list is displayed:

```jsx
<div style={{  opacity: query !== deferredQuery ? 0.5 : 1 }}>  <SearchResults query={deferredQuery} /></div>
```

Enter"a"in the example below, wait for the results to load, and then edit the input to"ab". Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:

```jsx
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{ opacity: isStale ? 0.5 : 1 }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}


```


### Note
Both deferred values andTransitionslet you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it “lag behind” the rest of the UI.


### Preventing already revealed content from hiding
When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:

```jsx
import { Suspense, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    setPage(url);
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}


```

When you pressed the button, theRoutercomponent renderedArtistPageinstead ofIndexPage. A component insideArtistPagesuspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced byBigSpinner.

To prevent this, you can mark the navigation state update as aTransitionwithstartTransition:

```jsx
function Router() {  const [page, setPage] = useState('/');  function navigate(url) {    startTransition(() => {      setPage(url);          });  }  // ...
```

This tells React that the state transition is not urgent, and it’s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button “waits” for theBiographyto load:

```jsx
import { Suspense, startTransition, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}


```

A Transition doesn’t wait forallcontent to load. It only waits long enough to avoid hiding already revealed content. For example, the websiteLayoutwas already revealed, so it would be bad to hide it behind a loading spinner. However, the nestedSuspenseboundary aroundAlbumsis new, so the Transition doesn’t wait for it.


### Note
Suspense-enabled routers are expected to wrap the navigation updates into Transitions by default.


### Indicating that a Transition is happening
In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replacestartTransitionwithuseTransitionwhich gives you a booleanisPendingvalue. In the example below, it’s used to change the website header styling while a Transition is happening:

```jsx
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout isPending={isPending}>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}


```


### Resetting Suspense boundaries on navigation
During a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it isdifferentcontent. You can express this with akey:

```jsx
<ProfilePage key={queryParams.id} />
```

Imagine you’re navigating within a user’s profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That’s the expected behavior.

However, now imagine you’re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user’s timeline isdifferent contentfrom another user’s timeline. By specifying akey, you ensure that React treats different users’ profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.


### Providing a fallback for server errors and client-only content
If you use one of thestreaming server rendering APIs(or a framework that relies on them), React will also use your<Suspense>boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest<Suspense>component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.

On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closestError Boundary.However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.

You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a<Suspense>boundary to replace their HTML with fallbacks:

```jsx
<Suspense fallback={<Loading />}>  <Chat /></Suspense>function Chat() {  if (typeof window === 'undefined') {    throw Error('Chat should only render on the client.');  }  // ...}
```

The server HTML will include the loading indicator. It will be replaced by theChatcomponent on the client.


## Troubleshooting

### How do I prevent the UI from being replaced by a fallback during an update?
Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.

To prevent this from happening,mark the update as non-urgent usingstartTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:

```jsx
function handleNextPageClick() {  // If this update suspends, don't hide the already displayed content  startTransition(() => {    setCurrentPage(currentPage + 1);  });}
```

This will avoid hiding existing content. However, any newly renderedSuspenseboundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.

React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it’s the result of an urgent update. You must opt in with an API likestartTransitionoruseDeferredValue.

If your router is integrated with Suspense, it should wrap its updates intostartTransitionautomatically.


--------------------------------------------------------------------------------


# <ViewTransition>- This feature is available in the latest Canary version of React
Source: https://react.dev/reference/react/ViewTransition


### Canary
The<ViewTransition />API is currently only available in React’s Canary and Experimental channels.

Learn more about React’s release channels here.

<ViewTransition>lets you animate elements that update inside a Transition.

```jsx
import {ViewTransition} from 'react';<ViewTransition>  <div>...</div></ViewTransition>
```

- Reference<ViewTransition>View Transition ClassStyling View Transitions
- <ViewTransition>
- View Transition Class
- Styling View Transitions
- UsageAnimating an element on enter/exitAnimating a shared elementAnimating reorder of items in a listAnimating from Suspense contentOpting-out of an animationCustomizing animationsCustomizing animations with typesBuilding View Transition enabled routers
- Animating an element on enter/exit
- Animating a shared element
- Animating reorder of items in a list
- Animating from Suspense content
- Opting-out of an animation
- Customizing animations
- Customizing animations with types
- Building View Transition enabled routers
- TroubleshootingMy<ViewTransition>is not activatingI’m getting an error “There are two<ViewTransition name=%s>components with the same name mounted at the same time.”
- My<ViewTransition>is not activating
- I’m getting an error “There are two<ViewTransition name=%s>components with the same name mounted at the same time.”

## Reference

### <ViewTransition>
Wrap elements in<ViewTransition>to animate them when they update inside aTransition. React uses the following heuristics to determine if a View Transition activates for an animation:

- enter: If aViewTransitionitself gets inserted in this Transition, then this will activate.
- exit: If aViewTransitionitself gets deleted in this Transition, then this will activate.
- update: If aViewTransitionhas any DOM mutations inside it that React is doing (such as a prop changing) or if theViewTransitionboundary itself changes size or position due to an immediate sibling. If there are nestedViewTransitionthen the mutation applies to them and not the parent.
- share: If a namedViewTransitionis inside a deleted subtree and another namedViewTransitionwith the same name is part of an inserted subtree in the same Transition, they form a Shared Element Transition, and it animates from the deleted one to the inserted one.
By default,<ViewTransition>animates with a smooth cross-fade (the browser default view transition). You can customize the animation by providing aView Transition Classto the<ViewTransition>component. You can  customize animations for each kind of trigger (seeStyling View Transitions).


#### How does<ViewTransition>work?
Under the hood, React appliesview-transition-nameto inline styles of the nearest DOM node nested inside the<ViewTransition>component. If there are multiple sibling DOM nodes like<ViewTransition><div /><div /></ViewTransition>then React adds a suffix to the name to make each unique but conceptually they’re part of the same one. React doesn’t apply these eagerly but only at the time that boundary should participate in an animation.

React automatically callsstartViewTransitionitself behind the scenes so you should never do that yourself. In fact, if you have something else on the page running a ViewTransition React will interrupt it. So it’s recommended that you use React itself to coordinate these. If you had other ways of trigger ViewTransitions in the past, we recommend that you migrate to the built-in way.

If there are other React ViewTransitions already running then React will wait for them to finish before starting the next one. However, importantly if there are multiple updates happening while the first one is running, those will all be batched into one. If you start A->B. Then in the meantime you get an update to go to C and then D. When the first A->B animation finishes the next one will animate from B->D.

ThegetSnapshotBeforeUpdatelife-cycle will be called beforestartViewTransitionand someview-transition-namewill update at the same time.

Then React callsstartViewTransition. Inside theupdateCallback, React will:

- Apply its mutations to the DOM and invoke useInsertionEffects.
- Wait for fonts to load.
- Call componentDidMount, componentDidUpdate, useLayoutEffect and refs.
- Wait for any pending Navigation to finish.
- Then React will measure any changes to the layout to see which boundaries will need to animate.
After the ready Promise of thestartViewTransitionis resolved, React will then revert theview-transition-name. Then React will invoke theonEnter,onExit,onUpdateandonSharecallbacks to allow for manual programmatic control over the Animations. This will be after the built-in default ones have already been computed.

If aflushSynchappens to get in the middle of this sequence, then React will skip the Transition since it relies on being able to complete synchronously.

After the finished Promise of thestartViewTransitionis resolved, React will then invokeuseEffect. This prevents those from interfering with the performance of the Animation. However, this is not a guarantee because if anothersetStatehappens while the Animation is running it’ll still have to invoke theuseEffectearlier to preserve the sequential guarantees.


#### Props
By default,<ViewTransition>animates with a smooth cross-fade. You can customize the animation, or specify a shared element transition, with these props:

- optionalenter: A string or object. TheView Transition Classto apply when enter is activated.
- optionalexit: A string or object. TheView Transition Classto apply when exit is activated.
- optionalupdate: A string or object. TheView Transition Classto apply when an update is activated.
- optionalshare: A string or object. TheView Transition Classto apply when a shared element is activated.
- optionaldefault: A string or object. TheView Transition Classused when no other matching activation prop is found.
- optionalname: A string or object. The name of the View Transition used for shared element transitions. If not provided, React will use a unique name for each View Transition to prevent unexpected animations.

#### Callback
These callbacks allow you to adjust the animation imperatively using theanimateAPIs:

- optionalonEnter: A function. React callsonEnterafter an “enter” animation.
- optionalonExit: A function. React callsonExitafter an “exit” animation.
- optionalonShare:  A function. React callsonShareafter a “share” animation.
- optionalonUpdate:  A function. React callsonUpdateafter an “update” animation.
Each callback receives as arguments:

- element: The DOM element that was animated.
- types: TheTransition Typesincluded in the animation.

### View Transition Class
The View Transition Class is the CSS class name(s) applied by React during the transition when the ViewTransition activates. It can be a string or an object.

- string: theclassadded on the child elements when activated. If'none'is provided, no class will be added.
- object: the class added on the child elements will be the key matching View Transition type added withaddTransitionType. The object can also specify adefaultto use if no matching type is found.
The value'none'can be used to prevent a View Transition from activating for a specific trigger.


### Styling View Transitions

### Note
In many early examples of View Transitions around the web, you’ll have seen using aview-transition-nameand then style it using::view-transition-...(my-name)selectors. We don’t recommend that for styling. Instead, we normally recommend using a View Transition Class instead.

To customize the animation for a<ViewTransition>you can provide a View Transition Class to one of the activation props. The View Transition Class is a CSS class name that React applies to the child elements when the ViewTransition activates.

For example, to customize an “enter” animation, provide a class name to theenterprop:

```jsx
<ViewTransition enter="slide-in">
```

When the<ViewTransition>activates an “enter” animation, React will add the class nameslide-in. Then you can refer to this class usingview transition pseudo selectorsto build reusable animations:

```jsx
::view-transition-group(.slide-in) {  }::view-transition-old(.slide-in) {}::view-transition-new(.slide-in) {}
```

In the future, CSS libraries may add built-in animations using View Transition Classes to make this easier to use.


#### Caveats
- By default,setStateupdates immediately and does not activate<ViewTransition>, only updates wrapped in aTransition. You can also use<Suspense>to opt-in to a Transition toreveal content.
- <ViewTransition>creates an image that can be moved around, scaled and cross-faded. Unlike Layout Animations you may have seen in React Native or Motion, this means that not every individual Element inside of it animates its position. This can lead to better performance and a more continuous feeling, smooth animation compared to animating every individual piece. However, it can also lose continuity in things that should be moving by themselves. So you might have to add more<ViewTransition>boundaries manually as a result.
- Many users may prefer not having animations on the page. React doesn’t automatically disable animations for this case. We recommend that using the@media (prefers-reduced-motion)media query to disable animations or tone them down based on user preference. In the future, CSS libraries may have this built-in to their presets.
- Currently,<ViewTransition>only works in the DOM. We’re working on adding support for React Native and other platforms.

## Usage

### Animating an element on enter/exit
Enter/Exit Transitions trigger when a<ViewTransition>is added or removed by a component in a transition:

```jsx
function Child() {  return (    <ViewTransition>      <div>Hi</div>    </ViewTransition>  );}function Parent() {  const [show, setShow] = useState();  if (show) {    return <Child />;  }  return null;}
```

WhensetShowis called,showswitches totrueand theChildcomponent is rendered. WhensetShowis called insidestartTransition, andChildrenders aViewTransitionbefore any other DOM nodes, anenteranimation is triggered.

Whenshowswitches back tofalse, anexitanimation is triggered.

```jsx
import {
  ViewTransition,
  useState,
  startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition>
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>

      {showItem ? <Item /> : null}
    </>
  );
}


```


### Pitfall
<ViewTransition>only activates if it is placed before any DOM node. IfChildinstead looked like this, no animation would trigger:

```jsx
function Component() {  return <ViewTransition>Hi</ViewTransition>;}
```


### Animating a shared element
Normally, we don’t recommend assigning a name to a<ViewTransition>and instead let React assign it an automatic name. The reason you might want to assign a name is to animate between completely different components when one tree unmounts and another tree mounts at the same time. To preserve continuity.

```jsx
<ViewTransition name={UNIQUE_NAME}>  <Child /></ViewTransition>
```

When one tree unmounts and another mounts, if there’s a pair where the same name exists in the unmounting tree and the mounting tree, they trigger the “share” animation on both. It animates from the unmounting side to the mounting side.

Unlike an exit/enter animation this can be deeply inside the deleted/mounted tree. If a<ViewTransition>would also be eligible for exit/enter, then the “share” animation takes precedence.

If Transition first unmounts one side and then leads to a<Suspense>fallback being shown before eventually the new name being mounted, then no shared element transition happens.

```jsx
import {
  ViewTransition,
  useState,
  startTransition
} from "react";
import {Video, Thumbnail, FullscreenVideo} from "./Video";
import videos from "./data";

export default function Component() {
  const [fullscreen, setFullscreen] = useState(false);
  if (fullscreen) {
    return <FullscreenVideo
      video={videos[0]}
      onExit={() => startTransition(() => setFullscreen(false))}
    />
  }
  return <Video
    video={videos[0]}
    onClick={() => startTransition(() => setFullscreen(true))}
  />
}


```


### Note
If either the mounted or unmounted side of a pair is outside the viewport, then no pair is formed. This ensures that it doesn’t fly in or out of the viewport when something is scrolled. Instead it’s treated as a regular enter/exit by itself.

This does not happen if the same Component instance changes position, which triggers an “update”. Those animate regardless if one position is outside the viewport.

There’s currently a quirk where if a deeply nested unmounted<ViewTransition>is inside the viewport but the mounted side is not within the viewport, then the unmounted side animates as its own “exit” animation even if it’s deeply nested instead of as part of the parent animation.


### Pitfall
It’s important that there’s only one thing with the same name mounted at a time in the entire app. Therefore it’s important to use unique namespaces for the name to avoid conflicts. To ensure you can do this you might want to add a constant in a separate module that you import.

```jsx
export const MY_NAME = "my-globally-unique-name";import {MY_NAME} from './shared-name';...<ViewTransition name={MY_NAME}>
```


### Animating reorder of items in a list
```jsx
items.map(item => <Component key={item.id} item={item} />)
```

When reordering a list, without updating the content, the “update” animation triggers on each<ViewTransition>in the list if they’re outside a DOM node. Similar to enter/exit animations.

This means that this will trigger the animation on this<ViewTransition>:

```jsx
function Component() {  return <ViewTransition><div>...</div></ViewTransition>;}
```

```jsx
import {
  ViewTransition,
  useState,
  startTransition
} from "react";
import {Video} from "./Video";
import videos from "./data";

export default function Component() {
  const [orderedVideos, setOrderedVideos] = useState(videos);
  const reorder = () => {
    startTransition(() => {
      setOrderedVideos((prev) => {
        return [...prev.sort(() => Math.random() - 0.5)];
      });
    });
  };
  return (
    <>
      <button onClick={reorder}>🎲</button>
      <div className="listContainer">
        {orderedVideos.map((video, i) => {
          return (
            <ViewTransition key={video.title}>
              <Video video={video} />
            </ViewTransition>
          );
        })}
      </div>
    </>
  );
}


```

However, this wouldn’t animate each individual item:

```jsx
function Component() {  return <div><ViewTransition>...</ViewTransition></div>;}
```

Instead, any parent<ViewTransition>would cross-fade. If there is no parent<ViewTransition>then there’s no animation in that case.

```jsx
import {
  ViewTransition,
  useState,
  startTransition
} from "react";
import {Video} from "./Video";
import videos from "./data";

export default function Component() {
  const [orderedVideos, setOrderedVideos] = useState(videos);
  const reorder = () => {
    startTransition(() => {
      setOrderedVideos((prev) => {
        return [...prev.sort(() => Math.random() - 0.5)];
      });
    });
  };
  return (
    <>
      <button onClick={reorder}>🎲</button>
      <ViewTransition>
        <div className="listContainer">
          {orderedVideos.map((video, i) => {
            return <Video video={video} key={video.title} />;
          })}
        </div>
      </ViewTransition>
    </>
  );
}


```

This means you might want to avoid wrapper elements in lists where you want to allow the Component to control its own reorder animation:

```jsx
items.map(item => <div><Component key={item.id} item={item} /></div>)
```

The above rule also applies if one of the items updates to resize, which then causes the siblings to resize, it’ll also animate its sibling<ViewTransition>but only if they’re immediate siblings.

This means that during an update, which causes a lot of re-layout, it doesn’t individually animate every<ViewTransition>on the page. That would lead to a lot of noisy animations which distracts from the actual change. Therefore React is more conservative about when an individual animation triggers.


### Pitfall
It’s important to properly use keys to preserve identity when reordering lists. It might seem like you could use “name”, shared element transitions, to animate reorders but that would not trigger if one side was outside the viewport. To animate a reorder you often want to show that it went to a position outside the viewport.


### Animating from Suspense content
Just like any Transition, React waits for data and new CSS (<link rel="stylesheet" precedence="...">) before running the animation. In addition to this, ViewTransitions also wait up to 500ms for new fonts to load before starting the animation to avoid them flickering in later. For the same reason, an image wrapped in ViewTransition will wait for the image to load.

If it’s inside a new Suspense boundary instance, then the fallback is shown first. After the Suspense boundary fully loads, it triggers the<ViewTransition>to animate the reveal to the content.

There are two ways to animate Suspense boundaries depending on where you place the<ViewTransition>:

Update:

```jsx
<ViewTransition>  <Suspense fallback={<A />}>    <B />  </Suspense></ViewTransition>
```

In this scenario when the content goes from A to B, it’ll be treated as an “update” and apply that class if appropriate. Both A and B will get the same view-transition-name and therefore they’re acting as a cross-fade by default.

```jsx
import {
  ViewTransition,
  useState,
  startTransition,
  Suspense
} from 'react';
import {Video, VideoPlaceholder} from "./Video";
import {useLazyVideoData} from "./data"

function LazyVideo() {
  const video = useLazyVideoData();
  return (
    <Video video={video}/>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>
      {showItem ? (
        <ViewTransition>
          <Suspense fallback={<VideoPlaceholder />}>
            <LazyVideo />
          </Suspense>
        </ViewTransition>
      ) : null}
    </>
  );
}


```

Enter/Exit:

```jsx
<Suspense fallback={<ViewTransition><A /></ViewTransition>}>  <ViewTransition><B /></ViewTransition></Suspense>
```

In this scenario, these are two separate ViewTransition instances each with their ownview-transition-name. This will be treated as an “exit” of the<A>and an “enter” of the<B>.

You can achieve different effects depending on where you choose to place the<ViewTransition>boundary.


### Opting-out of an animation
Sometimes you’re wrapping a large existing component, like a whole page, and you want to animate some updates, such as changing the theme. However, you don’t want it to opt-in all updates inside the whole page to cross-fade when they’re updating. Especially if you’re incrementally adding more animations.

You can use the class “none” to opt-out of an animation. By wrapping your children in a “none” you can disable animations for updates to them while the parent still triggers.

```jsx
<ViewTransition>  <div className={theme}>    <ViewTransition update="none">      {children}    </ViewTransition>  </div></ViewTransition>
```

This will only animate if the theme changes and not if only the children update. The children can still opt-in again with their own<ViewTransition>but at least it’s manual again.


### Customizing animations
By default,<ViewTransition>includes the default cross-fade from the browser.

To customize animations, you can provide props to the<ViewTransition>component to specify which animations to use, based on how the<ViewTransition>activates.

For example, we can slow down the default cross fade animation:

```jsx
<ViewTransition default="slow-fade">  <Video /></ViewTransition>
```

And define slow-fade in CSS using view transition classes:

```jsx
::view-transition-old(.slow-fade) {    animation-duration: 500ms;}::view-transition-new(.slow-fade) {    animation-duration: 500ms;}
```

```jsx
import {
  ViewTransition,
  useState,
  startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition default="slow-fade">
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>

      {showItem ? <Item /> : null}
    </>
  );
}


```

In addition to setting thedefault, you can also provide configurations forenter,exit,update, andshareanimations.

```jsx
import {
  ViewTransition,
  useState,
  startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition enter="slide-in" exit="slide-out">
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>

      {showItem ? <Item /> : null}
    </>
  );
}


```


### Customizing animations with types
You can use theaddTransitionTypeAPI to add a class name to the child elements when a specific transition type is activated for a specific activation trigger. This allows you to customize the animation for each type of transition.

For example, to customize the animation for all forward and backward navigations:

```jsx
<ViewTransition default={{  'navigation-back': 'slide-right',  'navigation-forward': 'slide-left', }}>  <div>...</div></ViewTransition> // in your router:startTransition(() => {  addTransitionType('navigation-' + navigationType);});
```

When the ViewTransition activates a “navigation-back” animation, React will add the class name “slide-right”. When the ViewTransition activates a “navigation-forward” animation, React will add the class name “slide-left”.

In the future, routers and other libraries may add support for standard view-transition types and styles.

```jsx
import {
  ViewTransition,
  addTransitionType,
  useState,
  startTransition,
} from "react";
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition enter={
        {
          "add-video-back": "slide-in-back",
          "add-video-forward": "slide-in-forward"
        }
      }
      exit={
        {
          "remove-video-back": "slide-in-forward",
          "remove-video-forward": "slide-in-back"
        }
      }>
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <div className="button-container">
        <button
          onClick={() => {
            startTransition(() => {
              if (showItem) {
                addTransitionType("remove-video-back")
              } else {
                addTransitionType("add-video-back")
              }
              setShowItem((prev) => !prev);
            });
          }}
        >⬅️</button>
        <button
          onClick={() => {
            startTransition(() => {
              if (showItem) {
                addTransitionType("remove-video-forward")
              } else {
                addTransitionType("add-video-forward")
              }
              setShowItem((prev) => !prev);
            });
          }}
        >➡️</button>
      </div>
      {showItem ? <Item /> : null}
    </>
  );
}


```


### Building View Transition enabled routers
React waits for any pending Navigation to finish to ensure that scroll restoration happens within the animation. If the Navigation is blocked on React, your router must unblock inuseLayoutEffectsinceuseEffectwould lead to a deadlock.

If astartTransitionis started from the legacy popstate event, such as during a “back”-navigation then it must finish synchronously to ensure scroll and form restoration works correctly. This is in conflict with running a View Transition animation. Therefore, React will skip animations from popstate. Therefore animations won’t run for the back button. You can fix this by upgrading your router to use the Navigation API.


## Troubleshooting

### My<ViewTransition>is not activating
<ViewTransition>only activates if it is placed before any DOM node:

```jsx
function Component() {  return (    <div>      <ViewTransition>Hi</ViewTransition>    </div>  );}
```

To fix, ensure that the<ViewTransition>comes before any other DOM nodes:

```jsx
function Component() {  return (    <ViewTransition>      <div>Hi</div>    </ViewTransition>  );}
```


### I’m getting an error “There are two<ViewTransition name=%s>components with the same name mounted at the same time.”
This error occurs when two<ViewTransition>components with the samenameare mounted at the same time:

```jsx
function Item() {  // 🚩 All items will get the same "name".  return <ViewTransition name="item">...</ViewTransition>;}function ItemList({items}) {  return (    <>      {item.map(item => <Item key={item.id} />)}    </>  );}
```

This will cause the View Transition to error. In development, React detects this issue to surface it and logs two errors:

To fix, ensure that there’s only one<ViewTransition>with the same name mounted at a time in the entire app by ensuring thenameis unique, or adding anidto the name:

```jsx
function Item({id}) {  // ✅ All items will get the same "name".  return <ViewTransition name={`item-${id}`}>...</ViewTransition>;}function ItemList({items}) {  return (    <>      {item.map(item => <Item key={item.id} item={item} />)}    </>  );}
```


--------------------------------------------------------------------------------


# act
Source: https://react.dev/reference/react/act

actis a test helper to apply pending React updates before making assertions.

```jsx
await act(async actFn)
```

To prepare a component for assertions, wrap the code rendering it and performing updates inside anawait act()call. This makes your test run closer to how React works in the browser.


### Note
You might find usingact()directly a bit too verbose. To avoid some of the boilerplate, you could use a library likeReact Testing Library, whose helpers are wrapped withact().

- Referenceawait act(async actFn)
- await act(async actFn)
- UsageRendering components in testsDispatching events in tests
- Rendering components in tests
- Dispatching events in tests
- TroubleshootingI’m getting an error: “The current testing environment is not configured to support act(…)”
- I’m getting an error: “The current testing environment is not configured to support act(…)”

## Reference

### await act(async actFn)
When writing UI tests, tasks like rendering, user events, or data fetching can be considered as “units” of interaction with a user interface. React provides a helper calledact()that makes sure all updates related to these “units” have been processed and applied to the DOM before you make any assertions.

The nameactcomes from theArrange-Act-Assertpattern.

```jsx
it ('renders with button disabled', async () => {  await act(async () => {    root.render(<TestComponent />)  });  expect(container.querySelector('button')).toBeDisabled();});
```


### Note
We recommend usingactwithawaitand anasyncfunction. Although the sync version works in many cases, it doesn’t work in all cases and due to the way React schedules updates internally, it’s difficult to predict when you can use the sync version.

We will deprecate and remove the sync version in the future.


#### Parameters
- async actFn: An async function wrapping renders or interactions for components being tested. Any updates triggered within theactFn, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled.

#### Returns
actdoes not return anything.


## Usage
When testing a component, you can useactto make assertions about its output.

For example, let’s say we have thisCountercomponent, the usage examples below show how to test it:

```jsx
function Counter() {  const [count, setCount] = useState(0);  const handleClick = () => {    setCount(prev => prev + 1);  }  useEffect(() => {    document.title = `You clicked ${count} times`;  }, [count]);  return (    <div>      <p>You clicked {count} times</p>      <button onClick={handleClick}>        Click me      </button>    </div>  )}
```


### Rendering components in tests
To test the render output of a component, wrap the render insideact():

```jsx
import {act} from 'react';import ReactDOMClient from 'react-dom/client';import Counter from './Counter';it('can render and update a counter', async () => {  container = document.createElement('div');  document.body.appendChild(container);    // ✅ Render the component inside act().  await act(() => {    ReactDOMClient.createRoot(container).render(<Counter />);  });    const button = container.querySelector('button');  const label = container.querySelector('p');  expect(label.textContent).toBe('You clicked 0 times');  expect(document.title).toBe('You clicked 0 times');});
```

Here, we create a container, append it to the document, and render theCountercomponent insideact(). This ensures that the component is rendered and its effects are applied before making assertions.

Usingactensures that all updates have been applied before we make assertions.


### Dispatching events in tests
To test events, wrap the event dispatch insideact():

```jsx
import {act} from 'react';import ReactDOMClient from 'react-dom/client';import Counter from './Counter';it.only('can render and update a counter', async () => {  const container = document.createElement('div');  document.body.appendChild(container);    await act( async () => {    ReactDOMClient.createRoot(container).render(<Counter />);  });    // ✅ Dispatch the event inside act().  await act(async () => {    button.dispatchEvent(new MouseEvent('click', { bubbles: true }));  });  const button = container.querySelector('button');  const label = container.querySelector('p');  expect(label.textContent).toBe('You clicked 1 times');  expect(document.title).toBe('You clicked 1 times');});
```

Here, we render the component withact, and then dispatch the event inside anotheract(). This ensures that all updates from the event are applied before making assertions.


### Pitfall
Don’t forget that dispatching DOM events only works when the DOM container is added to the document. You can use a library likeReact Testing Libraryto reduce the boilerplate code.


## Troubleshooting

### I’m getting an error: “The current testing environment is not configured to support act(…)”
Usingactrequires settingglobal.IS_REACT_ACT_ENVIRONMENT=truein your test environment. This is to ensure thatactis only used in the correct environment.

If you don’t set the global, you will see an error like this:

To fix, add this to your global setup file for React tests:

```jsx
global.IS_REACT_ACT_ENVIRONMENT=true
```


### Note
In testing frameworks likeReact Testing Library,IS_REACT_ACT_ENVIRONMENTis already set for you.


--------------------------------------------------------------------------------


# addTransitionType- This feature is available in the latest Canary version of React
Source: https://react.dev/reference/react/addTransitionType


### Canary
TheaddTransitionTypeAPI is currently only available in React’s Canary and Experimental channels.

Learn more about React’s release channels here.

addTransitionTypelets you specify the cause of a transition.

```jsx
startTransition(() => {  addTransitionType('my-transition-type');  setState(newState);});
```

- ReferenceaddTransitionType
- addTransitionType
- UsageAdding the cause of a transitionCustomize animations using browser view transition typesCustomize animations usingView TransitionClassCustomize animations usingViewTransitionevents
- Adding the cause of a transition
- Customize animations using browser view transition types
- Customize animations usingView TransitionClass
- Customize animations usingViewTransitionevents

## Reference

### addTransitionType

#### Parameters
- type: The type of transition to add. This can be any string.

#### Returns
addTransitionTypedoes not return anything.


#### Caveats
- If multiple transitions are combined, all Transition Types are collected. You can also add more than one type to a Transition.
- Transition Types are reset after each commit. This means a<Suspense>fallback will associate the types after astartTransition, but revealing the content does not.

## Usage

### Adding the cause of a transition
CalladdTransitionTypeinside ofstartTransitionto indicate the cause of a transition:

```jsx
import { startTransition, addTransitionType } from 'react';function Submit({action) {  function handleClick() {    startTransition(() => {      addTransitionType('submit-click');      action();    });  }  return <button onClick={handleClick}>Click me</button>;}
```

When you calladdTransitionTypeinside the scope ofstartTransition, React will associatesubmit-clickas one of the causes for the Transition.

Currently, Transition Types can be used to customize different animations based on what caused the Transition. You have three different ways to choose from for how to use them:

- Customize animations using browser view transition types
- Customize animations usingView TransitionClass
- Customize animations usingViewTransitionevents
In the future, we plan to support more use cases for using the cause of a transition.


### Customize animations using browser view transition types
When aViewTransitionactivates from a transition, React adds all the Transition Types as browserview transition typesto the element.

This allows you to customize different animations based on CSS scopes:

```jsx
function Component() {  return (    <ViewTransition>      <div>Hello</div>    </ViewTransition>  );}startTransition(() => {  addTransitionType('my-transition-type');  setShow(true);});
```

```jsx
:root:active-view-transition-type(my-transition-type) {  &::view-transition-...(...) {    ...  }}
```


### Customize animations usingView TransitionClass
You can customize animations for an activatedViewTransitionbased on type by passing an object to the View Transition Class:

```jsx
function Component() {  return (    <ViewTransition enter={{      'my-transition-type': 'my-transition-class',    }}>      <div>Hello</div>    </ViewTransition>  );}// ...startTransition(() => {  addTransitionType('my-transition-type');  setState(newState);});
```

If multiple types match, then they’re joined together. If no types match then the special “default” entry is used instead. If any type has the value “none” then that wins and the ViewTransition is disabled (not assigned a name).

These can be combined with enter/exit/update/layout/share props to match based on kind of trigger and Transition Type.

```jsx
<ViewTransition enter={{  'navigation-back': 'enter-right',  'navigation-forward': 'enter-left',}}exit={{  'navigation-back': 'exit-right',  'navigation-forward': 'exit-left',}}>
```


### Customize animations usingViewTransitionevents
You can imperatively customize animations for an activatedViewTransitionbased on type using View Transition events:

```jsx
<ViewTransition onUpdate={(inst, types) => {  if (types.includes('navigation-back')) {    ...  } else if (types.includes('navigation-forward')) {    ...  } else {    ...  }}}>
```

This allows you to pick different imperative Animations based on the cause.


--------------------------------------------------------------------------------


# Built-in React APIs
Source: https://react.dev/reference/react/apis

In addition toHooksandComponents, thereactpackage exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.

- createContextlets you define and provide context to the child components. Used withuseContext.
- lazylets you defer loading a component’s code until it’s rendered for the first time.
- memolets your component skip re-renders with same props. Used withuseMemoanduseCallback.
- startTransitionlets you mark a state update as non-urgent. Similar touseTransition.
- actlets you wrap renders and interactions in tests to ensure updates have processed before making assertions.

## Resource APIs
Resourcescan be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.

To read a value from a resource, use this API:

- uselets you read the value of a resource like aPromiseorcontext.
```jsx
function MessageComponent({ messagePromise }) {  const message = use(messagePromise);  const theme = use(ThemeContext);  // ...}
```


--------------------------------------------------------------------------------


# cache
Source: https://react.dev/reference/react/cache


### React Server Components
cacheis only for use withReact Server Components.

cachelets you cache the result of a data fetch or computation.

```jsx
const cachedFn = cache(fn);
```

- Referencecache(fn)
- cache(fn)
- UsageCache an expensive computationShare a snapshot of dataPreload data
- Cache an expensive computation
- Share a snapshot of data
- Preload data
- TroubleshootingMy memoized function still runs even though I’ve called it with the same arguments
- My memoized function still runs even though I’ve called it with the same arguments

## Reference

### cache(fn)
Callcacheoutside of any components to create a version of the function with caching.

```jsx
import {cache} from 'react';import calculateMetrics from 'lib/metrics';const getMetrics = cache(calculateMetrics);function Chart({data}) {  const report = getMetrics(data);  // ...}
```

WhengetMetricsis first called withdata,getMetricswill callcalculateMetrics(data)and store the result in cache. IfgetMetricsis called again with the samedata, it will return the cached result instead of callingcalculateMetrics(data)again.

See more examples below.


#### Parameters
- fn: The function you want to cache results for.fncan take any arguments and return any value.

#### Returns
cachereturns a cached version offnwith the same type signature. It does not callfnin the process.

When callingcachedFnwith given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it callsfnwith the arguments, stores the result in the cache, and returns the result. The only timefnis called is when there is a cache miss.


### Note
The optimization of caching return values based on inputs is known asmemoization. We refer to the function returned fromcacheas a memoized function.


#### Caveats
- React will invalidate the cache for all memoized functions for each server request.
- Each call tocachecreates a new function. This means that callingcachewith the same function multiple times will return different memoized functions that do not share the same cache.
- cachedFnwill also cache errors. Iffnthrows an error for certain arguments, it will be cached, and the same error is re-thrown whencachedFnis called with those same arguments.
- cacheis for use inServer Componentsonly.

## Usage

### Cache an expensive computation
Usecacheto skip duplicate work.

```jsx
import {cache} from 'react';import calculateUserMetrics from 'lib/user';const getUserMetrics = cache(calculateUserMetrics);function Profile({user}) {  const metrics = getUserMetrics(user);  // ...}function TeamReport({users}) {  for (let user in users) {    const metrics = getUserMetrics(user);    // ...  }  // ...}
```

If the sameuserobject is rendered in bothProfileandTeamReport, the two components can share work and only callcalculateUserMetricsonce for thatuser.

AssumeProfileis rendered first. It will callgetUserMetrics, and check if there is a cached result. Since it is the first timegetUserMetricsis called with thatuser, there will be a cache miss.getUserMetricswill then callcalculateUserMetricswith thatuserand write the result to cache.

WhenTeamReportrenders its list ofusersand reaches the sameuserobject, it will callgetUserMetricsand read the result from cache.

IfcalculateUserMetricscan be aborted by passing anAbortSignal, you can usecacheSignal()to cancel the expensive computation if React has finished rendering.calculateUserMetricsmay already handle cancellation internally by usingcacheSignaldirectly.


### Pitfall
To access the same cache, components must call the same memoized function.

```jsx
// Temperature.jsimport {cache} from 'react';import {calculateWeekReport} from './report';export function Temperature({cityData}) {  // 🚩 Wrong: Calling `cache` in component creates new `getWeekReport` for each render  const getWeekReport = cache(calculateWeekReport);  const report = getWeekReport(cityData);  // ...}
```

```jsx
// Precipitation.jsimport {cache} from 'react';import {calculateWeekReport} from './report';// 🚩 Wrong: `getWeekReport` is only accessible for `Precipitation` component.const getWeekReport = cache(calculateWeekReport);export function Precipitation({cityData}) {  const report = getWeekReport(cityData);  // ...}
```

In the above example,PrecipitationandTemperatureeach callcacheto create a new memoized function with their own cache look-up. If both components render for the samecityData, they will do duplicate work to callcalculateWeekReport.

In addition,Temperaturecreates anew memoized functioneach time the component is rendered which doesn’t allow for any cache sharing.

To maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can beimport-edacross components.

```jsx
// getWeekReport.jsimport {cache} from 'react';import {calculateWeekReport} from './report';export default cache(calculateWeekReport);
```

```jsx
// Temperature.jsimport getWeekReport from './getWeekReport';export default function Temperature({cityData}) {	const report = getWeekReport(cityData);  // ...}
```

```jsx
// Precipitation.jsimport getWeekReport from './getWeekReport';export default function Precipitation({cityData}) {  const report = getWeekReport(cityData);  // ...}
```

Here, both components call thesame memoized functionexported from./getWeekReport.jsto read and write to the same cache.


### Share a snapshot of data
To share a snapshot of data between components, callcachewith a data-fetching function likefetch. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.

```jsx
import {cache} from 'react';import {fetchTemperature} from './api.js';const getTemperature = cache(async (city) => {	return await fetchTemperature(city);});async function AnimatedWeatherCard({city}) {	const temperature = await getTemperature(city);	// ...}async function MinimalWeatherCard({city}) {	const temperature = await getTemperature(city);	// ...}
```

IfAnimatedWeatherCardandMinimalWeatherCardboth render for the samecity, they will receive the same snapshot of data from thememoized function.

IfAnimatedWeatherCardandMinimalWeatherCardsupply differentcityarguments togetTemperature, thenfetchTemperaturewill be called twice and each call site will receive different data.

Thecityacts as a cache key.


### Note
Asynchronous renderingis only supported for Server Components.

```jsx
async function AnimatedWeatherCard({city}) {	const temperature = await getTemperature(city);	// ...}
```

To render components that use asynchronous data in Client Components, seeuse()documentation.


### Preload data
By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.

```jsx
const getUser = cache(async (id) => {  return await db.user.query(id);});async function Profile({id}) {  const user = await getUser(id);  return (    <section>      <img src={user.profilePic} />      <h2>{user.name}</h2>    </section>  );}function Page({id}) {  // ✅ Good: start fetching the user data  getUser(id);  // ... some computational work  return (    <>      <Profile id={id} />    </>  );}
```

When renderingPage, the component callsgetUserbut note that it doesn’t use the returned data. This earlygetUsercall kicks off the asynchronous database query that occurs whilePageis doing other computational work and rendering children.

When renderingProfile, we callgetUseragain. If the initialgetUsercall has already returned and cached the user data, whenProfileasks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If theinitial data requesthasn’t been completed, preloading data in this pattern reduces delay in data-fetching.


#### Caching asynchronous work
When evaluating anasynchronous function, you will receive aPromisefor that work. The promise holds the state of that work (pending,fulfilled,failed) and its eventual settled result.

In this example, the asynchronous functionfetchDatareturns a promise that is awaiting thefetch.

```jsx
async function fetchData() {  return await fetch(`https://...`);}const getData = cache(fetchData);async function MyComponent() {  getData();  // ... some computational work  await getData();  // ...}
```

In callinggetDatathe first time, the promise returned fromfetchDatais cached. Subsequent look-ups will then return the same promise.

Notice that the firstgetDatacall does notawaitwhereas theseconddoes.awaitis a JavaScript operator that will wait and return the settled result of the promise. The firstgetDatacall simply initiates thefetchto cache the promise for the secondgetDatato look-up.

If by thesecond callthe promise is stillpending, thenawaitwill pause for the result. The optimization is that while we wait on thefetch, React can continue with computational work, thus reducing the wait time for thesecond call.

If the promise is already settled, either to an error or thefulfilledresult,awaitwill return that value immediately. In both outcomes, there is a performance benefit.


### Pitfall
```jsx
import {cache} from 'react';const getUser = cache(async (userId) => {  return await db.user.query(userId);});// 🚩 Wrong: Calling memoized function outside of component will not memoize.getUser('demo-id');async function DemoProfile() {  // ✅ Good: `getUser` will memoize.  const user = await getUser('demo-id');  return <Profile user={user} />;}
```

React only provides cache access to the memoized function in a component. When callinggetUseroutside of a component, it will still evaluate the function but not read or update the cache.

This is because cache access is provided through acontextwhich is only accessible from a component.


#### When should I usecache,memo, oruseMemo?
All mentioned APIs offer memoization but the difference is what they’re intended to memoize, who can access the cache, and when their cache is invalidated.


#### useMemo
In general, you should useuseMemofor caching an expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.

```jsx
'use client';function WeatherReport({record}) {  const avgTemp = useMemo(() => calculateAvg(record), record);  // ...}function App() {  const record = getRecord();  return (    <>      <WeatherReport record={record} />      <WeatherReport record={record} />    </>  );}
```

In this example,Apprenders twoWeatherReports with the same record. Even though both components do the same work, they cannot share work.useMemo’s cache is only local to the component.

However,useMemodoes ensure that ifAppre-renders and therecordobject doesn’t change, each component instance would skip work and use the memoized value ofavgTemp.useMemowill only cache the last computation ofavgTempwith the given dependencies.


#### cache
In general, you should usecachein Server Components to memoize work that can be shared across components.

```jsx
const cachedFetchReport = cache(fetchReport);function WeatherReport({city}) {  const report = cachedFetchReport(city);  // ...}function App() {  const city = "Los Angeles";  return (    <>      <WeatherReport city={city} />      <WeatherReport city={city} />    </>  );}
```

Re-writing the previous example to usecache, in this case thesecond instance ofWeatherReportwill be able to skip duplicate work and read from the same cache as thefirstWeatherReport. Another difference from the previous example is thatcacheis also recommended formemoizing data fetches, unlikeuseMemowhich should only be used for computations.

At this time,cacheshould only be used in Server Components and the cache will be invalidated across server requests.


#### memo
You should usememoto prevent a component re-rendering if its props are unchanged.

```jsx
'use client';function WeatherReport({record}) {  const avgTemp = calculateAvg(record);  // ...}const MemoWeatherReport = memo(WeatherReport);function App() {  const record = getRecord();  return (    <>      <MemoWeatherReport record={record} />      <MemoWeatherReport record={record} />    </>  );}
```

In this example, bothMemoWeatherReportcomponents will callcalculateAvgwhen first rendered. However, ifAppre-renders, with no changes torecord, none of the props have changed andMemoWeatherReportwill not re-render.

Compared touseMemo,memomemoizes the component render based on props vs. specific computations. Similar touseMemo, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.


## Troubleshooting

### My memoized function still runs even though I’ve called it with the same arguments
See prior mentioned pitfalls

- Calling different memoized functions will read from different caches.
- Calling a memoized function outside of a component will not use the cache.
If none of the above apply, it may be a problem with how React checks if something exists in cache.

If your arguments are notprimitives(ex. objects, functions, arrays), ensure you’re passing the same object reference.

When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.

```jsx
import {cache} from 'react';const calculateNorm = cache((vector) => {  // ...});function MapMarker(props) {  // 🚩 Wrong: props is an object that changes every render.  const length = calculateNorm(props);  // ...}function App() {  return (    <>      <MapMarker x={10} y={10} z={10} />      <MapMarker x={10} y={10} z={10} />    </>  );}
```

In this case the twoMapMarkers look like they’re doing the same work and callingcalculateNormwith the same value of{x: 10, y: 10, z:10}. Even though the objects contain the same values, they are not the same object reference as each component creates its ownpropsobject.

React will callObject.ison the input to verify if there is a cache hit.

```jsx
import {cache} from 'react';const calculateNorm = cache((x, y, z) => {  // ...});function MapMarker(props) {  // ✅ Good: Pass primitives to memoized function  const length = calculateNorm(props.x, props.y, props.z);  // ...}function App() {  return (    <>      <MapMarker x={10} y={10} z={10} />      <MapMarker x={10} y={10} z={10} />    </>  );}
```

One way to address this could be to pass the vector dimensions tocalculateNorm. This works because the dimensions themselves are primitives.

Another solution may be to pass the vector object itself as a prop to the component. We’ll need to pass the same object to both component instances.

```jsx
import {cache} from 'react';const calculateNorm = cache((vector) => {  // ...});function MapMarker(props) {  // ✅ Good: Pass the same `vector` object  const length = calculateNorm(props.vector);  // ...}function App() {  const vector = [10, 10, 10];  return (    <>      <MapMarker vector={vector} />      <MapMarker vector={vector} />    </>  );}
```


--------------------------------------------------------------------------------


# cacheSignal
Source: https://react.dev/reference/react/cacheSignal


### React Server Components
cacheSignalis currently only used withReact Server Components.

cacheSignalallows you to know when thecache()lifetime is over.

```jsx
const signal = cacheSignal();
```

- ReferencecacheSignal
- cacheSignal
- UsageCancel in-flight requestsIgnore errors after React has finished rendering
- Cancel in-flight requests
- Ignore errors after React has finished rendering

## Reference

### cacheSignal
CallcacheSignalto get anAbortSignal.

```jsx
import {cacheSignal} from 'react';async function Component() {  await fetch(url, { signal: cacheSignal() });}
```

When React has finished rendering, theAbortSignalwill be aborted. This allows you to cancel any in-flight work that is no longer needed.
Rendering is considered finished when:

- React has successfully completed rendering
- the render was aborted
- the render has failed

#### Parameters
This function does not accept any parameters.


#### Returns
cacheSignalreturns anAbortSignalif called during rendering. OtherwisecacheSignal()returnsnull.


#### Caveats
- cacheSignalis currently for use inReact Server Componentsonly. In Client Components, it will always returnnull. In the future it will also be used for Client Component when a client cache refreshes or invalidates. You should not assume it’ll always be null on the client.
- If called outside of rendering,cacheSignalwill returnnullto make it clear that the current scope isn’t cached forever.

## Usage

### Cancel in-flight requests
CallcacheSignalto abort in-flight requests.

```jsx
import {cache, cacheSignal} from 'react';const dedupedFetch = cache(fetch);async function Component() {  await dedupedFetch(url, { signal: cacheSignal() });}
```


### Pitfall
You can’t usecacheSignalto abort async work that was started outside of rendering e.g.

```jsx
import {cacheSignal} from 'react';// 🚩 Pitfall: The request will not actually be aborted if the rendering of `Component` is finished.const response = fetch(url, { signal: cacheSignal() });async function Component() {  await response;}
```


### Ignore errors after React has finished rendering
If a function throws, it may be due to cancellation (e.g.the Database connectionhas been closed). You can use theabortedpropertyto check if the error was due to cancellation or a real error. You may want toignore errorsthat were due to cancellation.

```jsx
import {cacheSignal} from "react";import {queryDatabase, logError} from "./database";async function getData(id) {  try {     return await queryDatabase(id);  } catch (x) {     if (!cacheSignal()?.aborted) {        // only log if it's a real error and not due to cancellation       logError(x);     }     return null;  }}async function Component({id}) {  const data = await getData(id);  if (data === null) {    return <div>No data available</div>;  }  return <div>{data.name}</div>;}
```


--------------------------------------------------------------------------------


# captureOwnerStack
Source: https://react.dev/reference/react/captureOwnerStack

captureOwnerStackreads the current Owner Stack in development and returns it as a string if available.

```jsx
const stack = captureOwnerStack();
```

- ReferencecaptureOwnerStack()
- captureOwnerStack()
- UsageEnhance a custom error overlay
- Enhance a custom error overlay
- TroubleshootingThe Owner Stack isnullcaptureOwnerStackis not available
- The Owner Stack isnull
- captureOwnerStackis not available

## Reference

### captureOwnerStack()
CallcaptureOwnerStackto get the current Owner Stack.

```jsx
import * as React from 'react';function Component() {  if (process.env.NODE_ENV !== 'production') {    const ownerStack = React.captureOwnerStack();    console.log(ownerStack);  }}
```


#### Parameters
captureOwnerStackdoes not take any parameters.


#### Returns
captureOwnerStackreturnsstring | null.

Owner Stacks are available in

- Component render
- Effects (e.g.useEffect)
- React’s event handlers (e.g.<button onClick={...} />)
- React error handlers (React Root optionsonCaughtError,onRecoverableError, andonUncaughtError)
If no Owner Stack is available,nullis returned (seeTroubleshooting: The Owner Stack isnull).


#### Caveats
- Owner Stacks are only available in development.captureOwnerStackwill always returnnulloutside of development.

#### Owner Stack vs Component Stack
The Owner Stack is different from the Component Stack available in React error handlers likeerrorInfo.componentStackinonUncaughtError.

For example, consider the following code:

```jsx
import {captureOwnerStack} from 'react';
import {createRoot} from 'react-dom/client';
import App, {Component} from './App.js';
import './styles.css';

createRoot(document.createElement('div'), {
  onUncaughtError: (error, errorInfo) => {
    // The stacks are logged instead of showing them in the UI directly to
    // highlight that browsers will apply sourcemaps to the logged stacks.
    // Note that sourcemapping is only applied in the real browser console not
    // in the fake one displayed on this page.
    // Press "fork" to be able to view the sourcemapped stack in a real console.
    console.log(errorInfo.componentStack);
    console.log(captureOwnerStack());
  },
}).render(
  <App>
    <Component label="disabled" />
  </App>
);


```

SubComponentwould throw an error.
The Component Stack of that error would be

```jsx
at SubComponentat fieldsetat Componentat mainat React.Suspenseat App
```

However, the Owner Stack would only read

```jsx
at Component
```

NeitherAppnor the DOM components (e.g.fieldset) are considered Owners in this Stack since they didn’t contribute to “creating” the node containingSubComponent.Appand DOM components only forwarded the node.Appjust rendered thechildrennode as opposed toComponentwhich created a node containingSubComponentvia<SubComponent />.

NeitherNavigationnorlegendare in the stack at all since it’s only a sibling to a node containing<SubComponent />.

SubComponentis omitted because it’s already part of the callstack.


## Usage

### Enhance a custom error overlay
```jsx
import { captureOwnerStack } from "react";import { instrumentedConsoleError } from "./errorOverlay";const originalConsoleError = console.error;console.error = function patchedConsoleError(...args) {  originalConsoleError.apply(console, args);  const ownerStack = captureOwnerStack();  onConsoleError({    // Keep in mind that in a real application, console.error can be    // called with multiple arguments which you should account for.    consoleMessage: args[0],    ownerStack,  });};
```

If you interceptconsole.errorcalls to highlight them in an error overlay, you can callcaptureOwnerStackto include the Owner Stack.

```jsx
import { captureOwnerStack } from "react";
import { createRoot } from "react-dom/client";
import App from './App';
import { onConsoleError } from "./errorOverlay";
import './styles.css';

const originalConsoleError = console.error;
console.error = function patchedConsoleError(...args) {
  originalConsoleError.apply(console, args);
  const ownerStack = captureOwnerStack();
  onConsoleError({
    // Keep in mind that in a real application, console.error can be
    // called with multiple arguments which you should account for.
    consoleMessage: args[0],
    ownerStack,
  });
};

const container = document.getElementById("root");
createRoot(container).render(<App />);


```


## Troubleshooting

### The Owner Stack isnull
The call ofcaptureOwnerStackhappened outside of a React controlled function e.g. in asetTimeoutcallback, after afetchcall or in a custom DOM event handler. During render, Effects, React event handlers, and React error handlers (e.g.hydrateRoot#options.onCaughtError) Owner Stacks should be available.

In the example below, clicking the button will log an empty Owner Stack becausecaptureOwnerStackwas called during a custom DOM event handler. The Owner Stack must be captured earlier e.g. by moving the call ofcaptureOwnerStackinto the Effect body.

```jsx
import {captureOwnerStack, useEffect} from 'react';

export default function App() {
  useEffect(() => {
    // Should call `captureOwnerStack` here.
    function handleEvent() {
      // Calling it in a custom DOM event handler is too late.
      // The Owner Stack will be `null` at this point.
      console.log('Owner Stack: ', captureOwnerStack());
    }

    document.addEventListener('click', handleEvent);

    return () => {
      document.removeEventListener('click', handleEvent);
    }
  })

  return <button>Click me to see that Owner Stacks are not available in custom DOM event handlers</button>;
}


```


### captureOwnerStackis not available
captureOwnerStackis only exported in development builds. It will beundefinedin production builds. IfcaptureOwnerStackis used in files that are bundled for production and development, you should conditionally access it from a namespace import.

```jsx
// Don't use named imports of `captureOwnerStack` in files that are bundled for development and production.import {captureOwnerStack} from 'react';// Use a namespace import instead and access `captureOwnerStack` conditionally.import * as React from 'react';if (process.env.NODE_ENV !== 'production') {  const ownerStack = React.captureOwnerStack();  console.log('Owner Stack', ownerStack);}
```


--------------------------------------------------------------------------------


# cloneElement
Source: https://react.dev/reference/react/cloneElement


### Pitfall
UsingcloneElementis uncommon and can lead to fragile code.See common alternatives.

cloneElementlets you create a new React element using another element as a starting point.

```jsx
const clonedElement = cloneElement(element, props, ...children)
```

- ReferencecloneElement(element, props, ...children)
- cloneElement(element, props, ...children)
- UsageOverriding props of an element
- Overriding props of an element
- AlternativesPassing data with a render propPassing data through contextExtracting logic into a custom Hook
- Passing data with a render prop
- Passing data through context
- Extracting logic into a custom Hook

## Reference

### cloneElement(element, props, ...children)
CallcloneElementto create a React element based on theelement, but with differentpropsandchildren:

```jsx
import { cloneElement } from 'react';// ...const clonedElement = cloneElement(  <Row title="Cabbage">    Hello  </Row>,  { isHighlighted: true },  'Goodbye');console.log(clonedElement); // <Row title="Cabbage" isHighlighted={true}>Goodbye</Row>
```

See more examples below.


#### Parameters
- element: Theelementargument must be a valid React element. For example, it could be a JSX node like<Something />, the result of callingcreateElement, or the result of anothercloneElementcall.
element: Theelementargument must be a valid React element. For example, it could be a JSX node like<Something />, the result of callingcreateElement, or the result of anothercloneElementcall.

- props: Thepropsargument must either be an object ornull. If you passnull, the cloned element will retain all of the originalelement.props. Otherwise, for every prop in thepropsobject, the returned element will “prefer” the value frompropsover the value fromelement.props. The rest of the props will be filled from the originalelement.props. If you passprops.keyorprops.ref, they will replace the original ones.
props: Thepropsargument must either be an object ornull. If you passnull, the cloned element will retain all of the originalelement.props. Otherwise, for every prop in thepropsobject, the returned element will “prefer” the value frompropsover the value fromelement.props. The rest of the props will be filled from the originalelement.props. If you passprops.keyorprops.ref, they will replace the original ones.

- optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes. If you don’t pass any...childrenarguments, the originalelement.props.childrenwill be preserved.
optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes. If you don’t pass any...childrenarguments, the originalelement.props.childrenwill be preserved.


#### Returns
cloneElementreturns a React element object with a few properties:

- type: Same aselement.type.
- props: The result of shallowly mergingelement.propswith the overridingpropsyou have passed.
- ref: The originalelement.ref, unless it was overridden byprops.ref.
- key: The originalelement.key, unless it was overridden byprops.key.
Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it.


#### Caveats
- Cloning an elementdoes not modify the original element.
Cloning an elementdoes not modify the original element.

- You should onlypass children as multiple arguments tocloneElementif they are all statically known,likecloneElement(element, null, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:cloneElement(element, null, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder.
You should onlypass children as multiple arguments tocloneElementif they are all statically known,likecloneElement(element, null, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:cloneElement(element, null, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder.

- cloneElementmakes it harder to trace the data flow, sotry thealternativesinstead.
cloneElementmakes it harder to trace the data flow, sotry thealternativesinstead.


## Usage

### Overriding props of an element
To override the props of someReact element, pass it tocloneElementwith theprops you want to override:

```jsx
import { cloneElement } from 'react';// ...const clonedElement = cloneElement(  <Row title="Cabbage" />,  { isHighlighted: true });
```

Here, the resultingcloned elementwill be<Row title="Cabbage" isHighlighted={true} />.

Let’s walk through an example to see when it’s useful.

Imagine aListcomponent that renders itschildrenas a list of selectable rows with a “Next” button that changes which row is selected. TheListcomponent needs to render the selectedRowdifferently, so it clones every<Row>child that it has received, and adds an extraisHighlighted: trueorisHighlighted: falseprop:

```jsx
export default function List({ children }) {  const [selectedIndex, setSelectedIndex] = useState(0);  return (    <div className="List">      {Children.map(children, (child, index) =>        cloneElement(child, {          isHighlighted: index === selectedIndex         })      )}
```

Let’s say the original JSX received byListlooks like this:

```jsx
<List>  <Row title="Cabbage" />  <Row title="Garlic" />  <Row title="Apple" /></List>
```

By cloning its children, theListcan pass extra information to everyRowinside. The result looks like this:

```jsx
<List>  <Row    title="Cabbage"    isHighlighted={true}   />  <Row    title="Garlic"    isHighlighted={false}   />  <Row    title="Apple"    isHighlighted={false}   /></List>
```

Notice how pressing “Next” updates the state of theList, and highlights a different row:

```jsx
import { Children, cloneElement, useState } from 'react';

export default function List({ children }) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  return (
    <div className="List">
      {Children.map(children, (child, index) =>
        cloneElement(child, {
          isHighlighted: index === selectedIndex 
        })
      )}
      <hr />
      <button onClick={() => {
        setSelectedIndex(i =>
          (i + 1) % Children.count(children)
        );
      }}>
        Next
      </button>
    </div>
  );
}


```

To summarize, theListcloned the<Row />elements it received and added an extra prop to them.


### Pitfall
Cloning children makes it hard to tell how the data flows through your app. Try one of thealternatives.


## Alternatives

### Passing data with a render prop
Instead of usingcloneElement, consider accepting arender proplikerenderItem. Here,ListreceivesrenderItemas a prop.ListcallsrenderItemfor every item and passesisHighlightedas an argument:

```jsx
export default function List({ items, renderItem }) {  const [selectedIndex, setSelectedIndex] = useState(0);  return (    <div className="List">      {items.map((item, index) => {        const isHighlighted = index === selectedIndex;        return renderItem(item, isHighlighted);      })}
```

TherenderItemprop is called a “render prop” because it’s a prop that specifies how to render something. For example, you can pass arenderItemimplementation that renders a<Row>with the givenisHighlightedvalue:

```jsx
<List  items={products}  renderItem={(product, isHighlighted) =>    <Row      key={product.id}      title={product.title}      isHighlighted={isHighlighted}    />  }/>
```

The end result is the same as withcloneElement:

```jsx
<List>  <Row    title="Cabbage"    isHighlighted={true}   />  <Row    title="Garlic"    isHighlighted={false}   />  <Row    title="Apple"    isHighlighted={false}   /></List>
```

However, you can clearly trace where theisHighlightedvalue is coming from.

```jsx
import { useState } from 'react';

export default function List({ items, renderItem }) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  return (
    <div className="List">
      {items.map((item, index) => {
        const isHighlighted = index === selectedIndex;
        return renderItem(item, isHighlighted);
      })}
      <hr />
      <button onClick={() => {
        setSelectedIndex(i =>
          (i + 1) % items.length
        );
      }}>
        Next
      </button>
    </div>
  );
}


```

This pattern is preferred tocloneElementbecause it is more explicit.


### Passing data through context
Another alternative tocloneElementis topass data through context.

For example, you can callcreateContextto define aHighlightContext:

```jsx
export const HighlightContext = createContext(false);
```

YourListcomponent can wrap every item it renders into aHighlightContextprovider:

```jsx
export default function List({ items, renderItem }) {  const [selectedIndex, setSelectedIndex] = useState(0);  return (    <div className="List">      {items.map((item, index) => {        const isHighlighted = index === selectedIndex;        return (          <HighlightContext key={item.id} value={isHighlighted}>            {renderItem(item)}          </HighlightContext>        );      })}
```

With this approach,Rowdoes not need to receive anisHighlightedprop at all. Instead, it reads the context:

```jsx
export default function Row({ title }) {  const isHighlighted = useContext(HighlightContext);  // ...
```

This allows the calling component to not know or worry about passingisHighlightedto<Row>:

```jsx
<List  items={products}  renderItem={product =>    <Row title={product.title} />  }/>
```

Instead,ListandRowcoordinate the highlighting logic through context.

```jsx
import { useState } from 'react';
import { HighlightContext } from './HighlightContext.js';

export default function List({ items, renderItem }) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  return (
    <div className="List">
      {items.map((item, index) => {
        const isHighlighted = index === selectedIndex;
        return (
          <HighlightContext
            key={item.id}
            value={isHighlighted}
          >
            {renderItem(item)}
          </HighlightContext>
        );
      })}
      <hr />
      <button onClick={() => {
        setSelectedIndex(i =>
          (i + 1) % items.length
        );
      }}>
        Next
      </button>
    </div>
  );
}


```

Learn more about passing data through context.


### Extracting logic into a custom Hook
Another approach you can try is to extract the “non-visual” logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write auseListcustom Hook like this:

```jsx
import { useState } from 'react';export default function useList(items) {  const [selectedIndex, setSelectedIndex] = useState(0);  function onNext() {    setSelectedIndex(i =>      (i + 1) % items.length    );  }  const selected = items[selectedIndex];  return [selected, onNext];}
```

Then you could use it like this:

```jsx
export default function App() {  const [selected, onNext] = useList(products);  return (    <div className="List">      {products.map(product =>        <Row          key={product.id}          title={product.title}          isHighlighted={selected === product}        />      )}      <hr />      <button onClick={onNext}>        Next      </button>    </div>  );}
```

The data flow is explicit, but the state is inside theuseListcustom Hook that you can use from any component:

```jsx
import Row from './Row.js';
import useList from './useList.js';
import { products } from './data.js';

export default function App() {
  const [selected, onNext] = useList(products);
  return (
    <div className="List">
      {products.map(product =>
        <Row
          key={product.id}
          title={product.title}
          isHighlighted={selected === product}
        />
      )}
      <hr />
      <button onClick={onNext}>
        Next
      </button>
    </div>
  );
}


```

This approach is particularly useful if you want to reuse this logic between different components.


--------------------------------------------------------------------------------


# Built-in React Components
Source: https://react.dev/reference/react/components

React exposes a few built-in components that you can use in your JSX.


## Built-in components
- <Fragment>, alternatively written as<>...</>, lets you group multiple JSX nodes together.
- <Profiler>lets you measure rendering performance of a React tree programmatically.
- <Suspense>lets you display a fallback while the child components are loading.
- <StrictMode>enables extra development-only checks that help you find bugs early.
- <Activity>lets you hide and restore the UI and internal state of its children.

## Your own components
You can alsodefine your own componentsas JavaScript functions.


--------------------------------------------------------------------------------


# createContext
Source: https://react.dev/reference/react/createContext

createContextlets you create acontextthat components can provide or read.

```jsx
const SomeContext = createContext(defaultValue)
```

- ReferencecreateContext(defaultValue)SomeContextProviderSomeContext.Consumer
- createContext(defaultValue)
- SomeContextProvider
- SomeContext.Consumer
- UsageCreating contextImporting and exporting context from a file
- Creating context
- Importing and exporting context from a file
- TroubleshootingI can’t find a way to change the context value
- I can’t find a way to change the context value

## Reference

### createContext(defaultValue)
CallcreateContextoutside of any components to create a context.

```jsx
import { createContext } from 'react';const ThemeContext = createContext('light');
```

See more examples below.


#### Parameters
- defaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don’t have any meaningful default value, specifynull. The default value is meant as a “last resort” fallback. It is static and never changes over time.

#### Returns
createContextreturns a context object.

The context object itself does not hold any information.It representswhichcontext other components read or provide. Typically, you will useSomeContextin components above to specify the context value, and calluseContext(SomeContext)in components below to read it. The context object has a few properties:

- SomeContextlets you provide the context value to components.
- SomeContext.Consumeris an alternative and rarely used way to read the context value.
- SomeContext.Provideris a legacy way to provide the context value before React 19.

### SomeContextProvider
Wrap your components into a context provider to specify the value of this context for all components inside:

```jsx
function App() {  const [theme, setTheme] = useState('light');  // ...  return (    <ThemeContext value={theme}>      <Page />    </ThemeContext>  );}
```


### Note
Starting in React 19, you can render<SomeContext>as a provider.

In older versions of React, use<SomeContext.Provider>.


#### Props
- value: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component callinguseContext(SomeContext)inside of the provider receives thevalueof the innermost corresponding context provider above it.

### SomeContext.Consumer
BeforeuseContextexisted, there was an older way to read context:

```jsx
function Button() {  // 🟡 Legacy way (not recommended)  return (    <ThemeContext.Consumer>      {theme => (        <button className={theme} />      )}    </ThemeContext.Consumer>  );}
```

Although this older way still works,newly written code should read context withuseContext()instead:

```jsx
function Button() {  // ✅ Recommended way  const theme = useContext(ThemeContext);  return <button className={theme} />;}
```


#### Props
- children: A function. React will call the function you pass with the current context value determined by the same algorithm asuseContext()does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes.

## Usage

### Creating context
Context lets componentspass information deep downwithout explicitly passing props.

CallcreateContextoutside any components to create one or more contexts.

```jsx
import { createContext } from 'react';const ThemeContext = createContext('light');const AuthContext = createContext(null);
```

createContextreturns acontext object. Components can read context by passing it touseContext():

```jsx
function Button() {  const theme = useContext(ThemeContext);  // ...}function Profile() {  const currentUser = useContext(AuthContext);  // ...}
```

By default, the values they receive will be thedefault valuesyou have specified when creating the contexts. However, by itself this isn’t useful because the default values never change.

Context is useful because you canprovide other, dynamic values from your components:

```jsx
function App() {  const [theme, setTheme] = useState('dark');  const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });  // ...  return (    <ThemeContext value={theme}>      <AuthContext value={currentUser}>        <Page />      </AuthContext>    </ThemeContext>  );}
```

Now thePagecomponent and any components inside it, no matter how deep, will “see” the passed context values. If the passed context values change, React will re-render the components reading the context as well.

Read more about reading and providing context and see examples.


### Importing and exporting context from a file
Often, components in different files will need access to the same context. This is why it’s common to declare contexts in a separate file. Then you can use theexportstatementto make context available for other files:

```jsx
// Contexts.jsimport { createContext } from 'react';export const ThemeContext = createContext('light');export const AuthContext = createContext(null);
```

Components declared in other files can then use theimportstatement to read or provide this context:

```jsx
// Button.jsimport { ThemeContext } from './Contexts.js';function Button() {  const theme = useContext(ThemeContext);  // ...}
```

```jsx
// App.jsimport { ThemeContext, AuthContext } from './Contexts.js';function App() {  // ...  return (    <ThemeContext value={theme}>      <AuthContext value={currentUser}>        <Page />      </AuthContext>    </ThemeContext>  );}
```

This works similar toimporting and exporting components.


## Troubleshooting

### I can’t find a way to change the context value
Code like this specifies thedefaultcontext value:

```jsx
const ThemeContext = createContext('light');
```

This value never changes. React only uses this value as a fallback if it can’t find a matching provider above.

To make context change over time,add state and wrap components in a context provider.


--------------------------------------------------------------------------------


# createElement
Source: https://react.dev/reference/react/createElement

createElementlets you create a React element. It serves as an alternative to writingJSX.

```jsx
const element = createElement(type, props, ...children)
```

- ReferencecreateElement(type, props, ...children)
- createElement(type, props, ...children)
- UsageCreating an element without JSX
- Creating an element without JSX

## Reference

### createElement(type, props, ...children)
CallcreateElementto create a React element with the giventype,props, andchildren.

```jsx
import { createElement } from 'react';function Greeting({ name }) {  return createElement(    'h1',    { className: 'greeting' },    'Hello'  );}
```

See more examples below.


#### Parameters
- type: Thetypeargument must be a valid React component type. For example, it could be a tag name string (such as'div'or'span'), or a React component (a function, a class, or a special component likeFragment).
type: Thetypeargument must be a valid React component type. For example, it could be a tag name string (such as'div'or'span'), or a React component (a function, a class, or a special component likeFragment).

- props: Thepropsargument must either be an object ornull. If you passnull, it will be treated the same as an empty object. React will create an element with props matching thepropsyou have passed. Note thatrefandkeyfrom yourpropsobject are special and willnotbe available aselement.props.refandelement.props.keyon the returnedelement. They will be available aselement.refandelement.key.
props: Thepropsargument must either be an object ornull. If you passnull, it will be treated the same as an empty object. React will create an element with props matching thepropsyou have passed. Note thatrefandkeyfrom yourpropsobject are special and willnotbe available aselement.props.refandelement.props.keyon the returnedelement. They will be available aselement.refandelement.key.

- optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes.
optional...children: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers,portals, empty nodes (null,undefined,true, andfalse), and arrays of React nodes.


#### Returns
createElementreturns a React element object with a few properties:

- type: Thetypeyou have passed.
- props: Thepropsyou have passed except forrefandkey.
- ref: Therefyou have passed. If missing,null.
- key: Thekeyyou have passed, coerced to a string. If missing,null.
Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it.


#### Caveats
- You musttreat React elements and their props asimmutableand never change their contents after creation. In development, React willfreezethe returned element and itspropsproperty shallowly to enforce this.
You musttreat React elements and their props asimmutableand never change their contents after creation. In development, React willfreezethe returned element and itspropsproperty shallowly to enforce this.

- When you use JSX,you must start a tag with a capital letter to render your own custom component.In other words,<Something />is equivalent tocreateElement(Something), but<something />(lowercase) is equivalent tocreateElement('something')(note it’s a string, so it will be treated as a built-in HTML tag).
When you use JSX,you must start a tag with a capital letter to render your own custom component.In other words,<Something />is equivalent tocreateElement(Something), but<something />(lowercase) is equivalent tocreateElement('something')(note it’s a string, so it will be treated as a built-in HTML tag).

- You should onlypass children as multiple arguments tocreateElementif they are all statically known,likecreateElement('h1', {}, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:createElement('ul', {}, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder.
You should onlypass children as multiple arguments tocreateElementif they are all statically known,likecreateElement('h1', {}, child1, child2, child3). If your children are dynamic, pass the entire array as the third argument:createElement('ul', {}, listItems). This ensures that React willwarn you about missingkeysfor any dynamic lists. For static lists this is not necessary because they never reorder.


## Usage

### Creating an element without JSX
If you don’t likeJSXor can’t use it in your project, you can usecreateElementas an alternative.

To create an element without JSX, callcreateElementwith sometype,props, andchildren:

```jsx
import { createElement } from 'react';function Greeting({ name }) {  return createElement(    'h1',    { className: 'greeting' },    'Hello ',    createElement('i', null, name),    '. Welcome!'  );}
```

Thechildrenare optional, and you can pass as many as you need (the example above has three children). This code will display a<h1>header with a greeting. For comparison, here is the same example rewritten with JSX:

```jsx
function Greeting({ name }) {  return (    <h1 className="greeting">      Hello <i>{name}</i>. Welcome!    </h1>  );}
```

To render your own React component, pass a function likeGreetingas thetypeinstead of a string like'h1':

```jsx
export default function App() {  return createElement(Greeting, { name: 'Taylor' });}
```

With JSX, it would look like this:

```jsx
export default function App() {  return <Greeting name="Taylor" />;}
```

Here is a complete example written withcreateElement:

```jsx
import { createElement } from 'react';

function Greeting({ name }) {
  return createElement(
    'h1',
    { className: 'greeting' },
    'Hello ',
    createElement('i', null, name),
    '. Welcome!'
  );
}

export default function App() {
  return createElement(
    Greeting,
    { name: 'Taylor' }
  );
}


```

And here is the same example written using JSX:

```jsx
function Greeting({ name }) {
  return (
    <h1 className="greeting">
      Hello <i>{name}</i>. Welcome!
    </h1>
  );
}

export default function App() {
  return <Greeting name="Taylor" />;
}


```

Both coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared tocreateElementis that it’s easy to see which closing tag corresponds to which opening tag.


#### What is a React element, exactly?
An element is a lightweight description of a piece of the user interface. For example, both<Greeting name="Taylor" />andcreateElement(Greeting, { name: 'Taylor' })produce an object like this:

```jsx
// Slightly simplified{  type: Greeting,  props: {    name: 'Taylor'  },  key: null,  ref: null,}
```

Note that creating this object does not render theGreetingcomponent or create any DOM elements.

A React element is more like a description—an instruction for React to later render theGreetingcomponent. By returning this object from yourAppcomponent, you tell React what to do next.

Creating elements is extremely cheap so you don’t need to try to optimize or avoid it.


--------------------------------------------------------------------------------


# createRef
Source: https://react.dev/reference/react/createRef


### Pitfall
createRefis mostly used forclass components.Function components typically rely onuseRefinstead.

createRefcreates arefobject which can contain arbitrary value.

```jsx
class MyInput extends Component {  inputRef = createRef();  // ...}
```

- ReferencecreateRef()
- createRef()
- UsageDeclaring a ref in a class component
- Declaring a ref in a class component
- AlternativesMigrating from a class withcreateRefto a function withuseRef
- Migrating from a class withcreateRefto a function withuseRef

## Reference

### createRef()
CallcreateRefto declare arefinside aclass component.

```jsx
import { createRef, Component } from 'react';class MyComponent extends Component {  intervalRef = createRef();  inputRef = createRef();  // ...
```

See more examples below.


#### Parameters
createReftakes no parameters.


#### Returns
createRefreturns an object with a single property:

- current: Initially, it’s set to thenull. You can later set it to something else. If you pass the ref object to React as arefattribute to a JSX node, React will set itscurrentproperty.

#### Caveats
- createRefalways returns adifferentobject. It’s equivalent to writing{ current: null }yourself.
- In a function component, you probably wantuseRefinstead which always returns the same object.
- const ref = useRef()is equivalent toconst [ref, _] = useState(() => createRef(null)).

## Usage

### Declaring a ref in a class component
To declare a ref inside aclass component,callcreateRefand assign its result to a class field:

```jsx
import { Component, createRef } from 'react';class Form extends Component {  inputRef = createRef();  // ...}
```

If you now passref={this.inputRef}to an<input>in your JSX, React will populatethis.inputRef.currentwith the input DOM node. For example, here is how you make a button that focuses the input:

```jsx
import { Component, createRef } from 'react';

export default class Form extends Component {
  inputRef = createRef();

  handleClick = () => {
    this.inputRef.current.focus();
  }

  render() {
    return (
      <>
        <input ref={this.inputRef} />
        <button onClick={this.handleClick}>
          Focus the input
        </button>
      </>
    );
  }
}


```


### Pitfall
createRefis mostly used forclass components.Function components typically rely onuseRefinstead.


## Alternatives

### Migrating from a class withcreateRefto a function withuseRef
We recommend using function components instead ofclass componentsin new code. If you have some existing class components usingcreateRef, here is how you can convert them. This is the original code:

```jsx
import { Component, createRef } from 'react';

export default class Form extends Component {
  inputRef = createRef();

  handleClick = () => {
    this.inputRef.current.focus();
  }

  render() {
    return (
      <>
        <input ref={this.inputRef} />
        <button onClick={this.handleClick}>
          Focus the input
        </button>
      </>
    );
  }
}


```

When youconvert this component from a class to a function,replace calls tocreateRefwith calls touseRef:

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


```


--------------------------------------------------------------------------------


# experimental_taintObjectReference- This feature is available in the latest Experimental version of React
Source: https://react.dev/reference/react/experimental_taintObjectReference


### Experimental Feature
This API is experimental and is not available in a stable version of React yet.

You can try it by upgrading React packages to the most recent experimental version:

- react@experimental
- react-dom@experimental
- eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.

This API is only available inside React Server Components.

taintObjectReferencelets you prevent a specific object instance from being passed to a Client Component like auserobject.

```jsx
experimental_taintObjectReference(message, object);
```

To prevent passing a key, hash or token, seetaintUniqueValue.

- ReferencetaintObjectReference(message, object)
- taintObjectReference(message, object)
- UsagePrevent user data from unintentionally reaching the client
- Prevent user data from unintentionally reaching the client

## Reference

### taintObjectReference(message, object)
CalltaintObjectReferencewith an object to register it with React as something that should not be allowed to be passed to the Client as is:

```jsx
import {experimental_taintObjectReference} from 'react';experimental_taintObjectReference(  'Do not pass ALL environment variables to the client.',  process.env);
```

See more examples below.


#### Parameters
- message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.
message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.

- object: The object to be tainted. Functions and class instances can be passed totaintObjectReferenceasobject. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined inmessage. When a specific instance of a Typed Array is passed totaintObjectReferenceasobject, any other copies of the Typed Array will not be tainted.
object: The object to be tainted. Functions and class instances can be passed totaintObjectReferenceasobject. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined inmessage. When a specific instance of a Typed Array is passed totaintObjectReferenceasobject, any other copies of the Typed Array will not be tainted.


#### Returns
experimental_taintObjectReferencereturnsundefined.


#### Caveats
- Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainteduserobject,const userInfo = {name: user.name, ssn: user.ssn}or{...user}will create new objects which are not tainted.taintObjectReferenceonly protects against simple mistakes when the object is passed through to a Client Component unchanged.

### Pitfall
Do not rely on just tainting for security.Tainting an object doesn’t prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untainted object. Using data from a tainted object (e.g.{secret: taintedObj.secret}) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.


## Usage

### Prevent user data from unintentionally reaching the client
A Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can “taint” the user object in our data API.

```jsx
import {experimental_taintObjectReference} from 'react';export async function getUser(id) {  const user = await db`SELECT * FROM users WHERE id = ${id}`;  experimental_taintObjectReference(    'Do not pass the entire user object to the client. ' +      'Instead, pick off the specific properties you need for this use case.',    user,  );  return user;}
```

Now whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.


#### Protecting against leaks in data fetching
If you’re running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:

```jsx
// api.jsexport async function getUser(id) {  const user = await db`SELECT * FROM users WHERE id = ${id}`;  return user;}
```

```jsx
import { getUser } from 'api.js';import { InfoCard } from 'components.js';export async function Profile(props) {  const user = await getUser(props.userId);  // DO NOT DO THIS  return <InfoCard user={user} />;}
```

```jsx
// components.js"use client";export async function InfoCard({ user }) {  return <div>{user.name}</div>;}
```

Ideally, thegetUsershould not expose data that the current user should not have access to. To prevent passing theuserobject to a Client Component down the line we can “taint” the user object:

```jsx
// api.jsimport {experimental_taintObjectReference} from 'react';export async function getUser(id) {  const user = await db`SELECT * FROM users WHERE id = ${id}`;  experimental_taintObjectReference(    'Do not pass the entire user object to the client. ' +      'Instead, pick off the specific properties you need for this use case.',    user,  );  return user;}
```

Now if anyone tries to pass theuserobject to a Client Component, an error will be thrown with the passed in error message.


--------------------------------------------------------------------------------


# experimental_taintUniqueValue- This feature is available in the latest Experimental version of React
Source: https://react.dev/reference/react/experimental_taintUniqueValue


### Experimental Feature
This API is experimental and is not available in a stable version of React yet.

You can try it by upgrading React packages to the most recent experimental version:

- react@experimental
- react-dom@experimental
- eslint-plugin-react-hooks@experimental
Experimental versions of React may contain bugs. Don’t use them in production.

This API is only available insideReact Server Components.

taintUniqueValuelets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.

```jsx
taintUniqueValue(errMessage, lifetime, value)
```

To prevent passing an object containing sensitive data, seetaintObjectReference.

- ReferencetaintUniqueValue(message, lifetime, value)
- taintUniqueValue(message, lifetime, value)
- UsagePrevent a token from being passed to Client Components
- Prevent a token from being passed to Client Components

## Reference

### taintUniqueValue(message, lifetime, value)
CalltaintUniqueValuewith a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:

```jsx
import {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue(  'Do not pass secret keys to the client.',  process,  process.env.SECRET_KEY);
```

See more examples below.


#### Parameters
- message: The message you want to display ifvalueis passed to a Client Component. This message will be displayed as a part of the Error that will be thrown ifvalueis passed to a Client Component.
message: The message you want to display ifvalueis passed to a Client Component. This message will be displayed as a part of the Error that will be thrown ifvalueis passed to a Client Component.

- lifetime: Any object that indicates how longvalueshould be tainted.valuewill be blocked from being sent to any Client Component while this object still exists. For example, passingglobalThisblocks the value for the lifetime of an app.lifetimeis typically an object whose properties containsvalue.
lifetime: Any object that indicates how longvalueshould be tainted.valuewill be blocked from being sent to any Client Component while this object still exists. For example, passingglobalThisblocks the value for the lifetime of an app.lifetimeis typically an object whose properties containsvalue.

- value: A string, bigint or TypedArray.valuemust be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password.valuewill be blocked from being sent to any Client Component.
value: A string, bigint or TypedArray.valuemust be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password.valuewill be blocked from being sent to any Client Component.


#### Returns
experimental_taintUniqueValuereturnsundefined.


#### Caveats
- Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly calltaintUniqueValueon these newly created values.
- Do not usetaintUniqueValueto protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret.

## Usage

### Prevent a token from being passed to Client Components
To ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, thetaintUniqueValuefunction provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.

Thelifetimeargument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects likeglobalThisorprocesscan serve as thelifetimeargument. These objects have a lifespan that spans the entire duration of your app’s execution.

```jsx
import {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue(  'Do not pass a user password to the client.',  globalThis,  process.env.SECRET_KEY);
```

If the tainted value’s lifespan is tied to a object, thelifetimeshould be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.

```jsx
import {experimental_taintUniqueValue} from 'react';export async function getUser(id) {  const user = await db`SELECT * FROM users WHERE id = ${id}`;  experimental_taintUniqueValue(    'Do not pass a user session token to the client.',    user,    user.session.token  );  return user;}
```

In this example, theuserobject serves as thelifetimeargument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.


### Pitfall
Do not rely solely on tainting for security.Tainting a value doesn’t block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value.

```jsx
import {experimental_taintUniqueValue} from 'react';const password = 'correct horse battery staple';experimental_taintUniqueValue(  'Do not pass the password to the client.',  globalThis,  password);const uppercasePassword = password.toUpperCase() // `uppercasePassword` is not tainted
```

In this example, the constantpasswordis tainted. Thenpasswordis used to create a new valueuppercasePasswordby calling thetoUpperCasemethod onpassword. The newly createduppercasePasswordis not tainted.

Other similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values.

Tainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling thetaintUniqueValuelike using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.


#### Usingserver-onlyandtaintUniqueValueto prevent leaking secrets
If you’re running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component.

```jsx
export async function Dashboard(props) {  // DO NOT DO THIS  return <Overview password={process.env.API_PASSWORD} />;}
```

```jsx
"use client";import {useEffect} from '...'export async function Overview({ password }) {  useEffect(() => {    const headers = { Authorization: password };    fetch(url, { headers }).then(...);  }, [password]);  ...}
```

This example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn’t have access to, it could lead to a data breach.

Ideally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged withserver-onlyto ensure that this file isn’t imported on the client.

```jsx
import "server-only";export function fetchAPI(url) {  const headers = { Authorization: process.env.API_PASSWORD };  return fetch(url, { headers });}
```

Sometimes mistakes happen during refactoring and not all of your colleagues might know about this.
To protect against this mistakes happening down the line we can “taint” the actual password:

```jsx
import "server-only";import {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue(  'Do not pass the API token password to the client. ' +    'Instead do all fetches on the server.'  process,  process.env.API_PASSWORD);
```

Now whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Function, an error will be thrown with message you defined when you calledtaintUniqueValue.


--------------------------------------------------------------------------------


# forwardRef
Source: https://react.dev/reference/react/forwardRef


### Deprecated
In React 19,forwardRefis no longer necessary. Passrefas a prop instead.

forwardRefwill be deprecated in a future release. Learn morehere.

forwardReflets your component expose a DOM node to the parent component with aref.

```jsx
const SomeComponent = forwardRef(render)
```

- ReferenceforwardRef(render)renderfunction
- forwardRef(render)
- renderfunction
- UsageExposing a DOM node to the parent componentForwarding a ref through multiple componentsExposing an imperative handle instead of a DOM node
- Exposing a DOM node to the parent component
- Forwarding a ref through multiple components
- Exposing an imperative handle instead of a DOM node
- TroubleshootingMy component is wrapped inforwardRef, but therefto it is alwaysnull
- My component is wrapped inforwardRef, but therefto it is alwaysnull

## Reference

### forwardRef(render)
CallforwardRef()to let your component receive a ref and forward it to a child component:

```jsx
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  // ...});
```

See more examples below.


#### Parameters
- render: The render function for your component. React calls this function with the props andrefthat your component received from its parent. The JSX you return will be the output of your component.

#### Returns
forwardRefreturns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned byforwardRefis also able to receive arefprop.


#### Caveats
- In Strict Mode, React willcall your render function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.

### renderfunction
forwardRefaccepts a render function as an argument. React calls this function withpropsandref:

```jsx
const MyInput = forwardRef(function MyInput(props, ref) {  return (    <label>      {props.label}      <input ref={ref} />    </label>  );});
```


#### Parameters
- props: The props passed by the parent component.
props: The props passed by the parent component.

- ref:  Therefattribute passed by the parent component. Therefcan be an object or a function. If the parent component has not passed a ref, it will benull. You should either pass therefyou receive to another component, or pass it touseImperativeHandle.
ref:  Therefattribute passed by the parent component. Therefcan be an object or a function. If the parent component has not passed a ref, it will benull. You should either pass therefyou receive to another component, or pass it touseImperativeHandle.


#### Returns
forwardRefreturns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned byforwardRefis able to take arefprop.


## Usage

### Exposing a DOM node to the parent component
By default, each component’s DOM nodes are private. However, sometimes it’s useful to expose a DOM node to the parent—for example, to allow focusing it. To opt in, wrap your component definition intoforwardRef():

```jsx
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  const { label, ...otherProps } = props;  return (    <label>      {label}      <input {...otherProps} />    </label>  );});
```

You will receive arefas the second argument after props. Pass it to the DOM node that you want to expose:

```jsx
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  const { label, ...otherProps } = props;  return (    <label>      {label}      <input {...otherProps} ref={ref} />    </label>  );});
```

This lets the parentFormcomponent access the<input>DOM nodeexposed byMyInput:

```jsx
function Form() {  const ref = useRef(null);  function handleClick() {    ref.current.focus();  }  return (    <form>      <MyInput label="Enter your name:" ref={ref} />      <button type="button" onClick={handleClick}>        Edit      </button>    </form>  );}
```

ThisFormcomponentpasses a reftoMyInput. TheMyInputcomponentforwardsthat ref to the<input>browser tag. As a result, theFormcomponent can access that<input>DOM node and callfocus()on it.

Keep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component’s internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won’t do it for application-level components like an avatar or a comment.


#### Examples of forwarding a ref

#### Example1of2:Focusing a text input
Clicking the button will focus the input. TheFormcomponent defines a ref and passes it to theMyInputcomponent. TheMyInputcomponent forwards that ref to the browser<input>. This lets theFormcomponent focus the<input>.

```jsx
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
  }

  return (
    <form>
      <MyInput label="Enter your name:" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}


```


### Forwarding a ref through multiple components
Instead of forwarding arefto a DOM node, you can forward it to your own component likeMyInput:

```jsx
const FormField = forwardRef(function FormField(props, ref) {  // ...  return (    <>      <MyInput ref={ref} />      ...    </>  );});
```

If thatMyInputcomponent forwards a ref to its<input>, a ref toFormFieldwill give you that<input>:

```jsx
function Form() {  const ref = useRef(null);  function handleClick() {    ref.current.focus();  }  return (    <form>      <FormField label="Enter your name:" ref={ref} isRequired={true} />      <button type="button" onClick={handleClick}>        Edit      </button>    </form>  );}
```

TheFormcomponent defines a ref and passes it toFormField. TheFormFieldcomponent forwards that ref toMyInput, which forwards it to a browser<input>DOM node. This is howFormaccesses that DOM node.

```jsx
import { useRef } from 'react';
import FormField from './FormField.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
  }

  return (
    <form>
      <FormField label="Enter your name:" ref={ref} isRequired={true} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}


```


### Exposing an imperative handle instead of a DOM node
Instead of exposing an entire DOM node, you can expose a custom object, called animperative handle,with a more constrained set of methods. To do this, you’d need to define a separate ref to hold the DOM node:

```jsx
const MyInput = forwardRef(function MyInput(props, ref) {  const inputRef = useRef(null);  // ...  return <input {...props} ref={inputRef} />;});
```

Pass therefyou received touseImperativeHandleand specify the value you want to expose to theref:

```jsx
import { forwardRef, useRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  const inputRef = useRef(null);  useImperativeHandle(ref, () => {    return {      focus() {        inputRef.current.focus();      },      scrollIntoView() {        inputRef.current.scrollIntoView();      },    };  }, []);  return <input {...props} ref={inputRef} />;});
```

If some component gets a ref toMyInput, it will only receive your{ focus, scrollIntoView }object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.

```jsx
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
    // This won't work because the DOM node isn't exposed:
    // ref.current.style.opacity = 0.5;
  }

  return (
    <form>
      <MyInput placeholder="Enter your name" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}


```

Read more about using imperative handles.


### Pitfall
Do not overuse refs.You should only use refs forimperativebehaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.

If you can express something as a prop, you should not use a ref.For example, instead of exposing an imperative handle like{ open, close }from aModalcomponent, it is better to takeisOpenas a prop like<Modal isOpen={isOpen} />.Effectscan help you expose imperative behaviors via props.


## Troubleshooting

### My component is wrapped inforwardRef, but therefto it is alwaysnull
This usually means that you forgot to actually use therefthat you received.

For example, this component doesn’t do anything with itsref:

```jsx
const MyInput = forwardRef(function MyInput({ label }, ref) {  return (    <label>      {label}      <input />    </label>  );});
```

To fix it, pass therefdown to a DOM node or another component that can accept a ref:

```jsx
const MyInput = forwardRef(function MyInput({ label }, ref) {  return (    <label>      {label}      <input ref={ref} />    </label>  );});
```

ThereftoMyInputcould also benullif some of the logic is conditional:

```jsx
const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {  return (    <label>      {label}      {showInput && <input ref={ref} />}    </label>  );});
```

IfshowInputisfalse, then the ref won’t be forwarded to any node, and a ref toMyInputwill remain empty. This is particularly easy to miss if the condition is hidden inside another component, likePanelin this example:

```jsx
const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {  return (    <label>      {label}      <Panel isExpanded={showInput}>        <input ref={ref} />      </Panel>    </label>  );});
```


--------------------------------------------------------------------------------


# Built-in React Hooks
Source: https://react.dev/reference/react/hooks

Hookslet you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.


## State Hooks
Statelets a component“remember” information like user input.For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.

To add state to a component, use one of these Hooks:

- useStatedeclares a state variable that you can update directly.
- useReducerdeclares a state variable with the update logic inside areducer function.
```jsx
function ImageGallery() {  const [index, setIndex] = useState(0);  // ...
```


## Context Hooks
Contextlets a componentreceive information from distant parents without passing it as props.For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.

- useContextreads and subscribes to a context.
```jsx
function Button() {  const theme = useContext(ThemeContext);  // ...
```


## Ref Hooks
Refslet a componenthold some information that isn’t used for rendering,like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.

- useRefdeclares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.
- useImperativeHandlelets you customize the ref exposed by your component. This is rarely used.
```jsx
function Form() {  const inputRef = useRef(null);  // ...
```


## Effect Hooks
Effectslet a componentconnect to and synchronize with external systems.This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.

- useEffectconnects a component to an external system.
```jsx
function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);  // ...
```

Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system,you might not need an Effect.

There are two rarely used variations ofuseEffectwith differences in timing:

- useLayoutEffectfires before the browser repaints the screen. You can measure layout here.
- useInsertionEffectfires before React makes changes to the DOM. Libraries can insert dynamic CSS here.
You can also separate events from Effects:

- useEffectEventcreates a non-reactive event to fire from any Effect hook.

## Performance Hooks
A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.

To skip calculations and unnecessary re-rendering, use one of these Hooks:

- useMemolets you cache the result of an expensive calculation.
- useCallbacklets you cache a function definition before passing it down to an optimized component.
```jsx
function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}
```

Sometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart).

To prioritize rendering, use one of these Hooks:

- useTransitionlets you mark a state transition as non-blocking and allow other updates to interrupt it.
- useDeferredValuelets you defer updating a non-critical part of the UI and let other parts update first.

## Other Hooks
These Hooks are mostly useful to library authors and aren’t commonly used in the application code.

- useDebugValuelets you customize the label React DevTools displays for your custom Hook.
- useIdlets a component associate a unique ID with itself. Typically used with accessibility APIs.
- useSyncExternalStorelets a component subscribe to an external store.
- useActionStateallows you to manage state of actions.

## Your own Hooks
You can alsodefine your own custom Hooksas JavaScript functions.


--------------------------------------------------------------------------------


# isValidElement
Source: https://react.dev/reference/react/isValidElement

isValidElementchecks whether a value is a React element.

```jsx
const isElement = isValidElement(value)
```

- ReferenceisValidElement(value)
- isValidElement(value)
- UsageChecking if something is a React element
- Checking if something is a React element

## Reference

### isValidElement(value)
CallisValidElement(value)to check whethervalueis a React element.

```jsx
import { isValidElement, createElement } from 'react';// ✅ React elementsconsole.log(isValidElement(<p />)); // trueconsole.log(isValidElement(createElement('p'))); // true// ❌ Not React elementsconsole.log(isValidElement(25)); // falseconsole.log(isValidElement('Hello')); // falseconsole.log(isValidElement({ age: 42 })); // false
```

See more examples below.


#### Parameters
- value: Thevalueyou want to check. It can be any a value of any type.

#### Returns
isValidElementreturnstrueif thevalueis a React element. Otherwise, it returnsfalse.


#### Caveats
- OnlyJSX tagsand objects returned bycreateElementare considered to be React elements.For example, even though a number like42is a valid Reactnode(and can be returned from a component), it is not a valid React element. Arrays and portals created withcreatePortalare alsonotconsidered to be React elements.

## Usage

### Checking if something is a React element
CallisValidElementto check if some value is aReact element.

React elements are:

- Values produced by writing aJSX tag
- Values produced by callingcreateElement
For React elements,isValidElementreturnstrue:

```jsx
import { isValidElement, createElement } from 'react';// ✅ JSX tags are React elementsconsole.log(isValidElement(<p />)); // trueconsole.log(isValidElement(<MyComponent />)); // true// ✅ Values returned by createElement are React elementsconsole.log(isValidElement(createElement('p'))); // trueconsole.log(isValidElement(createElement(MyComponent))); // true
```

Any other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.

For them,isValidElementreturnsfalse:

```jsx
// ❌ These are *not* React elementsconsole.log(isValidElement(null)); // falseconsole.log(isValidElement(25)); // falseconsole.log(isValidElement('Hello')); // falseconsole.log(isValidElement({ age: 42 })); // falseconsole.log(isValidElement([<div />, <div />])); // falseconsole.log(isValidElement(MyComponent)); // false
```

It is very uncommon to needisValidElement. It’s mostly useful if you’re calling another API thatonlyaccepts elements (likecloneElementdoes) and you want to avoid an error when your argument is not a React element.

Unless you have some very specific reason to add anisValidElementcheck, you probably don’t need it.


#### React elements vs React nodes
When you write a component, you can return any kind ofReact nodefrom it:

```jsx
function MyComponent() {  // ... you can return any React node ...}
```

A React node can be:

- A React element created like<div />orcreateElement('div')
- A portal created withcreatePortal
- A string
- A number
- true,false,null, orundefined(which are not displayed)
- An array of other React nodes
NoteisValidElementchecks whether the argument is aReact element,not whether it’s a React node.For example,42is not a valid React element. However, it is a perfectly valid React node:

```jsx
function MyComponent() {  return 42; // It's ok to return a number from component}
```

This is why you shouldn’t useisValidElementas a way to check whether something can be rendered.


--------------------------------------------------------------------------------


# lazy
Source: https://react.dev/reference/react/lazy

lazylets you defer loading component’s code until it is rendered for the first time.

```jsx
const SomeComponent = lazy(load)
```

- Referencelazy(load)loadfunction
- lazy(load)
- loadfunction
- UsageLazy-loading components with Suspense
- Lazy-loading components with Suspense
- TroubleshootingMylazycomponent’s state gets reset unexpectedly
- Mylazycomponent’s state gets reset unexpectedly

## Reference

### lazy(load)
Calllazyoutside your components to declare a lazy-loaded React component:

```jsx
import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
```

See more examples below.


#### Parameters
- load: A function that returns aPromiseor anotherthenable(a Promise-like object with athenmethod). React will not callloaduntil the first time you attempt to render the returned component. After React first callsload, it will wait for it to resolve, and then render the resolved value’s.defaultas a React component. Both the returned Promise and the Promise’s resolved value will be cached, so React will not callloadmore than once. If the Promise rejects, React willthrowthe rejection reason for the nearest Error Boundary to handle.

#### Returns
lazyreturns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it willsuspend.Use<Suspense>to display a loading indicator while it’s loading.


### loadfunction

#### Parameters
loadreceives no parameters.


#### Returns
You need to return aPromiseor some otherthenable(a Promise-like object with athenmethod). It needs to eventually resolve to an object whose.defaultproperty is a valid React component type, such as a function,memo, or aforwardRefcomponent.


## Usage

### Lazy-loading components with Suspense
Usually, you import components with the staticimportdeclaration:

```jsx
import MarkdownPreview from './MarkdownPreview.js';
```

To defer loading this component’s code until it’s rendered for the first time, replace this import with:

```jsx
import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
```

This code relies ondynamicimport(),which might require support from your bundler or framework. Using this pattern requires that the lazy component you’re importing was exported as thedefaultexport.

Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a<Suspense>boundary:

```jsx
<Suspense fallback={<Loading />}>  <h2>Preview</h2>  <MarkdownPreview /></Suspense>
```

In this example, the code forMarkdownPreviewwon’t be loaded until you attempt to render it. IfMarkdownPreviewhasn’t loaded yet,Loadingwill be shown in its place. Try ticking the checkbox:

```jsx
import { useState, Suspense, lazy } from 'react';
import Loading from './Loading.js';

const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));

export default function MarkdownEditor() {
  const [showPreview, setShowPreview] = useState(false);
  const [markdown, setMarkdown] = useState('Hello, **world**!');
  return (
    <>
      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />
      <label>
        <input type="checkbox" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />
        Show preview
      </label>
      <hr />
      {showPreview && (
        <Suspense fallback={<Loading />}>
          <h2>Preview</h2>
          <MarkdownPreview markdown={markdown} />
        </Suspense>
      )}
    </>
  );
}

// Add a fixed delay so you can see the loading state
function delayForDemo(promise) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  }).then(() => promise);
}


```

This demo loads with an artificial delay. The next time you untick and tick the checkbox,Previewwill be cached, so there will be no loading state. To see the loading state again, click “Reset” on the sandbox.

Learn more about managing loading states with Suspense.


## Troubleshooting

### Mylazycomponent’s state gets reset unexpectedly
Do not declarelazycomponentsinsideother components:

```jsx
import { lazy } from 'react';function Editor() {  // 🔴 Bad: This will cause all state to be reset on re-renders  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));  // ...}
```

Instead, always declare them at the top level of your module:

```jsx
import { lazy } from 'react';// ✅ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {  // ...}
```


--------------------------------------------------------------------------------


# Legacy React APIs
Source: https://react.dev/reference/react/legacy

These APIs are exported from thereactpackage, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.


## Legacy APIs
- Childrenlets you manipulate and transform the JSX received as thechildrenprop.See alternatives.
- cloneElementlets you create a React element using another element as a starting point.See alternatives.
- Componentlets you define a React component as a JavaScript class.See alternatives.
- createElementlets you create a React element. Typically, you’ll use JSX instead.
- createRefcreates a ref object which can contain arbitrary value.See alternatives.
- forwardReflets your component expose a DOM node to parent component with aref.
- isValidElementchecks whether a value is a React element. Typically used withcloneElement.
- PureComponentis similar toComponent,but it skip re-renders with same props.See alternatives.

## Removed APIs
These APIs were removed in React 19:

- createFactory: use JSX instead.
- Class Components:static contextTypes: usestatic contextTypeinstead.
- Class Components:static childContextTypes: usestatic contextTypeinstead.
- Class Components:static getChildContext: useContextinstead.
- Class Components:static propTypes: use a type system likeTypeScriptinstead.
- Class Components:this.refs: usecreateRefinstead.

--------------------------------------------------------------------------------


# memo
Source: https://react.dev/reference/react/memo

memolets you skip re-rendering a component when its props are unchanged.

```jsx
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
```


### Note
React Compilerautomatically applies the equivalent ofmemoto all components, reducing the need for manual memoization. You can use the compiler to handle component memoization automatically.

- Referencememo(Component, arePropsEqual?)
- memo(Component, arePropsEqual?)
- UsageSkipping re-rendering when props are unchangedUpdating a memoized component using stateUpdating a memoized component using a contextMinimizing props changesSpecifying a custom comparison functionDo I still need React.memo if I use React Compiler?
- Skipping re-rendering when props are unchanged
- Updating a memoized component using state
- Updating a memoized component using a context
- Minimizing props changes
- Specifying a custom comparison function
- Do I still need React.memo if I use React Compiler?
- TroubleshootingMy component re-renders when a prop is an object, array, or function
- My component re-renders when a prop is an object, array, or function

## Reference

### memo(Component, arePropsEqual?)
Wrap a component inmemoto get amemoizedversion of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.

```jsx
import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {  // ...});
```

See more examples below.


#### Parameters
- Component: The component that you want to memoize. Thememodoes not modify this component, but returns a new, memoized component instead. Any valid React component, including functions andforwardRefcomponents, is accepted.
Component: The component that you want to memoize. Thememodoes not modify this component, but returns a new, memoized component instead. Any valid React component, including functions andforwardRefcomponents, is accepted.

- optionalarePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should returntrueif the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should returnfalse. Usually, you will not specify this function. By default, React will compare each prop withObject.is.
optionalarePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should returntrueif the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should returnfalse. Usually, you will not specify this function. By default, React will compare each prop withObject.is.


#### Returns
memoreturns a new React component. It behaves the same as the component provided tomemoexcept that React will not always re-render it when its parent is being re-rendered unless its props have changed.


## Usage

### Skipping re-rendering when props are unchanged
React normally re-renders a component whenever its parent re-renders. Withmemo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to bememoized.

To memoize a component, wrap it inmemoand use the value that it returns in place of your original component:

```jsx
const Greeting = memo(function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;});export default Greeting;
```

A React component should always havepure rendering logic.This means that it must return the same output if its props, state, and context haven’t changed. By usingmemo, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props haven’t changed. Even withmemo, your component will re-render if its own state changes or if a context that it’s using changes.

In this example, notice that theGreetingcomponent re-renders whenevernameis changed (because that’s one of its props), but not whenaddressis changed (because it’s not passed toGreetingas a prop):

```jsx
import { memo, useState } from 'react';

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}

const Greeting = memo(function Greeting({ name }) {
  console.log("Greeting was rendered at", new Date().toLocaleTimeString());
  return <h3>Hello{name && ', '}{name}!</h3>;
});


```


### Note
You should only rely onmemoas a performance optimization.If your code doesn’t work without it, find the underlying problem and fix it first. Then you may addmemoto improve performance.


#### Should you add memo everywhere?
If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.

Optimizing withmemois only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders,memois unnecessary. Keep in mind thatmemois completely useless if the props passed to your component arealways different,such as if you pass an object or a plain function defined during rendering. This is why you will often needuseMemoanduseCallbacktogether withmemo.

There is no benefit to wrapping a component inmemoin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.

In practice, you can make a lot of memoization unnecessary by following a few principles:

1. When a component visually wraps other components, let itaccept JSX as children.This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.
1. Prefer local state and don’tlift state upany further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
1. Keep yourrendering logic pure.If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
1. Avoidunnecessary Effects that update state.Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
1. Try toremove unnecessary dependencies from your Effects.For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.
If a specific interaction still feels laggy,use the React Developer Tools profilerto see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researchingdoing granular memoization automaticallyto solve this once and for all.


### Updating a memoized component using state
Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.

```jsx
import { memo, useState } from 'react';

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}

const Greeting = memo(function Greeting({ name }) {
  console.log('Greeting was rendered at', new Date().toLocaleTimeString());
  const [greeting, setGreeting] = useState('Hello');
  return (
    <>
      <h3>{greeting}{name && ', '}{name}!</h3>
      <GreetingSelector value={greeting} onChange={setGreeting} />
    </>
  );
});

function GreetingSelector({ value, onChange }) {
  return (
    <>
      <label>
        <input
          type="radio"
          checked={value === 'Hello'}
          onChange={e => onChange('Hello')}
        />
        Regular greeting
      </label>
      <label>
        <input
          type="radio"
          checked={value === 'Hello and welcome'}
          onChange={e => onChange('Hello and welcome')}
        />
        Enthusiastic greeting
      </label>
    </>
  );
}


```

If you set a state variable to its current value, React will skip re-rendering your component even withoutmemo. You may still see your component function being called an extra time, but the result will be discarded.


### Updating a memoized component using a context
Even when a component is memoized, it will still re-render when a context that it’s using changes. Memoization only has to do with props that are passed to the component from its parent.

```jsx
import { createContext, memo, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  const [theme, setTheme] = useState('dark');

  function handleClick() {
    setTheme(theme === 'dark' ? 'light' : 'dark');
  }

  return (
    <ThemeContext value={theme}>
      <button onClick={handleClick}>
        Switch theme
      </button>
      <Greeting name="Taylor" />
    </ThemeContext>
  );
}

const Greeting = memo(function Greeting({ name }) {
  console.log("Greeting was rendered at", new Date().toLocaleTimeString());
  const theme = useContext(ThemeContext);
  return (
    <h3 className={theme}>Hello, {name}!</h3>
  );
});


```

To make your component re-render only when apartof some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.


### Minimizing props changes
When you usememo, your component re-renders whenever any prop is notshallowly equalto what it was previously. This means that React compares every prop in your component with its previous value using theObject.iscomparison. Note thatObject.is(3, 3)istrue, butObject.is({}, {})isfalse.

To get the most out ofmemo, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by usinguseMemo:

```jsx
function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  const person = useMemo(    () => ({ name, age }),    [name, age]  );  return <Profile person={person} />;}const Profile = memo(function Profile({ person }) {  // ...});
```

A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:

```jsx
function Page() {  const [name, setName] = useState('Taylor');  const [age, setAge] = useState(42);  return <Profile name={name} age={age} />;}const Profile = memo(function Profile({ name, age }) {  // ...});
```

Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:

```jsx
function GroupsLanding({ person }) {  const hasGroups = person.groups !== null;  return <CallToAction hasGroups={hasGroups} />;}const CallToAction = memo(function CallToAction({ hasGroups }) {  // ...});
```

When you need to pass a function to memoized component, either declare it outside your component so that it never changes, oruseCallbackto cache its definition between re-renders.


### Specifying a custom comparison function
In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument tomemo. It should returntrueonly if the new props would result in the same output as the old props; otherwise it should returnfalse.

```jsx
const Chart = memo(function Chart({ dataPoints }) {  // ...}, arePropsEqual);function arePropsEqual(oldProps, newProps) {  return (    oldProps.dataPoints.length === newProps.dataPoints.length &&    oldProps.dataPoints.every((oldPoint, index) => {      const newPoint = newProps.dataPoints[index];      return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;    })  );}
```

If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.

When you do performance measurements, make sure that React is running in the production mode.


### Pitfall
If you provide a customarePropsEqualimplementation,you must compare every prop, including functions.Functions oftenclose overthe props and state of parent components. If you returntruewhenoldProps.onClick !== newProps.onClick, your component will keep “seeing” the props and state from a previous render inside itsonClickhandler, leading to very confusing bugs.

Avoid doing deep equality checks insidearePropsEqualunless you are 100% sure that the data structure you’re working with has a known limited depth.Deep equality checks can become incredibly slowand can freeze your app for many seconds if someone changes the data structure later.


### Do I still need React.memo if I use React Compiler?
When you enableReact Compiler, you typically don’t needReact.memoanymore. The compiler automatically optimizes component re-rendering for you.

Here’s how it works:

Without React Compiler, you needReact.memoto prevent unnecessary re-renders:

```jsx
// Parent re-renders every secondfunction Parent() {  const [seconds, setSeconds] = useState(0);  useEffect(() => {    const interval = setInterval(() => {      setSeconds(s => s + 1);    }, 1000);    return () => clearInterval(interval);  }, []);  return (    <>      <h1>Seconds: {seconds}</h1>      <ExpensiveChild name="John" />    </>  );}// Without memo, this re-renders every second even though props don't changeconst ExpensiveChild = memo(function ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;});
```

With React Compiler enabled, the same optimization happens automatically:

```jsx
// No memo needed - compiler prevents re-renders automaticallyfunction ExpensiveChild({ name }) {  console.log('ExpensiveChild rendered');  return <div>Hello, {name}!</div>;}
```

Here’s the key part of what the React Compiler generates:

```jsx
function Parent() {  const $ = _c(7);  const [seconds, setSeconds] = useState(0);  // ... other code ...  let t3;  if ($[4] === Symbol.for("react.memo_cache_sentinel")) {    t3 = <ExpensiveChild name="John" />;    $[4] = t3;  } else {    t3 = $[4];  }  // ... return statement ...}
```

Notice the highlighted lines: The compiler wraps<ExpensiveChild name="John" />in a cache check. Since thenameprop is always"John", this JSX is created once and reused on every parent re-render. This is exactly whatReact.memodoes - it prevents the child from re-rendering when its props haven’t changed.

The React Compiler automatically:

1. Tracks that thenameprop passed toExpensiveChildhasn’t changed
1. Reuses the previously created JSX for<ExpensiveChild name="John" />
1. Skips re-renderingExpensiveChildentirely
This meansyou can safely removeReact.memofrom your components when using React Compiler. The compiler provides the same optimization automatically, making your code cleaner and easier to maintain.


### Note
The compiler’s optimization is actually more comprehensive thanReact.memo. It also memoizes intermediate values and expensive computations within your components, similar to combiningReact.memowithuseMemothroughout your component tree.


## Troubleshooting

### My component re-renders when a prop is an object, array, or function
React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this,simplify props or memoize props in the parent component.


--------------------------------------------------------------------------------


# startTransition
Source: https://react.dev/reference/react/startTransition

startTransitionlets you render a part of the UI in the background.

```jsx
startTransition(action)
```

- ReferencestartTransition(action)
- startTransition(action)
- UsageMarking a state update as a non-blocking Transition
- Marking a state update as a non-blocking Transition

## Reference

### startTransition(action)
ThestartTransitionfunction lets you mark a state update as a Transition.

```jsx
import { startTransition } from 'react';function TabContainer() {  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
```

See more examples below.


#### Parameters
- action: A function that updates some state by calling one or moresetfunctions. React callsactionimmediately with no parameters and marks all state updates scheduled synchronously during theactionfunction call as Transitions. Any async calls awaited in theactionwill be included in the transition, but currently require wrapping anysetfunctions after theawaitin an additionalstartTransition(seeTroubleshooting). State updates marked as Transitions will benon-blockingandwill not display unwanted loading indicators..

#### Returns
startTransitiondoes not return anything.


#### Caveats
- startTransitiondoes not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you needuseTransitioninstead.
startTransitiondoes not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you needuseTransitioninstead.

- You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook return value, tryuseDeferredValueinstead.
You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook return value, tryuseDeferredValueinstead.

- The function you pass tostartTransitionis called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in asetTimeout, for example, they won’t be marked as Transitions.
The function you pass tostartTransitionis called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in asetTimeout, for example, they won’t be marked as Transitions.

- You must wrap any state updates after any async requests in anotherstartTransitionto mark them as Transitions. This is a known limitation that we will fix in the future (seeTroubleshooting).
You must wrap any state updates after any async requests in anotherstartTransitionto mark them as Transitions. This is a known limitation that we will fix in the future (seeTroubleshooting).

- A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.
A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.

- Transition updates can’t be used to control text inputs.
Transition updates can’t be used to control text inputs.

- If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.
If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.


## Usage

### Marking a state update as a non-blocking Transition
You can mark a state update as aTransitionby wrapping it in astartTransitioncall:

```jsx
import { startTransition } from 'react';function TabContainer() {  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
```

Transitions let you keep the user interface updates responsive even on slow devices.

With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.


### Note
startTransitionis very similar touseTransition, except that it does not provide theisPendingflag to track whether a Transition is ongoing. You can callstartTransitionwhenuseTransitionis not available. For example,startTransitionworks outside components, such as from a data library.

Learn about Transitions and see examples on theuseTransitionpage.


--------------------------------------------------------------------------------


# use
Source: https://react.dev/reference/react/use

useis a React API that lets you read the value of a resource like aPromiseorcontext.

```jsx
const value = use(resource);
```

- Referenceuse(resource)
- use(resource)
- UsageReading context withuseStreaming data from the server to the clientDealing with rejected Promises
- Reading context withuse
- Streaming data from the server to the client
- Dealing with rejected Promises
- Troubleshooting“Suspense Exception: This is not a real error!”
- “Suspense Exception: This is not a real error!”

## Reference

### use(resource)
Callusein your component to read the value of a resource like aPromiseorcontext.

```jsx
import { use } from 'react';function MessageComponent({ messagePromise }) {  const message = use(messagePromise);  const theme = use(ThemeContext);  // ...
```

Unlike React Hooks,usecan be called within loops and conditional statements likeif. Like React Hooks, the function that callsusemust be a Component or Hook.

When called with a Promise, theuseAPI integrates withSuspenseandError Boundaries. The component callingusesuspendswhile the Promise passed touseis pending. If the component that callsuseis wrapped in a Suspense boundary, the fallback will be displayed.  Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by theuseAPI. If the Promise passed touseis rejected, the fallback of the nearest Error Boundary will be displayed.

See more examples below.


#### Parameters
- resource: this is the source of the data you want to read a value from. A resource can be aPromiseor acontext.

#### Returns
TheuseAPI returns the value that was read from the resource like the resolved value of aPromiseorcontext.


#### Caveats
- TheuseAPI must be called inside a Component or a Hook.
- When fetching data in aServer Component, preferasyncandawaitoveruse.asyncandawaitpick up rendering from the point whereawaitwas invoked, whereasusere-renders the component after the data is resolved.
- Prefer creating Promises inServer Componentsand passing them toClient Componentsover creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders.See this example.

## Usage

### Reading context withuse
When acontextis passed touse, it works similarly touseContext. WhileuseContextmust be called at the top level of your component,usecan be called inside conditionals likeifand loops likefor.useis preferred overuseContextbecause it is more flexible.

```jsx
import { use } from 'react';function Button() {  const theme = use(ThemeContext);  // ...
```

usereturns thecontext valuefor thecontextyou passed. To determine the context value, React searches the component tree and findsthe closest context provider abovefor that particular context.

To pass context to aButton, wrap it or one of its parent components into the corresponding context provider.

```jsx
function MyPage() {  return (    <ThemeContext value="dark">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}
```

It doesn’t matter how many layers of components there are between the provider and theButton. When aButtonanywhereinside ofFormcallsuse(ThemeContext), it will receive"dark"as the value.

UnlikeuseContext,usecan be called in conditionals and loops likeif.

```jsx
function HorizontalRule({ show }) {  if (show) {    const theme = use(ThemeContext);    return <hr className={theme} />;  }  return false;}
```

useis called from inside aifstatement, allowing you to conditionally read values from a Context.


### Pitfall
LikeuseContext,use(context)always looks for the closest context providerabovethe component that calls it. It searches upwards anddoes notconsider context providers in the component from which you’re callinguse(context).

```jsx
import { createContext, use } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button show={true}>Sign up</Button>
      <Button show={false}>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = use(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ show, children }) {
  if (show) {
    const theme = use(ThemeContext);
    const className = 'button-' + theme;
    return (
      <button className={className}>
        {children}
      </button>
    );
  }
  return false
}


```


### Streaming data from the server to the client
Data can be streamed from the server to the client by passing a Promise as a prop from aServer Componentto aClient Component.

```jsx
import { fetchMessage } from './lib.js';import { Message } from './message.js';export default function App() {  const messagePromise = fetchMessage();  return (    <Suspense fallback={<p>waiting for message...</p>}>      <Message messagePromise={messagePromise} />    </Suspense>  );}
```

TheClient Componentthen takesthe Promise it received as a propand passes it to theuseAPI. This allows theClient Componentto read the value fromthe Promisethat was initially created by the Server Component.

```jsx
// message.js'use client';import { use } from 'react';export function Message({ messagePromise }) {  const messageContent = use(messagePromise);  return <p>Here is the message: {messageContent}</p>;}
```

BecauseMessageis wrapped inSuspense, the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by theuseAPI and theMessagecomponent will replace the Suspense fallback.

```jsx
"use client";

import { use, Suspense } from "react";

function Message({ messagePromise }) {
  const messageContent = use(messagePromise);
  return <p>Here is the message: {messageContent}</p>;
}

export function MessageContainer({ messagePromise }) {
  return (
    <Suspense fallback={<p>⌛Downloading message...</p>}>
      <Message messagePromise={messagePromise} />
    </Suspense>
  );
}


```


### Note
When passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren’t serializable and cannot be the resolved value of such a Promise.


#### Should I resolve a Promise in a Server or Client Component?
A Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with theuseAPI. You can also resolve the Promise in a Server Component withawaitand pass the required data to the Client Component as a prop.

```jsx
export default async function App() {  const messageContent = await fetchMessage();  return <Message messageContent={messageContent} />}
```

But usingawaitin aServer Componentwill block its rendering until theawaitstatement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.


### Dealing with rejected Promises
In some cases a Promise passed tousecould be rejected. You can handle rejected Promises by either:

1. Displaying an error to users with an Error Boundary.
1. Providing an alternative value withPromise.catch

### Pitfall
usecannot be called in a try-catch block. Instead of a try-catch blockwrap your component in an Error Boundary, orprovide an alternative value to use with the Promise’s.catchmethod.


#### Displaying an error to users with an Error Boundary
If you’d like to display an error to your users when a Promise is rejected, you can use anError Boundary. To use an Error Boundary, wrap the component where you are calling theuseAPI in an Error Boundary. If the Promise passed touseis rejected the fallback for the Error Boundary will be displayed.

```jsx
"use client";

import { use, Suspense } from "react";
import { ErrorBoundary } from "react-error-boundary";

export function MessageContainer({ messagePromise }) {
  return (
    <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
      <Suspense fallback={<p>⌛Downloading message...</p>}>
        <Message messagePromise={messagePromise} />
      </Suspense>
    </ErrorBoundary>
  );
}

function Message({ messagePromise }) {
  const content = use(messagePromise);
  return <p>Here is the message: {content}</p>;
}


```


#### Providing an alternative value withPromise.catch
If you’d like to provide an alternative value when the Promise passed touseis rejected you can use the Promise’scatchmethod.

```jsx
import { Message } from './message.js';export default function App() {  const messagePromise = new Promise((resolve, reject) => {    reject();  }).catch(() => {    return "no new message found.";  });  return (    <Suspense fallback={<p>waiting for message...</p>}>      <Message messagePromise={messagePromise} />    </Suspense>  );}
```

To use the Promise’scatchmethod, callcatchon the Promise object.catchtakes a single argument: a function that takes an error message as an argument. Whatever isreturnedby the function passed tocatchwill be used as the resolved value of the Promise.


## Troubleshooting

### “Suspense Exception: This is not a real error!”
You are either callinguseoutside of a React Component or Hook function, or callingusein a try–catch block. If you are callinguseinside a try–catch block, wrap your component in an Error Boundary, or call the Promise’scatchto catch the error and resolve the Promise with another value.See these examples.

If you are callinguseoutside a React Component or Hook function, move theusecall to a React Component or Hook function.

```jsx
function MessageComponent({messagePromise}) {  function download() {    // ❌ the function calling `use` is not a Component or Hook    const message = use(messagePromise);    // ...
```

Instead, calluseoutside any component closures, where the function that callsuseis a Component or Hook.

```jsx
function MessageComponent({messagePromise}) {  // ✅ `use` is being called from a component.   const message = use(messagePromise);  // ...
```


--------------------------------------------------------------------------------


# useActionState
Source: https://react.dev/reference/react/useActionState

useActionStateis a React Hook that lets you update state with side effects usingActions.

```jsx
const [state, dispatchAction, isPending] = useActionState(reducerAction, initialState, permalink?);
```

- ReferenceuseActionState(reducerAction, initialState, permalink?)reducerActionfunction
- useActionState(reducerAction, initialState, permalink?)
- reducerActionfunction
- UsageAdding state to an ActionUsing multiple Action typesUsing withuseOptimisticUsing with Action propsCancelling queued ActionsUsing with<form>Action propsHandling errors
- Adding state to an Action
- Using multiple Action types
- Using withuseOptimistic
- Using with Action props
- Cancelling queued Actions
- Using with<form>Action props
- Handling errors
- TroubleshootingMyisPendingflag is not updatingMy Action cannot read form dataMy actions are being skippedMy state doesn’t resetI’m getting an error: “An async function with useActionState was called outside of a transition.”I’m getting an error: “Cannot update action state while rendering”
- MyisPendingflag is not updating
- My Action cannot read form data
- My actions are being skipped
- My state doesn’t reset
- I’m getting an error: “An async function with useActionState was called outside of a transition.”
- I’m getting an error: “Cannot update action state while rendering”

## Reference

### useActionState(reducerAction, initialState, permalink?)
CalluseActionStateat the top level of your component to create state for the result of an Action.

```jsx
import { useActionState } from 'react';function reducerAction(previousState, actionPayload) {  // ...}function MyCart({initialState}) {  const [state, dispatchAction, isPending] = useActionState(reducerAction, initialState);  // ...}
```

See more examples below.


#### Parameters
- reducerAction: The function to be called when the Action is triggered. When called, it receives the previous state (initially theinitialStateyou provided, then its previous return value) as its first argument, followed by theactionPayloadpassed todispatchAction.
- initialState: The value you want the state to be initially. React ignores this argument afterdispatchActionis invoked for the first time.
- optionalpermalink: A string containing the unique page URL that this form modifies.For use on pages withReact Server Componentswith progressive enhancement.IfreducerActionis aServer Functionand the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL rather than the current page’s URL.
- For use on pages withReact Server Componentswith progressive enhancement.
- IfreducerActionis aServer Functionand the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL rather than the current page’s URL.

#### Returns
useActionStatereturns an array with exactly three values:

1. The current state. During the first render, it will match theinitialStateyou passed. AfterdispatchActionis invoked, it will match the value returned by thereducerAction.
1. AdispatchActionfunction that you call insideActions.
1. TheisPendingflag that tells you if any dispatched Actions for this Hook are pending.

#### Caveats
- useActionStateis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
- React queues and executes multiple calls todispatchActionsequentially. Each call toreducerActionreceives the result of the previous call.
- ThedispatchActionfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.
- When using thepermalinkoption, ensure the same form component is rendered on the destination page (including the samereducerActionandpermalink) so React knows how to pass the state through. Once the page becomes interactive, this parameter has no effect.
- When using Server Functions,initialStateneeds to beserializable(values like plain objects, arrays, strings, and numbers).
- IfdispatchActionthrows an error, React cancels all queued actions and shows the nearestError Boundary.
- If there are multiple ongoing Actions, React batches them together. This is a limitation that may be removed in a future release.

### Note
dispatchActionmust be called from an Action.

You can wrap it instartTransition, or pass it to anAction prop. Calls outside that scope won’t be treated as part of the Transition andlog an erroron development mode.


### reducerActionfunction
ThereducerActionfunction passed touseActionStatereceives the previous state and returns a new state.

Unlike reducers inuseReducer, thereducerActioncan be async and perform side effects:

```jsx
async function reducerAction(previousState, actionPayload) {  const newState = await post(actionPayload);  return newState;}
```

Each time you calldispatchAction, React calls thereducerActionwith theactionPayload. The reducer will perform side effects such as posting data, and return the new state. IfdispatchActionis called multiple times, React queues and executes them in order so the result of the previous call is passed aspreviousStatefor the current call.


#### Parameters
- previousState: The last state. Initially this is equal to theinitialState. After the first call todispatchAction, it’s equal to the last state returned.
previousState: The last state. Initially this is equal to theinitialState. After the first call todispatchAction, it’s equal to the last state returned.

- optionalactionPayload: The argument passed todispatchAction. It can be a value of any type. Similar touseReducerconventions, it is usually an object with atypeproperty identifying it and, optionally, other properties with additional information.
optionalactionPayload: The argument passed todispatchAction. It can be a value of any type. Similar touseReducerconventions, it is usually an object with atypeproperty identifying it and, optionally, other properties with additional information.


#### Returns
reducerActionreturns the new state, and triggers a Transition to re-render with that state.


#### Caveats
- reducerActioncan be sync or async. It can perform sync actions like showing a notification, or async actions like posting updates to a server.
- reducerActionis not invoked twice in<StrictMode>sincereducerActionis designed to allow side effects.
- The return type ofreducerActionmust match the type ofinitialState. If TypeScript infers a mismatch, you may need to explicitly annotate your state type.
- If you set state afterawaitin thereducerActionyou currently need to wrap the state update in an additionalstartTransition. See thestartTransitiondocs for more info.
- When using Server Functions,actionPayloadneeds to beserializable(values like plain objects, arrays, strings, and numbers).

#### Why is it calledreducerAction?
The function passed touseActionStateis called areducer actionbecause:

- Itreducesthe previous state into a new state, likeuseReducer.
- It’s anActionbecause it’s called inside a Transition and can perform side effects.
Conceptually,useActionStateis likeuseReducer, but you can do side effects in the reducer.


## Usage

### Adding state to an Action
CalluseActionStateat the top level of your component to create state for the result of an Action.

```jsx
import { useActionState } from 'react';async function addToCartAction(prevCount) {  // ...}function Counter() {  const [count, dispatchAction, isPending] = useActionState(addToCartAction, 0);  // ...}
```

useActionStatereturns an array with exactly three items:

1. Thecurrent state, initially set to the initial state you provided.
1. Theaction dispatcherthat lets you triggerreducerAction.
1. Apending statethat tells you whether the Action is in progress.
To calladdToCartAction, call theaction dispatcher. React will queue calls toaddToCartActionwith the previous count.

```jsx
import { useActionState, startTransition } from 'react';
import { addToCart } from './api';
import Total from './Total';

export default function Checkout() {
  const [count, dispatchAction, isPending] = useActionState(async (prevCount) => {
    return await addToCart(prevCount)
  }, 0);

  function handleClick() {
    startTransition(() => {
      dispatchAction();
    });
  }

  return (
    <div className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <span>Qty: {count}</span>
      </div>
      <div className="row">
        <button onClick={handleClick}>Add Ticket{isPending ? ' 🌀' : '  '}</button>
      </div>
      <hr />
      <Total quantity={count} />
    </div>
  );
}


```

Every time you click “Add Ticket,” React queues a call toaddToCartAction. React shows the pending state until all the tickets are added, and then re-renders with the final state.


#### HowuseActionStatequeuing works
Try clicking “Add Ticket” multiple times. Every time you click, a newaddToCartActionis queued. Since there’s an artificial 1 second delay, that means 4 clicks will take ~4 seconds to complete.

This is intentional in the design ofuseActionState.

We have to wait for the previous result ofaddToCartActionin order to pass theprevCountto the next call toaddToCartAction. That means React has to wait for the previous Action to finish before calling the next Action.

You can typically solve this byusing with useOptimisticbut for more complex cases you may want to considercancelling queued actionsor not usinguseActionState.


### Using multiple Action types
To handle multiple types, you can pass an argument todispatchAction.

By convention, it is common to write it as a switch statement. For each case in the switch, calculate and return some next state. The argument can have any shape, but it is common to pass objects with atypeproperty identifying the action.

```jsx
import { useActionState, startTransition } from 'react';
import { addToCart, removeFromCart } from './api';
import Total from './Total';

export default function Checkout() {
  const [count, dispatchAction, isPending] = useActionState(updateCartAction, 0);

  function handleAdd() {
    startTransition(() => {
      dispatchAction({ type: 'ADD' });
    });
  }

  function handleRemove() {
    startTransition(() => {
      dispatchAction({ type: 'REMOVE' });
    });
  }

  return (
    <div className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <span className="stepper">
          <span className="qty">{isPending ? '🌀' : count}</span>
          <span className="buttons">
            <button onClick={handleAdd}>▲</button>
            <button onClick={handleRemove}>▼</button>
          </span>
        </span>
      </div>
      <hr />
      <Total quantity={count} isPending={isPending}/>
    </div>
  );
}

async function updateCartAction(prevCount, actionPayload) {
  switch (actionPayload.type) {
    case 'ADD': {
      return await addToCart(prevCount);
    }
    case 'REMOVE': {
      return await removeFromCart(prevCount);
    }
  }
  return prevCount;
}


```

When you click to increase or decrease the quantity, an"ADD"or"REMOVE"is dispatched. In thereducerAction, different APIs are called to update the quantity.

In this example, we use the pending state of the Actions to replace both the quantity and the total. If you want to provide immediate feedback, such as immediately updating the quantity, you can useuseOptimistic.


#### How isuseActionStatedifferent fromuseReducer?
You might notice this example looks a lot likeuseReducer, but they serve different purposes:

- UseuseReducerto manage state of your UI. The reducer must be pure.
UseuseReducerto manage state of your UI. The reducer must be pure.

- UseuseActionStateto manage state of your Actions. The reducer can perform side effects.
UseuseActionStateto manage state of your Actions. The reducer can perform side effects.

You can think ofuseActionStateasuseReducerfor side effects from user Actions. Since it computes the next Action to take based on the previous Action, it has toorder the calls sequentially. If you want to perform Actions in parallel, useuseStateanduseTransitiondirectly.


### Using withuseOptimistic
You can combineuseActionStatewithuseOptimisticto show immediate UI feedback:

```jsx
import { useActionState, startTransition, useOptimistic } from 'react';
import { addToCart, removeFromCart } from './api';
import Total from './Total';

export default function Checkout() {
  const [count, dispatchAction, isPending] = useActionState(updateCartAction, 0);
  const [optimisticCount, setOptimisticCount] = useOptimistic(count);

  function handleAdd() {
    startTransition(() => {
      setOptimisticCount(c => c + 1);
      dispatchAction({ type: 'ADD' });
    });
  }

  function handleRemove() {
    startTransition(() => {
      setOptimisticCount(c => c - 1);
      dispatchAction({ type: 'REMOVE' });
    });
  }

  return (
    <div className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <span className="stepper">
          <span className="pending">{isPending && '🌀'}</span>
          <span className="qty">{optimisticCount}</span>
          <span className="buttons">
            <button onClick={handleAdd}>▲</button>
            <button onClick={handleRemove}>▼</button>
          </span>
        </span>
      </div>
      <hr />
      <Total quantity={optimisticCount} isPending={isPending}/>
    </div>
  );
}

async function updateCartAction(prevCount, actionPayload) {
  switch (actionPayload.type) {
    case 'ADD': {
      return await addToCart(prevCount);
    }
    case 'REMOVE': {
      return await removeFromCart(prevCount);
    }
  }
  return prevCount;
}


```

setOptimisticCountimmediately updates the quantity, anddispatchAction()queues theupdateCartAction. A pending indicator appears on both the quantity and total to give the user feedback that their update is still being applied.


### Using with Action props
When you pass thedispatchActionfunction to a component that exposes anAction prop, you don’t need to callstartTransitionoruseOptimisticyourself.

This example shows using theincreaseActionanddecreaseActionprops of a QuantityStepper component:

```jsx
import { useActionState } from 'react';
import { addToCart, removeFromCart } from './api';
import QuantityStepper from './QuantityStepper';
import Total from './Total';

export default function Checkout() {
  const [count, dispatchAction, isPending] = useActionState(updateCartAction, 0);

  function addAction() {
    dispatchAction({type: 'ADD'});
  }

  function removeAction() {
    dispatchAction({type: 'REMOVE'});
  }

  return (
    <div className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <QuantityStepper
          value={count}
          increaseAction={addAction}
          decreaseAction={removeAction}
        />
      </div>
      <hr />
      <Total quantity={count} isPending={isPending} />
    </div>
  );
}

async function updateCartAction(prevCount, actionPayload) {
  switch (actionPayload.type) {
    case 'ADD': {
      return await addToCart(prevCount);
    }
    case 'REMOVE': {
      return await removeFromCart(prevCount);
    }
  }
  return prevCount;
}


```

Since<QuantityStepper>has built-in support for transitions, pending state, and optimistically updating the count, you just need to tell the Actionwhatto change, andhowto change it is handled for you.


### Cancelling queued Actions
You can use anAbortControllerto cancel pending Actions:

```jsx
import { useActionState, useRef } from 'react';
import { addToCart, removeFromCart } from './api';
import QuantityStepper from './QuantityStepper';
import Total from './Total';

export default function Checkout() {
  const abortRef = useRef(null);
  const [count, dispatchAction, isPending] = useActionState(updateCartAction, 0);
  
  async function addAction() {
    if (abortRef.current) {
      abortRef.current.abort();
    }
    abortRef.current = new AbortController();
    await dispatchAction({ type: 'ADD', signal: abortRef.current.signal });
  }

  async function removeAction() {
    if (abortRef.current) {
      abortRef.current.abort();
    }
    abortRef.current = new AbortController();
    await dispatchAction({ type: 'REMOVE', signal: abortRef.current.signal });
  }

  return (
    <div className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <QuantityStepper
          value={count}
          increaseAction={addAction}
          decreaseAction={removeAction}
        />
      </div>
      <hr />
      <Total quantity={count} isPending={isPending} />
    </div>
  );
}

async function updateCartAction(prevCount, actionPayload) {
  switch (actionPayload.type) {
    case 'ADD': {
      try {
        return await addToCart(prevCount, { signal: actionPayload.signal });
      } catch (e) {
        return prevCount + 1;
      }
    }
    case 'REMOVE': {
      try {
        return await removeFromCart(prevCount, { signal: actionPayload.signal });
      } catch (e) {
        return Math.max(0, prevCount - 1);
      }
    }
  }
  return prevCount;
}


```

Try clicking increase or decrease multiple times, and notice that the total updates within 1 second no matter how many times you click. This works because it uses anAbortControllerto “complete” the previous Action so the next Action can proceed.


### Pitfall
Aborting an Action isn’t always safe.

For example, if the Action performs a mutation (like writing to a database), aborting the network request doesn’t undo the server-side change. This is whyuseActionStatedoesn’t abort by default. It’s only safe when you know the side effect can be safely ignored or retried.


### Using with<form>Action props
You can pass thedispatchActionfunction as theactionprop to a<form>.

When used this way, React automatically wraps the submission in a Transition, so you don’t need to callstartTransitionyourself. ThereducerActionreceives the previous state and the submittedFormData:

```jsx
import { useActionState, useOptimistic } from 'react';
import { addToCart, removeFromCart } from './api';
import Total from './Total';

export default function Checkout() {
  const [count, dispatchAction, isPending] = useActionState(updateCartAction, 0);
  const [optimisticCount, setOptimisticCount] = useOptimistic(count);

  async function formAction(formData) {
    const type = formData.get('type');
    if (type === 'ADD') {
      setOptimisticCount(c => c + 1);
    } else {
      setOptimisticCount(c => Math.max(0, c - 1));
    }
    return dispatchAction(formData);
  }

  return (
    <form action={formAction} className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <span className="stepper">
          <span className="pending">{isPending && '🌀'}</span>
          <span className="qty">{optimisticCount}</span>
          <span className="buttons">
            <button type="submit" name="type" value="ADD">▲</button>
            <button type="submit" name="type" value="REMOVE">▼</button>
          </span>
        </span>
      </div>
      <hr />
      <Total quantity={count} isPending={isPending} />
    </form>
  );
}

async function updateCartAction(prevCount, formData) {
  const type = formData.get('type');
  switch (type) {
    case 'ADD': {
      return await addToCart(prevCount);
    }
    case 'REMOVE': {
      return await removeFromCart(prevCount);
    }
  }
  return prevCount;
}


```

In this example, when the user clicks the stepper arrows, the button submits the form anduseActionStatecallsupdateCartActionwith the form data. The example usesuseOptimisticto immediately show the new quantity while the server confirms the update.


### React Server Components
When used with aServer Function,useActionStateallows the server’s response to be shown before hydration (when React attaches to server-rendered HTML) completes. You can also use the optionalpermalinkparameter for progressive enhancement (allowing the form to work before JavaScript loads) on pages with dynamic content. This is typically handled by your framework for you.

See the<form>docs for more information on using Actions with forms.


### Handling errors
There are two ways to handle errors withuseActionState.

For known errors, such as “quantity not available” validation errors from your backend, you can return it as part of yourreducerActionstate and display it in the UI.

For unknown errors, such asundefined is not a function, you can throw an error. React will cancel all queued Actions and shows the nearestError Boundaryby rethrowing the error from theuseActionStatehook.

```jsx
import {useActionState, startTransition} from 'react';
import {ErrorBoundary} from 'react-error-boundary';
import {addToCart} from './api';
import Total from './Total';

function Checkout() {
  const [state, dispatchAction, isPending] = useActionState(
    async (prevState, quantity) => {
      const result = await addToCart(prevState.count, quantity);
      if (result.error) {
        // Return the error from the API as state
        return {...prevState, error: `Could not add quanitiy ${quantity}: ${result.error}`};
      }
      
      if (!isPending) {
        // Clear the error state for the first dispatch.
        return {count: result.count, error: null};    
      }
      
      // Return the new count, and any errors that happened.
      return {count: result.count, error: prevState.error};
      
      
    },
    {
      count: 0,
      error: null,
    }
  );

  function handleAdd(quantity) {
    startTransition(() => {
      dispatchAction(quantity);
    });
  }

  return (
    <div className="checkout">
      <h2>Checkout</h2>
      <div className="row">
        <span>Eras Tour Tickets</span>
        <span>
          {isPending && '🌀 '}Qty: {state.count}
        </span>
      </div>
      <div className="buttons">
        <button onClick={() => handleAdd(1)}>Add 1</button>
        <button onClick={() => handleAdd(10)}>Add 10</button>
        <button onClick={() => handleAdd(NaN)}>Add NaN</button>
      </div>
      {state.error && <div className="error">{state.error}</div>}
      <hr />
      <Total quantity={state.count} isPending={isPending} />
    </div>
  );
}



export default function App() {
  return (
    <ErrorBoundary
      fallbackRender={({resetErrorBoundary}) => (
        <div className="checkout">
          <h2>Something went wrong</h2>
          <p>The action could not be completed.</p>
          <button onClick={resetErrorBoundary}>Try again</button>
        </div>
      )}>
      <Checkout />
    </ErrorBoundary>
  );
}


```

In this example, “Add 10” simulates an API that returns a validation error, whichupdateCartActionstores in state and displays inline. “Add NaN” results in an invalid count, soupdateCartActionthrows, which propagates throughuseActionStateto theErrorBoundaryand shows a reset UI.


## Troubleshooting

### MyisPendingflag is not updating
If you’re callingdispatchActionmanually (not through an Action prop), make sure you wrap the call instartTransition:

```jsx
import { useActionState, startTransition } from 'react';function MyComponent() {  const [state, dispatchAction, isPending] = useActionState(myAction, null);  function handleClick() {    // ✅ Correct: wrap in startTransition    startTransition(() => {      dispatchAction();    });  }  // ...}
```

WhendispatchActionis passed to an Action prop, React automatically wraps it in a Transition.


### My Action cannot read form data
When you useuseActionState, thereducerActionreceives an extra argument as its first argument: the previous or initial state. The submitted form data is therefore its second argument instead of its first.

```jsx
// Without useActionStatefunction action(formData) {  const name = formData.get('name');}// With useActionStatefunction action(prevState, formData) {  const name = formData.get('name');}
```


### My actions are being skipped
If you calldispatchActionmultiple times and some of them don’t run, it may be because an earlierdispatchActioncall threw an error.

When areducerActionthrows, React skips all subsequently queueddispatchActioncalls.

To handle this, catch errors within yourreducerActionand return an error state instead of throwing:

```jsx
async function myReducerAction(prevState, data) {  try {    const result = await submitData(data);    return { success: true, data: result };  } catch (error) {    // ✅ Return error state instead of throwing    return { success: false, error: error.message };  }}
```


### My state doesn’t reset
useActionStatedoesn’t provide a built-in reset function. To reset the state, you can design yourreducerActionto handle a reset signal:

```jsx
const initialState = { name: '', error: null };async function formAction(prevState, payload) {  // Handle reset  if (payload === null) {    return initialState;  }  // Normal action logic  const result = await submitData(payload);  return result;}function MyComponent() {  const [state, dispatchAction, isPending] = useActionState(formAction, initialState);  function handleReset() {    startTransition(() => {      dispatchAction(null); // Pass null to trigger reset    });  }  // ...}
```

Alternatively, you can add akeyprop to the component usinguseActionStateto force it to remount with fresh state, or a<form>actionprop, which resets automatically after submission.


### I’m getting an error: “An async function with useActionState was called outside of a transition.”
A common mistake is to forget to calldispatchActionfrom inside a Transition:

This error happens becausedispatchActionmust run inside a Transition:

```jsx
function MyComponent() {  const [state, dispatchAction, isPending] = useActionState(myAsyncAction, null);  function handleClick() {    // ❌ Wrong: calling dispatchAction outside a Transition    dispatchAction();  }  // ...}
```

To fix, either wrap the call instartTransition:

```jsx
import { useActionState, startTransition } from 'react';function MyComponent() {  const [state, dispatchAction, isPending] = useActionState(myAsyncAction, null);  function handleClick() {    // ✅ Correct: wrap in startTransition    startTransition(() => {      dispatchAction();    });  }  // ...}
```

Or passdispatchActionto an Action prop, is call in a Transition:

```jsx
function MyComponent() {  const [state, dispatchAction, isPending] = useActionState(myAsyncAction, null);  // ✅ Correct: action prop wraps in a Transition for you  return <Button action={dispatchAction}>...</Button>;}
```


### I’m getting an error: “Cannot update action state while rendering”
You cannot calldispatchActionduring render:

This causes an infinite loop because callingdispatchActionschedules a state update, which triggers a re-render, which callsdispatchActionagain.

```jsx
function MyComponent() {  const [state, dispatchAction, isPending] = useActionState(myAction, null);  // ❌ Wrong: calling dispatchAction during render  dispatchAction();  // ...}
```

To fix, only calldispatchActionin response to user events (like form submissions or button clicks).


--------------------------------------------------------------------------------


# useCallback
Source: https://react.dev/reference/react/useCallback

useCallbackis a React Hook that lets you cache a function definition between re-renders.

```jsx
const cachedFn = useCallback(fn, dependencies)
```


### Note
React Compilerautomatically memoizes values and functions, reducing the need for manualuseCallbackcalls. You can use the compiler to handle memoization automatically.

- ReferenceuseCallback(fn, dependencies)
- useCallback(fn, dependencies)
- UsageSkipping re-rendering of componentsUpdating state from a memoized callbackPreventing an Effect from firing too oftenOptimizing a custom Hook
- Skipping re-rendering of components
- Updating state from a memoized callback
- Preventing an Effect from firing too often
- Optimizing a custom Hook
- TroubleshootingEvery time my component renders,useCallbackreturns a different functionI need to calluseCallbackfor each list item in a loop, but it’s not allowed
- Every time my component renders,useCallbackreturns a different function
- I need to calluseCallbackfor each list item in a loop, but it’s not allowed

## Reference

### useCallback(fn, dependencies)
CalluseCallbackat the top level of your component to cache a function definition between re-renders:

```jsx
import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);
```

See more examples below.


#### Parameters
- fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if thedependencieshave not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.
fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if thedependencieshave not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.

- dependencies: The list of all reactive values referenced inside of thefncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm.
dependencies: The list of all reactive values referenced inside of thefncode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm.


#### Returns
On the initial render,useCallbackreturns thefnfunction you have passed.

During subsequent renders, it will either return an already storedfnfunction from the last render (if the dependencies haven’t changed), or return thefnfunction you have passed during this render.


#### Caveats
- useCallbackis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
- Reactwill not throw away the cached function unless there is a specific reason to do that.For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely onuseCallbackas a performance optimization. Otherwise, astate variableor arefmay be more appropriate.

## Usage

### Skipping re-rendering of components
When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.

To cache a function between re-renders of your component, wrap its definition into theuseCallbackHook:

```jsx
import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ...
```

You need to pass two things touseCallback:

1. A function definition that you want to cache between re-renders.
1. Alist of dependenciesincluding every value within your component that’s used inside your function.
On the initial render, thereturned functionyou’ll get fromuseCallbackwill be the function you passed.

On the following renders, React will compare thedependencieswith the dependencies you passed during the previous render. If none of the dependencies have changed (compared withObject.is),useCallbackwill return the same function as before. Otherwise,useCallbackwill return the function you passed onthisrender.

In other words,useCallbackcaches a function between re-renders until its dependencies change.

Let’s walk through an example to see when this is useful.

Say you’re passing ahandleSubmitfunction down from theProductPageto theShippingFormcomponent:

```jsx
function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );
```

You’ve noticed that toggling thethemeprop freezes the app for a moment, but if you remove<ShippingForm />from your JSX, it feels fast. This tells you that it’s worth trying to optimize theShippingFormcomponent.

By default, when a component re-renders, React re-renders all of its children recursively.This is why, whenProductPagere-renders with a differenttheme, theShippingFormcomponentalsore-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tellShippingFormto skip re-rendering when its props are the same as on last render by wrapping it inmemo:

```jsx
import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});
```

With this change,ShippingFormwill skip re-rendering if all of its props are thesameas on the last render.This is when caching a function becomes important! Let’s say you definedhandleSubmitwithoutuseCallback:

```jsx
function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }  return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}
```

In JavaScript, afunction () {}or() => {}always creates adifferentfunction,similar to how the{}object literal always creates a new object. Normally, this wouldn’t be a problem, but it means thatShippingFormprops will never be the same, and yourmemooptimization won’t work. This is whereuseCallbackcomes in handy:

```jsx
function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}
```

By wrappinghandleSubmitinuseCallback, you ensure that it’s thesamefunction between the re-renders(until dependencies change). You don’thave towrap a function inuseCallbackunless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped inmemo,and this lets it skip re-rendering. There are other reasons you might needuseCallbackwhich are described further on this page.


### Note
You should only rely onuseCallbackas a performance optimization.If your code doesn’t work without it, find the underlying problem and fix it first. Then you may adduseCallbackback.


#### How is useCallback related to useMemo?
You will often seeuseMemoalongsideuseCallback. They are both useful when you’re trying to optimize a child component. They let youmemoize(or, in other words, cache) something you’re passing down:

```jsx
import { useMemo, useCallback } from 'react';function ProductPage({ productId, referrer }) {  const product = useData('/product/' + productId);  const requirements = useMemo(() => { // Calls your function and caches its result    return computeRequirements(product);  }, [product]);  const handleSubmit = useCallback((orderDetails) => { // Caches your function itself    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  return (    <div className={theme}>      <ShippingForm requirements={requirements} onSubmit={handleSubmit} />    </div>  );}
```

The difference is inwhatthey’re letting you cache:

- useMemocaches theresultof calling your function.In this example, it caches the result of callingcomputeRequirements(product)so that it doesn’t change unlessproducthas changed. This lets you pass therequirementsobject down without unnecessarily re-renderingShippingForm. When necessary, React will call the function you’ve passed during rendering to calculate the result.
- useCallbackcachesthe function itself.UnlikeuseMemo, it does not call the function you provide. Instead, it caches the function you provided so thathandleSubmititselfdoesn’t change unlessproductIdorreferrerhas changed. This lets you pass thehandleSubmitfunction down without unnecessarily re-renderingShippingForm. Your code won’t run until the user submits the form.
If you’re already familiar withuseMemo,you might find it helpful to think ofuseCallbackas this:

```jsx
// Simplified implementation (inside React)function useCallback(fn, dependencies) {  return useMemo(() => fn, dependencies);}
```

Read more about the difference betweenuseMemoanduseCallback.


#### Should you add useCallback everywhere?
If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.

Caching a function withuseCallbackis only valuable in a few cases:

- You pass it as a prop to a component wrapped inmemo.You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only if dependencies changed.
- The function you’re passing is later used as a dependency of some Hook. For example, another function wrapped inuseCallbackdepends on it, or you depend on this function fromuseEffect.
There is no benefit to wrapping a function inuseCallbackin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.

Note thatuseCallbackdoes not preventcreatingthe function. You’re always creating a function (and that’s fine!), but React ignores it and gives you back a cached function if nothing changed.

In practice, you can make a lot of memoization unnecessary by following a few principles:

1. When a component visually wraps other components, let itaccept JSX as children.Then, if the wrapper component updates its own state, React knows that its children don’t need to re-render.
1. Prefer local state and don’tlift state upany further than necessary. Don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
1. Keep yourrendering logic pure.If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
1. Avoidunnecessary Effects that update state.Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
1. Try toremove unnecessary dependencies from your Effects.For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.
If a specific interaction still feels laggy,use the React Developer Tools profilerto see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In long term, we’re researchingdoing memoization automaticallyto solve this once and for all.


#### The difference between useCallback and declaring a function directly

#### Example1of2:Skipping re-rendering withuseCallbackandmemo
In this example, theShippingFormcomponent isartificially slowed downso that you can see what happens when a React component you’re rendering is genuinely slow. Try incrementing the counter and toggling the theme.

Incrementing the counter feels slow because it forces the slowed downShippingFormto re-render. That’s expected because the counter has changed, and so you need to reflect the user’s new choice on the screen.

Next, try toggling the theme.Thanks touseCallbacktogether withmemo, it’s fast despite the artificial slowdown!ShippingFormskipped re-rendering because thehandleSubmitfunction has not changed. ThehandleSubmitfunction has not changed because bothproductIdandreferrer(youruseCallbackdependencies) haven’t changed since last render.

```jsx
import { useCallback } from 'react';
import ShippingForm from './ShippingForm.js';

export default function ProductPage({ productId, referrer, theme }) {
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]);

  return (
    <div className={theme}>
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
}

function post(url, data) {
  // Imagine this sends a request...
  console.log('POST /' + url);
  console.log(data);
}


```


### Updating state from a memoized callback
Sometimes, you might need to update state based on previous state from a memoized callback.

ThishandleAddTodofunction specifiestodosas a dependency because it computes the next todos from it:

```jsx
function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos([...todos, newTodo]);  }, [todos]);  // ...
```

You’ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing anupdater functioninstead:

```jsx
function TodoList() {  const [todos, setTodos] = useState([]);  const handleAddTodo = useCallback((text) => {    const newTodo = { id: nextId++, text };    setTodos(todos => [...todos, newTodo]);  }, []); // ✅ No need for the todos dependency  // ...
```

Here, instead of makingtodosa dependency and reading it inside, you pass an instruction abouthowto update the state (todos => [...todos, newTodo]) to React.Read more about updater functions.


### Preventing an Effect from firing too often
Sometimes, you might want to call a function from inside anEffect:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    // ...
```

This creates a problem.Every reactive value must be declared as a dependency of your Effect.However, if you declarecreateOptionsas a dependency, it will cause your Effect to constantly reconnect to the chat room:

```jsx
  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🔴 Problem: This dependency changes on every render  // ...
```

To solve this, you can wrap the function you need to call from an Effect intouseCallback:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const createOptions = useCallback(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // ✅ Only changes when createOptions changes  // ...
```

This ensures that thecreateOptionsfunction is the same between re-renders if theroomIdis the same.However, it’s even better to remove the need for a function dependency.Move your functioninsidethe Effect:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    function createOptions() { // ✅ No need for useCallback or function dependencies!      return {        serverUrl: 'https://localhost:1234',        roomId: roomId      };    }    const options = createOptions();    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ...
```

Now your code is simpler and doesn’t needuseCallback.Learn more about removing Effect dependencies.


### Optimizing a custom Hook
If you’re writing acustom Hook,it’s recommended to wrap any functions that it returns intouseCallback:

```jsx
function useRouter() {  const { dispatch } = useContext(RouterStateContext);  const navigate = useCallback((url) => {    dispatch({ type: 'navigate', url });  }, [dispatch]);  const goBack = useCallback(() => {    dispatch({ type: 'back' });  }, [dispatch]);  return {    navigate,    goBack,  };}
```

This ensures that the consumers of your Hook can optimize their own code when needed.


## Troubleshooting

### Every time my component renders,useCallbackreturns a different function
Make sure you’ve specified the dependency array as a second argument!

If you forget the dependency array,useCallbackwill return a new function every time:

```jsx
function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // 🔴 Returns a new function every time: no dependency array  // ...
```

This is the corrected version passing the dependency array as a second argument:

```jsx
function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ✅ Does not return a new function unnecessarily  // ...
```

If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:

```jsx
  const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);
```

You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:

```jsx
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
```

When you find which dependency is breaking memoization, either find a way to remove it, ormemoize it as well.


### I need to calluseCallbackfor each list item in a loop, but it’s not allowed
Suppose theChartcomponent is wrapped inmemo. You want to skip re-rendering everyChartin the list when theReportListcomponent re-renders. However, you can’t calluseCallbackin a loop:

```jsx
function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}
```

Instead, extract a component for an individual item, and putuseCallbackthere:

```jsx
function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}
```

Alternatively, you could removeuseCallbackin the last snippet and instead wrapReportitself inmemo.If theitemprop does not change,Reportwill skip re-rendering, soChartwill skip re-rendering too:

```jsx
function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});
```


--------------------------------------------------------------------------------


# useContext
Source: https://react.dev/reference/react/useContext

useContextis a React Hook that lets you read and subscribe tocontextfrom your component.

```jsx
const value = useContext(SomeContext)
```

- ReferenceuseContext(SomeContext)
- useContext(SomeContext)
- UsagePassing data deeply into the treeUpdating data passed via contextSpecifying a fallback default valueOverriding context for a part of the treeOptimizing re-renders when passing objects and functions
- Passing data deeply into the tree
- Updating data passed via context
- Specifying a fallback default value
- Overriding context for a part of the tree
- Optimizing re-renders when passing objects and functions
- TroubleshootingMy component doesn’t see the value from my providerI am always gettingundefinedfrom my context although the default value is different
- My component doesn’t see the value from my provider
- I am always gettingundefinedfrom my context although the default value is different

## Reference

### useContext(SomeContext)
CalluseContextat the top level of your component to read and subscribe tocontext.

```jsx
import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ...
```

See more examples below.


#### Parameters
- SomeContext: The context that you’ve previously created withcreateContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.

#### Returns
useContextreturns the context value for the calling component. It is determined as thevaluepassed to the closestSomeContextabove the calling component in the tree. If there is no such provider, then the returned value will be thedefaultValueyou have passed tocreateContextfor that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.


#### Caveats
- useContext()call in a component is not affected by providers returned from thesamecomponent. The corresponding<Context>needs to beabovethe component doing theuseContext()call.
- Reactautomatically re-rendersall the children that use a particular context starting from the provider that receives a differentvalue. The previous and the next values are compared with theObject.iscomparison. Skipping re-renders withmemodoes not prevent the children receiving fresh context values.
- If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works ifSomeContextthat you use to provide context andSomeContextthat you use to read it areexactlythe same object, as determined by a===comparison.

## Usage

### Passing data deeply into the tree
CalluseContextat the top level of your component to read and subscribe tocontext.

```jsx
import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ...
```

useContextreturns thecontext valuefor thecontextyou passed. To determine the context value, React searches the component tree and findsthe closest context provider abovefor that particular context.

To pass context to aButton, wrap it or one of its parent components into the corresponding context provider:

```jsx
function MyPage() {  return (    <ThemeContext value="dark">      <Form />    </ThemeContext>  );}function Form() {  // ... renders buttons inside ...}
```

It doesn’t matter how many layers of components there are between the provider and theButton. When aButtonanywhereinside ofFormcallsuseContext(ThemeContext), it will receive"dark"as the value.


### Pitfall
useContext()always looks for the closest providerabovethe component that calls it. It searches upwards anddoes notconsider providers in the component from which you’re callinguseContext().

```jsx
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}


```


### Updating data passed via context
Often, you’ll want the context to change over time. To update context, combine it withstate.Declare a state variable in the parent component, and pass the current state down as thecontext valueto the provider.

```jsx
function MyPage() {  const [theme, setTheme] = useState('dark');  return (    <ThemeContext value={theme}>      <Form />      <Button onClick={() => {        setTheme('light');      }}>        Switch to light theme      </Button>    </ThemeContext>  );}
```

Now anyButtoninside of the provider will receive the currentthemevalue. If you callsetThemeto update thethemevalue that you pass to the provider, allButtoncomponents will re-render with the new'light'value.


#### Examples of updating context

#### Example1of5:Updating a value via context
In this example, theMyAppcomponent holds a state variable which is then passed to theThemeContextprovider. Checking the “Dark mode” checkbox updates the state. Changing the provided value re-renders all the components using that context.

```jsx
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext value={theme}>
      <Form />
      <label>
        <input
          type="checkbox"
          checked={theme === 'dark'}
          onChange={(e) => {
            setTheme(e.target.checked ? 'dark' : 'light')
          }}
        />
        Use dark mode
      </label>
    </ThemeContext>
  )
}

function Form({ children }) {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}


```

Note thatvalue="dark"passes the"dark"string, butvalue={theme}passes the value of the JavaScriptthemevariable withJSX curly braces.Curly braces also let you pass context values that aren’t strings.


### Specifying a fallback default value
If React can’t find any providers of that particularcontextin the parent tree, the context value returned byuseContext()will be equal to thedefault valuethat you specified when youcreated that context:

```jsx
const ThemeContext = createContext(null);
```

The default valuenever changes. If you want to update context, use it with state asdescribed above.

Often, instead ofnull, there is some more meaningful value you can use as a default, for example:

```jsx
const ThemeContext = createContext('light');
```

This way, if you accidentally render some component without a corresponding provider, it won’t break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.

In the example below, the “Toggle theme” button is always light because it’soutside any theme context providerand the default context theme value is'light'. Try editing the default theme to be'dark'.

```jsx
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

export default function MyApp() {
  const [theme, setTheme] = useState('light');
  return (
    <>
      <ThemeContext value={theme}>
        <Form />
      </ThemeContext>
      <Button onClick={() => {
        setTheme(theme === 'dark' ? 'light' : 'dark');
      }}>
        Toggle theme
      </Button>
    </>
  )
}

function Form({ children }) {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children, onClick }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className} onClick={onClick}>
      {children}
    </button>
  );
}


```


### Overriding context for a part of the tree
You can override the context for a part of the tree by wrapping that part in a provider with a different value.

```jsx
<ThemeContext value="dark">  ...  <ThemeContext value="light">    <Footer />  </ThemeContext>  ...</ThemeContext>
```

You can nest and override providers as many times as you need.


#### Examples of overriding context

#### Example1of2:Overriding a theme
Here, the buttoninsidetheFooterreceives a different context value ("light") than the buttons outside ("dark").

```jsx
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
      <ThemeContext value="light">
        <Footer />
      </ThemeContext>
    </Panel>
  );
}

function Footer() {
  return (
    <footer>
      <Button>Settings</Button>
    </footer>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      {title && <h1>{title}</h1>}
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}


```


### Optimizing re-renders when passing objects and functions
You can pass any values via context, including objects and functions.

```jsx
function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  function login(response) {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }  return (    <AuthContext value={{ currentUser, login }}>      <Page />    </AuthContext>  );}
```

Here, thecontext valueis a JavaScript object with two properties, one of which is a function. WheneverMyAppre-renders (for example, on a route update), this will be adifferentobject pointing at adifferentfunction, so React will also have to re-render all components deep in the tree that calluseContext(AuthContext).

In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, likecurrentUser, has not changed. To help React take advantage of that fact, you may wrap theloginfunction withuseCallbackand wrap the object creation intouseMemo. This is a performance optimization:

```jsx
import { useCallback, useMemo } from 'react';function MyApp() {  const [currentUser, setCurrentUser] = useState(null);  const login = useCallback((response) => {    storeCredentials(response.credentials);    setCurrentUser(response.user);  }, []);  const contextValue = useMemo(() => ({    currentUser,    login  }), [currentUser, login]);  return (    <AuthContext value={contextValue}>      <Page />    </AuthContext>  );}
```

As a result of this change, even ifMyAppneeds to re-render, the components callinguseContext(AuthContext)won’t need to re-render unlesscurrentUserhas changed.

Read more aboutuseMemoanduseCallback.


## Troubleshooting

### My component doesn’t see the value from my provider
There are a few common ways that this can happen:

1. You’re rendering<SomeContext>in the same component (or below) as where you’re callinguseContext(). Move<SomeContext>above and outsidethe component callinguseContext().
1. You may have forgotten to wrap your component with<SomeContext>, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right usingReact DevTools.
1. You might be running into some build issue with your tooling that causesSomeContextas seen from the providing component andSomeContextas seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals likewindow.SomeContext1andwindow.SomeContext2and then checking whetherwindow.SomeContext1 === window.SomeContext2in the console. If they’re not the same, fix that issue on the build tool level.

### I am always gettingundefinedfrom my context although the default value is different
You might have a provider without avaluein the tree:

```jsx
// 🚩 Doesn't work: no value prop<ThemeContext>   <Button /></ThemeContext>
```

If you forget to specifyvalue, it’s like passingvalue={undefined}.

You may have also mistakingly used a different prop name by mistake:

```jsx
// 🚩 Doesn't work: prop should be called "value"<ThemeContext theme={theme}>   <Button /></ThemeContext>
```

In both of these cases you should see a warning from React in the console. To fix them, call the propvalue:

```jsx
// ✅ Passing the value prop<ThemeContext value={theme}>   <Button /></ThemeContext>
```

Note that thedefault value from yourcreateContext(defaultValue)callis only usedif there is no matching provider above at all.If there is a<SomeContext value={undefined}>component somewhere in the parent tree, the component callinguseContext(SomeContext)willreceiveundefinedas the context value.


--------------------------------------------------------------------------------


# useDebugValue
Source: https://react.dev/reference/react/useDebugValue

useDebugValueis a React Hook that lets you add a label to a custom Hook inReact DevTools.

```jsx
useDebugValue(value, format?)
```

- ReferenceuseDebugValue(value, format?)
- useDebugValue(value, format?)
- UsageAdding a label to a custom HookDeferring formatting of a debug value
- Adding a label to a custom Hook
- Deferring formatting of a debug value

## Reference

### useDebugValue(value, format?)
CalluseDebugValueat the top level of yourcustom Hookto display a readable debug value:

```jsx
import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}
```

See more examples below.


#### Parameters
- value: The value you want to display in React DevTools. It can have any type.
- optionalformat: A formatting function. When the component is inspected, React DevTools will call the formatting function with thevalueas the argument, and then display the returned formatted value (which may have any type). If you don’t specify the formatting function, the originalvalueitself will be displayed.

#### Returns
useDebugValuedoes not return anything.


## Usage

### Adding a label to a custom Hook
CalluseDebugValueat the top level of yourcustom Hookto display a readabledebug valueforReact DevTools.

```jsx
import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}
```

This gives components callinguseOnlineStatusa label likeOnlineStatus: "Online"when you inspect them:

Without theuseDebugValuecall, only the underlying data (in this example,true) would be displayed.

```jsx
import { useSyncExternalStore, useDebugValue } from 'react';

export function useOnlineStatus() {
  const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);
  useDebugValue(isOnline ? 'Online' : 'Offline');
  return isOnline;
}

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}


```


### Note
Don’t add debug values to every custom Hook. It’s most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that’s difficult to inspect.


### Deferring formatting of a debug value
You can also pass a formatting function as the second argument touseDebugValue:

```jsx
useDebugValue(date, date => date.toDateString());
```

Your formatting function will receive thedebug valueas a parameter and should return aformatted display value. When your component is inspected, React DevTools will call this function and display its result.

This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, ifdateis a Date value, this avoids callingtoDateString()on it for every render.


--------------------------------------------------------------------------------


# useDeferredValue
Source: https://react.dev/reference/react/useDeferredValue

useDeferredValueis a React Hook that lets you defer updating a part of the UI.

```jsx
const deferredValue = useDeferredValue(value)
```

- ReferenceuseDeferredValue(value, initialValue?)
- useDeferredValue(value, initialValue?)
- UsageShowing stale content while fresh content is loadingIndicating that the content is staleDeferring re-rendering for a part of the UI
- Showing stale content while fresh content is loading
- Indicating that the content is stale
- Deferring re-rendering for a part of the UI

## Reference

### useDeferredValue(value, initialValue?)
CalluseDeferredValueat the top level of your component to get a deferred version of that value.

```jsx
import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}
```

See more examples below.


#### Parameters
- value: The value you want to defer. It can have any type.
- optionalinitialValue: A value to use during the initial render of a component. If this option is omitted,useDeferredValuewill not defer during the initial render, because there’s no previous version ofvaluethat it can render instead.

#### Returns
- currentValue: During the initial render, the returned deferred value will be theinitialValue, or the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value).

#### Caveats
- When an update is inside a Transition,useDeferredValuealways returns the newvalueand does not spawn a deferred render, since the update is already deferred.
When an update is inside a Transition,useDeferredValuealways returns the newvalueand does not spawn a deferred render, since the update is already deferred.

- The values you pass touseDeferredValueshould either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it touseDeferredValue, it will be different on every render, causing unnecessary background re-renders.
The values you pass touseDeferredValueshould either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it touseDeferredValue, it will be different on every render, causing unnecessary background re-renders.

- WhenuseDeferredValuereceives a different value (compared withObject.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to thevalue, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.
WhenuseDeferredValuereceives a different value (compared withObject.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to thevalue, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.

- useDeferredValueis integrated with<Suspense>.If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.
useDeferredValueis integrated with<Suspense>.If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.

- useDeferredValuedoes not by itself prevent extra network requests.
useDeferredValuedoes not by itself prevent extra network requests.

- There is no fixed delay caused byuseDeferredValueitself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.
There is no fixed delay caused byuseDeferredValueitself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.

- The background re-render caused byuseDeferredValuedoes not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.
The background re-render caused byuseDeferredValuedoes not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.


## Usage

### Showing stale content while fresh content is loading
CalluseDeferredValueat the top level of your component to defer updating some part of your UI.

```jsx
import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}
```

During the initial render, thedeferred valuewill be the same as thevalueyou provided.

During updates, thedeferred valuewill “lag behind” the latestvalue. In particular, React will first re-renderwithoutupdating the deferred value, and then try to re-render with the newly received value in the background.

Let’s walk through an example to see when this is useful.


### Note
This example assumes you use a Suspense-enabled data source:

- Data fetching with Suspense-enabled frameworks likeRelayandNext.js
- Lazy-loading component code withlazy
- Reading the value of a Promise withuse
Learn more about Suspense and its limitations.

In this example, theSearchResultscomponentsuspendswhile fetching the search results. Try typing"a", waiting for the results, and then editing it to"ab". The results for"a"get replaced by the loading fallback.

```jsx
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}


```

A common alternative UI pattern is todeferupdating the list of results and to keep showing the previous results until the new results are ready. CalluseDeferredValueto pass a deferred version of the query down:

```jsx
export default function App() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  return (    <>      <label>        Search albums:        <input value={query} onChange={e => setQuery(e.target.value)} />      </label>      <Suspense fallback={<h2>Loading...</h2>}>        <SearchResults query={deferredQuery} />      </Suspense>    </>  );}
```

Thequerywill update immediately, so the input will display the new value. However, thedeferredQuerywill keep its previous value until the data has loaded, soSearchResultswill show the stale results for a bit.

Enter"a"in the example below, wait for the results to load, and then edit the input to"ab". Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:

```jsx
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={deferredQuery} />
      </Suspense>
    </>
  );
}


```


#### How does deferring a value work under the hood?
You can think of it as happening in two steps:

1. First, React re-renders with the newquery("ab") but with the olddeferredQuery(still"a").ThedeferredQueryvalue, which you pass to the result list, isdeferred:it “lags behind” thequeryvalue.
First, React re-renders with the newquery("ab") but with the olddeferredQuery(still"a").ThedeferredQueryvalue, which you pass to the result list, isdeferred:it “lags behind” thequeryvalue.

1. In the background, React tries to re-render withbothqueryanddeferredQueryupdated to"ab".If this re-render completes, React will show it on the screen. However, if it suspends (the results for"ab"have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.
In the background, React tries to re-render withbothqueryanddeferredQueryupdated to"ab".If this re-render completes, React will show it on the screen. However, if it suspends (the results for"ab"have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.

The deferred “background” rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.

Note that there is still a network request per each keystroke. What’s being deferred here is displaying results (until they’re ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn’t fetch again.


### Indicating that the content is stale
In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:

```jsx
<div style={{  opacity: query !== deferredQuery ? 0.5 : 1,}}>  <SearchResults query={deferredQuery} /></div>
```

With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:

```jsx
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{
          opacity: isStale ? 0.5 : 1,
          transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'
        }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}


```


### Deferring re-rendering for a part of the UI
You can also applyuseDeferredValueas a performance optimization. It is useful when a part of your UI is slow to re-render, there’s no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.

Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:

```jsx
function App() {  const [text, setText] = useState('');  return (    <>      <input value={text} onChange={e => setText(e.target.value)} />      <SlowList text={text} />    </>  );}
```

First, optimizeSlowListto skip re-rendering when its props are the same. To do this,wrap it inmemo:

```jsx
const SlowList = memo(function SlowList({ text }) {  // ...});
```

However, this only helps if theSlowListprops arethe sameas during the previous render. The problem you’re facing now is that it’s slow when they’redifferent,and when you actually need to show different visual output.

Concretely, the main performance problem is that whenever you type into the input, theSlowListreceives new props, and re-rendering its entire tree makes the typing feel janky. In this case,useDeferredValuelets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):

```jsx
function App() {  const [text, setText] = useState('');  const deferredText = useDeferredValue(text);  return (    <>      <input value={text} onChange={e => setText(e.target.value)} />      <SlowList text={deferredText} />    </>  );}
```

This does not make re-rendering of theSlowListfaster. However, it tells React that re-rendering the list can be deprioritized so that it doesn’t block the keystrokes. The list will “lag behind” the input and then “catch up”. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.


#### The difference between useDeferredValue and unoptimized re-rendering

#### Example1of2:Deferred re-rendering of the list
In this example, each item in theSlowListcomponent isartificially slowed downso that you can see howuseDeferredValuelets you keep the input responsive. Type into the input and notice that typing feels snappy while the list “lags behind” it.

```jsx
import { useState, useDeferredValue } from 'react';
import SlowList from './SlowList.js';

export default function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <SlowList text={deferredText} />
    </>
  );
}


```


### Pitfall
This optimization requiresSlowListto be wrapped inmemo.This is because whenever thetextchanges, React needs to be able to re-render the parent component quickly. During that re-render,deferredTextstill has its previous value, soSlowListis able to skip re-rendering (its props have not changed). Withoutmemo,it would have to re-render anyway, defeating the point of the optimization.


#### How is deferring a value different from debouncing and throttling?
There are two common optimization techniques you might have used before in this scenario:

- Debouncingmeans you’d wait for the user to stop typing (e.g. for a second) before updating the list.
- Throttlingmeans you’d update the list every once in a while (e.g. at most once a second).
While these techniques are helpful in some cases,useDeferredValueis better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user’s device.

Unlike debouncing or throttling, it doesn’t require choosing any fixed delay. If the user’s device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn’t be noticeable. If the user’s device is slow, the list would “lag behind” the input proportionally to how slow the device is.

Also, unlike with debouncing or throttling, deferred re-renders done byuseDeferredValueare interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because they’reblocking:they merely postpone the moment when rendering blocks the keystroke.

If the work you’re optimizing doesn’t happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.


--------------------------------------------------------------------------------


# useEffect
Source: https://react.dev/reference/react/useEffect

useEffectis a React Hook that lets yousynchronize a component with an external system.

```jsx
useEffect(setup, dependencies?)
```

- ReferenceuseEffect(setup, dependencies?)
- useEffect(setup, dependencies?)
- UsageConnecting to an external systemWrapping Effects in custom HooksControlling a non-React widgetFetching data with EffectsSpecifying reactive dependenciesUpdating state based on previous state from an EffectRemoving unnecessary object dependenciesRemoving unnecessary function dependenciesReading the latest props and state from an EffectDisplaying different content on the server and the client
- Connecting to an external system
- Wrapping Effects in custom Hooks
- Controlling a non-React widget
- Fetching data with Effects
- Specifying reactive dependencies
- Updating state based on previous state from an Effect
- Removing unnecessary object dependencies
- Removing unnecessary function dependencies
- Reading the latest props and state from an Effect
- Displaying different content on the server and the client
- TroubleshootingMy Effect runs twice when the component mountsMy Effect runs after every re-renderMy Effect keeps re-running in an infinite cycleMy cleanup logic runs even though my component didn’t unmountMy Effect does something visual, and I see a flicker before it runs
- My Effect runs twice when the component mounts
- My Effect runs after every re-render
- My Effect keeps re-running in an infinite cycle
- My cleanup logic runs even though my component didn’t unmount
- My Effect does something visual, and I see a flicker before it runs

## Reference

### useEffect(setup, dependencies?)
CalluseEffectat the top level of your component to declare an Effect:

```jsx
import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}
```

See more examples below.


#### Parameters
- setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When yourcomponent commits, React will run your setup function. After every commit with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.
setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When yourcomponent commits, React will run your setup function. After every commit with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.

- optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every commit of the component.See the difference between passing an array of dependencies, an empty array, and no dependencies at all.
optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every commit of the component.See the difference between passing an array of dependencies, an empty array, and no dependencies at all.


#### Returns
useEffectreturnsundefined.


#### Caveats
- useEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
useEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.

- If you’renot trying to synchronize with some external system,you probably don’t need an Effect.
If you’renot trying to synchronize with some external system,you probably don’t need an Effect.

- When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.
When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.

- If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.
If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.

- If your Effect wasn’t caused by an interaction (like a click), React will generally let the browserpaint the updated screen first before running your Effect.If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replaceuseEffectwithuseLayoutEffect.
If your Effect wasn’t caused by an interaction (like a click), React will generally let the browserpaint the updated screen first before running your Effect.If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replaceuseEffectwithuseLayoutEffect.

- If your Effect is caused by an interaction (like a click),React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as analert(), you can usesetTimeout. Seereactwg/react-18/128for more information.
If your Effect is caused by an interaction (like a click),React may run your Effect before the browser paints the updated screen. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as analert(), you can usesetTimeout. Seereactwg/react-18/128for more information.

- Even if your Effect was caused by an interaction (like a click),React may allow the browser to repaint the screen before processing the state updates inside your Effect.Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replaceuseEffectwithuseLayoutEffect.
Even if your Effect was caused by an interaction (like a click),React may allow the browser to repaint the screen before processing the state updates inside your Effect.Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replaceuseEffectwithuseLayoutEffect.

- Effectsonly run on the client.They don’t run during server rendering.
Effectsonly run on the client.They don’t run during server rendering.


## Usage

### Connecting to an external system
Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are calledexternal.

Toconnect your component to some external system,calluseEffectat the top level of your component:

```jsx
import { useState, useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  	const connection = createConnection(serverUrl, roomId);    connection.connect();  	return () => {      connection.disconnect();  	};  }, [serverUrl, roomId]);  // ...}
```

You need to pass two arguments touseEffect:

1. Asetup functionwithsetup codethat connects to that system.It should return acleanup functionwithcleanup codethat disconnects from that system.
- It should return acleanup functionwithcleanup codethat disconnects from that system.
1. Alist of dependenciesincluding every value from your component used inside of those functions.
React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times:

1. Yoursetup coderuns when your component is added to the page(mounts).
1. After every commit of your component where thedependencieshave changed:First, yourcleanup coderuns with the old props and state.Then, yoursetup coderuns with the new props and state.
- First, yourcleanup coderuns with the old props and state.
- Then, yoursetup coderuns with the new props and state.
1. Yourcleanup coderuns one final time after your component is removed from the page(unmounts).
Let’s illustrate this sequence for the example above.

When theChatRoomcomponent above gets added to the page, it will connect to the chat room with the initialserverUrlandroomId. If eitherserverUrlorroomIdchange as a result of a commit (say, if the user picks a different chat room in a dropdown), your Effect willdisconnect from the previous room, and connect to the next one.When theChatRoomcomponent is removed from the page, your Effect will disconnect one last time.

Tohelp you find bugs,in development React runssetupandcleanupone extra time before thesetup.This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and asetup→cleanup→setupsequence (as in development).See common solutions.

Try towrite every Effect as an independent processandthink about a single setup/cleanup cycle at a time.It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed.


### Note
An Effect lets youkeep your component synchronizedwith some external system (like a chat service). Here,external systemmeans any piece of code that’s not controlled by React, such as:

- A timer managed withsetInterval()andclearInterval().
- An event subscription usingwindow.addEventListener()andwindow.removeEventListener().
- A third-party animation library with an API likeanimation.start()andanimation.reset().
If you’re not connecting to any external system,you probably don’t need an Effect.


#### Examples of connecting to an external system

#### Example1of5:Connecting to a chat server
In this example, theChatRoomcomponent uses an Effect to stay connected to an external system defined inchat.js. Press “Open chat” to make theChatRoomcomponent appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, asexplained here.Try changing theroomIdandserverUrlusing the dropdown and the input, and see how the Effect re-connects to the chat. Press “Close chat” to see the Effect disconnect one last time.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}


```


### Wrapping Effects in custom Hooks
Effects are an“escape hatch”:you use them when you need to “step outside React” and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it’s usually a sign that you need to extract somecustom Hooksfor common behaviors your components rely on.

For example, thisuseChatRoomcustom Hook “hides” the logic of your Effect behind a more declarative API:

```jsx
function useChatRoom({ serverUrl, roomId }) {  useEffect(() => {    const options = {      serverUrl: serverUrl,      roomId: roomId    };    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId, serverUrl]);}
```

Then you can use it from any component like this:

```jsx
function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useChatRoom({    roomId: roomId,    serverUrl: serverUrl  });  // ...
```

There are also many excellent custom Hooks for every purpose available in the React ecosystem.

Learn more about wrapping Effects in custom Hooks.


#### Examples of wrapping Effects in custom Hooks

#### Example1of3:CustomuseChatRoomHook
This example is identical to one of theearlier examples,but the logic is extracted to a custom Hook.

```jsx
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl
  });

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}


```


### Controlling a non-React widget
Sometimes, you want to keep an external system synchronized to some prop or state of your component.

For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of aMapWidgetclass defined inmap-widget.js. When you change thezoomLevelprop of theMapcomponent, the Effect calls thesetZoom()on the class instance to keep it synchronized:

```jsx
import { useRef, useEffect } from 'react';
import { MapWidget } from './map-widget.js';

export default function Map({ zoomLevel }) {
  const containerRef = useRef(null);
  const mapRef = useRef(null);

  useEffect(() => {
    if (mapRef.current === null) {
      mapRef.current = new MapWidget(containerRef.current);
    }

    const map = mapRef.current;
    map.setZoom(zoomLevel);
  }, [zoomLevel]);

  return (
    <div
      style={{ width: 200, height: 200 }}
      ref={containerRef}
    />
  );
}


```

In this example, a cleanup function is not needed because theMapWidgetclass manages only the DOM node that was passed to it. After theMapReact component is removed from the tree, both the DOM node and theMapWidgetclass instance will be automatically garbage-collected by the browser JavaScript engine.


### Fetching data with Effects
You can use an Effect to fetch data for your component. Note thatif you use a framework,using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually.

If you want to fetch data from an Effect manually, your code might look like this:

```jsx
import { useState, useEffect } from 'react';import { fetchBio } from './api.js';export default function Page() {  const [person, setPerson] = useState('Alice');  const [bio, setBio] = useState(null);  useEffect(() => {    let ignore = false;    setBio(null);    fetchBio(person).then(result => {      if (!ignore) {        setBio(result);      }    });    return () => {      ignore = true;    };  }, [person]);  // ...
```

Note theignorevariable which is initialized tofalse, and is set totrueduring cleanup. This ensuresyour code doesn’t suffer from “race conditions”:network responses may arrive in a different order than you sent them.

```jsx
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    let ignore = false;
    setBio(null);
    fetchBio(person).then(result => {
      if (!ignore) {
        setBio(result);
      }
    });
    return () => {
      ignore = true;
    }
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}


```

You can also rewrite using theasync/awaitsyntax, but you still need to provide a cleanup function:

```jsx
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    async function startFetching() {
      setBio(null);
      const result = await fetchBio(person);
      if (!ignore) {
        setBio(result);
      }
    }

    let ignore = false;
    startFetching();
    return () => {
      ignore = true;
    }
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}


```

Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later.It’s easier to use a custom Hook—either your own or maintained by the community.


#### What are good alternatives to data fetching in Effects?
Writingfetchcalls inside Effects is apopular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:

- Effects don’t run on the server.This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
- Fetching directly in Effects makes it easy to create “network waterfalls”.You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
- Fetching directly in Effects usually means you don’t preload or cache data.For example, if the component unmounts and then mounts again, it would have to fetch the data again.
- It’s not very ergonomic.There’s quite a bit of boilerplate code involved when writingfetchcalls in a way that doesn’t suffer from bugs likerace conditions.
This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:

- If you use aframework, use its built-in data fetching mechanism.Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.
- Otherwise, consider using or building a client-side cache.Popular open source solutions includeTanStack Query,useSWR, andReact Router 6.4+.You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).
You can continue fetching data directly in Effects if neither of these approaches suit you.


### Specifying reactive dependencies
Notice that you can’t “choose” the dependencies of your Effect.Everyreactive valueused by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code:

```jsx
function ChatRoom({ roomId }) { // This is a reactive value  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too  useEffect(() => {    const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values    connection.connect();    return () => connection.disconnect();  }, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect  // ...}
```

If eitherserverUrlorroomIdchange, your Effect will reconnect to the chat using the new values.

Reactive valuesinclude props and all variables and functions declared directly inside of your component.SinceroomIdandserverUrlare reactive values, you can’t remove them from the dependencies. If you try to omit them andyour linter is correctly configured for React,the linter will flag this as a mistake you need to fix:

```jsx
function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');    useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'  // ...}
```

To remove a dependency, you need to“prove” to the linter that itdoesn’t needto be a dependency.For example, you can moveserverUrlout of your component to prove that it’s not reactive and won’t change on re-renders:

```jsx
const serverUrl = 'https://localhost:1234'; // Not a reactive value anymorefunction ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ All dependencies declared  // ...}
```

Now thatserverUrlis not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency.If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ([]):

```jsx
const serverUrl = 'https://localhost:1234'; // Not a reactive value anymoreconst roomId = 'music'; // Not a reactive value anymorefunction ChatRoom() {  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => connection.disconnect();  }, []); // ✅ All dependencies declared  // ...}
```

An Effect with empty dependenciesdoesn’t re-run when any of your component’s props or state change.


### Pitfall
If you have an existing codebase, you might have some Effects that suppress the linter like this:

```jsx
useEffect(() => {  // ...  // 🔴 Avoid suppressing the linter like this:  // eslint-ignore-next-line react-hooks/exhaustive-deps}, []);
```

When dependencies don’t match the code, there is a high risk of introducing bugs.By suppressing the linter, you “lie” to React about the values your Effect depends on.Instead, prove they’re unnecessary.


#### Examples of passing reactive dependencies

#### Example1of3:Passing a dependency array
If you specify the dependencies, your Effect runsafter the initial commitandafter commits with changed dependencies.

```jsx
useEffect(() => {  // ...}, [a, b]); // Runs again if a or b are different
```

In the below example,serverUrlandroomIdarereactive values,so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, sincemessageisn’t used in the Effect (and so it isn’t a dependency), editing the message doesn’t re-connect to the chat.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
      <label>
        Your message:{' '}
        <input value={message} onChange={e => setMessage(e.target.value)} />
      </label>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
        <button onClick={() => setShow(!show)}>
          {show ? 'Close chat' : 'Open chat'}
        </button>
      </label>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId}/>}
    </>
  );
}


```


### Updating state based on previous state from an Effect
When you want to update state based on previous state from an Effect, you might run into a problem:

```jsx
function Counter() {  const [count, setCount] = useState(0);  useEffect(() => {    const intervalId = setInterval(() => {      setCount(count + 1); // You want to increment the counter every second...    }, 1000)    return () => clearInterval(intervalId);  }, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.  // ...}
```

Sincecountis a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time thecountchanges. This is not ideal.

To fix this,pass thec => c + 1state updatertosetCount:

```jsx
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(c => c + 1); // ✅ Pass a state updater
    }, 1000);
    return () => clearInterval(intervalId);
  }, []); // ✅ Now count is not a dependency

  return <h1>{count}</h1>;
}


```

Now that you’re passingc => c + 1instead ofcount + 1,your Effect no longer needs to depend oncount.As a result of this fix, it won’t need to cleanup and setup the interval again every time thecountchanges.


### Removing unnecessary object dependencies
If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every commit because theoptionsobject isdifferent for every render:

```jsx
const serverUrl = 'https://localhost:1234';function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = { // 🚩 This object is created from scratch on every re-render    serverUrl: serverUrl,    roomId: roomId  };  useEffect(() => {    const connection = createConnection(options); // It's used inside the Effect    connection.connect();    return () => connection.disconnect();  }, [options]); // 🚩 As a result, these dependencies are always different on a commit  // ...
```

Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

Now that you create theoptionsobject inside the Effect, the Effect itself only depends on theroomIdstring.

With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string likeroomIddoesn’t change unless you set it to another value.Read more about removing dependencies.


### Removing unnecessary function dependencies
If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every commit because thecreateOptionsfunction isdifferent for every render:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  function createOptions() { // 🚩 This function is created from scratch on every re-render    return {      serverUrl: serverUrl,      roomId: roomId    };  }  useEffect(() => {    const options = createOptions(); // It's used inside the Effect    const connection = createConnection();    connection.connect();    return () => connection.disconnect();  }, [createOptions]); // 🚩 As a result, these dependencies are always different on a commit  // ...
```

By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every commit.

Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}


```

Now that you define thecreateOptionsfunction inside the Effect, the Effect itself only depends on theroomIdstring. With this fix, typing into the input doesn’t reconnect the chat. Unlike a function which gets re-created, a string likeroomIddoesn’t change unless you set it to another value.Read more about removing dependencies.


### Reading the latest props and state from an Effect
By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect “reacts” to every change of that value. For most dependencies, that’s the behavior you want.

However, sometimes you’ll want to read thelatestprops and state from an Effect without “reacting” to them.For example, imagine you want to log the number of the items in the shopping cart for every page visit:

```jsx
function Page({ url, shoppingCart }) {  useEffect(() => {    logVisit(url, shoppingCart.length);  }, [url, shoppingCart]); // ✅ All dependencies declared  // ...}
```

What if you want to log a new page visit after everyurlchange, butnotif only theshoppingCartchanges?You can’t excludeshoppingCartfrom dependencies without breaking thereactivity rules.However, you can express that youdon’t wanta piece of code to “react” to changes even though it is called from inside an Effect.Declare anEffect Eventwith theuseEffectEventHook, and move the code readingshoppingCartinside of it:

```jsx
function Page({ url, shoppingCart }) {  const onVisit = useEffectEvent(visitedUrl => {    logVisit(visitedUrl, shoppingCart.length)  });  useEffect(() => {    onVisit(url);  }, [url]); // ✅ All dependencies declared  // ...}
```

Effect Events are not reactive and must always be omitted from dependencies of your Effect.This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By readingshoppingCartinside ofonVisit, you ensure thatshoppingCartwon’t re-run your Effect.

Read more about how Effect Events let you separate reactive and non-reactive code.


### Displaying different content on the server and the client
If your app uses server rendering (eitherdirectlyor via aframework), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, forhydrationto work, your initial render output must be identical on the client and the server.

In rare cases, you might need to display different content on the client. For example, if your app reads some data fromlocalStorage, it can’t possibly do that on the server. Here is how you could implement this:

```jsx
function MyComponent() {  const [didMount, setDidMount] = useState(false);  useEffect(() => {    setDidMount(true);  }, []);  if (didMount) {    // ... return client-only JSX ...  }  else {    // ... return initial JSX ...  }}
```

While the app is loading, the user will see the initial render output. Then, when it’s loaded and hydrated, your Effect will run and setdidMounttotrue, triggering a re-render. This will switch to the client-only render output. Effects don’t run on the server, so this is whydidMountwasfalseduring the initial server render.

Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time—potentially, many seconds—so you don’t want to make jarring changes to your component’s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.


## Troubleshooting

### My Effect runs twice when the component mounts
When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.

This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development).

Read more abouthow this helps find bugsandhow to fix your logic.


### My Effect runs after every re-render
First, check that you haven’t forgotten to specify the dependency array:

```jsx
useEffect(() => {  // ...}); // 🚩 No dependency array: re-runs after every commit!
```

If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render.

You can debug this problem by manually logging your dependencies to the console:

```jsx
  useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);
```

You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:

```jsx
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
```

When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:

- Updating state based on previous state from an Effect
- Removing unnecessary object dependencies
- Removing unnecessary function dependencies
- Reading the latest props and state from an Effect
As a last resort (if these methods didn’t help), wrap its creation withuseMemooruseCallback(for functions).


### My Effect keeps re-running in an infinite cycle
If your Effect runs in an infinite cycle, these two things must be true:

- Your Effect is updating some state.
- That state leads to a re-render, which causes the Effect’s dependencies to change.
Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it?

If there is no external system, consider whetherremoving the Effect altogetherwould simplify your logic.

If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, aref(which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed.

Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing.Read how to debug dependency changes.


### My cleanup logic runs even though my component didn’t unmount
The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, Reactruns setup+cleanup one extra time immediately after component mounts.

If you have cleanup code without corresponding setup code, it’s usually a code smell:

```jsx
useEffect(() => {  // 🔴 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);
```

Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:

```jsx
  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);
```

Learn how the Effect lifecycle is different from the component’s lifecycle.


### My Effect does something visual, and I see a flicker before it runs
If your Effect must block the browser frompainting the screen,replaceuseEffectwithuseLayoutEffect. Note thatthis shouldn’t be needed for the vast majority of Effects.You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.


--------------------------------------------------------------------------------


# useEffectEvent
Source: https://react.dev/reference/react/useEffectEvent

useEffectEventis a React Hook that lets you separate events from Effects.

```jsx
const onEvent = useEffectEvent(callback)
```

- ReferenceuseEffectEvent(callback)
- useEffectEvent(callback)
- UsageUsing an event in an EffectUsing a timer with latest valuesUsing an event listener with latest valuesAvoid reconnecting to external systemsUsing Effect Events in custom Hooks
- Using an event in an Effect
- Using a timer with latest values
- Using an event listener with latest values
- Avoid reconnecting to external systems
- Using Effect Events in custom Hooks
- TroubleshootingI’m getting an error: “A function wrapped in useEffectEvent can’t be called during rendering”I’m getting a lint error: “Functions returned from useEffectEvent must not be included in the dependency array”I’m getting a lint error: ”… is a function created with useEffectEvent, and can only be called from Effects”
- I’m getting an error: “A function wrapped in useEffectEvent can’t be called during rendering”
- I’m getting a lint error: “Functions returned from useEffectEvent must not be included in the dependency array”
- I’m getting a lint error: ”… is a function created with useEffectEvent, and can only be called from Effects”

## Reference

### useEffectEvent(callback)
CalluseEffectEventat the top level of your component to create an Effect Event.

```jsx
import { useEffectEvent, useEffect } from 'react';function ChatRoom({ roomId, theme }) {  const onConnected = useEffectEvent(() => {    showNotification('Connected!', theme);  });}
```

Effect Events are a part of your Effect logic, but they behave more like an event handler. They always “see” the latest values from render (like props and state) without re-synchronizing your Effect, so they’re excluded from Effect dependencies. SeeSeparating Events from Effectsto learn more.

See more examples below.


#### Parameters
- callback: A function containing the logic for your Effect Event. The function can accept any number of arguments and return any value. When you call the returned Effect Event function, thecallbackalways accesses the latest committed values from render at the time of the call.

#### Returns
useEffectEventreturns an Effect Event function with the same type signature as yourcallback.

You can call this function insideuseEffect,useLayoutEffect,useInsertionEffect, or from within other Effect Events in the same component.


#### Caveats
- useEffectEventis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the Effect Event into it.
- Effect Events can only be called from inside Effects or other Effect Events. Do not call them during rendering or pass them to other components or Hooks. Theeslint-plugin-react-hookslinter enforces this restriction.
- Do not useuseEffectEventto avoid specifying dependencies in your Effect’s dependency array. This hides bugs and makes your code harder to understand. Only use it for logic that is genuinely an event fired from Effects.
- Effect Event functions do not have a stable identity. Their identity intentionally changes on every render.

#### Why are Effect Events not stable?
Unlikesetfunctions fromuseStateor refs, Effect Event functions do not have a stable identity. Their identity intentionally changes on every render:

```jsx
// 🔴 Wrong: including Effect Event in dependenciesuseEffect(() => {  onSomething();}, [onSomething]); // ESLint will warn about this
```

This is a deliberate design choice. Effect Events are meant to be called only from within Effects in the same component. Since you can only call them locally and cannot pass them to other components or include them in dependency arrays, a stable identity would serve no purpose, and would actually mask bugs.

The non-stable identity acts as a runtime assertion: if your code incorrectly depends on the function identity, you’ll see the Effect re-running on every render, making the bug obvious.

This design reinforces that Effect Events conceptually belong to a particular effect, and are not a general purpose API to opt-out of reactivity.


## Usage

### Using an event in an Effect
CalluseEffectEventat the top level of your component to create anEffect Event:

```jsx
const onConnected = useEffectEvent(() => {  if (!muted) {    showNotification('Connected!');  }});
```

useEffectEventaccepts anevent callbackand returns anEffect Event. The Effect Event is a function that can be called inside of Effects without re-connecting the Effect:

```jsx
useEffect(() => {  const connection = createConnection(roomId);  connection.on('connected', onConnected);  connection.connect();  return () => {    connection.disconnect();  }}, [roomId]);
```

SinceonConnectedis anEffect Event,mutedandonConnectare not in the Effect dependencies.


### Pitfall
It might be tempting to useuseEffectEventto avoid listing dependencies that you think are “unnecessary.” However, this hides bugs and makes your code harder to understand:

```jsx
// 🔴 Wrong: Using Effect Events to hide dependenciesconst logVisit = useEffectEvent(() => {  log(pageUrl);});useEffect(() => {  logVisit()}, []); // Missing pageUrl means you miss logs
```

If a value should cause your Effect to re-run, keep it as a dependency. Only use Effect Events for logic that genuinely should not re-trigger your Effect.

SeeSeparating Events from Effectsto learn more.


### Using a timer with latest values
When you usesetIntervalorsetTimeoutin an Effect, you often want to read the latest values from render without restarting the timer whenever those values change.

This counter incrementscountby the currentincrementvalue every second. TheonTickEffect Event reads the latestcountandincrementwithout causing the interval to restart:

```jsx
import { useState, useEffect, useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  const onTick = useEffectEvent(() => {
    setCount(count + increment);
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick();
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>–</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}


```

Try changing the increment value while the timer is running. The counter immediately uses the new increment value, but the timer keeps ticking smoothly without restarting.


### Using an event listener with latest values
When you set up an event listener in an Effect, you often need to read the latest values from render in the callback. WithoutuseEffectEvent, you would need to include the values in your dependencies, causing the listener to be removed and re-added on every change.

This example shows a dot that follows the cursor, but only when “Can move” is checked. TheonMoveEffect Event always reads the latestcanMovevalue without re-running the Effect:

```jsx
import { useState, useEffect, useEffectEvent } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  const onMove = useEffectEvent(e => {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener('pointermove', onMove);
    return () => window.removeEventListener('pointermove', onMove);
  }, []);

  return (
    <>
      <label>
        <input
          type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}


```

Toggle the checkbox and move your cursor. The dot responds immediately to the checkbox state, but the event listener is only set up once when the component mounts.


### Avoid reconnecting to external systems
A common use case foruseEffectEventis when you want to do something in response to an Effect, but that “something” depends on a value you don’t want to react to.

In this example, a chat component connects to a room and shows a notification when connected. The user can mute notifications with a checkbox. However, you don’t want to reconnect to the chat room every time the user changes the settings:

```jsx
import { useState, useEffect, useEffectEvent } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

function ChatRoom({ roomId, muted }) {
  const onConnected = useEffectEvent((roomId) => {
    console.log('✅ Connected to ' + roomId + ' (muted: ' + muted + ')');
    if (!muted) {
      showNotification('Connected to ' + roomId);
    }
  });

  useEffect(() => {
    const connection = createConnection(roomId);
    console.log('⏳ Connecting to ' + roomId + '...');
    connection.on('connected', () => {
      onConnected(roomId);
    });
    connection.connect();
    return () => {
      console.log('❌ Disconnected from ' + roomId);
      connection.disconnect();
    }
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [muted, setMuted] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={muted}
          onChange={e => setMuted(e.target.checked)}
        />
        Mute notifications
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        muted={muted}
      />
    </>
  );
}


```

Try switching rooms. The chat reconnects and shows a notification. Now mute the notifications. Sincemutedis read inside the Effect Event rather than the Effect, the chat stays connected.


### Using Effect Events in custom Hooks
You can useuseEffectEventinside your own custom Hooks. This lets you create reusable Hooks that encapsulate Effects while keeping some values non-reactive:

```jsx
import { useState, useEffect, useEffectEvent } from 'react';

function useInterval(callback, delay) {
  const onTick = useEffectEvent(callback);

  useEffect(() => {
    if (delay === null) {
      return;
    }
    const id = setInterval(() => {
      onTick();
    }, delay);
    return () => clearInterval(id);
  }, [delay]);
}

function Counter({ incrementBy }) {
  const [count, setCount] = useState(0);

  useInterval(() => {
    setCount(c => c + incrementBy);
  }, 1000);

  return (
    <div>
      <h2>Count: {count}</h2>
      <p>Incrementing by {incrementBy} every second</p>
    </div>
  );
}

export default function App() {
  const [incrementBy, setIncrementBy] = useState(1);

  return (
    <>
      <label>
        Increment by:{' '}
        <select
          value={incrementBy}
          onChange={(e) => setIncrementBy(Number(e.target.value))}
        >
          <option value={1}>1</option>
          <option value={5}>5</option>
          <option value={10}>10</option>
        </select>
      </label>
      <hr />
      <Counter incrementBy={incrementBy} />
    </>
  );
}


```

In this example,useIntervalis a custom Hook that sets up an interval. Thecallbackpassed to it is wrapped in an Effect Event, so the interval does not reset even if a newcallbackis passed in every render.


## Troubleshooting

### I’m getting an error: “A function wrapped in useEffectEvent can’t be called during rendering”
This error means you’re calling an Effect Event function during the render phase of your component. Effect Events can only be called from inside Effects or other Effect Events.

```jsx
function MyComponent({ data }) {  const onLog = useEffectEvent(() => {    console.log(data);  });  // 🔴 Wrong: calling during render  onLog();  // ✅ Correct: call from an Effect  useEffect(() => {    onLog();  }, []);  return <div>{data}</div>;}
```

If you need to run logic during render, don’t wrap it inuseEffectEvent. Call the logic directly or move it into an Effect.


### I’m getting a lint error: “Functions returned from useEffectEvent must not be included in the dependency array”
If you see a warning like “Functions returned fromuseEffectEventmust not be included in the dependency array”, remove the Effect Event from your dependencies:

```jsx
const onSomething = useEffectEvent(() => {  // ...});// 🔴 Wrong: Effect Event in dependenciesuseEffect(() => {  onSomething();}, [onSomething]);// ✅ Correct: no Effect Event in dependenciesuseEffect(() => {  onSomething();}, []);
```

Effect Events are designed to be called from Effects without being listed as dependencies. The linter enforces this because the function identity isintentionally not stable. Including it would cause your Effect to re-run on every render.


### I’m getting a lint error: ”… is a function created with useEffectEvent, and can only be called from Effects”
If you see a warning like ”… is a function created with React HookuseEffectEvent, and can only be called from Effects and Effect Events”, you’re calling the function from the wrong place:

```jsx
const onSomething = useEffectEvent(() => {  console.log(value);});// 🔴 Wrong: calling from event handlerfunction handleClick() {  onSomething();}// 🔴 Wrong: passing to child componentreturn <Child onSomething={onSomething} />;// ✅ Correct: calling from EffectuseEffect(() => {  onSomething();}, []);
```

Effect Events are specifically designed to be used in Effects local to the component they’re defined in. If you need a callback for event handlers or to pass to children, use a regular function oruseCallbackinstead.


--------------------------------------------------------------------------------


# useId
Source: https://react.dev/reference/react/useId

useIdis a React Hook for generating unique IDs that can be passed to accessibility attributes.

```jsx
const id = useId()
```

- ReferenceuseId()
- useId()
- UsageGenerating unique IDs for accessibility attributesGenerating IDs for several related elementsSpecifying a shared prefix for all generated IDsUsing the same ID prefix on the client and the server
- Generating unique IDs for accessibility attributes
- Generating IDs for several related elements
- Specifying a shared prefix for all generated IDs
- Using the same ID prefix on the client and the server

## Reference

### useId()
CalluseIdat the top level of your component to generate a unique ID:

```jsx
import { useId } from 'react';function PasswordField() {  const passwordHintId = useId();  // ...
```

See more examples below.


#### Parameters
useIddoes not take any parameters.


#### Returns
useIdreturns a unique ID string associated with this particularuseIdcall in this particular component.


#### Caveats
- useIdis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
useIdis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.

- useIdshould not be used to generate cache keysforuse(). The ID is stable when a component is mounted but may change during rendering. Cache keys should be generated from your data.
useIdshould not be used to generate cache keysforuse(). The ID is stable when a component is mounted but may change during rendering. Cache keys should be generated from your data.

- useIdshould not be used to generate keysin a list.Keys should be generated from your data.
useIdshould not be used to generate keysin a list.Keys should be generated from your data.

- useIdcurrently cannot be used inasync Server Components.
useIdcurrently cannot be used inasync Server Components.


## Usage

### Pitfall
Do not calluseIdto generate keys in a list.Keys should be generated from your data.


### Generating unique IDs for accessibility attributes
CalluseIdat the top level of your component to generate a unique ID:

```jsx
import { useId } from 'react';function PasswordField() {  const passwordHintId = useId();  // ...
```

You can then pass thegenerated IDto different attributes:

```jsx
<>  <input type="password" aria-describedby={passwordHintId} />  <p id={passwordHintId}></>
```

Let’s walk through an example to see when this is useful.

HTML accessibility attributeslikearia-describedbylet you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).

In regular HTML, you would write it like this:

```jsx
<label>  Password:  <input    type="password"    aria-describedby="password-hint"  /></label><p id="password-hint">  The password should contain at least 18 characters</p>
```

However, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page—but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID withuseId:

```jsx
import { useId } from 'react';function PasswordField() {  const passwordHintId = useId();  return (    <>      <label>        Password:        <input          type="password"          aria-describedby={passwordHintId}        />      </label>      <p id={passwordHintId}>        The password should contain at least 18 characters      </p>    </>  );}
```

Now, even ifPasswordFieldappears multiple times on the screen, the generated IDs won’t clash.

```jsx
import { useId } from 'react';

function PasswordField() {
  const passwordHintId = useId();
  return (
    <>
      <label>
        Password:
        <input
          type="password"
          aria-describedby={passwordHintId}
        />
      </label>
      <p id={passwordHintId}>
        The password should contain at least 18 characters
      </p>
    </>
  );
}

export default function App() {
  return (
    <>
      <h2>Choose password</h2>
      <PasswordField />
      <h2>Confirm password</h2>
      <PasswordField />
    </>
  );
}


```

Watch this videoto see the difference in the user experience with assistive technologies.


### Pitfall
Withserver rendering,useIdrequires an identical component tree on the server and the client. If the trees you render on the server and the client don’t match exactly, the generated IDs won’t match.


#### Why is useId better than an incrementing counter?
You might be wondering whyuseIdis better than incrementing a global variable likenextId++.

The primary benefit ofuseIdis that React ensures that it works withserver rendering.During server rendering, your components generate HTML output. Later, on the client,hydrationattaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.

This is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By callinguseId, you ensure that hydration will work, and the output will match between the server and the client.

Inside React,useIdis generated from the “parent path” of the calling component. This is why, if the client and the server tree are the same, the “parent path” will match up regardless of rendering order.


### Generating IDs for several related elements
If you need to give IDs to multiple related elements, you can calluseIdto generate a shared prefix for them:

```jsx
import { useId } from 'react';

export default function Form() {
  const id = useId();
  return (
    <form>
      <label htmlFor={id + '-firstName'}>First Name:</label>
      <input id={id + '-firstName'} type="text" />
      <hr />
      <label htmlFor={id + '-lastName'}>Last Name:</label>
      <input id={id + '-lastName'} type="text" />
    </form>
  );
}


```

This lets you avoid callinguseIdfor every single element that needs a unique ID.


### Specifying a shared prefix for all generated IDs
If you render multiple independent React applications on a single page, passidentifierPrefixas an option to yourcreateRootorhydrateRootcalls. This ensures that the IDs generated by the two different apps never clash because every identifier generated withuseIdwill start with the distinct prefix you’ve specified.

```jsx
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root1 = createRoot(document.getElementById('root1'), {
  identifierPrefix: 'my-first-app-'
});
root1.render(<App />);

const root2 = createRoot(document.getElementById('root2'), {
  identifierPrefix: 'my-second-app-'
});
root2.render(<App />);


```


### Using the same ID prefix on the client and the server
If yourender multiple independent React apps on the same page, and some of these apps are server-rendered, make sure that theidentifierPrefixyou pass to thehydrateRootcall on the client side is the same as theidentifierPrefixyou pass to theserver APIssuch asrenderToPipeableStream.

```jsx
// Serverimport { renderToPipeableStream } from 'react-dom/server';const { pipe } = renderToPipeableStream(  <App />,  { identifierPrefix: 'react-app1' });
```

```jsx
// Clientimport { hydrateRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = hydrateRoot(  domNode,  reactNode,  { identifierPrefix: 'react-app1' });
```

You do not need to passidentifierPrefixif you only have one React app on the page.


--------------------------------------------------------------------------------


# useImperativeHandle
Source: https://react.dev/reference/react/useImperativeHandle

useImperativeHandleis a React Hook that lets you customize the handle exposed as aref.

```jsx
useImperativeHandle(ref, createHandle, dependencies?)
```

- ReferenceuseImperativeHandle(ref, createHandle, dependencies?)
- useImperativeHandle(ref, createHandle, dependencies?)
- UsageExposing a custom ref handle to the parent componentExposing your own imperative methods
- Exposing a custom ref handle to the parent component
- Exposing your own imperative methods

## Reference

### useImperativeHandle(ref, createHandle, dependencies?)
CalluseImperativeHandleat the top level of your component to customize the ref handle it exposes:

```jsx
import { useImperativeHandle } from 'react';function MyInput({ ref }) {  useImperativeHandle(ref, () => {    return {      // ... your methods ...    };  }, []);  // ...
```

See more examples below.


#### Parameters
- ref: Therefyou received as a prop to theMyInputcomponent.
ref: Therefyou received as a prop to theMyInputcomponent.

- createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.
createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.

- optionaldependencies: The list of all reactive values referenced inside of thecreateHandlecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, yourcreateHandlefunction will re-execute, and the newly created handle will be assigned to the ref.
optionaldependencies: The list of all reactive values referenced inside of thecreateHandlecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, yourcreateHandlefunction will re-execute, and the newly created handle will be assigned to the ref.


### Note
Starting with React 19,refis available as a prop.In React 18 and earlier, it was necessary to get thereffromforwardRef.


#### Returns
useImperativeHandlereturnsundefined.


## Usage

### Exposing a custom ref handle to the parent component
To expose a DOM node to the parent element, pass in therefprop to the node.

```jsx
function MyInput({ ref }) {  return <input ref={ref} />;};
```

With the code above,a ref toMyInputwill receive the<input>DOM node.However, you can expose a custom value instead. To customize the exposed handle, calluseImperativeHandleat the top level of your component:

```jsx
import { useImperativeHandle } from 'react';function MyInput({ ref }) {  useImperativeHandle(ref, () => {    return {      // ... your methods ...    };  }, []);  return <input />;};
```

Note that in the code above, therefis no longer passed to the<input>.

For example, suppose you don’t want to expose the entire<input>DOM node, but you want to expose two of its methods:focusandscrollIntoView. To do this, keep the real browser DOM in a separate ref. Then useuseImperativeHandleto expose a handle with only the methods that you want the parent component to call:

```jsx
import { useRef, useImperativeHandle } from 'react';function MyInput({ ref }) {  const inputRef = useRef(null);  useImperativeHandle(ref, () => {    return {      focus() {        inputRef.current.focus();      },      scrollIntoView() {        inputRef.current.scrollIntoView();      },    };  }, []);  return <input ref={inputRef} />;};
```

Now, if the parent component gets a ref toMyInput, it will be able to call thefocusandscrollIntoViewmethods on it. However, it will not have full access to the underlying<input>DOM node.

```jsx
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
    // This won't work because the DOM node isn't exposed:
    // ref.current.style.opacity = 0.5;
  }

  return (
    <form>
      <MyInput placeholder="Enter your name" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}


```


### Exposing your own imperative methods
The methods you expose via an imperative handle don’t have to match the DOM methods exactly. For example, thisPostcomponent exposes ascrollAndFocusAddCommentmethod via an imperative handle. This lets the parentPagescroll the list of commentsandfocus the input field when you click the button:

```jsx
import { useRef } from 'react';
import Post from './Post.js';

export default function Page() {
  const postRef = useRef(null);

  function handleClick() {
    postRef.current.scrollAndFocusAddComment();
  }

  return (
    <>
      <button onClick={handleClick}>
        Write a comment
      </button>
      <Post ref={postRef} />
    </>
  );
}


```


### Pitfall
Do not overuse refs.You should only use refs forimperativebehaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.

If you can express something as a prop, you should not use a ref.For example, instead of exposing an imperative handle like{ open, close }from aModalcomponent, it is better to takeisOpenas a prop like<Modal isOpen={isOpen} />.Effectscan help you expose imperative behaviors via props.


--------------------------------------------------------------------------------


# useInsertionEffect
Source: https://react.dev/reference/react/useInsertionEffect


### Pitfall
useInsertionEffectis for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably wantuseEffectoruseLayoutEffectinstead.

useInsertionEffectallows inserting elements into the DOM before any layout Effects fire.

```jsx
useInsertionEffect(setup, dependencies?)
```

- ReferenceuseInsertionEffect(setup, dependencies?)
- useInsertionEffect(setup, dependencies?)
- UsageInjecting dynamic styles from CSS-in-JS libraries
- Injecting dynamic styles from CSS-in-JS libraries

## Reference

### useInsertionEffect(setup, dependencies?)
CalluseInsertionEffectto insert styles before any Effects fire that may need to read layout:

```jsx
import { useInsertionEffect } from 'react';// Inside your CSS-in-JS libraryfunction useCSS(rule) {  useInsertionEffect(() => {    // ... inject <style> tags here ...  });  return rule;}
```

See more examples below.


#### Parameters
- setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.
setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.

- optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component.
optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component.


#### Returns
useInsertionEffectreturnsundefined.


#### Caveats
- Effects only run on the client. They don’t run during server rendering.
- You can’t update state from insideuseInsertionEffect.
- By the timeuseInsertionEffectruns, refs are not attached yet.
- useInsertionEffectmay run either before or after the DOM has been updated. You shouldn’t rely on the DOM being updated at any particular time.
- Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect,useInsertionEffectwill fire both cleanup and setup one component at a time. This results in an “interleaving” of the cleanup and setup functions.

## Usage

### Injecting dynamic styles from CSS-in-JS libraries
Traditionally, you would style React components using plain CSS.

```jsx
// In your JS file:<button className="success" />// In your CSS file:.success { color: green; }
```

Some teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:

1. Static extraction to CSS files with a compiler
1. Inline styles, e.g.<div style={{ opacity: 1 }}>
1. Runtime injection of<style>tags
If you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles).We don’t recommend runtime<style>tag injection for two reasons:

1. Runtime injection forces the browser to recalculate the styles a lot more often.
1. Runtime injection can be very slow if it happens at the wrong time in the React lifecycle.
The first problem is not solvable, butuseInsertionEffecthelps you solve the second problem.

CalluseInsertionEffectto insert the styles before any layout Effects fire:

```jsx
// Inside your CSS-in-JS librarylet isInserted = new Set();function useCSS(rule) {  useInsertionEffect(() => {    // As explained earlier, we don't recommend runtime injection of <style> tags.    // But if you have to do it, then it's important to do in useInsertionEffect.    if (!isInserted.has(rule)) {      isInserted.add(rule);      document.head.appendChild(getStyleForRule(rule));    }  });  return rule;}function Button() {  const className = useCSS('...');  return <div className={className} />;}
```

Similarly touseEffect,useInsertionEffectdoes not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:

```jsx
let collectedRulesSet = new Set();function useCSS(rule) {  if (typeof window === 'undefined') {    collectedRulesSet.add(rule);  }  useInsertionEffect(() => {    // ...  });  return rule;}
```

Read more about upgrading CSS-in-JS libraries with runtime injection touseInsertionEffect.


#### How is this better than injecting styles during rendering or useLayoutEffect?
If you insert styles during rendering and React is processing anon-blocking update,the browser will recalculate the styles every single frame while rendering a component tree, which can beextremely slow.

useInsertionEffectis better than inserting styles duringuseLayoutEffectoruseEffectbecause it ensures that by the time other Effects run in your components, the<style>tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles.


--------------------------------------------------------------------------------


# useLayoutEffect
Source: https://react.dev/reference/react/useLayoutEffect


### Pitfall
useLayoutEffectcan hurt performance. PreferuseEffectwhen possible.

useLayoutEffectis a version ofuseEffectthat fires before the browser repaints the screen.

```jsx
useLayoutEffect(setup, dependencies?)
```

- ReferenceuseLayoutEffect(setup, dependencies?)
- useLayoutEffect(setup, dependencies?)
- UsageMeasuring layout before the browser repaints the screen
- Measuring layout before the browser repaints the screen
- TroubleshootingI’m getting an error: “useLayoutEffectdoes nothing on the server”
- I’m getting an error: “useLayoutEffectdoes nothing on the server”

## Reference

### useLayoutEffect(setup, dependencies?)
CalluseLayoutEffectto perform the layout measurements before the browser repaints the screen:

```jsx
import { useState, useRef, useLayoutEffect } from 'react';function Tooltip() {  const ref = useRef(null);  const [tooltipHeight, setTooltipHeight] = useState(0);  useLayoutEffect(() => {    const { height } = ref.current.getBoundingClientRect();    setTooltipHeight(height);  }, []);  // ...
```

See more examples below.


#### Parameters
- setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. Before yourcomponent commits, React will run your setup function. After every commit with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.
setup: The function with your Effect’s logic. Your setup function may also optionally return acleanupfunction. Before yourcomponent commits, React will run your setup function. After every commit with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.

- optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every commit of the component.
optionaldependencies: The list of all reactive values referenced inside of thesetupcode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison. If you omit this argument, your Effect will re-run after every commit of the component.


#### Returns
useLayoutEffectreturnsundefined.


#### Caveats
- useLayoutEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there.
useLayoutEffectis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there.

- When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.
When Strict Mode is on, React willrun one extra development-only setup+cleanup cyclebefore the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem,implement the cleanup function.

- If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.
If some of your dependencies are objects or functions defined inside the component, there is a risk that they willcause the Effect to re-run more often than needed.To fix this, remove unnecessaryobjectandfunctiondependencies. You can alsoextract state updatesandnon-reactive logicoutside of your Effect.

- Effectsonly run on the client.They don’t run during server rendering.
Effectsonly run on the client.They don’t run during server rendering.

- The code insideuseLayoutEffectand all state updates scheduled from itblock the browser from repainting the screen.When used excessively, this makes your app slow. When possible, preferuseEffect.
The code insideuseLayoutEffectand all state updates scheduled from itblock the browser from repainting the screen.When used excessively, this makes your app slow. When possible, preferuseEffect.

- If you trigger a state update insideuseLayoutEffect, React will execute all remaining Effects immediately includinguseEffect.
If you trigger a state update insideuseLayoutEffect, React will execute all remaining Effects immediately includinguseEffect.


## Usage

### Measuring layout before the browser repaints the screen
Most components don’t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates theirlayout(position and size) and repaints the screen.

Sometimes, that’s not enough. Imagine a tooltip that appears next to some element on hover. If there’s enough space, the tooltip should appear above the element, but if it doesn’t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).

To do this, you need to render in two passes:

1. Render the tooltip anywhere (even with a wrong position).
1. Measure its height and decide where to place the tooltip.
1. Render the tooltipagainin the correct place.
All of this needs to happen before the browser repaints the screen.You don’t want the user to see the tooltip moving. CalluseLayoutEffectto perform the layout measurements before the browser repaints the screen:

```jsx
function Tooltip() {  const ref = useRef(null);  const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet  useLayoutEffect(() => {    const { height } = ref.current.getBoundingClientRect();    setTooltipHeight(height); // Re-render now that you know the real height  }, []);  // ...use tooltipHeight in the rendering logic below...}
```

Here’s how this works step by step:

1. Tooltiprenders with the initialtooltipHeight = 0(so the tooltip may be wrongly positioned).
1. React places it in the DOM and runs the code inuseLayoutEffect.
1. YouruseLayoutEffectmeasures the heightof the tooltip content and triggers an immediate re-render.
1. Tooltiprenders again with the realtooltipHeight(so the tooltip is correctly positioned).
1. React updates it in the DOM, and the browser finally displays the tooltip.
Hover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:

```jsx
import { useRef, useLayoutEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import TooltipContainer from './TooltipContainer.js';

export default function Tooltip({ children, targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
    console.log('Measured tooltip height: ' + height);
  }, []);

  let tooltipX = 0;
  let tooltipY = 0;
  if (targetRect !== null) {
    tooltipX = targetRect.left;
    tooltipY = targetRect.top - tooltipHeight;
    if (tooltipY < 0) {
      // It doesn't fit above, so place below.
      tooltipY = targetRect.bottom;
    }
  }

  return createPortal(
    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>
      {children}
    </TooltipContainer>,
    document.body
  );
}


```

Notice that even though theTooltipcomponent has to render in two passes (first, withtooltipHeightinitialized to0and then with the real measured height), you only see the final result. This is why you needuseLayoutEffectinstead ofuseEffectfor this example. Let’s look at the difference in detail below.


#### useLayoutEffect vs useEffect

#### Example1of2:useLayoutEffectblocks the browser from repainting
React guarantees that the code insideuseLayoutEffectand any state updates scheduled inside it will be processedbefore the browser repaints the screen.This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words,useLayoutEffectblocks the browser from painting.

```jsx
import { useRef, useLayoutEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import TooltipContainer from './TooltipContainer.js';

export default function Tooltip({ children, targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
  }, []);

  let tooltipX = 0;
  let tooltipY = 0;
  if (targetRect !== null) {
    tooltipX = targetRect.left;
    tooltipY = targetRect.top - tooltipHeight;
    if (tooltipY < 0) {
      // It doesn't fit above, so place below.
      tooltipY = targetRect.bottom;
    }
  }

  return createPortal(
    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>
      {children}
    </TooltipContainer>,
    document.body
  );
}


```


### Note
Rendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.


## Troubleshooting

### I’m getting an error: “useLayoutEffectdoes nothing on the server”
The purpose ofuseLayoutEffectis to let your componentuse layout information for rendering:

1. Render the initial content.
1. Measure the layoutbefore the browser repaints the screen.
1. Render the final content using the layout information you’ve read.
When you or your framework usesserver rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.

The problem is that on the server, there is no layout information.

In theearlier example, theuseLayoutEffectcall in theTooltipcomponent lets it position itself correctly (either above or below content) depending on the content height. If you tried to renderTooltipas a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would “jump” on the client after the JavaScript loads and runs.

Usually, components that rely on layout information don’t need to render on the server anyway. For example, it probably doesn’t make sense to show aTooltipduring the initial render. It is triggered by a client interaction.

However, if you’re running into this problem, you have a few different options:

- ReplaceuseLayoutEffectwithuseEffect.This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).
ReplaceuseLayoutEffectwithuseEffect.This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).

- Alternatively,mark your component as client-only.This tells React to replace its content up to the closest<Suspense>boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.
Alternatively,mark your component as client-only.This tells React to replace its content up to the closest<Suspense>boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.

- Alternatively, you can render a component withuseLayoutEffectonly after hydration. Keep a booleanisMountedstate that’s initialized tofalse, and set it totrueinside auseEffectcall. Your rendering logic can then be likereturn isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will seeFallbackContentwhich should not calluseLayoutEffect. Then React will replace it withRealContentwhich runs on the client only and can includeuseLayoutEffectcalls.
Alternatively, you can render a component withuseLayoutEffectonly after hydration. Keep a booleanisMountedstate that’s initialized tofalse, and set it totrueinside auseEffectcall. Your rendering logic can then be likereturn isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will seeFallbackContentwhich should not calluseLayoutEffect. Then React will replace it withRealContentwhich runs on the client only and can includeuseLayoutEffectcalls.

- If you synchronize your component with an external data store and rely onuseLayoutEffectfor different reasons than measuring layout, consideruseSyncExternalStoreinstead whichsupports server rendering.
If you synchronize your component with an external data store and rely onuseLayoutEffectfor different reasons than measuring layout, consideruseSyncExternalStoreinstead whichsupports server rendering.


--------------------------------------------------------------------------------


# useMemo
Source: https://react.dev/reference/react/useMemo

useMemois a React Hook that lets you cache the result of a calculation between re-renders.

```jsx
const cachedValue = useMemo(calculateValue, dependencies)
```


### Note
React Compilerautomatically memoizes values and functions, reducing the need for manualuseMemocalls. You can use the compiler to handle memoization automatically.

- ReferenceuseMemo(calculateValue, dependencies)
- useMemo(calculateValue, dependencies)
- UsageSkipping expensive recalculationsSkipping re-rendering of componentsPreventing an Effect from firing too oftenMemoizing a dependency of another HookMemoizing a function
- Skipping expensive recalculations
- Skipping re-rendering of components
- Preventing an Effect from firing too often
- Memoizing a dependency of another Hook
- Memoizing a function
- TroubleshootingMy calculation runs twice on every re-renderMyuseMemocall is supposed to return an object, but returns undefinedEvery time my component renders, the calculation inuseMemore-runsI need to calluseMemofor each list item in a loop, but it’s not allowed
- My calculation runs twice on every re-render
- MyuseMemocall is supposed to return an object, but returns undefined
- Every time my component renders, the calculation inuseMemore-runs
- I need to calluseMemofor each list item in a loop, but it’s not allowed

## Reference

### useMemo(calculateValue, dependencies)
CalluseMemoat the top level of your component to cache a calculation between re-renders:

```jsx
import { useMemo } from 'react';function TodoList({ todos, tab }) {  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab]  );  // ...}
```

See more examples below.


#### Parameters
- calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if thedependencieshave not changed since the last render. Otherwise, it will callcalculateValue, return its result, and store it so it can be reused later.
calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if thedependencieshave not changed since the last render. Otherwise, it will callcalculateValue, return its result, and store it so it can be reused later.

- dependencies: The list of all reactive values referenced inside of thecalculateValuecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison.
dependencies: The list of all reactive values referenced inside of thecalculateValuecode. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter isconfigured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like[dep1, dep2, dep3]. React will compare each dependency with its previous value using theObject.iscomparison.


#### Returns
On the initial render,useMemoreturns the result of callingcalculateValuewith no arguments.

During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or callcalculateValueagain, and return the result thatcalculateValuehas returned.


#### Caveats
- useMemois a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
- In Strict Mode, React willcall your calculation function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.
- Reactwill not throw away the cached value unless there is a specific reason to do that.For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely onuseMemosolely as a performance optimization. Otherwise, astate variableor arefmay be more appropriate.

### Note
Caching return values like this is also known asmemoization,which is why this Hook is calleduseMemo.


## Usage

### Skipping expensive recalculations
To cache a calculation between re-renders, wrap it in auseMemocall at the top level of your component:

```jsx
import { useMemo } from 'react';function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}
```

You need to pass two things touseMemo:

1. Acalculation functionthat takes no arguments, like() =>, and returns what you wanted to calculate.
1. Alist of dependenciesincluding every value within your component that’s used inside your calculation.
On the initial render, thevalueyou’ll get fromuseMemowill be the result of calling yourcalculation.

On every subsequent render, React will compare thedependencieswith the dependencies you passed during the last render. If none of the dependencies have changed (compared withObject.is),useMemowill return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.

In other words,useMemocaches a calculation result between re-renders until its dependencies change.

Let’s walk through an example to see when this is useful.

By default, React will re-run the entire body of your component every time that it re-renders. For example, if thisTodoListupdates its state or receives new props from its parent, thefilterTodosfunction will re-run:

```jsx
function TodoList({ todos, tab, theme }) {  const visibleTodos = filterTodos(todos, tab);  // ...}
```

Usually, this isn’t a problem because most calculations are very fast. However, if you’re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn’t changed. If bothtodosandtabare the same as they were during the last render, wrapping the calculation inuseMemolike earlier lets you reusevisibleTodosyou’ve already calculated before.

This type of caching is calledmemoization.


### Note
You should only rely onuseMemoas a performance optimization.If your code doesn’t work without it, find the underlying problem and fix it first. Then you may adduseMemoto improve performance.


#### How to tell if a calculation is expensive?
In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:

```jsx
console.time('filter array');const visibleTodos = filterTodos(todos, tab);console.timeEnd('filter array');
```

Perform the interaction you’re measuring (for example, typing into the input). You will then see logs likefilter array: 0.15msin your console. If the overall logged time adds up to a significant amount (say,1msor more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation inuseMemoto verify whether the total logged time has decreased for that interaction or not:

```jsx
console.time('filter array');const visibleTodos = useMemo(() => {  return filterTodos(todos, tab); // Skipped if todos and tab haven't changed}, [todos, tab]);console.timeEnd('filter array');
```

useMemowon’t make thefirstrender faster. It only helps you skip unnecessary work on updates.

Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers aCPU Throttlingoption for this.

Also note that measuring performance in development will not give you the most accurate results. (For example, whenStrict Modeis on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.


#### Should you add useMemo everywhere?
If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.

Optimizing withuseMemois only valuable in a few cases:

- The calculation you’re putting inuseMemois noticeably slow, and its dependencies rarely change.
- You pass it as a prop to a component wrapped inmemo.You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only when dependencies aren’t the same.
- The value you’re passing is later used as a dependency of some Hook. For example, maybe anotheruseMemocalculation value depends on it. Or maybe you are depending on this value fromuseEffect.
There is no benefit to wrapping a calculation inuseMemoin other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.

In practice, you can make a lot of memoization unnecessary by following a few principles:

1. When a component visually wraps other components, let itaccept JSX as children.This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.
1. Prefer local state and don’tlift state upany further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
1. Keep yourrendering logic pure.If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
1. Avoidunnecessary Effects that update state.Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
1. Try toremove unnecessary dependencies from your Effects.For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.
If a specific interaction still feels laggy,use the React Developer Tools profilerto see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researchingdoing granular memoization automaticallyto solve this once and for all.


#### The difference between useMemo and calculating a value directly

#### Example1of2:Skipping recalculation withuseMemo
In this example, thefilterTodosimplementation isartificially slowed downso that you can see what happens when some JavaScript function you’re calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.

Switching the tabs feels slow because it forces the slowed downfilterTodosto re-execute. That’s expected because thetabhas changed, and so the entire calculationneedsto re-run. (If you’re curious why it runs twice, it’s explainedhere.)

Toggle the theme.Thanks touseMemo, it’s fast despite the artificial slowdown!The slowfilterTodoscall was skipped because bothtodosandtab(which you pass as dependencies touseMemo) haven’t changed since the last render.

```jsx
import { useMemo } from 'react';
import { filterTodos } from './utils.js'

export default function TodoList({ todos, theme, tab }) {
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab]
  );
  return (
    <div className={theme}>
      <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>
      <ul>
        {visibleTodos.map(todo => (
          <li key={todo.id}>
            {todo.completed ?
              <s>{todo.text}</s> :
              todo.text
            }
          </li>
        ))}
      </ul>
    </div>
  );
}


```


### Skipping re-rendering of components
In some cases,useMemocan also help you optimize performance of re-rendering child components. To illustrate this, let’s say thisTodoListcomponent passes thevisibleTodosas a prop to the childListcomponent:

```jsx
export default function TodoList({ todos, tab, theme }) {  // ...  return (    <div className={theme}>      <List items={visibleTodos} />    </div>  );}
```

You’ve noticed that toggling thethemeprop freezes the app for a moment, but if you remove<List />from your JSX, it feels fast. This tells you that it’s worth trying to optimize theListcomponent.

By default, when a component re-renders, React re-renders all of its children recursively.This is why, whenTodoListre-renders with a differenttheme, theListcomponentalsore-renders. This is fine for components that don’t require much calculation to re-render. But if you’ve verified that a re-render is slow, you can tellListto skip re-rendering when its props are the same as on last render by wrapping it inmemo:

```jsx
import { memo } from 'react';const List = memo(function List({ items }) {  // ...});
```

With this change,Listwill skip re-rendering if all of its props are thesameas on the last render.This is where caching the calculation becomes important! Imagine that you calculatedvisibleTodoswithoutuseMemo:

```jsx
export default function TodoList({ todos, tab, theme }) {  // Every time the theme changes, this will be a different array...  const visibleTodos = filterTodos(todos, tab);  return (    <div className={theme}>      {/* ... so List's props will never be the same, and it will re-render every time */}      <List items={visibleTodos} />    </div>  );}
```

In the above example, thefilterTodosfunction always creates adifferentarray,similar to how the{}object literal always creates a new object. Normally, this wouldn’t be a problem, but it means thatListprops will never be the same, and yourmemooptimization won’t work. This is whereuseMemocomes in handy:

```jsx
export default function TodoList({ todos, tab, theme }) {  // Tell React to cache your calculation between re-renders...  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab] // ...so as long as these dependencies don't change...  );  return (    <div className={theme}>      {/* ...List will receive the same props and can skip re-rendering */}      <List items={visibleTodos} />    </div>  );}
```

By wrapping thevisibleTodoscalculation inuseMemo, you ensure that it has thesamevalue between the re-renders(until dependencies change). You don’thave towrap a calculation inuseMemounless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped inmemo,and this lets it skip re-rendering. There are a few other reasons to adduseMemowhich are described further on this page.


#### Memoizing individual JSX nodes
Instead of wrappingListinmemo, you could wrap the<List />JSX node itself inuseMemo:

```jsx
export default function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);  return (    <div className={theme}>      {children}    </div>  );}
```

The behavior would be the same. If thevisibleTodoshaven’t changed,Listwon’t be re-rendered.

A JSX node like<List items={visibleTodos} />is an object like{ type: List, props: { items: visibleTodos } }. Creating this object is very cheap, but React doesn’t know whether its contents is the same as last time or not. This is why by default, React will re-render theListcomponent.

However, if React sees the same exact JSX as during the previous render, it won’t try to re-render your component. This is because JSX nodes areimmutable.A JSX node object could not have changed over time, so React knows it’s safe to skip a re-render. However, for this to work, the node has toactually be the same object, not merely look the same in code. This is whatuseMemodoes in this example.

Manually wrapping JSX nodes intouseMemois not convenient. For example, you can’t do this conditionally. This is usually why you would wrap components withmemoinstead of wrapping JSX nodes.


#### The difference between skipping re-renders and always re-rendering

#### Example1of2:Skipping re-rendering withuseMemoandmemo
In this example, theListcomponent isartificially slowed downso that you can see what happens when a React component you’re rendering is genuinely slow. Try switching the tabs and toggling the theme.

Switching the tabs feels slow because it forces the slowed downListto re-render. That’s expected because thetabhas changed, and so you need to reflect the user’s new choice on the screen.

Next, try toggling the theme.Thanks touseMemotogether withmemo, it’s fast despite the artificial slowdown!TheListskipped re-rendering because thevisibleTodosarray has not changed since the last render. ThevisibleTodosarray has not changed because bothtodosandtab(which you pass as dependencies touseMemo) haven’t changed since the last render.

```jsx
import { useMemo } from 'react';
import List from './List.js';
import { filterTodos } from './utils.js'

export default function TodoList({ todos, theme, tab }) {
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab]
  );
  return (
    <div className={theme}>
      <p><b>Note: <code>List</code> is artificially slowed down!</b></p>
      <List items={visibleTodos} />
    </div>
  );
}


```


### Preventing an Effect from firing too often
Sometimes, you might want to use a value inside anEffect:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = {    serverUrl: 'https://localhost:1234',    roomId: roomId  }  useEffect(() => {    const connection = createConnection(options);    connection.connect();    // ...
```

This creates a problem.Every reactive value must be declared as a dependency of your Effect.However, if you declareoptionsas a dependency, it will cause your Effect to constantly reconnect to the chat room:

```jsx
  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // 🔴 Problem: This dependency changes on every render  // ...
```

To solve this, you can wrap the object you need to call from an Effect inuseMemo:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  const options = useMemo(() => {    return {      serverUrl: 'https://localhost:1234',      roomId: roomId    };  }, [roomId]); // ✅ Only changes when roomId changes  useEffect(() => {    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [options]); // ✅ Only changes when options changes  // ...
```

This ensures that theoptionsobject is the same between re-renders ifuseMemoreturns the cached object.

However, sinceuseMemois performance optimization, not a semantic guarantee, React may throw away the cached value ifthere is a specific reason to do that. This will also cause the effect to re-fire,so it’s even better to remove the need for a function dependencyby moving your objectinsidethe Effect:

```jsx
function ChatRoom({ roomId }) {  const [message, setMessage] = useState('');  useEffect(() => {    const options = { // ✅ No need for useMemo or object dependencies!      serverUrl: 'https://localhost:1234',      roomId: roomId    }    const connection = createConnection(options);    connection.connect();    return () => connection.disconnect();  }, [roomId]); // ✅ Only changes when roomId changes  // ...
```

Now your code is simpler and doesn’t needuseMemo.Learn more about removing Effect dependencies.


### Memoizing a dependency of another Hook
Suppose you have a calculation that depends on an object created directly in the component body:

```jsx
function Dropdown({ allItems, text }) {  const searchOptions = { matchMode: 'whole-word', text };  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body  // ...
```

Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again.The lines of code creating thesearchOptionsobject will also run on every re-render.SincesearchOptionsis a dependency of youruseMemocall, and it’s different every time, React knows the dependencies are different, and recalculatesearchItemsevery time.

To fix this, you could memoize thesearchOptionsobjectitselfbefore passing it as a dependency:

```jsx
function Dropdown({ allItems, text }) {  const searchOptions = useMemo(() => {    return { matchMode: 'whole-word', text };  }, [text]); // ✅ Only changes when text changes  const visibleItems = useMemo(() => {    return searchItems(allItems, searchOptions);  }, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes  // ...
```

In the example above, if thetextdid not change, thesearchOptionsobject also won’t change. However, an even better fix is to move thesearchOptionsobject declarationinsideof theuseMemocalculation function:

```jsx
function Dropdown({ allItems, text }) {  const visibleItems = useMemo(() => {    const searchOptions = { matchMode: 'whole-word', text };    return searchItems(allItems, searchOptions);  }, [allItems, text]); // ✅ Only changes when allItems or text changes  // ...
```

Now your calculation depends ontextdirectly (which is a string and can’t “accidentally” become different).


### Memoizing a function
Suppose theFormcomponent is wrapped inmemo.You want to pass a function to it as a prop:

```jsx
export default function ProductPage({ productId, referrer }) {  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }  return <Form onSubmit={handleSubmit} />;}
```

Just as{}creates a different object, function declarations likefunction() {}and expressions like() => {}produce adifferentfunction on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if theFormcomponent is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that isalwaysdifferent would defeat the point of memoization.

To memoize a function withuseMemo, your calculation function would have to return another function:

```jsx
export default function Page({ productId, referrer }) {  const handleSubmit = useMemo(() => {    return (orderDetails) => {      post('/product/' + productId + '/buy', {        referrer,        orderDetails      });    };  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}
```

This looks clunky!Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions intouseCallbackinstead ofuseMemoto avoid having to write an extra nested function:

```jsx
export default function Page({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails    });  }, [productId, referrer]);  return <Form onSubmit={handleSubmit} />;}
```

The two examples above are completely equivalent. The only benefit touseCallbackis that it lets you avoid writing an extra nested function inside. It doesn’t do anything else.Read more aboutuseCallback.


## Troubleshooting

### My calculation runs twice on every re-render
InStrict Mode, React will call some of your functions twice instead of once:

```jsx
function TodoList({ todos, tab }) {  // This component function will run twice for every render.  const visibleTodos = useMemo(() => {    // This calculation will run twice if any of the dependencies change.    return filterTodos(todos, tab);  }, [todos, tab]);  // ...
```

This is expected and shouldn’t break your code.

Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.

For example, this impure calculation function mutates an array you received as a prop:

```jsx
  const visibleTodos = useMemo(() => {    // 🚩 Mistake: mutating a prop    todos.push({ id: 'last', text: 'Go for a walk!' });    const filtered = filterTodos(todos, tab);    return filtered;  }, [todos, tab]);
```

React calls your function twice, so you’d notice the todo is added twice. Your calculation shouldn’t change any existing objects, but it’s okay to change anynewobjects you created during the calculation. For example, if thefilterTodosfunction always returns adifferentarray, you can mutatethatarray instead:

```jsx
  const visibleTodos = useMemo(() => {    const filtered = filterTodos(todos, tab);    // ✅ Correct: mutating an object you created during the calculation    filtered.push({ id: 'last', text: 'Go for a walk!' });    return filtered;  }, [todos, tab]);
```

Readkeeping components pureto learn more about purity.

Also, check out the guides onupdating objectsandupdating arrayswithout mutation.


### MyuseMemocall is supposed to return an object, but returns undefined
This code doesn’t work:

```jsx
  // 🔴 You can't return an object from an arrow function with () => {  const searchOptions = useMemo(() => {    matchMode: 'whole-word',    text: text  }, [text]);
```

In JavaScript,() => {starts the arrow function body, so the{brace is not a part of your object. This is why it doesn’t return an object, and leads to mistakes. You could fix it by adding parentheses like({and}):

```jsx
  // This works, but is easy for someone to break again  const searchOptions = useMemo(() => ({    matchMode: 'whole-word',    text: text  }), [text]);
```

However, this is still confusing and too easy for someone to break by removing the parentheses.

To avoid this mistake, write areturnstatement explicitly:

```jsx
  // ✅ This works and is explicit  const searchOptions = useMemo(() => {    return {      matchMode: 'whole-word',      text: text    };  }, [text]);
```


### Every time my component renders, the calculation inuseMemore-runs
Make sure you’ve specified the dependency array as a second argument!

If you forget the dependency array,useMemowill re-run the calculation every time:

```jsx
function TodoList({ todos, tab }) {  // 🔴 Recalculates every time: no dependency array  const visibleTodos = useMemo(() => filterTodos(todos, tab));  // ...
```

This is the corrected version passing the dependency array as a second argument:

```jsx
function TodoList({ todos, tab }) {  // ✅ Does not recalculate unnecessarily  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...
```

If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:

```jsx
  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  console.log([todos, tab]);
```

You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved astemp1and the second one got saved astemp2, you can then use the browser console to check whether each dependency in both arrays is the same:

```jsx
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
```

When you find which dependency breaks memoization, either find a way to remove it, ormemoize it as well.


### I need to calluseMemofor each list item in a loop, but it’s not allowed
Suppose theChartcomponent is wrapped inmemo. You want to skip re-rendering everyChartin the list when theReportListcomponent re-renders. However, you can’t calluseMemoin a loop:

```jsx
function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useMemo in a loop like this:        const data = useMemo(() => calculateReport(item), [item]);        return (          <figure key={item.id}>            <Chart data={data} />          </figure>        );      })}    </article>  );}
```

Instead, extract a component for each item and memoize data for individual items:

```jsx
function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useMemo at the top level:  const data = useMemo(() => calculateReport(item), [item]);  return (    <figure>      <Chart data={data} />    </figure>  );}
```

Alternatively, you could removeuseMemoand instead wrapReportitself inmemo.If theitemprop does not change,Reportwill skip re-rendering, soChartwill skip re-rendering too:

```jsx
function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  const data = calculateReport(item);  return (    <figure>      <Chart data={data} />    </figure>  );});
```


--------------------------------------------------------------------------------


# useOptimistic
Source: https://react.dev/reference/react/useOptimistic

useOptimisticis a React Hook that lets you optimistically update the UI.

```jsx
const [optimisticState, setOptimistic] = useOptimistic(value, reducer?);
```

- ReferenceuseOptimistic(value, reducer?)setfunctions, likesetOptimistic(optimisticState)
- useOptimistic(value, reducer?)
- setfunctions, likesetOptimistic(optimisticState)
- UsageAdding optimistic state to a componentUsing optimistic state in Action propsAdding optimistic state to Action propsUpdating props or state optimisticallyUpdating multiple values togetherOptimistically adding to a listHandling multipleactiontypesOptimistic delete with error recovery
- Adding optimistic state to a component
- Using optimistic state in Action props
- Adding optimistic state to Action props
- Updating props or state optimistically
- Updating multiple values together
- Optimistically adding to a list
- Handling multipleactiontypes
- Optimistic delete with error recovery
- TroubleshootingI’m getting an error: “An optimistic state update occurred outside a Transition or Action”I’m getting an error: “Cannot update optimistic state while rendering”My optimistic updates show stale valuesI don’t know if my optimistic update is pending
- I’m getting an error: “An optimistic state update occurred outside a Transition or Action”
- I’m getting an error: “Cannot update optimistic state while rendering”
- My optimistic updates show stale values
- I don’t know if my optimistic update is pending

## Reference

### useOptimistic(value, reducer?)
CalluseOptimisticat the top level of your component to create optimistic state for a value.

```jsx
import { useOptimistic } from 'react';function MyComponent({name, todos}) {  const [optimisticAge, setOptimisticAge] = useOptimistic(28);  const [optimisticName, setOptimisticName] = useOptimistic(name);  const [optimisticTodos, setOptimisticTodos] = useOptimistic(todos, todoReducer);  // ...}
```

See more examples below.


#### Parameters
- value: The value returned when there are no pending Actions.
- optionalreducer(currentState, action): The reducer function that specifies how the optimistic state gets updated. It must be pure, should take the current state and reducer action arguments, and should return the next optimistic state.

#### Returns
useOptimisticreturns an array with exactly two values:

1. optimisticState: The current optimistic state. It is equal tovalueunless an Action is pending, in which case it is equal to the state returned byreducer(or the value passed to the set function if noreducerwas provided).
1. Thesetfunctionthat lets you update the optimistic state to a different value inside an Action.

### setfunctions, likesetOptimistic(optimisticState)
Thesetfunction returned byuseOptimisticlets you update the state for the duration of anAction. You can pass the next state directly, or a function that calculates it from the previous state:

```jsx
const [optimisticLike, setOptimisticLike] = useOptimistic(false);const [optimisticSubs, setOptimisticSubs] = useOptimistic(subs);function handleClick() {  startTransition(async () => {    setOptimisticLike(true);    setOptimisticSubs(a => a + 1);    await saveChanges();  });}
```


#### Parameters
- optimisticState: The value that you want the optimistic state to be during anAction. If you provided areducertouseOptimistic, this value will be passed as the second argument to your reducer. It can be a value of any type.If you pass a function asoptimisticState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next optimistic state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying the queued updaters to the previous state similar touseStateupdaters.
- If you pass a function asoptimisticState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next optimistic state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying the queued updaters to the previous state similar touseStateupdaters.

#### Returns
setfunctions do not have a return value.


#### Caveats
- Thesetfunction must be called inside anAction. If you call the setter outside an Action,React will show a warningand the optimistic state will briefly render.

#### How optimistic state works
useOptimisticlets you show a temporary value while a Action is in progress:

```jsx
const [value, setValue] = useState('a');const [optimistic, setOptimistic] = useOptimistic(value);startTransition(async () => {  setOptimistic('b');  const newValue = await saveChanges('b');  setValue(newValue);});
```

When the setter is called inside an Action,useOptimisticwill trigger a re-render to show that state while the Action is in progress. Otherwise, thevaluepassed touseOptimisticis returned.

This state is called the “optimistic” because it is used to immediately present the user with the result of performing an Action, even though the Action actually takes time to complete.

How the update flows

1. Update immediately: WhensetOptimistic('b')is called, React immediately renders with'b'.
Update immediately: WhensetOptimistic('b')is called, React immediately renders with'b'.

1. (Optional) await in Action: If you await in the Action, React continues showing'b'.
(Optional) await in Action: If you await in the Action, React continues showing'b'.

1. Transition scheduled:setValue(newValue)schedules an update to the real state.
Transition scheduled:setValue(newValue)schedules an update to the real state.

1. (Optional) wait for Suspense: IfnewValuesuspends, React continues showing'b'.
(Optional) wait for Suspense: IfnewValuesuspends, React continues showing'b'.

1. Single render commit: Finally, thenewValuecommits forvalueandoptimistic.
Single render commit: Finally, thenewValuecommits forvalueandoptimistic.

There’s no extra render to “clear” the optimistic state. The optimistic and real state converge in the same render when the Transition completes.


### Note

#### Optimistic state is temporary
Optimistic state only renders while an Action is in progress, otherwisevalueis rendered.

IfsaveChangesreturned'c', then bothvalueandoptimisticwill be'c', not'b'.

How the final state is determined

Thevalueargument touseOptimisticdetermines what displays after the Action finishes. How this works depends on the pattern you use:

- Hardcoded valueslikeuseOptimistic(false): After the Action,stateis stillfalse, so the UI showsfalse. This is useful for pending states where you always start fromfalse.
Hardcoded valueslikeuseOptimistic(false): After the Action,stateis stillfalse, so the UI showsfalse. This is useful for pending states where you always start fromfalse.

- Props or state passed inlikeuseOptimistic(isLiked): If the parent updatesisLikedduring the Action, the new value is used after the Action completes. This is how the UI reflects the result of the Action.
Props or state passed inlikeuseOptimistic(isLiked): If the parent updatesisLikedduring the Action, the new value is used after the Action completes. This is how the UI reflects the result of the Action.

- Reducer patternlikeuseOptimistic(items, fn): Ifitemschanges while the Action is pending, React re-runs yourreducerwith the newitemsto recalculate the state. This keeps your optimistic additions on top of the latest data.
Reducer patternlikeuseOptimistic(items, fn): Ifitemschanges while the Action is pending, React re-runs yourreducerwith the newitemsto recalculate the state. This keeps your optimistic additions on top of the latest data.

What happens when the Action fails

If the Action throws an error, the Transition still ends, and React renders with whatevervaluecurrently is. Since the parent typically only updatesvalueon success, a failure meansvaluehasn’t changed, so the UI shows what it showed before the optimistic update. You can catch the error to show a message to the user.


## Usage

### Adding optimistic state to a component
CalluseOptimisticat the top level of your component to declare one or more optimistic states.

```jsx
import { useOptimistic } from 'react';function MyComponent({age, name, todos}) {  const [optimisticAge, setOptimisticAge] = useOptimistic(age);  const [optimisticName, setOptimisticName] = useOptimistic(name);  const [optimisticTodos, setOptimisticTodos] = useOptimistic(todos, reducer);  // ...
```

useOptimisticreturns an array with exactly two items:

1. Theoptimistic state, initially set to thevalueprovided.
1. Theset functionthat lets you temporarily change the state during anAction.If areduceris provided, it will run before returning the optimistic state.
- If areduceris provided, it will run before returning the optimistic state.
To use theoptimistic state, call thesetfunction inside an Action.

Actions are functions called insidestartTransition:

```jsx
function onAgeChange(e) {  startTransition(async () => {    setOptimisticAge(42);    const newAge = await postAge(42);    setAge(newAge);  });}
```

React will render the optimistic state42first while theageremains the current age. The Action waits for POST, and then renders thenewAgefor bothageandoptimisticAge.

SeeHow optimistic state worksfor a deep dive.


### Note
When usingAction props, you can call the set function withoutstartTransition:

```jsx
async function submitAction() {  setOptimisticName('Taylor');  await updateName('Taylor');}
```

This works because Action props are already called insidestartTransition.

For an example, see:Using optimistic state in Action props.


### Using optimistic state in Action props
In anAction prop, you can call the optimistic setter directly withoutstartTransition.

This example sets optimistic state inside a<form>submitActionprop:

```jsx
import { useOptimistic, startTransition } from 'react';
import { updateName } from './actions.js';

export default function EditName({ name, action }) {
  const [optimisticName, setOptimisticName] = useOptimistic(name);

  async function submitAction(formData) {
    const newName = formData.get('name');
    setOptimisticName(newName);
    
    const updatedName = await updateName(newName);
    startTransition(() => {
      action(updatedName);
    })
  }

  return (
    <form action={submitAction}>
      <p>Your name is: {optimisticName}</p>
      <p>
        <label>Change it: </label>
        <input
          type="text"
          name="name"
          disabled={name !== optimisticName}
        />
      </p>
    </form>
  );
}


```

In this example, when the user submits the form, theoptimisticNameupdates immediately to show thenewNameoptimistically while the server request is in progress. When the request completes,nameandoptimisticNameare rendered with the actualupdatedNamefrom the response.


#### Why doesn’t this needstartTransition?
By convention, props called insidestartTransitionare named with “Action”.

SincesubmitActionis named with “Action”, you know it’s already called insidestartTransition.

SeeExposingactionprop from componentsfor the Action prop pattern.


### Adding optimistic state to Action props
When creating anAction prop, you can adduseOptimisticto show immediate feedback.

Here’s a button that shows “Submitting…” while theactionis pending:

```jsx
import { useOptimistic, startTransition } from 'react';

export default function Button({ action, children }) {
  const [isPending, setIsPending] = useOptimistic(false);

  return (
    <button
      disabled={isPending}
      onClick={() => {
        startTransition(async () => {
          setIsPending(true);
          await action();
        });
      }}
    >
      {isPending ? 'Submitting...' : children}
    </button>
  );
}


```

When the button is clicked,setIsPending(true)uses optimistic state to immediately show “Submitting…” and disable the button. When the Action is done,isPendingis rendered asfalseautomatically.

This pattern automatically shows a pending state howeveractionprop is used withButton:

```jsx
// Show pending state for a state update<Button action={() => { setState(c => c + 1) }} />// Show pending state for a navigation<Button action={() => { navigate('/done') }} />// Show pending state for a POST<Button action={async () => { await fetch(/* ... */) }} />// Show pending state for any combination<Button action={async () => {  setState(c => c + 1);  await fetch(/* ... */);  navigate('/done');}} />
```

The pending state will be shown until everything in theactionprop is finished.


### Note
You can also useuseTransitionto get pending state viaisPending.

The difference is thatuseTransitiongives you thestartTransitionfunction, whileuseOptimisticworks with any Transition. Use whichever fits your component’s needs.


### Updating props or state optimistically
You can wrap props or state inuseOptimisticto update it immediately while an Action is in progress.

In this example,LikeButtonreceivesisLikedas a prop and immediately toggles it when clicked:

```jsx
import { useState, useOptimistic, startTransition } from 'react';
import { toggleLike } from './actions.js';

export default function App() {
  const [isLiked, setIsLiked] = useState(false);
  const [optimisticIsLiked, setOptimisticIsLiked] = useOptimistic(isLiked);

  function handleClick() {
    startTransition(async () => {
      const newValue = !optimisticIsLiked
      console.log('⏳ setting optimistic state: ' + newValue);
      
      setOptimisticIsLiked(newValue);
      const updatedValue = await toggleLike(newValue);
      
      startTransition(() => {
        console.log('⏳ setting real state: ' + updatedValue );
        setIsLiked(updatedValue);
      });
    });
  }

  if (optimisticIsLiked !== isLiked) {
    console.log('✅ rendering optimistic state: ' + optimisticIsLiked);  
  } else {
    console.log('✅ rendering real value: ' + optimisticIsLiked);
  }
  

  return (
    <button onClick={handleClick}>
      {optimisticIsLiked ? '❤️ Unlike' : '🤍 Like'}
    </button>
  );
}


```

When the button is clicked,setOptimisticIsLikedimmediately updates the displayed state to show the heart as liked. Meanwhile,await toggleLikeruns in the background. When theawaitcompletes,setIsLikedparent updates the “real”isLikedstate, and the optimistic state is rendered to match this new value.


### Note
This example reads fromoptimisticIsLikedto calculate the next value. This works when the base state won’t change, but if the base state might change while your Action is pending, you may want to use a state updater or the reducer.

SeeUpdating state based on the current statefor an example.


### Updating multiple values together
When an optimistic update affects multiple related values, use a reducer to update them together. This ensures the UI stays consistent.

Here’s a follow button that updates both the follow state and follower count:

```jsx
import { useOptimistic, startTransition } from 'react';

export default function FollowButton({ user, followAction }) {
  const [optimisticState, updateOptimistic] = useOptimistic(
    { isFollowing: user.isFollowing, followerCount: user.followerCount },
    (current, isFollowing) => ({
      isFollowing,
      followerCount: current.followerCount + (isFollowing ? 1 : -1)
    })
  );

  function handleClick() {
    const newFollowState = !optimisticState.isFollowing;
    startTransition(async () => {
      updateOptimistic(newFollowState);
      await followAction(newFollowState);
    });
  }

  return (
    <div>
      <p><strong>{user.name}</strong></p>
      <p>{optimisticState.followerCount} followers</p>
      <button onClick={handleClick}>
        {optimisticState.isFollowing ? 'Unfollow' : 'Follow'}
      </button>
    </div>
  );
}


```

The reducer receives the newisFollowingvalue and calculates both the new follow state and the updated follower count in a single update. This ensures the button text and count always stay in sync.


#### Choosing between updaters and reducers
useOptimisticsupports two patterns for calculating state based on current state:

Updater functionswork likeuseState updaters. Pass a function to the setter:

```jsx
const [optimistic, setOptimistic] = useOptimistic(value);setOptimistic(current => !current);
```

Reducersseparate the update logic from the setter call:

```jsx
const [optimistic, dispatch] = useOptimistic(value, (current, action) => {  // Calculate next state based on current and action});dispatch(action);
```

Use updatersfor calculations where the setter call naturally describes the update. This is similar to usingsetState(prev => ...)withuseState.

Use reducerswhen you need to pass data to the update (like which item to add) or when handling multiple types of updates with a single hook.

Why use a reducer?

Reducers are essential when the base state might change while your Transition is pending. Iftodoschanges while your add is pending (for example, another user added a todo), React will re-run your reducer with the newtodosto recalculate what to show. This ensures your new todo is added to the latest list, not an outdated copy.

An updater function likesetOptimistic(prev => [...prev, newItem])would only see the state from when the Transition started, missing any updates that happened during the async work.


### Optimistically adding to a list
When you need to optimistically add items to a list, use areducer:

```jsx
import { useOptimistic, startTransition } from 'react';

export default function TodoList({ todos, addTodoAction }) {
  const [optimisticTodos, addOptimisticTodo] = useOptimistic(
    todos,
    (currentTodos, newTodo) => [
      ...currentTodos,
      { id: newTodo.id, text: newTodo.text, pending: true }
    ]
  );

  function handleAddTodo(text) {
    const newTodo = { id: crypto.randomUUID(), text: text };
    startTransition(async () => {
      addOptimisticTodo(newTodo);
      await addTodoAction(newTodo);
    });
  }

  return (
    <div>
      <button onClick={() => handleAddTodo('New todo')}>Add Todo</button>
      <ul>
        {optimisticTodos.map(todo => (
          <li key={todo.id}>
            {todo.text} {todo.pending && "(Adding...)"}
          </li>
        ))}
      </ul>
    </div>
  );
}


```

Thereducerreceives the current list of todos and the new todo to add. This is important because if thetodosprop changes while your add is pending (for example, another user added a todo), React will update your optimistic state by re-running the reducer with the updated list. This ensures your new todo is added to the latest list, not an outdated copy.


### Note
Each optimistic item includes apending: trueflag so you can show loading state for individual items. When the server responds and the parent updates the canonicaltodoslist with the saved item, the optimistic state updates to the confirmed item without the pending flag.


### Handling multipleactiontypes
When you need to handle multiple types of optimistic updates (like adding and removing items), use a reducer pattern withactionobjects.

This shopping cart example shows how to handle add and remove with a single reducer:

```jsx
import { useOptimistic, startTransition } from 'react';

export default function ShoppingCart({ cart, cartActions }) {
  const [optimisticCart, dispatch] = useOptimistic(
    cart,
    (currentCart, action) => {
      switch (action.type) {
        case 'add':
          const exists = currentCart.find(item => item.id === action.item.id);
          if (exists) {
            return currentCart.map(item =>
              item.id === action.item.id
                ? { ...item, quantity: item.quantity + 1, pending: true }
                : item
            );
          }
          return [...currentCart, { ...action.item, quantity: 1, pending: true }];
        case 'remove':
          return currentCart.filter(item => item.id !== action.id);
        case 'update_quantity':
          return currentCart.map(item =>
            item.id === action.id
              ? { ...item, quantity: action.quantity, pending: true }
              : item
          );
        default:
          return currentCart;
      }
    }
  );

  function handleAdd(item) {
    startTransition(async () => {
      dispatch({ type: 'add', item });
      await cartActions.add(item);
    });
  }

  function handleRemove(id) {
    startTransition(async () => {
      dispatch({ type: 'remove', id });
      await cartActions.remove(id);
    });
  }

  function handleUpdateQuantity(id, quantity) {
    startTransition(async () => {
      dispatch({ type: 'update_quantity', id, quantity });
      await cartActions.updateQuantity(id, quantity);
    });
  }

  const total = optimisticCart.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );

  return (
    <div>
      <h2>Shopping Cart</h2>
      <div style={{ marginBottom: 16 }}>
        <button onClick={() => handleAdd({
          id: 1, name: 'T-Shirt', price: 25
        })}>
          Add T-Shirt ($25)
        </button>{' '}
        <button onClick={() => handleAdd({
          id: 2, name: 'Mug', price: 15
        })}>
          Add Mug ($15)
        </button>
      </div>
      {optimisticCart.length === 0 ? (
        <p>Your cart is empty</p>
      ) : (
        <ul>
          {optimisticCart.map(item => (
            <li key={item.id}>
              {item.name} - ${item.price} ×
              {item.quantity}
              {' '}= ${item.price * item.quantity}
              <button
                onClick={() => handleRemove(item.id)}
                style={{ marginLeft: 8 }}
              >
                Remove
              </button>
              {item.pending && ' ...'}
            </li>
          ))}
        </ul>
      )}
      <p><strong>Total: ${total}</strong></p>
    </div>
  );
}


```

The reducer handles threeactiontypes (add,remove,update_quantity) and returns the new optimistic state for each. Eachactionsets apending: trueflag so you can show visual feedback while theServer Functionruns.


### Optimistic delete with error recovery
When deleting items optimistically, you should handle the case where the Action fails.

This example shows how to display an error message when a delete fails, and the UI automatically rolls back to show the item again.

```jsx
import { useState, useOptimistic, startTransition } from 'react';

export default function ItemList({ items, deleteAction }) {
  const [error, setError] = useState(null);
  const [optimisticItems, removeItem] = useOptimistic(
    items,
    (currentItems, idToRemove) =>
      currentItems.map(item =>
        item.id === idToRemove
          ? { ...item, deleting: true }
          : item
      )
  );

  function handleDelete(id) {
    setError(null);
    startTransition(async () => {
      removeItem(id);
      try {
        await deleteAction(id);
      } catch (e) {
        setError(e.message);
      }
    });
  }

  return (
    <div>
      <h2>Your Items</h2>
      <ul>
        {optimisticItems.map(item => (
          <li
            key={item.id}
            style={{
              opacity: item.deleting ? 0.5 : 1,
              textDecoration: item.deleting ? 'line-through' : 'none',
              transition: 'opacity 0.2s'
            }}
          >
            {item.name}
            <button
              onClick={() => handleDelete(item.id)}
              disabled={item.deleting}
              style={{ marginLeft: 8 }}
            >
              {item.deleting ? 'Deleting...' : 'Delete'}
            </button>
          </li>
        ))}
      </ul>
      {error && (
        <p style={{ color: 'red', padding: 8, background: '#fee' }}>
          {error}
        </p>
      )}
    </div>
  );
}


```

Try deleting ‘Deploy to production’. When the delete fails, the item automatically reappears in the list.


## Troubleshooting

### I’m getting an error: “An optimistic state update occurred outside a Transition or Action”
You may see this error:

The optimistic setter function must be called insidestartTransition:

```jsx
// 🚩 Incorrect: outside a Transitionfunction handleClick() {  setOptimistic(newValue);  // Warning!  // ...}// ✅ Correct: inside a Transitionfunction handleClick() {  startTransition(async () => {    setOptimistic(newValue);    // ...  });}// ✅ Also correct: inside an Action propfunction submitAction(formData) {  setOptimistic(newValue);  // ...}
```

When you call the setter outside an Action, the optimistic state will briefly appear and then immediately revert back to the original value. This happens because there’s no Transition to “hold” the optimistic state while your Action runs.


### I’m getting an error: “Cannot update optimistic state while rendering”
You may see this error:

This error occurs when you call the optimistic setter during the render phase of a component. You can only call it from event handlers, effects, or other callbacks:

```jsx
// 🚩 Incorrect: calling during renderfunction MyComponent({ items }) {  const [isPending, setPending] = useOptimistic(false);  // This runs during render - not allowed!  setPending(true);    // ...}// ✅ Correct: calling inside startTransitionfunction MyComponent({ items }) {  const [isPending, setPending] = useOptimistic(false);  function handleClick() {    startTransition(() => {      setPending(true);      // ...    });  }  // ...}// ✅ Also correct: calling from an Actionfunction MyComponent({ items }) {  const [isPending, setPending] = useOptimistic(false);  function action() {    setPending(true);    // ...  }  // ...}
```


### My optimistic updates show stale values
If your optimistic state seems to be based on old data, consider using an updater function or reducer to calculate the optimistic state relative to the current state.

```jsx
// May show stale data if state changes during Actionconst [optimistic, setOptimistic] = useOptimistic(count);setOptimistic(5);  // Always sets to 5, even if count changed// Better: relative updates handle state changes correctlyconst [optimistic, adjust] = useOptimistic(count, (current, delta) => current + delta);adjust(1);  // Always adds 1 to whatever the current count is
```

SeeUpdating state based on the current statefor details.


### I don’t know if my optimistic update is pending
To know whenuseOptimisticis pending, you have three options:

1. Check ifoptimisticValue === value
```jsx
const [optimistic, setOptimistic] = useOptimistic(value);const isPending = optimistic !== value;
```

If the values are not equal, there’s a Transition in progress.

1. Add auseTransition
```jsx
const [isPending, startTransition] = useTransition();const [optimistic, setOptimistic] = useOptimistic(value);//...startTransition(() => {  setOptimistic(state);})
```

SinceuseTransitionusesuseOptimisticforisPendingunder the hood, this is equivalent to option 1.

1. Add apendingflag in your reducer
```jsx
const [optimistic, addOptimistic] = useOptimistic(  items,  (state, newItem) => [...state, { ...newItem, isPending: true }]);
```

Since each optimistic item has its own flag, you can show loading state for individual items.


--------------------------------------------------------------------------------


# useReducer
Source: https://react.dev/reference/react/useReducer

useReduceris a React Hook that lets you add areducerto your component.

```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init?)
```

- ReferenceuseReducer(reducer, initialArg, init?)dispatchfunction
- useReducer(reducer, initialArg, init?)
- dispatchfunction
- UsageAdding a reducer to a componentWriting the reducer functionAvoiding recreating the initial state
- Adding a reducer to a component
- Writing the reducer function
- Avoiding recreating the initial state
- TroubleshootingI’ve dispatched an action, but logging gives me the old state valueI’ve dispatched an action, but the screen doesn’t updateA part of my reducer state becomes undefined after dispatchingMy entire reducer state becomes undefined after dispatchingI’m getting an error: “Too many re-renders”My reducer or initializer function runs twice
- I’ve dispatched an action, but logging gives me the old state value
- I’ve dispatched an action, but the screen doesn’t update
- A part of my reducer state becomes undefined after dispatching
- My entire reducer state becomes undefined after dispatching
- I’m getting an error: “Too many re-renders”
- My reducer or initializer function runs twice

## Reference

### useReducer(reducer, initialArg, init?)
CalluseReducerat the top level of your component to manage its state with areducer.

```jsx
import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ...
```

See more examples below.


#### Parameters
- reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.
- initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the nextinitargument.
- optionalinit: The initializer function that should return the initial state. If it’s not specified, the initial state is set toinitialArg. Otherwise, the initial state is set to the result of callinginit(initialArg).

#### Returns
useReducerreturns an array with exactly two values:

1. The current state. During the first render, it’s set toinit(initialArg)orinitialArg(if there’s noinit).
1. Thedispatchfunctionthat lets you update the state to a different value and trigger a re-render.

#### Caveats
- useReduceris a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
- Thedispatchfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.
- In Strict Mode, React willcall your reducer and initializer twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.

### dispatchfunction
Thedispatchfunction returned byuseReducerlets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to thedispatchfunction:

```jsx
const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ...
```

React will set the next state to the result of calling thereducerfunction you’ve provided with the currentstateand the action you’ve passed todispatch.


#### Parameters
- action: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with atypeproperty identifying it and, optionally, other properties with additional information.

#### Returns
dispatchfunctions do not have a return value.


#### Caveats
- Thedispatchfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thedispatchfunction,you will still get the old valuethat was on the screen before your call.
Thedispatchfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thedispatchfunction,you will still get the old valuethat was on the screen before your call.

- If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.
If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.

- Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync.
Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync.


## Usage

### Adding a reducer to a component
CalluseReducerat the top level of your component to manage state with areducer.

```jsx
import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ...
```

useReducerreturns an array with exactly two items:

1. Thecurrent stateof this state variable, initially set to theinitial stateyou provided.
1. Thedispatchfunctionthat lets you change it in response to interaction.
To update what’s on the screen, calldispatchwith an object representing what the user did, called anaction:

```jsx
function handleClick() {  dispatch({ type: 'incremented_age' });}
```

React will pass the current state and the action to yourreducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.

```jsx
import { useReducer } from 'react';

function reducer(state, action) {
  if (action.type === 'incremented_age') {
    return {
      age: state.age + 1
    };
  }
  throw Error('Unknown action.');
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { age: 42 });

  return (
    <>
      <button onClick={() => {
        dispatch({ type: 'incremented_age' })
      }}>
        Increment age
      </button>
      <p>Hello! You are {state.age}.</p>
    </>
  );
}


```

useReduceris very similar touseState, but it lets you move the state update logic from event handlers into a single function outside of your component. Read more aboutchoosing betweenuseStateanduseReducer.


### Writing the reducer function
A reducer function is declared like this:

```jsx
function reducer(state, action) {  // ...}
```

Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as aswitchstatement.For eachcasein theswitch, calculate and return some next state.

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        name: state.name,        age: state.age + 1      };    }    case 'changed_name': {      return {        name: action.nextName,        age: state.age      };    }  }  throw Error('Unknown action: ' + action.type);}
```

Actions can have any shape. By convention, it’s common to pass objects with atypeproperty identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.

```jsx
function Form() {  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });    function handleButtonClick() {    dispatch({ type: 'incremented_age' });  }  function handleInputChange(e) {    dispatch({      type: 'changed_name',      nextName: e.target.value    });  }  // ...
```

The action type names are local to your component.Each action describes a single interaction, even if that leads to multiple changes in data.The shape of the state is arbitrary, but usually it’ll be an object or an array.

Readextracting state logic into a reducerto learn more.


### Pitfall
State is read-only. Don’t modify any objects or arrays in state:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Don't mutate an object in state like this:      state.age = state.age + 1;      return state;    }
```

Instead, always return new objects from your reducer:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Instead, return a new object      return {        ...state,        age: state.age + 1      };    }
```

Readupdating objects in stateandupdating arrays in stateto learn more.


#### Basic useReducer examples

#### Example1of3:Form (object)
In this example, the reducer manages a state object with two fields:nameandage.

```jsx
import { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'incremented_age': {
      return {
        name: state.name,
        age: state.age + 1
      };
    }
    case 'changed_name': {
      return {
        name: action.nextName,
        age: state.age
      };
    }
  }
  throw Error('Unknown action: ' + action.type);
}

const initialState = { name: 'Taylor', age: 42 };

export default function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  function handleButtonClick() {
    dispatch({ type: 'incremented_age' });
  }

  function handleInputChange(e) {
    dispatch({
      type: 'changed_name',
      nextName: e.target.value
    }); 
  }

  return (
    <>
      <input
        value={state.name}
        onChange={handleInputChange}
      />
      <button onClick={handleButtonClick}>
        Increment age
      </button>
      <p>Hello, {state.name}. You are {state.age}.</p>
    </>
  );
}


```


### Avoiding recreating the initial state
React saves the initial state once and ignores it on the next renders.

```jsx
function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, createInitialState(username));  // ...
```

Although the result ofcreateInitialState(username)is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.

To solve this, you maypass it as aninitializerfunctiontouseReduceras the third argument instead:

```jsx
function createInitialState(username) {  // ...}function TodoList({ username }) {  const [state, dispatch] = useReducer(reducer, username, createInitialState);  // ...
```

Notice that you’re passingcreateInitialState, which is thefunction itself, and notcreateInitialState(), which is the result of calling it. This way, the initial state does not get re-created after initialization.

In the above example,createInitialStatetakes ausernameargument. If your initializer doesn’t need any information to compute the initial state, you may passnullas the second argument touseReducer.


#### The difference between passing an initializer and passing the initial state directly

#### Example1of2:Passing the initializer function
This example passes the initializer function, so thecreateInitialStatefunction only runs during initialization. It does not run when component re-renders, such as when you type into the input.

```jsx
import { useReducer } from 'react';

function createInitialState(username) {
  const initialTodos = [];
  for (let i = 0; i < 50; i++) {
    initialTodos.push({
      id: i,
      text: username + "'s task #" + (i + 1)
    });
  }
  return {
    draft: '',
    todos: initialTodos,
  };
}

function reducer(state, action) {
  switch (action.type) {
    case 'changed_draft': {
      return {
        draft: action.nextDraft,
        todos: state.todos,
      };
    };
    case 'added_todo': {
      return {
        draft: '',
        todos: [{
          id: state.todos.length,
          text: state.draft
        }, ...state.todos]
      }
    }
  }
  throw Error('Unknown action: ' + action.type);
}

export default function TodoList({ username }) {
  const [state, dispatch] = useReducer(
    reducer,
    username,
    createInitialState
  );
  return (
    <>
      <input
        value={state.draft}
        onChange={e => {
          dispatch({
            type: 'changed_draft',
            nextDraft: e.target.value
          })
        }}
      />
      <button onClick={() => {
        dispatch({ type: 'added_todo' });
      }}>Add</button>
      <ul>
        {state.todos.map(item => (
          <li key={item.id}>
            {item.text}
          </li>
        ))}
      </ul>
    </>
  );
}


```


## Troubleshooting

### I’ve dispatched an action, but logging gives me the old state value
Calling thedispatchfunctiondoes not change state in the running code:

```jsx
function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // Request a re-render with 43  console.log(state.age);  // Still 42!  setTimeout(() => {    console.log(state.age); // Also 42!  }, 5000);}
```

This is becausestates behaves like a snapshot.Updating state requests another render with the new state value, but does not affect thestateJavaScript variable in your already-running event handler.

If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:

```jsx
const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }
```


### I’ve dispatched an action, but the screen doesn’t update
React willignore your update if the next state is equal to the previous state,as determined by anObject.iscomparison. This usually happens when you change an object or an array in state directly:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Wrong: mutating existing object      state.age++;      return state;    }    case 'changed_name': {      // 🚩 Wrong: mutating existing object      state.name = action.nextName;      return state;    }    // ...  }}
```

You mutated an existingstateobject and returned it, so React ignored the update. To fix this, you need to ensure that you’re alwaysupdating objects in stateandupdating arrays in stateinstead of mutating them:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Correct: creating a new object      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ Correct: creating a new object      return {        ...state,        name: action.nextName      };    }    // ...  }}
```


### A part of my reducer state becomes undefined after dispatching
Make sure that everycasebranchcopies all of the existing fieldswhen returning the new state:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // Don't forget this!        age: state.age + 1      };    }    // ...
```

Without...stateabove, the returned next state would only contain theagefield and nothing else.


### My entire reducer state becomes undefined after dispatching
If your state unexpectedly becomesundefined, you’re likely forgetting toreturnstate in one of the cases, or your action type doesn’t match any of thecasestatements. To find why, throw an error outside theswitch:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}
```

You can also use a static type checker like TypeScript to catch such mistakes.


### I’m getting an error: “Too many re-renders”
You might get an error that says:Too many re-renders. React limits the number of renders to prevent an infinite loop.Typically, this means that you’re unconditionally dispatching an actionduring render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:

```jsx
// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>
```

If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specificdispatchfunction call responsible for the error.


### My reducer or initializer function runs twice
InStrict Mode, React will call your reducer and initializer functions twice. This shouldn’t break your code.

Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.

For example, this impure reducer function mutates an array in state:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 Mistake: mutating state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}
```

Because React calls your reducer function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake byreplacing the array instead of mutating it:

```jsx
function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ Correct: replacing with new state      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}
```

Now that this reducer function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes.Only component, initializer, and reducer functions need to be pure.Event handlers don’t need to be pure, so React will never call your event handlers twice.

Readkeeping components pureto learn more.


--------------------------------------------------------------------------------


# useRef
Source: https://react.dev/reference/react/useRef

useRefis a React Hook that lets you reference a value that’s not needed for rendering.

```jsx
const ref = useRef(initialValue)
```

- ReferenceuseRef(initialValue)
- useRef(initialValue)
- UsageReferencing a value with a refManipulating the DOM with a refAvoiding recreating the ref contents
- Referencing a value with a ref
- Manipulating the DOM with a ref
- Avoiding recreating the ref contents
- TroubleshootingI can’t get a ref to a custom component
- I can’t get a ref to a custom component

## Reference

### useRef(initialValue)
CalluseRefat the top level of your component to declare aref.

```jsx
import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ...
```

See more examples below.


#### Parameters
- initialValue: The value you want the ref object’scurrentproperty to be initially. It can be a value of any type. This argument is ignored after the initial render.

#### Returns
useRefreturns an object with a single property:

- current: Initially, it’s set to theinitialValueyou have passed. You can later set it to something else. If you pass the ref object to React as arefattribute to a JSX node, React will set itscurrentproperty.
On the next renders,useRefwill return the same object.


#### Caveats
- You can mutate theref.currentproperty. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn’t mutate that object.
- When you change theref.currentproperty, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.
- Do not writeor readref.currentduring rendering, except forinitialization.This makes your component’s behavior unpredictable.
- In Strict Mode, React willcall your component function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.

## Usage

### Referencing a value with a ref
CalluseRefat the top level of your component to declare one or morerefs.

```jsx
import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ...
```

useRefreturns aref objectwith a singlecurrentpropertyinitially set to theinitial valueyou provided.

On the next renders,useRefwill return the same object. You can change itscurrentproperty to store information and read it later. This might remind you ofstate, but there is an important difference.

Changing a ref does not trigger a re-render.This means refs are perfect for storing information that doesn’t affect the visual output of your component. For example, if you need to store aninterval IDand retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change itscurrentproperty:

```jsx
function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}
```

Later, you can read that interval ID from the ref so that you can callclear that interval:

```jsx
function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}
```

By using a ref, you ensure that:

- You canstore informationbetween re-renders (unlike regular variables, which reset on every render).
- Changing itdoes not trigger a re-render(unlike state variables, which trigger a re-render).
- Theinformation is localto each copy of your component (unlike the variables outside, which are shared).
Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more aboutchoosing betweenuseRefanduseState.


#### Examples of referencing a value with useRef

#### Example1of2:Click counter
This component uses a ref to keep track of how many times the button was clicked. Note that it’s okay to use a ref instead of state here because the click count is only read and written in an event handler.

```jsx
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}


```

If you show{ref.current}in the JSX, the number won’t update on click. This is because settingref.currentdoes not trigger a re-render. Information that’s used for rendering should be state instead.


### Pitfall
Do not writeor readref.currentduring rendering.

React expects that the body of your componentbehaves like a pure function:

- If the inputs (props,state, andcontext) are the same, it should return exactly the same JSX.
- Calling it in a different order or with different arguments should not affect the results of other calls.
Reading or writing a refduring renderingbreaks these expectations.

```jsx
function MyComponent() {  // ...  // 🚩 Don't write a ref during rendering  myRef.current = 123;  // ...  // 🚩 Don't read a ref during rendering  return <h1>{myOtherRef.current}</h1>;}
```

You can read or write refsfrom event handlers or effects instead.

```jsx
function MyComponent() {  // ...  useEffect(() => {    // ✅ You can read or write refs in effects    myRef.current = 123;  });  // ...  function handleClick() {    // ✅ You can read or write refs in event handlers    doSomething(myOtherRef.current);  }  // ...}
```

If youhave toreador writesomething during rendering,use stateinstead.

When you break these rules, your component might still work, but most of the newer features we’re adding to React will rely on these expectations. Read more aboutkeeping your components pure.


### Manipulating the DOM with a ref
It’s particularly common to use a ref to manipulate theDOM.React has built-in support for this.

First, declare aref objectwith aninitial valueofnull:

```jsx
import { useRef } from 'react';function MyComponent() {  const inputRef = useRef(null);  // ...
```

Then pass your ref object as therefattribute to the JSX of the DOM node you want to manipulate:

```jsx
  // ...  return <input ref={inputRef} />;
```

After React creates the DOM node and puts it on the screen, React will set thecurrentpropertyof your ref object to that DOM node. Now you can access the<input>’s DOM node and call methods likefocus():

```jsx
  function handleClick() {    inputRef.current.focus();  }
```

React will set thecurrentproperty back tonullwhen the node is removed from the screen.

Read more aboutmanipulating the DOM with refs.


#### Examples of manipulating the DOM with useRef

#### Example1of4:Focusing a text input
In this example, clicking the button will focus the input:

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}


```


### Avoiding recreating the ref contents
React saves the initial ref value once and ignores it on the next renders.

```jsx
function Video() {  const playerRef = useRef(new VideoPlayer());  // ...
```

Although the result ofnew VideoPlayer()is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating expensive objects.

To solve it, you may initialize the ref like this instead:

```jsx
function Video() {  const playerRef = useRef(null);  if (playerRef.current === null) {    playerRef.current = new VideoPlayer();  }  // ...
```

Normally, writing or readingref.currentduring render is not allowed. However, it’s fine in this case because the result is always the same, and the condition only executes during initialization so it’s fully predictable.


#### How to avoid null checks when initializing useRef later
If you use a type checker and don’t want to always check fornull, you can try a pattern like this instead:

```jsx
function Video() {  const playerRef = useRef(null);  function getPlayer() {    if (playerRef.current !== null) {      return playerRef.current;    }    const player = new VideoPlayer();    playerRef.current = player;    return player;  }  // ...
```

Here, theplayerRefitself is nullable. However, you should be able to convince your type checker that there is no case in whichgetPlayer()returnsnull. Then usegetPlayer()in your event handlers.


## Troubleshooting

### I can’t get a ref to a custom component
If you try to pass arefto your own component like this:

```jsx
const inputRef = useRef(null);return <MyInput ref={inputRef} />;
```

You might get an error in the console:

By default, your own components don’t expose refs to the DOM nodes inside them.

To fix this, find the component that you want to get a ref to:

```jsx
export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}
```

And then addrefto the list of props your component accepts and passrefas a prop to the relevant childbuilt-in componentlike this:

```jsx
function MyInput({ value, onChange, ref }) {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );};export default MyInput;
```

Then the parent component can get a ref to it.

Read more aboutaccessing another component’s DOM nodes.


--------------------------------------------------------------------------------


# useState
Source: https://react.dev/reference/react/useState

useStateis a React Hook that lets you add astate variableto your component.

```jsx
const [state, setState] = useState(initialState)
```

- ReferenceuseState(initialState)setfunctions, likesetSomething(nextState)
- useState(initialState)
- setfunctions, likesetSomething(nextState)
- UsageAdding state to a componentUpdating state based on the previous stateUpdating objects and arrays in stateAvoiding recreating the initial stateResetting state with a keyStoring information from previous renders
- Adding state to a component
- Updating state based on the previous state
- Updating objects and arrays in state
- Avoiding recreating the initial state
- Resetting state with a key
- Storing information from previous renders
- TroubleshootingI’ve updated the state, but logging gives me the old valueI’ve updated the state, but the screen doesn’t updateI’m getting an error: “Too many re-renders”My initializer or updater function runs twiceI’m trying to set state to a function, but it gets called instead
- I’ve updated the state, but logging gives me the old value
- I’ve updated the state, but the screen doesn’t update
- I’m getting an error: “Too many re-renders”
- My initializer or updater function runs twice
- I’m trying to set state to a function, but it gets called instead

## Reference

### useState(initialState)
CalluseStateat the top level of your component to declare astate variable.

```jsx
import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(28);  const [name, setName] = useState('Taylor');  const [todos, setTodos] = useState(() => createTodos());  // ...
```

The convention is to name state variables like[something, setSomething]usingarray destructuring.

See more examples below.


#### Parameters
- initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.If you pass a function asinitialState, it will be treated as aninitializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state.See an example below.
- If you pass a function asinitialState, it will be treated as aninitializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state.See an example below.

#### Returns
useStatereturns an array with exactly two values:

1. The current state. During the first render, it will match theinitialStateyou have passed.
1. Thesetfunctionthat lets you update the state to a different value and trigger a re-render.

#### Caveats
- useStateis a Hook, so you can only call itat the top level of your componentor your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
- In Strict Mode, React willcall your initializer function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.

### setfunctions, likesetSomething(nextState)
Thesetfunction returned byuseStatelets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:

```jsx
const [name, setName] = useState('Edward');function handleClick() {  setName('Taylor');  setAge(a => a + 1);  // ...
```


#### Parameters
- nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.See an example below.
- If you pass a function asnextState, it will be treated as anupdater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.See an example below.

#### Returns
setfunctions do not have a return value.


#### Caveats
- Thesetfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thesetfunction,you will still get the old valuethat was on the screen before your call.
Thesetfunctiononly updates the state variable for thenextrender. If you read the state variable after calling thesetfunction,you will still get the old valuethat was on the screen before your call.

- If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.
If the new value you provide is identical to the currentstate, as determined by anObject.iscomparison, React willskip re-rendering the component and its children.This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.

- Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync.
Reactbatches state updates.It updates the screenafter all the event handlers have runand have called theirsetfunctions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can useflushSync.

- Thesetfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.
Thesetfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.

- Calling thesetfunctionduring renderingis only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it tostore information from the previous renders.See an example below.
Calling thesetfunctionduring renderingis only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it tostore information from the previous renders.See an example below.

- In Strict Mode, React willcall your updater function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.
In Strict Mode, React willcall your updater function twicein order tohelp you find accidental impurities.This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.


## Usage

### Adding state to a component
CalluseStateat the top level of your component to declare one or morestate variables.

```jsx
import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(42);  const [name, setName] = useState('Taylor');  // ...
```

The convention is to name state variables like[something, setSomething]usingarray destructuring.

useStatereturns an array with exactly two items:

1. Thecurrent stateof this state variable, initially set to theinitial stateyou provided.
1. Thesetfunctionthat lets you change it to any other value in response to interaction.
To update what’s on the screen, call thesetfunction with some next state:

```jsx
function handleClick() {  setName('Robin');}
```

React will store the next state, render your component again with the new values, and update the UI.


### Pitfall
Calling thesetfunctiondoes notchange the current state in the already executing code:

```jsx
function handleClick() {  setName('Robin');  console.log(name); // Still "Taylor"!}
```

It only affects whatuseStatewill return starting from thenextrender.


#### Basic useState examples

#### Example1of4:Counter (number)
In this example, thecountstate variable holds a number. Clicking the button increments it.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      You pressed me {count} times
    </button>
  );
}


```


### Updating state based on the previous state
Suppose theageis42. This handler callssetAge(age + 1)three times:

```jsx
function handleClick() {  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)}
```

However, after one click,agewill only be43rather than45! This is because calling thesetfunctiondoes not updatetheagestate variable in the already running code. So eachsetAge(age + 1)call becomessetAge(43).

To solve this problem,you may pass anupdater functiontosetAgeinstead of the next state:

```jsx
function handleClick() {  setAge(a => a + 1); // setAge(42 => 43)  setAge(a => a + 1); // setAge(43 => 44)  setAge(a => a + 1); // setAge(44 => 45)}
```

Here,a => a + 1is your updater function. It takes thepending stateand calculates thenext statefrom it.

React puts your updater functions in aqueue.Then, during the next render, it will call them in the same order:

1. a => a + 1will receive42as the pending state and return43as the next state.
1. a => a + 1will receive43as the pending state and return44as the next state.
1. a => a + 1will receive44as the pending state and return45as the next state.
There are no other queued updates, so React will store45as the current state in the end.

By convention, it’s common to name the pending state argument for the first letter of the state variable name, likeaforage. However, you may also call it likeprevAgeor something else that you find clearer.

React maycall your updaters twicein development to verify that they arepure.


#### Is using an updater always preferred?
You might hear a recommendation to always write code likesetAge(a => a + 1)if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.

In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, theagestate variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale”ageat the beginning of the event handler.

However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).

If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of someotherstate variable, you might want to combine them into one object anduse a reducer.


#### The difference between passing an updater and passing the next state directly

#### Example1of2:Passing the updater function
This example passes the updater function, so the “+3” button works.

```jsx
import { useState } from 'react';

export default function Counter() {
  const [age, setAge] = useState(42);

  function increment() {
    setAge(a => a + 1);
  }

  return (
    <>
      <h1>Your age: {age}</h1>
      <button onClick={() => {
        increment();
        increment();
        increment();
      }}>+3</button>
      <button onClick={() => {
        increment();
      }}>+1</button>
    </>
  );
}


```


### Updating objects and arrays in state
You can put objects and arrays into state. In React, state is considered read-only, soyou shouldreplaceit rather thanmutateyour existing objects. For example, if you have aformobject in state, don’t mutate it:

```jsx
// 🚩 Don't mutate an object in state like this:form.firstName = 'Taylor';
```

Instead, replace the whole object by creating a new one:

```jsx
// ✅ Replace state with a new objectsetForm({  ...form,  firstName: 'Taylor'});
```

Readupdating objects in stateandupdating arrays in stateto learn more.


#### Examples of objects and arrays in state

#### Example1of4:Form (object)
In this example, theformstate variable holds an object. Each input has a change handler that callssetFormwith the next state of the entire form. The{ ...form }spread syntax ensures that the state object is replaced rather than mutated.

```jsx
import { useState } from 'react';

export default function Form() {
  const [form, setForm] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com',
  });

  return (
    <>
      <label>
        First name:
        <input
          value={form.firstName}
          onChange={e => {
            setForm({
              ...form,
              firstName: e.target.value
            });
          }}
        />
      </label>
      <label>
        Last name:
        <input
          value={form.lastName}
          onChange={e => {
            setForm({
              ...form,
              lastName: e.target.value
            });
          }}
        />
      </label>
      <label>
        Email:
        <input
          value={form.email}
          onChange={e => {
            setForm({
              ...form,
              email: e.target.value
            });
          }}
        />
      </label>
      <p>
        {form.firstName}{' '}
        {form.lastName}{' '}
        ({form.email})
      </p>
    </>
  );
}


```


### Avoiding recreating the initial state
React saves the initial state once and ignores it on the next renders.

```jsx
function TodoList() {  const [todos, setTodos] = useState(createInitialTodos());  // ...
```

Although the result ofcreateInitialTodos()is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.

To solve this, you maypass it as aninitializerfunctiontouseStateinstead:

```jsx
function TodoList() {  const [todos, setTodos] = useState(createInitialTodos);  // ...
```

Notice that you’re passingcreateInitialTodos, which is thefunction itself, and notcreateInitialTodos(), which is the result of calling it. If you pass a function touseState, React will only call it during initialization.

React maycall your initializers twicein development to verify that they arepure.


#### The difference between passing an initializer and passing the initial state directly

#### Example1of2:Passing the initializer function
This example passes the initializer function, so thecreateInitialTodosfunction only runs during initialization. It does not run when component re-renders, such as when you type into the input.

```jsx
import { useState } from 'react';

function createInitialTodos() {
  const initialTodos = [];
  for (let i = 0; i < 50; i++) {
    initialTodos.push({
      id: i,
      text: 'Item ' + (i + 1)
    });
  }
  return initialTodos;
}

export default function TodoList() {
  const [todos, setTodos] = useState(createInitialTodos);
  const [text, setText] = useState('');

  return (
    <>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button onClick={() => {
        setText('');
        setTodos([{
          id: todos.length,
          text: text
        }, ...todos]);
      }}>Add</button>
      <ul>
        {todos.map(item => (
          <li key={item.id}>
            {item.text}
          </li>
        ))}
      </ul>
    </>
  );
}


```


### Resetting state with a key
You’ll often encounter thekeyattribute whenrendering lists.However, it also serves another purpose.

You canreset a component’s state by passing a differentkeyto a component.In this example, the Reset button changes theversionstate variable, which we pass as akeyto theForm. When thekeychanges, React re-creates theFormcomponent (and all of its children) from scratch, so its state gets reset.

Readpreserving and resetting stateto learn more.

```jsx
import { useState } from 'react';

export default function App() {
  const [version, setVersion] = useState(0);

  function handleReset() {
    setVersion(version + 1);
  }

  return (
    <>
      <button onClick={handleReset}>Reset</button>
      <Form key={version} />
    </>
  );
}

function Form() {
  const [name, setName] = useState('Taylor');

  return (
    <>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <p>Hello, {name}.</p>
    </>
  );
}


```


### Storing information from previous renders
Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes.

In most cases, you don’t need this:

- If the value you need can be computed entirely from the current props or other state,remove that redundant state altogether.If you’re worried about recomputing too often, theuseMemoHookcan help.
- If you want to reset the entire component tree’s state,pass a differentkeyto your component.
- If you can, update all the relevant state in the event handlers.
In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling asetfunction while your component is rendering.

Here’s an example. ThisCountLabelcomponent displays thecountprop passed to it:

```jsx
export default function CountLabel({ count }) {  return <h1>{count}</h1>}
```

Say you want to show whether the counter hasincreased or decreasedsince the last change. Thecountprop doesn’t tell you this — you need to keep track of its previous value. Add theprevCountstate variable to track it. Add another state variable calledtrendto hold whether the count has increased or decreased. CompareprevCountwithcount, and if they’re not equal, update bothprevCountandtrend. Now you can show both the current count prop andhow it has changed since the last render.

```jsx
import { useState } from 'react';

export default function CountLabel({ count }) {
  const [prevCount, setPrevCount] = useState(count);
  const [trend, setTrend] = useState(null);
  if (prevCount !== count) {
    setPrevCount(count);
    setTrend(count > prevCount ? 'increasing' : 'decreasing');
  }
  return (
    <>
      <h1>{count}</h1>
      {trend && <p>The count is {trend}</p>}
    </>
  );
}


```

Note that if you call asetfunction while rendering, it must be inside a condition likeprevCount !== count, and there must be a call likesetPrevCount(count)inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of thecurrently renderingcomponent like this. Calling thesetfunction ofanothercomponent during rendering is an error. Finally, yoursetcall should stillupdate state without mutation— this doesn’t mean you can break other rules ofpure functions.

This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call thesetfunction during render, React will re-render that component immediately after your component exits with areturnstatement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an earlyreturn;to restart rendering earlier.


## Troubleshooting

### I’ve updated the state, but logging gives me the old value
Calling thesetfunctiondoes not change state in the running code:

```jsx
function handleClick() {  console.log(count);  // 0  setCount(count + 1); // Request a re-render with 1  console.log(count);  // Still 0!  setTimeout(() => {    console.log(count); // Also 0!  }, 5000);}
```

This is becausestates behaves like a snapshot.Updating state requests another render with the new state value, but does not affect thecountJavaScript variable in your already-running event handler.

If you need to use the next state, you can save it in a variable before passing it to thesetfunction:

```jsx
const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1
```


### I’ve updated the state, but the screen doesn’t update
React willignore your update if the next state is equal to the previous state,as determined by anObject.iscomparison. This usually happens when you change an object or an array in state directly:

```jsx
obj.x = 10;  // 🚩 Wrong: mutating existing objectsetObj(obj); // 🚩 Doesn't do anything
```

You mutated an existingobjobject and passed it back tosetObj, so React ignored the update. To fix this, you need to ensure that you’re alwaysreplacingobjects and arrays in state instead ofmutatingthem:

```jsx
// ✅ Correct: creating a new objectsetObj({  ...obj,  x: 10});
```


### I’m getting an error: “Too many re-renders”
You might get an error that says:Too many re-renders. React limits the number of renders to prevent an infinite loop.Typically, this means that you’re unconditionally setting stateduring render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:

```jsx
// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>
```

If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specificsetfunction call responsible for the error.


### My initializer or updater function runs twice
InStrict Mode, React will call some of your functions twice instead of once:

```jsx
function TodoList() {  // This component function will run twice for every render.  const [todos, setTodos] = useState(() => {    // This initializer function will run twice during initialization.    return createTodos();  });  function handleClick() {    setTodos(prevTodos => {      // This updater function will run twice for every click.      return [...prevTodos, createTodo()];    });  }  // ...
```

This is expected and shouldn’t break your code.

Thisdevelopment-onlybehavior helps youkeep components pure.React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.

For example, this impure updater function mutates an array in state:

```jsx
setTodos(prevTodos => {  // 🚩 Mistake: mutating state  prevTodos.push(createTodo());});
```

Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake byreplacing the array instead of mutating it:

```jsx
setTodos(prevTodos => {  // ✅ Correct: replacing with new state  return [...prevTodos, createTodo()];});
```

Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes.Only component, initializer, and updater functions need to be pure.Event handlers don’t need to be pure, so React will never call your event handlers twice.

Readkeeping components pureto learn more.


### I’m trying to set state to a function, but it gets called instead
You can’t put a function into state like this:

```jsx
const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}
```

Because you’re passing a function, React assumes thatsomeFunctionis aninitializer function, and thatsomeOtherFunctionis anupdater function, so it tries to call them and store the result. To actuallystorea function, you have to put() =>before them in both cases. Then React will store the functions you pass.

```jsx
const [fn, setFn] = useState(() => someFunction);function handleClick() {  setFn(() => someOtherFunction);}
```


--------------------------------------------------------------------------------


# useSyncExternalStore
Source: https://react.dev/reference/react/useSyncExternalStore

useSyncExternalStoreis a React Hook that lets you subscribe to an external store.

```jsx
const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
```

- ReferenceuseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
- useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
- UsageSubscribing to an external storeSubscribing to a browser APIExtracting the logic to a custom HookAdding support for server rendering
- Subscribing to an external store
- Subscribing to a browser API
- Extracting the logic to a custom Hook
- Adding support for server rendering
- TroubleshootingI’m getting an error: “The result ofgetSnapshotshould be cached”Mysubscribefunction gets called after every re-render
- I’m getting an error: “The result ofgetSnapshotshould be cached”
- Mysubscribefunction gets called after every re-render

## Reference

### useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
CalluseSyncExternalStoreat the top level of your component to read a value from an external data store.

```jsx
import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);  // ...}
```

It returns the snapshot of the data in the store. You need to pass two functions as arguments:

1. Thesubscribefunction should subscribe to the store and return a function that unsubscribes.
1. ThegetSnapshotfunction should read a snapshot of the data from the store.
See more examples below.


#### Parameters
- subscribe: A function that takes a singlecallbackargument and subscribes it to the store. When the store changes, it should invoke the providedcallback, which will cause React to re-callgetSnapshotand (if needed) re-render the component. Thesubscribefunction should return a function that cleans up the subscription.
subscribe: A function that takes a singlecallbackargument and subscribes it to the store. When the store changes, it should invoke the providedcallback, which will cause React to re-callgetSnapshotand (if needed) re-render the component. Thesubscribefunction should return a function that cleans up the subscription.

- getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls togetSnapshotmust return the same value. If the store changes and the returned value is different (as compared byObject.is), React re-renders the component.
getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls togetSnapshotmust return the same value. If the store changes and the returned value is different (as compared byObject.is), React re-renders the component.

- optionalgetServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.
optionalgetServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.


#### Returns
The current snapshot of the store which you can use in your rendering logic.


#### Caveats
- The store snapshot returned bygetSnapshotmust be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.
The store snapshot returned bygetSnapshotmust be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.

- If a differentsubscribefunction is passed during a re-render, React will re-subscribe to the store using the newly passedsubscribefunction. You can prevent this by declaringsubscribeoutside the component.
If a differentsubscribefunction is passed during a re-render, React will re-subscribe to the store using the newly passedsubscribefunction. You can prevent this by declaringsubscribeoutside the component.

- If the store is mutated during anon-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will callgetSnapshota second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.
If the store is mutated during anon-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will callgetSnapshota second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.

- It’s not recommended tosuspenda render based on a store value returned byuseSyncExternalStore. The reason is that mutations to the external store cannot be marked asnon-blocking Transition updates, so they will trigger the nearestSuspensefallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.For example, the following are discouraged:constLazyProductDetailPage=lazy(()=>import('./ProductDetailPage.js'));functionShoppingApp(){constselectedProductId=useSyncExternalStore(...);// ❌ Calling `use` with a Promise dependent on `selectedProductId`constdata=use(fetchItem(selectedProductId))// ❌ Conditionally rendering a lazy component based on `selectedProductId`returnselectedProductId!=null?<LazyProductDetailPage/>:<FeaturedProducts/>;}
It’s not recommended tosuspenda render based on a store value returned byuseSyncExternalStore. The reason is that mutations to the external store cannot be marked asnon-blocking Transition updates, so they will trigger the nearestSuspensefallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.

For example, the following are discouraged:

```jsx
const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() {  const selectedProductId = useSyncExternalStore(...);  // ❌ Calling `use` with a Promise dependent on `selectedProductId`  const data = use(fetchItem(selectedProductId))  // ❌ Conditionally rendering a lazy component based on `selectedProductId`  return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;}
```


## Usage

### Subscribing to an external store
Most of your React components will only read data from theirprops,state,andcontext.However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:

- Third-party state management libraries that hold state outside of React.
- Browser APIs that expose a mutable value and events to subscribe to its changes.
CalluseSyncExternalStoreat the top level of your component to read a value from an external data store.

```jsx
import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);  // ...}
```

It returns thesnapshotof the data in the store. You need to pass two functions as arguments:

1. Thesubscribefunctionshould subscribe to the store and return a function that unsubscribes.
1. ThegetSnapshotfunctionshould read a snapshot of the data from the store.
React will use these functions to keep your component subscribed to the store and re-render it on changes.

For example, in the sandbox below,todosStoreis implemented as an external store that stores data outside of React. TheTodosAppcomponent connects to that external store with theuseSyncExternalStoreHook.

```jsx
import { useSyncExternalStore } from 'react';
import { todosStore } from './todoStore.js';

export default function TodosApp() {
  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
  return (
    <>
      <button onClick={() => todosStore.addTodo()}>Add todo</button>
      <hr />
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}


```


### Note
When possible, we recommend using built-in React state withuseStateanduseReducerinstead. TheuseSyncExternalStoreAPI is mostly useful if you need to integrate with existing non-React code.


### Subscribing to a browser API
Another reason to adduseSyncExternalStoreis when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property callednavigator.onLine.

This value can change without React’s knowledge, so you should read it withuseSyncExternalStore.

```jsx
import { useSyncExternalStore } from 'react';function ChatIndicator() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}
```

To implement thegetSnapshotfunction, read the current value from the browser API:

```jsx
function getSnapshot() {  return navigator.onLine;}
```

Next, you need to implement thesubscribefunction. For example, whennavigator.onLinechanges, the browser fires theonlineandofflineevents on thewindowobject. You need to subscribe thecallbackargument to the corresponding events, and then return a function that cleans up the subscriptions:

```jsx
function subscribe(callback) {  window.addEventListener('online', callback);  window.addEventListener('offline', callback);  return () => {    window.removeEventListener('online', callback);    window.removeEventListener('offline', callback);  };}
```

Now React knows how to read the value from the externalnavigator.onLineAPI and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:

```jsx
import { useSyncExternalStore } from 'react';

export default function ChatIndicator() {
  const isOnline = useSyncExternalStore(subscribe, getSnapshot);
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function getSnapshot() {
  return navigator.onLine;
}

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}


```


### Extracting the logic to a custom Hook
Usually you won’t writeuseSyncExternalStoredirectly in your components. Instead, you’ll typically call it from your own custom Hook. This lets you use the same external store from different components.

For example, this customuseOnlineStatusHook tracks whether the network is online:

```jsx
import { useSyncExternalStore } from 'react';export function useOnlineStatus() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  return isOnline;}function getSnapshot() {  // ...}function subscribe(callback) {  // ...}
```

Now different components can calluseOnlineStatuswithout repeating the underlying implementation:

```jsx
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}


```


### Adding support for server rendering
If your React app usesserver rendering,your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:

- If you’re connecting to a browser-only API, it won’t work because it does not exist on the server.
- If you’re connecting to a third-party data store, you’ll need its data to match between the server and client.
To solve these issues, pass agetServerSnapshotfunction as the third argument touseSyncExternalStore:

```jsx
import { useSyncExternalStore } from 'react';export function useOnlineStatus() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);  return isOnline;}function getSnapshot() {  return navigator.onLine;}function getServerSnapshot() {  return true; // Always show "Online" for server-generated HTML}function subscribe(callback) {  // ...}
```

ThegetServerSnapshotfunction is similar togetSnapshot, but it runs only in two situations:

- It runs on the server when generating the HTML.
- It runs on the client duringhydration, i.e. when React takes the server HTML and makes it interactive.
This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument toforce rendering on the client.


### Note
Make sure thatgetServerSnapshotreturns the same exact data on the initial client render as it returned on the server. For example, ifgetServerSnapshotreturned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a<script>tag during server rendering that sets a global likewindow.MY_STORE_DATA, and read from that global on the client ingetServerSnapshot. Your external store should provide instructions on how to do that.


## Troubleshooting

### I’m getting an error: “The result ofgetSnapshotshould be cached”
This error means yourgetSnapshotfunction returns a new object every time it’s called, for example:

```jsx
function getSnapshot() {  // 🔴 Do not return always different objects from getSnapshot  return {    todos: myStore.todos  };}
```

React will re-render the component ifgetSnapshotreturn value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.

YourgetSnapshotobject should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:

```jsx
function getSnapshot() {  // ✅ You can return immutable data  return myStore.todos;}
```

If your store data is mutable, yourgetSnapshotfunction should return an immutable snapshot of it. This means itdoesneed to create new objects, but it shouldn’t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.


### Mysubscribefunction gets called after every re-render
Thissubscribefunction is definedinsidea component so it is different on every re-render:

```jsx
function ChatIndicator() {  // 🚩 Always a different function, so React will resubscribe on every re-render  function subscribe() {    // ...  }    const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}
```

React will resubscribe to your store if you pass a differentsubscribefunction between re-renders. If this causes performance issues and you’d like to avoid resubscribing, move thesubscribefunction outside:

```jsx
// ✅ Always the same function, so React won't need to resubscribefunction subscribe() {  // ...}function ChatIndicator() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}
```

Alternatively, wrapsubscribeintouseCallbackto only resubscribe when some argument changes:

```jsx
function ChatIndicator({ userId }) {  // ✅ Same function as long as userId doesn't change  const subscribe = useCallback(() => {    // ...  }, [userId]);    const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}
```


--------------------------------------------------------------------------------


# useTransition
Source: https://react.dev/reference/react/useTransition

useTransitionis a React Hook that lets you render a part of the UI in the background.

```jsx
const [isPending, startTransition] = useTransition()
```

- ReferenceuseTransition()startTransition(action)
- useTransition()
- startTransition(action)
- UsagePerform non-blocking updates with ActionsExposingactionprop from componentsDisplaying a pending visual statePreventing unwanted loading indicatorsBuilding a Suspense-enabled routerDisplaying an error to users with an error boundary
- Perform non-blocking updates with Actions
- Exposingactionprop from components
- Displaying a pending visual state
- Preventing unwanted loading indicators
- Building a Suspense-enabled router
- Displaying an error to users with an error boundary
- TroubleshootingUpdating an input in a Transition doesn’t workReact doesn’t treat my state update as a TransitionReact doesn’t treat my state update afterawaitas a TransitionI want to calluseTransitionfrom outside a componentThe function I pass tostartTransitionexecutes immediatelyMy state updates in Transitions are out of order
- Updating an input in a Transition doesn’t work
- React doesn’t treat my state update as a Transition
- React doesn’t treat my state update afterawaitas a Transition
- I want to calluseTransitionfrom outside a component
- The function I pass tostartTransitionexecutes immediately
- My state updates in Transitions are out of order

## Reference

### useTransition()
CalluseTransitionat the top level of your component to mark some state updates as Transitions.

```jsx
import { useTransition } from 'react';function TabContainer() {  const [isPending, startTransition] = useTransition();  // ...}
```

See more examples below.


#### Parameters
useTransitiondoes not take any parameters.


#### Returns
useTransitionreturns an array with exactly two items:

1. TheisPendingflag that tells you whether there is a pending Transition.
1. ThestartTransitionfunctionthat lets you mark updates as a Transition.

### startTransition(action)
ThestartTransitionfunction returned byuseTransitionlets you mark an update as a Transition.

```jsx
function TabContainer() {  const [isPending, startTransition] = useTransition();  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
```


### Note

#### Functions called instartTransitionare called “Actions”.
The function passed tostartTransitionis called an “Action”. By convention, any callback called insidestartTransition(such as a callback prop) should be namedactionor include the “Action” suffix:

```jsx
function SubmitButton({ submitAction }) {  const [isPending, startTransition] = useTransition();  return (    <button      disabled={isPending}      onClick={() => {        startTransition(async () => {          await submitAction();        });      }}    >      Submit    </button>  );}
```


#### Parameters
- action: A function that updates some state by calling one or moresetfunctions. React callsactionimmediately with no parameters and marks all state updates scheduled synchronously during theactionfunction call as Transitions. Any async calls that are awaited in theactionwill be included in the Transition, but currently require wrapping anysetfunctions after theawaitin an additionalstartTransition(seeTroubleshooting). State updates marked as Transitions will benon-blockingandwill not display unwanted loading indicators.

#### Returns
startTransitiondoes not return anything.


#### Caveats
- useTransitionis a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalonestartTransitioninstead.
useTransitionis a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalonestartTransitioninstead.

- You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook value, tryuseDeferredValueinstead.
You can wrap an update into a Transition only if you have access to thesetfunction of that state. If you want to start a Transition in response to some prop or a custom Hook value, tryuseDeferredValueinstead.

- The function you pass tostartTransitionis called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in asetTimeout, for example, they won’t be marked as Transitions.
The function you pass tostartTransitionis called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in asetTimeout, for example, they won’t be marked as Transitions.

- You must wrap any state updates after any async requests in anotherstartTransitionto mark them as Transitions. This is a known limitation that we will fix in the future (seeTroubleshooting).
You must wrap any state updates after any async requests in anotherstartTransitionto mark them as Transitions. This is a known limitation that we will fix in the future (seeTroubleshooting).

- ThestartTransitionfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.
ThestartTransitionfunction has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do.Learn more about removing Effect dependencies.

- A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.
A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.

- Transition updates can’t be used to control text inputs.
Transition updates can’t be used to control text inputs.

- If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.
If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.


## Usage

### Perform non-blocking updates with Actions
CalluseTransitionat the top of your component to create Actions, and access the pending state:

```jsx
import {useState, useTransition} from 'react';function CheckoutForm() {  const [isPending, startTransition] = useTransition();  // ...}
```

useTransitionreturns an array with exactly two items:

1. TheisPendingflagthat tells you whether there is a pending Transition.
1. ThestartTransitionfunctionthat lets you create an Action.
To start a Transition, pass a function tostartTransitionlike this:

```jsx
import {useState, useTransition} from 'react';import {updateQuantity} from './api';function CheckoutForm() {  const [isPending, startTransition] = useTransition();  const [quantity, setQuantity] = useState(1);  function onSubmit(newQuantity) {    startTransition(async function () {      const savedQuantity = await updateQuantity(newQuantity);      startTransition(() => {        setQuantity(savedQuantity);      });    });  }  // ...}
```

The function passed tostartTransitionis called the “Action”. You can update state and (optionally) perform side effects within an Action, and the work will be done in the background without blocking user interactions on the page. A Transition can include multiple Actions, and while a Transition is in progress, your UI stays responsive. For example, if the user clicks a tab but then changes their mind and clicks another tab, the second click will be immediately handled without waiting for the first update to finish.

To give the user feedback about in-progress Transitions, theisPendingstate switches totrueat the first call tostartTransition, and staystrueuntil all Actions complete and the final state is shown to the user. Transitions ensure side effects in Actions to complete in order toprevent unwanted loading indicators, and you can provide immediate feedback while the Transition is in progress withuseOptimistic.


#### The difference between Actions and regular event handling

#### Example1of2:Updating the quantity in an Action
In this example, theupdateQuantityfunction simulates a request to the server to update the item’s quantity in the cart. This function isartificially slowed downso that it takes at least a second to complete the request.

Update the quantity multiple times quickly. Notice that the pending “Total” state is shown while any requests are in progress, and the “Total” updates only after the final request is complete. Because the update is in an Action, the “quantity” can continue to be updated while the request is in progress.

```jsx
import { useState, useTransition } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
  const [quantity, setQuantity] = useState(1);
  const [isPending, startTransition] = useTransition();

  const updateQuantityAction = async newQuantity => {
    // To access the pending state of a transition,
    // call startTransition again.
    startTransition(async () => {
      const savedQuantity = await updateQuantity(newQuantity);
      startTransition(() => {
        setQuantity(savedQuantity);
      });
    });
  };

  return (
    <div>
      <h1>Checkout</h1>
      <Item action={updateQuantityAction}/>
      <hr />
      <Total quantity={quantity} isPending={isPending} />
    </div>
  );
}


```

This is a basic example to demonstrate how Actions work, but this example does not handle requests completing out of order. When updating the quantity multiple times, it’s possible for the previous requests to finish after later requests causing the quantity to update out of order. This is a known limitation that we will fix in the future (seeTroubleshootingbelow).

For common use cases, React provides built-in abstractions such as:

- useActionState
- <form>actions
- Server Functions
These solutions handle request ordering for you. When using Transitions to build your own custom hooks or libraries that manage async state transitions, you have greater control over the request ordering, but you must handle it yourself.


### Exposingactionprop from components
You can expose anactionprop from a component to allow a parent to call an Action.

For example, thisTabButtoncomponent wraps itsonClicklogic in anactionprop:

```jsx
export default function TabButton({ action, children, isActive }) {  const [isPending, startTransition] = useTransition();  if (isActive) {    return <b>{children}</b>  }  return (    <button onClick={() => {      startTransition(async () => {        // await the action that's passed in.        // This allows it to be either sync or async.        await action();      });    }}>      {children}    </button>  );}
```

Because the parent component updates its state inside theaction, that state update gets marked as a Transition. This means you can click on “Posts” and then immediately click “Contact” and it does not block user interactions:

```jsx
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={async () => {
      startTransition(async () => {
        // await the action that's passed in.
        // This allows it to be either sync or async.
        await action();
      });
    }}>
      {children}
    </button>
  );
}


```


### Note
When exposing anactionprop from a component, you shouldawaitit inside the transition.

This allows theactioncallback to be either synchronous or asynchronous without requiring an additionalstartTransitionto wrap theawaitin the action.


### Displaying a pending visual state
You can use theisPendingboolean value returned byuseTransitionto indicate to the user that a Transition is in progress. For example, the tab button can have a special “pending” visual state:

```jsx
function TabButton({ action, children, isActive }) {  const [isPending, startTransition] = useTransition();  // ...  if (isPending) {    return <b className="pending">{children}</b>;  }  // ...
```

Notice how clicking “Posts” now feels more responsive because the tab button itself updates right away:

```jsx
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={() => {
      startTransition(async () => {
        await action();
      });
    }}>
      {children}
    </button>
  );
}


```


### Preventing unwanted loading indicators
In this example, thePostsTabcomponent fetches some data usinguse. When you click the “Posts” tab, thePostsTabcomponentsuspends, causing the closest loading fallback to appear:

```jsx
import { Suspense, useState } from 'react';
import TabButton from './TabButton.js';
import AboutTab from './AboutTab.js';
import PostsTab from './PostsTab.js';
import ContactTab from './ContactTab.js';

export default function TabContainer() {
  const [tab, setTab] = useState('about');
  return (
    <Suspense fallback={<h1>🌀 Loading...</h1>}>
      <TabButton
        isActive={tab === 'about'}
        action={() => setTab('about')}
      >
        About
      </TabButton>
      <TabButton
        isActive={tab === 'posts'}
        action={() => setTab('posts')}
      >
        Posts
      </TabButton>
      <TabButton
        isActive={tab === 'contact'}
        action={() => setTab('contact')}
      >
        Contact
      </TabButton>
      <hr />
      {tab === 'about' && <AboutTab />}
      {tab === 'posts' && <PostsTab />}
      {tab === 'contact' && <ContactTab />}
    </Suspense>
  );
}


```

Hiding the entire tab container to show a loading indicator leads to a jarring user experience. If you adduseTransitiontoTabButton, you can instead display the pending state in the tab button instead.

Notice that clicking “Posts” no longer replaces the entire tab container with a spinner:

```jsx
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={() => {
      startTransition(async () => {
        await action();
      });
    }}>
      {children}
    </button>
  );
}


```

Read more about using Transitions with Suspense.


### Note
Transitions only “wait” long enough to avoid hidingalready revealedcontent (like the tab container). If the Posts tab had anested<Suspense>boundary,the Transition would not “wait” for it.


### Building a Suspense-enabled router
If you’re building a React framework or a router, we recommend marking page navigations as Transitions.

```jsx
function Router() {  const [page, setPage] = useState('/');  const [isPending, startTransition] = useTransition();  function navigate(url) {    startTransition(() => {      setPage(url);    });  }  // ...
```

This is recommended for three reasons:

- Transitions are interruptible,which lets the user click away without waiting for the re-render to complete.
- Transitions prevent unwanted loading indicators,which lets the user avoid jarring jumps on navigation.
- Transitions wait for all pending actionswhich lets the user wait for side effects to complete before the new page is shown.
Here is a simplified router example using Transitions for navigations.

```jsx
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout isPending={isPending}>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}


```


### Note
Suspense-enabledrouters are expected to wrap the navigation updates into Transitions by default.


### Displaying an error to users with an error boundary
If a function passed tostartTransitionthrows an error, you can display an error to your user with anerror boundary. To use an error boundary, wrap the component where you are calling theuseTransitionin an error boundary. Once the function passed tostartTransitionerrors, the fallback for the error boundary will be displayed.

```jsx
import { useTransition } from "react";
import { ErrorBoundary } from "react-error-boundary";

export function AddCommentContainer() {
  return (
    <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
      <AddCommentButton />
    </ErrorBoundary>
  );
}

function addComment(comment) {
  // For demonstration purposes to show Error Boundary
  if (comment == null) {
    throw new Error("Example Error: An error thrown to trigger error boundary");
  }
}

function AddCommentButton() {
  const [pending, startTransition] = useTransition();

  return (
    <button
      disabled={pending}
      onClick={() => {
        startTransition(() => {
          // Intentionally not passing a comment
          // so error gets thrown
          addComment();
        });
      }}
    >
      Add comment
    </button>
  );
}


```


## Troubleshooting

### Updating an input in a Transition doesn’t work
You can’t use a Transition for a state variable that controls an input:

```jsx
const [text, setText] = useState('');// ...function handleChange(e) {  // ❌ Can't use Transitions for controlled input state  startTransition(() => {    setText(e.target.value);  });}// ...return <input value={text} onChange={handleChange} />;
```

This is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:

1. You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will “lag behind” the input) to the rest of your rendering logic.
1. Alternatively, you can have one state variable, and adduseDeferredValuewhich will “lag behind” the real value. It will trigger non-blocking re-renders to “catch up” with the new value automatically.

### React doesn’t treat my state update as a Transition
When you wrap a state update in a Transition, make sure that it happensduringthestartTransitioncall:

```jsx
startTransition(() => {  // ✅ Setting state *during* startTransition call  setPage('/about');});
```

The function you pass tostartTransitionmust be synchronous. You can’t mark an update as a Transition like this:

```jsx
startTransition(() => {  // ❌ Setting state *after* startTransition call  setTimeout(() => {    setPage('/about');  }, 1000);});
```

Instead, you could do this:

```jsx
setTimeout(() => {  startTransition(() => {    // ✅ Setting state *during* startTransition call    setPage('/about');  });}, 1000);
```


### React doesn’t treat my state update afterawaitas a Transition
When you useawaitinside astartTransitionfunction, the state updates that happen after theawaitare not marked as Transitions. You must wrap state updates after eachawaitin astartTransitioncall:

```jsx
startTransition(async () => {  await someAsyncFunction();  // ❌ Not using startTransition after await  setPage('/about');});
```

However, this works instead:

```jsx
startTransition(async () => {  await someAsyncFunction();  // ✅ Using startTransition *after* await  startTransition(() => {    setPage('/about');  });});
```

This is a JavaScript limitation due to React losing the scope of the async context. In the future, whenAsyncContextis available, this limitation will be removed.


### I want to calluseTransitionfrom outside a component
You can’t calluseTransitionoutside a component because it’s a Hook. In this case, use the standalonestartTransitionmethod instead. It works the same way, but it doesn’t provide theisPendingindicator.


### The function I pass tostartTransitionexecutes immediately
If you run this code, it will print 1, 2, 3:

```jsx
console.log(1);startTransition(() => {  console.log(2);  setPage('/about');});console.log(3);
```

It is expected to print 1, 2, 3.The function you pass tostartTransitiondoes not get delayed. Unlike with the browsersetTimeout, it does not run the callback later. React executes your function immediately, but any state updates scheduledwhile it is runningare marked as Transitions. You can imagine that it works like this:

```jsx
// A simplified version of how React workslet isInsideTransition = false;function startTransition(scope) {  isInsideTransition = true;  scope();  isInsideTransition = false;}function setState() {  if (isInsideTransition) {    // ... schedule a Transition state update ...  } else {    // ... schedule an urgent state update ...  }}
```


### My state updates in Transitions are out of order
If youawaitinsidestartTransition, you might see the updates happen out of order.

In this example, theupdateQuantityfunction simulates a request to the server to update the item’s quantity in the cart. This functionartificially returns every other request after the previousto simulate race conditions for network requests.

Try updating the quantity once, then update it quickly multiple times. You might see the incorrect total:

```jsx
import { useState, useTransition } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
  const [quantity, setQuantity] = useState(1);
  const [isPending, startTransition] = useTransition();
  // Store the actual quantity in separate state to show the mismatch.
  const [clientQuantity, setClientQuantity] = useState(1);

  const updateQuantityAction = newQuantity => {
    setClientQuantity(newQuantity);

    // Access the pending state of the transition,
    // by wrapping in startTransition again.
    startTransition(async () => {
      const savedQuantity = await updateQuantity(newQuantity);
      startTransition(() => {
        setQuantity(savedQuantity);
      });
    });
  };

  return (
    <div>
      <h1>Checkout</h1>
      <Item action={updateQuantityAction}/>
      <hr />
      <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />
    </div>
  );
}


```

When clicking multiple times, it’s possible for previous requests to finish after later requests. When this happens, React currently has no way to know the intended order. This is because the updates are scheduled asynchronously, and React loses context of the order across the async boundary.

This is expected, because Actions within a Transition do not guarantee execution order. For common use cases, React provides higher-level abstractions likeuseActionStateand<form>actionsthat handle ordering for you. For advanced use cases, you’ll need to implement your own queuing and abort logic to handle this.

Example ofuseActionStatehandling execution order:

```jsx
import { useState, useActionState } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
  // Store the actual quantity in separate state to show the mismatch.
  const [clientQuantity, setClientQuantity] = useState(1);
  const [quantity, updateQuantityAction, isPending] = useActionState(
    async (prevState, payload) => {
      setClientQuantity(payload);
      const savedQuantity = await updateQuantity(payload);
      return savedQuantity; // Return the new quantity to update the state
    },
    1 // Initial quantity
  );

  return (
    <div>
      <h1>Checkout</h1>
      <Item action={updateQuantityAction}/>
      <hr />
      <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />
    </div>
  );
}


```


--------------------------------------------------------------------------------


# Directives
Source: https://react.dev/reference/rsc/directives


### React Server Components
Directives are for use inReact Server Components.

Directives provide instructions tobundlers compatible with React Server Components.


## Source code directives
- 'use client'lets you mark what code runs on the client.
- 'use server'marks server-side functions that can be called from client-side code.

--------------------------------------------------------------------------------


# Server Components
Source: https://react.dev/reference/rsc/server-components

Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.

This separate environment is the “server” in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.

- Server Components without a Server
- Server Components with a Server
- Adding interactivity to Server Components
- Async components with Server Components

### Note

#### How do I build support for Server Components?
While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future.


### Server Components without a Server
Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.

Without Server Components, it’s common to fetch static data on the client with an Effect:

```jsx
// bundle.jsimport marked from 'marked'; // 35.9K (11.2K gzipped)import sanitizeHtml from 'sanitize-html'; // 206K (63.3K gzipped)function Page({page}) {  const [content, setContent] = useState('');  // NOTE: loads *after* first page render.  useEffect(() => {    fetch(`/api/content/${page}`).then((data) => {      setContent(data.content);    });  }, [page]);  return <div>{sanitizeHtml(marked(content))}</div>;}
```

```jsx
// api.jsapp.get(`/api/content/:page`, async (req, res) => {  const page = req.params.page;  const content = await file.readFile(`${page}.md`);  res.send({content});});
```

This pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page.

With Server Components, you can render these components once at build time:

```jsx
import marked from 'marked'; // Not included in bundleimport sanitizeHtml from 'sanitize-html'; // Not included in bundleasync function Page({page}) {  // NOTE: loads *during* render, when the app is built.  const content = await file.readFile(`${page}.md`);  return <div>{sanitizeHtml(marked(content))}</div>;}
```

The rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the originalPagecomponent, or the expensive libraries for rendering the markdown. The client will only see the rendered output:

```jsx
<div><!-- html for markdown --></div>
```

This means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content.


### Note
You may notice that the Server Component above is an async function:

```jsx
async function Page({page}) {  //...}
```

Async Components are a new feature of Server Components that allow you toawaitin render.

SeeAsync components with Server Componentsbelow.


### Server Components with a Server
Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.

Without Server Components, it’s common to fetch dynamic data on the client in an Effect:

```jsx
// bundle.jsfunction Note({id}) {  const [note, setNote] = useState('');  // NOTE: loads *after* first render.  useEffect(() => {    fetch(`/api/notes/${id}`).then(data => {      setNote(data.note);    });  }, [id]);  return (    <div>      <Author id={note.authorId} />      <p>{note}</p>    </div>  );}function Author({id}) {  const [author, setAuthor] = useState('');  // NOTE: loads *after* Note renders.  // Causing an expensive client-server waterfall.  useEffect(() => {    fetch(`/api/authors/${id}`).then(data => {      setAuthor(data.author);    });  }, [id]);  return <span>By: {author.name}</span>;}
```

```jsx
// apiimport db from './database';app.get(`/api/notes/:id`, async (req, res) => {  const note = await db.notes.get(id);  res.send({note});});app.get(`/api/authors/:id`, async (req, res) => {  const author = await db.authors.get(id);  res.send({author});});
```

With Server Components, you can read the data and render it in the component:

```jsx
import db from './database';async function Note({id}) {  // NOTE: loads *during* render.  const note = await db.notes.get(id);  return (    <div>      <Author id={note.authorId} />      <p>{note}</p>    </div>  );}async function Author({id}) {  // NOTE: loads *after* Note,  // but is fast if data is co-located.  const author = await db.authors.get(id);  return <span>By: {author.name}</span>;}
```

The bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the originalNoteandAuthorcomponents; only the rendered output is sent to the client:

```jsx
<div>  <span>By: The React Team</span>  <p>React 19 is...</p></div>
```

Server Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple “request/response” mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.


### Adding interactivity to Server Components
Server Components are not sent to the browser, so they cannot use interactive APIs likeuseState. To add interactivity to Server Components, you can compose them with Client Component using the"use client"directive.


### Note

#### There is no directive for Server Components.
A common misunderstanding is that Server Components are denoted by"use server", but there is no directive for Server Components. The"use server"directive is used for Server Functions.

For more info, see the docs forDirectives.

In the following example, theNotesServer Component imports anExpandableClient Component that uses state to toggle itsexpandedstate:

```jsx
// Server Componentimport Expandable from './Expandable';async function Notes() {  const notes = await db.notes.getAll();  return (    <div>      {notes.map(note => (        <Expandable key={note.id}>          <p note={note} />        </Expandable>      ))}    </div>  )}
```

```jsx
// Client Component"use client"export default function Expandable({children}) {  const [expanded, setExpanded] = useState(false);  return (    <div>      <button        onClick={() => setExpanded(!expanded)}      >        Toggle      </button>      {expanded && children}    </div>  )}
```

This works by first renderingNotesas a Server Component, and then instructing the bundler to create a bundle for the Client ComponentExpandable. In the browser, the Client Components will see output of the Server Components passed as props:

```jsx
<head>  <!-- the bundle for Client Components -->  <script src="bundle.js" /></head><body>  <div>    <Expandable key={1}>      <p>this is the first note</p>    </Expandable>    <Expandable key={2}>      <p>this is the second note</p>    </Expandable>    <!--...-->  </div></body>
```


### Async components with Server Components
Server Components introduce a new way to write Components using async/await. When youawaitin an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.

You can even create a promise on the server, and await it on the client:

```jsx
// Server Componentimport db from './database';async function Page({id}) {  // Will suspend the Server Component.  const note = await db.notes.get(id);  // NOTE: not awaited, will start here and await on the client.  const commentsPromise = db.comments.get(note.id);  return (    <div>      {note}      <Suspense fallback={<p>Loading Comments...</p>}>        <Comments commentsPromise={commentsPromise} />      </Suspense>    </div>  );}
```

```jsx
// Client Component"use client";import {use} from 'react';function Comments({commentsPromise}) {  // NOTE: this will resume the promise from the server.  // It will suspend until the data is available.  const comments = use(commentsPromise);  return comments.map(comment => <p>{comment}</p>);}
```

Thenotecontent is important data for the page to render, so weawaitit on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with theuseAPI. This will Suspend on the client, without blocking thenotecontent from rendering.

Since async components are not supported on the client, we await the promise withuse.


--------------------------------------------------------------------------------


# Server Functions
Source: https://react.dev/reference/rsc/server-functions


### React Server Components
Server Functions are for use inReact Server Components.

Note:Until September 2024, we referred to all Server Functions as “Server Actions”. If a Server Function is passed to an action prop or called from inside an action then it is a Server Action, but not all Server Functions are Server Actions. The naming in this documentation has been updated to reflect that Server Functions can be used for multiple purposes.

Server Functions allow Client Components to call async functions executed on the server.


### Note

#### How do I build support for Server Functions?
While Server Functions in React 19 are stable and will not break between minor versions, the underlying APIs used to implement Server Functions in a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support Server Functions as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement Server Functions in the future.

When a Server Function is defined with the"use server"directive, your framework will automatically create a reference to the Server Function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.

Server Functions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.


## Usage

### Creating a Server Function from a Server Component
Server Components can define Server Functions with the"use server"directive:

```jsx
// Server Componentimport Button from './Button';function EmptyNote () {  async function createNoteAction() {    // Server Function    'use server';        await db.notes.create();  }  return <Button onClick={createNoteAction}/>;}
```

When React renders theEmptyNoteServer Component, it will create a reference to thecreateNoteActionfunction, and pass that reference to theButtonClient Component. When the button is clicked, React will send a request to the server to execute thecreateNoteActionfunction with the reference provided:

```jsx
"use client";export default function Button({onClick}) {   console.log(onClick);   // {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNoteAction'}  return <button onClick={() => onClick()}>Create Empty Note</button>}
```

For more, see the docs for"use server".


### Importing Server Functions from Client Components
Client Components can import Server Functions from files that use the"use server"directive:

```jsx
"use server";export async function createNote() {  await db.notes.create();}
```

When the bundler builds theEmptyNoteClient Component, it will create a reference to thecreateNotefunction in the bundle. When thebuttonis clicked, React will send a request to the server to execute thecreateNotefunction using the reference provided:

```jsx
"use client";import {createNote} from './actions';function EmptyNote() {  console.log(createNote);  // {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNote'}  <button onClick={() => createNote()} />}
```

For more, see the docs for"use server".


### Server Functions with Actions
Server Functions can be called from Actions on the client:

```jsx
"use server";export async function updateName(name) {  if (!name) {    return {error: 'Name is required'};  }  await db.users.updateName(name);}
```

```jsx
"use client";import {updateName} from './actions';function UpdateName() {  const [name, setName] = useState('');  const [error, setError] = useState(null);  const [isPending, startTransition] = useTransition();  const submitAction = async () => {    startTransition(async () => {      const {error} = await updateName(name);      if (error) {        setError(error);      } else {        setName('');      }    })  }    return (    <form action={submitAction}>      <input type="text" name="name" disabled={isPending}/>      {error && <span>Failed: {error}</span>}    </form>  )}
```

This allows you to access theisPendingstate of the Server Function by wrapping it in an Action on the client.

For more, see the docs forCalling a Server Function outside of<form>


### Server Functions with Form Actions
Server Functions work with the new Form features in React 19.

You can pass a Server Function to a Form to automatically submit the form to the server:

```jsx
"use client";import {updateName} from './actions';function UpdateName() {  return (    <form action={updateName}>      <input type="text" name="name" />    </form>  )}
```

When the Form submission succeeds, React will automatically reset the form. You can adduseActionStateto access the pending state, last response, or to support progressive enhancement.

For more, see the docs forServer Functions in Forms.


### Server Functions withuseActionState
You can call Server Functions withuseActionStatefor the common case where you just need access to the action pending state and last returned response:

```jsx
"use client";import {updateName} from './actions';function UpdateName() {  const [state, submitAction, isPending] = useActionState(updateName, {error: null});  return (    <form action={submitAction}>      <input type="text" name="name" disabled={isPending}/>      {state.error && <span>Failed: {state.error}</span>}    </form>  );}
```

When usinguseActionStatewith Server Functions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated.

For more, see the docs foruseActionState.


### Progressive enhancement withuseActionState
Server Functions also support progressive enhancement with the third argument ofuseActionState.

```jsx
"use client";import {updateName} from './actions';function UpdateName() {  const [, submitAction] = useActionState(updateName, null, `/name/update`);  return (    <form action={submitAction}>      ...    </form>  );}
```

When thepermalinkis provided touseActionState, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads.

For more, see the docs foruseActionState.


--------------------------------------------------------------------------------


# 'use client'
Source: https://react.dev/reference/rsc/use-client


### React Server Components
'use client'is for use withReact Server Components.

'use client'lets you mark what code runs on the client.

- Reference'use client'How'use client'marks client codeWhen to use'use client'Serializable types returned by Server Components
- 'use client'
- How'use client'marks client code
- When to use'use client'
- Serializable types returned by Server Components
- UsageBuilding with interactivity and stateUsing client APIsUsing third-party libraries
- Building with interactivity and state
- Using client APIs
- Using third-party libraries

## Reference

### 'use client'
Add'use client'at the top of a file to mark the module and its transitive dependencies as client code.

```jsx
'use client';import { useState } from 'react';import { formatDate } from './formatters';import Button from './button';export default function RichTextEditor({ timestamp, text }) {  const date = formatDate(timestamp);  // ...  const editButton = <Button />;  // ...}
```

When a file marked with'use client'is imported from a Server Component,compatible bundlerswill treat the module import as a boundary between server-run and client-run code.

As dependencies ofRichTextEditor,formatDateandButtonwill also be evaluated on the client regardless of whether their modules contain a'use client'directive. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code.


#### Caveats
- 'use client'must be at the very beginning of a file, above any imports or other code (comments are OK). They must be written with single or double quotes, but not backticks.
- When a'use client'module is imported from another client-rendered module, the directive has no effect.
- When a component module contains a'use client'directive, any usage of that component is guaranteed to be a Client Component. However, a component can still be evaluated on the client even if it does not have a'use client'directive.A component usage is considered a Client Component if it is defined in module with'use client'directive or when it is a transitive dependency of a module that contains a'use client'directive. Otherwise, it is a Server Component.
- A component usage is considered a Client Component if it is defined in module with'use client'directive or when it is a transitive dependency of a module that contains a'use client'directive. Otherwise, it is a Server Component.
- Code that is marked for client evaluation is not limited to components. All code that is a part of the Client module sub-tree is sent to and run by the client.
- When a server evaluated module imports values from a'use client'module, the values must either be a React component orsupported serializable prop valuesto be passed to a Client Component. Any other use case will throw an exception.

### How'use client'marks client code
In a React app, components are often split into separate files, ormodules.

For apps that use React Server Components, the app is server-rendered by default.'use client'introduces a server-client boundary in themodule dependency tree, effectively creating a subtree of Client modules.

To better illustrate this, consider the following React Server Components app.

```jsx
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
  return (
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
  );
}


```

In the module dependency tree of this example app, the'use client'directive inInspirationGenerator.jsmarks that module and all of its transitive dependencies as Client modules. The subtree starting atInspirationGenerator.jsis now marked as Client modules.

'use client'segments the module dependency tree of the React Server Components app, markingInspirationGenerator.jsand all of its dependencies as client-rendered.

During render, the framework will server-render the root component and continue through therender tree, opting-out of evaluating any code imported from client-marked code.

The server-rendered portion of the render tree is then sent to the client. The client, with its client code downloaded, then completes rendering the rest of the tree.

The render tree for the React Server Components app.InspirationGeneratorand its child componentFancyTextare components exported from client-marked code and considered Client Components.

We introduce the following definitions:

- Client Componentsare components in a render tree that are rendered on the client.
- Server Componentsare components in a render tree that are rendered on the server.
Working through the example app,App,FancyTextandCopyrightare all server-rendered and considered Server Components. AsInspirationGenerator.jsand its transitive dependencies are marked as client code, the componentInspirationGeneratorand its child componentFancyTextare Client Components.


#### How isFancyTextboth a Server and a Client Component?
By the above definitions, the componentFancyTextis both a Server and Client Component, how can that be?

First, let’s clarify that the term “component” is not very precise. Here are just two ways “component” can be understood:

1. A “component” can refer to acomponent definition. In most cases this will be a function.
```jsx
// This is a definition of a componentfunction MyComponent() {  return <p>My Component</p>}
```

1. A “component” can also refer to acomponent usageof its definition.
```jsx
import MyComponent from './MyComponent';function App() {  // This is a usage of a component  return <MyComponent />;}
```

Often, the imprecision is not important when explaining concepts, but in this case it is.

When we talk about Server or Client Components, we are referring to component usages.

- If the component is defined in a module with a'use client'directive, or the component is imported and called in a Client Component, then the component usage is a Client Component.
- Otherwise, the component usage is a Server Component.
Back to the question ofFancyText, we see that the component definition doesnothave a'use client'directive and it has two usages.

The usage ofFancyTextas a child ofApp, marks that usage as a Server Component. WhenFancyTextis imported and called underInspirationGenerator, that usage ofFancyTextis a Client Component asInspirationGeneratorcontains a'use client'directive.

This means that the component definition forFancyTextwill both be evaluated on the server and also downloaded by the client to render its Client Component usage.


#### Why isCopyrighta Server Component?
BecauseCopyrightis rendered as a child of the Client ComponentInspirationGenerator, you might be surprised that it is a Server Component.

Recall that'use client'defines the boundary between server and client code on themodule dependency tree, not the render tree.

'use client'defines the boundary between server and client code on the module dependency tree.

In the module dependency tree, we see thatApp.jsimports and callsCopyrightfrom theCopyright.jsmodule. AsCopyright.jsdoes not contain a'use client'directive, the component usage is rendered on the server.Appis rendered on the server as it is the root component.

Client Components can render Server Components because you can pass JSX as props. In this case,InspirationGeneratorreceivesCopyrightaschildren. However, theInspirationGeneratormodule never directly imports theCopyrightmodule nor calls the component, all of that is done byApp. In fact, theCopyrightcomponent is fully executed beforeInspirationGeneratorstarts rendering.

The takeaway is that a parent-child render relationship between components does not guarantee the same render environment.


### When to use'use client'
With'use client', you can determine when components are Client Components. As Server Components are default, here is a brief overview of the advantages and limitations to Server Components to determine when you need to mark something as client rendered.

For simplicity, we talk about Server Components, but the same principles apply to all code in your app that is server run.


#### Advantages of Server Components
- Server Components can reduce the amount of code sent and run by the client. Only Client modules are bundled and evaluated by the client.
- Server Components benefit from running on the server. They can access the local filesystem and may experience low latency for data fetches and network requests.

#### Limitations of Server Components
- Server Components cannot support interaction as event handlers must be registered and triggered by a client.For example, event handlers likeonClickcan only be defined in Client Components.
- For example, event handlers likeonClickcan only be defined in Client Components.
- Server Components cannot use most Hooks.When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state.
- When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state.

### Serializable types returned by Server Components
As in any React app, parent components pass data to child components. As they are rendered in different environments, passing data from a Server Component to a Client Component requires extra consideration.

Prop values passed from a Server Component to Client Component must be serializable.

Serializable props include:

- Primitivesstringnumberbigintbooleanundefinednullsymbol, only symbols registered in the global Symbol registry viaSymbol.for
- string
- number
- bigint
- boolean
- undefined
- null
- symbol, only symbols registered in the global Symbol registry viaSymbol.for
- Iterables containing serializable valuesStringArrayMapSetTypedArrayandArrayBuffer
- String
- Array
- Map
- Set
- TypedArrayandArrayBuffer
- Date
- Plainobjects: those created withobject initializers, with serializable properties
- Functions that areServer Functions
- Client or Server Component elements (JSX)
- Promises
Notably, these are not supported:

- Functionsthat are not exported from client-marked modules or marked with'use server'
- Classes
- Objects that are instances of any class (other than the built-ins mentioned) or objects witha null prototype
- Symbols not registered globally, ex.Symbol('my new symbol')

## Usage

### Building with interactivity and state
```jsx
'use client';

import { useState } from 'react';

export default function Counter({initialValue = 0}) {
  const [countValue, setCountValue] = useState(initialValue);
  const increment = () => setCountValue(countValue + 1);
  const decrement = () => setCountValue(countValue - 1);
  return (
    <>
      <h2>Count Value: {countValue}</h2>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
    </>
  );
}


```

AsCounterrequires both theuseStateHook and event handlers to increment or decrement the value, this component must be a Client Component and will require a'use client'directive at the top.

In contrast, a component that renders UI without interaction will not need to be a Client Component.

```jsx
import { readFile } from 'node:fs/promises';import Counter from './Counter';export default async function CounterContainer() {  const initialValue = await readFile('/path/to/counter_value');  return <Counter initialValue={initialValue} />}
```

For example,Counter’s parent component,CounterContainer, does not require'use client'as it is not interactive and does not use state. In addition,CounterContainermust be a Server Component as it reads from the local file system on the server, which is possible only in a Server Component.

There are also components that don’t use any server or client-only features and can be agnostic to where they render. In our earlier example,FancyTextis one such component.

```jsx
export default function FancyText({title, text}) {  return title    ? <h1 className='fancy title'>{text}</h1>    : <h3 className='fancy cursive'>{text}</h3>}
```

In this case, we don’t add the'use client'directive, resulting inFancyText’soutput(rather than its source code) to be sent to the browser when referenced from a Server Component. As demonstrated in the earlier Inspirations app example,FancyTextis used as both a Server or Client Component, depending on where it is imported and used.

But ifFancyText’s HTML output was large relative to its source code (including dependencies), it might be more efficient to force it to always be a Client Component. Components that return a long SVG path string are one case where it may be more efficient to force a component to be a Client Component.


### Using client APIs
Your React app may use client-specific APIs, such as the browser’s APIs for web storage, audio and video manipulation, and device hardware, amongothers.

In this example, the component usesDOM APIsto manipulate acanvaselement. Since those APIs are only available in the browser, it must be marked as a Client Component.

```jsx
'use client';import {useRef, useEffect} from 'react';export default function Circle() {  const ref = useRef(null);  useLayoutEffect(() => {    const canvas = ref.current;    const context = canvas.getContext('2d');    context.reset();    context.beginPath();    context.arc(100, 75, 50, 0, 2 * Math.PI);    context.stroke();  });  return <canvas ref={ref} />;}
```


### Using third-party libraries
Often in a React app, you’ll leverage third-party libraries to handle common UI patterns or logic.

These libraries may rely on component Hooks or client APIs. Third-party components that use any of the following React APIs must run on the client:

- createContext
- reactandreact-domHooks, excludinguseanduseId
- forwardRef
- memo
- startTransition
- If they use client APIs, ex. DOM insertion or native platform views
If these libraries have been updated to be compatible with React Server Components, then they will already include'use client'markers of their own, allowing you to use them directly from your Server Components. If a library hasn’t been updated, or if a component needs props like event handlers that can only be specified on the client, you may need to add your own Client Component file in between the third-party Client Component and your Server Component where you’d like to use it.


--------------------------------------------------------------------------------


# 'use server'
Source: https://react.dev/reference/rsc/use-server


### React Server Components
'use server'is for use withusing React Server Components.

'use server'marks server-side functions that can be called from client-side code.

- Reference'use server'Security considerationsSerializable arguments and return values
- 'use server'
- Security considerations
- Serializable arguments and return values
- UsageServer Functions in formsCalling a Server Function outside of<form>
- Server Functions in forms
- Calling a Server Function outside of<form>

## Reference

### 'use server'
Add'use server'at the top of an async function body to mark the function as callable by the client. We call these functionsServer Functions.

```jsx
async function addToCart(data) {  'use server';  // ...}
```

When calling a Server Function on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Function returns a value, that value will be serialized and returned to the client.

Instead of individually marking functions with'use server', you can add the directive to the top of a file to mark all exports within that file as Server Functions that can be used anywhere, including imported in client code.


#### Caveats
- 'use server'must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.
- 'use server'can only be used in server-side files. The resulting Server Functions can be passed to Client Components through props. See supportedtypes for serialization.
- To import a Server Functions fromclient code, the directive must be used on a module level.
- Because the underlying network calls are always asynchronous,'use server'can only be used on async functions.
- Always treat arguments to Server Functions as untrusted input and authorize any mutations. Seesecurity considerations.
- Server Functions should be called in aTransition. Server Functions passed to<form action>orformActionwill automatically be called in a transition.
- Server Functions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Functions typically process one action at a time and do not have a way to cache the return value.

### Security considerations
Arguments to Server Functions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate.

In any Server Function, make sure to validate that the logged-in user is allowed to perform that action.


### Under Construction
To prevent sending sensitive data from a Server Function, there are experimental taint APIs to prevent unique values and objects from being passed to client code.

Seeexperimental_taintUniqueValueandexperimental_taintObjectReference.


### Serializable arguments and return values
Since client code calls the Server Function over the network, any arguments passed will need to be serializable.

Here are supported types for Server Function arguments:

- Primitivesstringnumberbigintbooleanundefinednullsymbol, only symbols registered in the global Symbol registry viaSymbol.for
- string
- number
- bigint
- boolean
- undefined
- null
- symbol, only symbols registered in the global Symbol registry viaSymbol.for
- Iterables containing serializable valuesStringArrayMapSetTypedArrayandArrayBuffer
- String
- Array
- Map
- Set
- TypedArrayandArrayBuffer
- Date
- FormDatainstances
- Plainobjects: those created withobject initializers, with serializable properties
- Functions that are Server Functions
- Promises
Notably, these are not supported:

- React elements, orJSX
- Functions, including component functions or any other function that is not a Server Function
- Classes
- Objects that are instances of any class (other than the built-ins mentioned) or objects witha null prototype
- Symbols not registered globally, ex.Symbol('my new symbol')
- Events from event handlers
Supported serializable return values are the same asserializable propsfor a boundary Client Component.


## Usage

### Server Functions in forms
The most common use case of Server Functions will be calling functions that mutate data. On the browser, theHTML form elementis the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Functions as Actions informs.

Here is a form that allows a user to request a username.

```jsx
// App.jsasync function requestUsername(formData) {  'use server';  const username = formData.get('username');  // ...}export default function App() {  return (    <form action={requestUsername}>      <input type="text" name="username" />      <button type="submit">Request</button>    </form>  );}
```

In this examplerequestUsernameis a Server Function passed to a<form>. When a user submits this form, there is a network request to the server functionrequestUsername. When calling a Server Function in a form, React will supply the form’sFormDataas the first argument to the Server Function.

By passing a Server Function to the formaction, React canprogressively enhancethe form. This means that forms can be submitted before the JavaScript bundle is loaded.


#### Handling return values in forms
In the username request form, there might be the chance that a username is not available.requestUsernameshould tell us if it fails or not.

To update the UI based on the result of a Server Function while supporting progressive enhancement, useuseActionState.

```jsx
// requestUsername.js'use server';export default async function requestUsername(formData) {  const username = formData.get('username');  if (canRequest(username)) {    // ...    return 'successful';  }  return 'failed';}
```

```jsx
// UsernameForm.js'use client';import { useActionState } from 'react';import requestUsername from './requestUsername';function UsernameForm() {  const [state, action] = useActionState(requestUsername, null, 'n/a');  return (    <>      <form action={action}>        <input type="text" name="username" />        <button type="submit">Request</button>      </form>      <p>Last submission request returned: {state}</p>    </>  );}
```

Note that like most Hooks,useActionStatecan only be called inclient code.


### Calling a Server Function outside of<form>
Server Functions are exposed server endpoints and can be called anywhere in client code.

When using a Server Function outside aform, call the Server Function in aTransition, which allows you to display a loading indicator, showoptimistic state updates, and handle unexpected errors. Forms will automatically wrap Server Functions in transitions.

```jsx
import incrementLike from './actions';import { useState, useTransition } from 'react';function LikeButton() {  const [isPending, startTransition] = useTransition();  const [likeCount, setLikeCount] = useState(0);  const onClick = () => {    startTransition(async () => {      const currentCount = await incrementLike();      setLikeCount(currentCount);    });  };  return (    <>      <p>Total Likes: {likeCount}</p>      <button onClick={onClick} disabled={isPending}>Like</button>;    </>  );}
```

```jsx
// actions.js'use server';let likeCount = 0;export default async function incrementLike() {  likeCount++;  return likeCount;}
```

To read a Server Function return value, you’ll need toawaitthe promise returned.


--------------------------------------------------------------------------------


# Rules of React
Source: https://react.dev/reference/rules

Just as different programming languages have their own ways of expressing concepts, React has its own idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications.

- Components and Hooks must be pure
- React calls Components and Hooks
- Rules of Hooks

### Note
To learn more about expressing UIs with React, we recommend readingThinking in React.

This section describes the rules you need to follow to write idiomatic React code. Writing idiomatic React code can help you write well organized, safe, and composable applications. These properties make your app more resilient to changes and makes it easier to work with other developers, libraries, and tools.

These rules are known as theRules of React. They are rules – and not just guidelines – in the sense that if they are broken, your app likely has bugs. Your code also becomes unidiomatic and harder to understand and reason about.

We strongly recommend usingStrict Modealongside React’sESLint pluginto help your codebase follow the Rules of React. By following the Rules of React, you’ll be able to find and address these bugs and keep your application maintainable.


## Components and Hooks must be pure
Purity in Components and Hooksis a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code.

- Components must be idempotent– React components are assumed to always return the same output with respect to their inputs – props, state, and context.
- Side effects must run outside of render– Side effects should not run in render, as React can render components multiple times to create the best possible user experience.
- Props and state are immutable– A component’s props and state are immutable snapshots with respect to a single render. Never mutate them directly.
- Return values and arguments to Hooks are immutable– Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook.
- Values are immutable after being passed to JSX– Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created.

## React calls Components and Hooks
React is responsible for rendering components and hooks when necessary to optimize the user experience.It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.

- Never call component functions directly– Components should only be used in JSX. Don’t call them as regular functions.
- Never pass around hooks as regular values– Hooks should only be called inside of components. Never pass it around as a regular value.

## Rules of Hooks
Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow theRules of Hookswhen using them.

- Only call Hooks at the top level– Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns.
- Only call Hooks from React functions– Don’t call Hooks from regular JavaScript functions.

--------------------------------------------------------------------------------


# Components and Hooks must be pure
Source: https://react.dev/reference/rules/components-and-hooks-must-be-pure

Pure functions only perform a calculation and nothing more. It makes your code easier to understand, debug, and allows React to automatically optimize your components and Hooks correctly.


### Note
This reference page covers advanced topics and requires familiarity with the concepts covered in theKeeping Components Purepage.

- Why does purity matter?
- Components and Hooks must be idempotent
- Side effects must run outside of renderWhen is it okay to have mutation?
- When is it okay to have mutation?
- Props and state are immutableDon’t mutate PropsDon’t mutate State
- Don’t mutate Props
- Don’t mutate State
- Return values and arguments to Hooks are immutable
- Values are immutable after being passed to JSX

### Why does purity matter?
One of the key concepts that makes React,Reactispurity. A pure component or hook is one that is:

- Idempotent– Youalways get the same result every timeyou run it with the same inputs – props, state, context for component inputs; and arguments for hook inputs.
- Has no side effects in render– Code with side effects should runseparately from rendering. For example as anevent handler– where the user interacts with the UI and causes it to update; or as anEffect– which runs after render.
- Does not mutate non-local values: Components and Hooks shouldnever modify values that aren’t created locallyin render.
When render is kept pure, React can understand how to prioritize which updates are most important for the user to see first. This is made possible because of render purity: since components don’t have side effectsin render, React can pause rendering components that aren’t as important to update, and only come back to them later when it’s needed.

Concretely, this means that rendering logic can be run multiple times in a way that allows React to give your user a pleasant user experience. However, if your component has an untracked side effect – like modifying the value of a global variableduring render– when React runs your rendering code again, your side effects will be triggered in a way that won’t match what you want. This often leads to unexpected bugs that can degrade how your users experience your app. You can see anexample of this in the Keeping Components Pure page.


#### How does React run your code?
React is declarative: you tell Reactwhatto render, and React will figure outhowbest to display it to your user. To do this, React has a few phases where it runs your code. You don’t need to know about all of these phases to use React well. But at a high level, you should know about what code runs inrender, and what runs outside of it.

Renderingrefers to calculating what the next version of your UI should look like. After rendering, React takes this new calculation and compares it to the calculation used to create the previous version of your UI. Then React commits just the minimum changes needed to theDOM(what your user actually sees) to apply the changes. Finally,Effectsare flushed (meaning they are run until there are no more left). For more detailed information see the docs forRenderandCommit and Effect Hooks.


#### How to tell if code runs in render
One quick heuristic to tell if code runs during render is to examine where it is: if it’s written at the top level like in the example below, there’s a good chance it runs during render.

```jsx
function Dropdown() {  const selectedItems = new Set(); // created during render  // ...}
```

Event handlers and Effects don’t run in render:

```jsx
function Dropdown() {  const selectedItems = new Set();  const onSelect = (item) => {    // this code is in an event handler, so it's only run when the user triggers this    selectedItems.add(item);  }}
```

```jsx
function Dropdown() {  const selectedItems = new Set();  useEffect(() => {    // this code is inside of an Effect, so it only runs after rendering    logForAnalytics(selectedItems);  }, [selectedItems]);}
```


## Components and Hooks must be idempotent
Components must always return the same output with respect to their inputs – props, state, and context. This is known asidempotency.Idempotencyis a term popularized in functional programming. It refers to the idea that youalways get the same result every timeyou run that piece of code with the same inputs.

This means thatallcode that runsduring rendermust also be idempotent in order for this rule to hold. For example, this line of code is not idempotent (and therefore, neither is the component):

```jsx
function Clock() {  const time = new Date(); // 🔴 Bad: always returns a different result!  return <span>{time.toLocaleString()}</span>}
```

new Date()is not idempotent as it always returns the current date and changes its result every time it’s called. When you render the above component, the time displayed on the screen will stay stuck on the time that the component was rendered. Similarly, functions likeMath.random()also aren’t idempotent, because they return different results every time they’re called, even when the inputs are the same.

This doesn’t mean you shouldn’t use non-idempotent functions likenew Date()at all– you should just avoid using themduring render. In this case, we cansynchronizethe latest date to this component using anEffect:

```jsx
import { useState, useEffect } from 'react';

function useTime() {
  // 1. Keep track of the current date's state. `useState` receives an initializer function as its
  //    initial state. It only runs once when the hook is called, so only the current date at the
  //    time the hook is called is set first.
  const [time, setTime] = useState(() => new Date());

  useEffect(() => {
    // 2. Update the current date every second using `setInterval`.
    const id = setInterval(() => {
      setTime(new Date()); // ✅ Good: non-idempotent code no longer runs in render
    }, 1000);
    // 3. Return a cleanup function so we don't leak the `setInterval` timer.
    return () => clearInterval(id);
  }, []);

  return time;
}

export default function Clock() {
  const time = useTime();
  return <span>{time.toLocaleString()}</span>;
}


```

By wrapping the non-idempotentnew Date()call in an Effect, it moves that calculationoutside of rendering.

If you don’t need to synchronize some external state with React, you can also consider using anevent handlerif it only needs to be updated in response to a user interaction.


## Side effects must run outside of render
Side effectsshould not runin render, as React can render components multiple times to create the best possible user experience.


### Note
Side effects are a broader term than Effects. Effects specifically refer to code that’s wrapped inuseEffect, while a side effect is a general term for code that has any observable effect other than its primary result of returning a value to the caller.

Side effects are typically written inside ofevent handlersor Effects. But never during render.

While render must be kept pure, side effects are necessary at some point in order for your app to do anything interesting, like showing something on the screen! The key point of this rule is that side effects should not runin render, as React can render components multiple times. In most cases, you’ll useevent handlersto handle side effects. Using an event handler explicitly tells React that this code doesn’t need to run during render, keeping render pure. If you’ve exhausted all options – and only as a last resort – you can also handle side effects usinguseEffect.


### When is it okay to have mutation?

#### Local mutation
One common example of a side effect is mutation, which in JavaScript refers to changing the value of a non-primitivevalue. In general, while mutation is not idiomatic in React,localmutation is absolutely fine:

```jsx
function FriendList({ friends }) {  const items = []; // ✅ Good: locally created  for (let i = 0; i < friends.length; i++) {    const friend = friends[i];    items.push(      <Friend key={friend.id} friend={friend} />    ); // ✅ Good: local mutation is okay  }  return <section>{items}</section>;}
```

There is no need to contort your code to avoid local mutation.Array.mapcould also be used here for brevity, but there is nothing wrong with creating a local array and then pushing items into itduring render.

Even though it looks like we are mutatingitems, the key point to note is that this code only does solocally– the mutation isn’t “remembered” when the component is rendered again. In other words,itemsonly stays around as long as the component does. Becauseitemsis alwaysrecreatedevery time<FriendList />is rendered, the component will always return the same result.

On the other hand, ifitemswas created outside of the component, it holds on to its previous values and remembers changes:

```jsx
const items = []; // 🔴 Bad: created outside of the componentfunction FriendList({ friends }) {  for (let i = 0; i < friends.length; i++) {    const friend = friends[i];    items.push(      <Friend key={friend.id} friend={friend} />    ); // 🔴 Bad: mutates a value created outside of render  }  return <section>{items}</section>;}
```

When<FriendList />runs again, we will continue appendingfriendstoitemsevery time that component is run, leading to multiple duplicated results. This version of<FriendList />has observable side effectsduring renderandbreaks the rule.


#### Lazy initialization
Lazy initialization is also fine despite not being fully “pure”:

```jsx
function ExpenseForm() {  SuperCalculator.initializeIfNotReady(); // ✅ Good: if it doesn't affect other components  // Continue rendering...}
```


#### Changing the DOM
Side effects that are directly visible to the user are not allowed in the render logic of React components. In other words, merely calling a component function shouldn’t by itself produce a change on the screen.

```jsx
function ProductDetailPage({ product }) {  document.title = product.title; // 🔴 Bad: Changes the DOM}
```

One way to achieve the desired result of updatingdocument.titleoutside of render is tosynchronize the component withdocument.

As long as calling a component multiple times is safe and doesn’t affect the rendering of other components, React doesn’t care if it’s 100% pure in the strict functional programming sense of the word. It is more important thatcomponents must be idempotent.


## Props and state are immutable
A component’s props and state are immutablesnapshots. Never mutate them directly. Instead, pass new props down, and use the setter function fromuseState.

You can think of the props and state values as snapshots that are updated after rendering. For this reason, you don’t modify the props or state variables directly: instead you pass new props, or use the setter function provided to you to tell React that state needs to update the next time the component is rendered.


### Don’t mutate Props
Props are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug as it may or may not work depending on the circumstances.

```jsx
function Post({ item }) {  item.url = new Url(item.url, base); // 🔴 Bad: never mutate props directly  return <Link url={item.url}>{item.title}</Link>;}
```

```jsx
function Post({ item }) {  const url = new Url(item.url, base); // ✅ Good: make a copy instead  return <Link url={url}>{item.title}</Link>;}
```


### Don’t mutate State
useStatereturns the state variable and a setter to update that state.

```jsx
const [stateVariable, setter] = useState(0);
```

Rather than updating the state variable in-place, we need to update it using the setter function that is returned byuseState. Changing values on the state variable doesn’t cause the component to update, leaving your users with an outdated UI. Using the setter function informs React that the state has changed, and that we need to queue a re-render to update the UI.

```jsx
function Counter() {  const [count, setCount] = useState(0);  function handleClick() {    count = count + 1; // 🔴 Bad: never mutate state directly  }  return (    <button onClick={handleClick}>      You pressed me {count} times    </button>  );}
```

```jsx
function Counter() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1); // ✅ Good: use the setter function returned by useState  }  return (    <button onClick={handleClick}>      You pressed me {count} times    </button>  );}
```


## Return values and arguments to Hooks are immutable
Once values are passed to a hook, you should not modify them. Like props in JSX, values become immutable when passed to a hook.

```jsx
function useIconStyle(icon) {  const theme = useContext(ThemeContext);  if (icon.enabled) {    icon.className = computeStyle(icon, theme); // 🔴 Bad: never mutate hook arguments directly  }  return icon;}
```

```jsx
function useIconStyle(icon) {  const theme = useContext(ThemeContext);  const newIcon = { ...icon }; // ✅ Good: make a copy instead  if (icon.enabled) {    newIcon.className = computeStyle(icon, theme);  }  return newIcon;}
```

One important principle in React islocal reasoning: the ability to understand what a component or hook does by looking at its code in isolation. Hooks should be treated like “black boxes” when they are called. For example, a custom hook might have used its arguments as dependencies to memoize values inside it:

```jsx
function useIconStyle(icon) {  const theme = useContext(ThemeContext);  return useMemo(() => {    const newIcon = { ...icon };    if (icon.enabled) {      newIcon.className = computeStyle(icon, theme);    }    return newIcon;  }, [icon, theme]);}
```

If you were to mutate the Hook’s arguments, the custom hook’s memoization will become incorrect,  so it’s important to avoid doing that.

```jsx
style = useIconStyle(icon);         // `style` is memoized based on `icon`icon.enabled = false;               // Bad: 🔴 never mutate hook arguments directlystyle = useIconStyle(icon);         // previously memoized result is returned
```

```jsx
style = useIconStyle(icon);         // `style` is memoized based on `icon`icon = { ...icon, enabled: false }; // Good: ✅ make a copy insteadstyle = useIconStyle(icon);         // new value of `style` is calculated
```

Similarly, it’s important to not modify the return values of Hooks, as they may have been memoized.


## Values are immutable after being passed to JSX
Don’t mutate values after they’ve been used in JSX. Move the mutation to before the JSX is created.

When you use JSX in an expression, React may eagerly evaluate the JSX before the component finishes rendering. This means that mutating values after they’ve been passed to JSX can lead to outdated UIs, as React won’t know to update the component’s output.

```jsx
function Page({ colour }) {  const styles = { colour, size: "large" };  const header = <Header styles={styles} />;  styles.size = "small"; // 🔴 Bad: styles was already used in the JSX above  const footer = <Footer styles={styles} />;  return (    <>      {header}      <Content />      {footer}    </>  );}
```

```jsx
function Page({ colour }) {  const headerStyles = { colour, size: "large" };  const header = <Header styles={headerStyles} />;  const footerStyles = { colour, size: "small" }; // ✅ Good: we created a new value  const footer = <Footer styles={footerStyles} />;  return (    <>      {header}      <Content />      {footer}    </>  );}
```


--------------------------------------------------------------------------------


# React calls Components and Hooks
Source: https://react.dev/reference/rules/react-calls-components-and-hooks

React is responsible for rendering components and Hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.

- Never call component functions directly
- Never pass around Hooks as regular valuesDon’t dynamically mutate a HookDon’t dynamically use Hooks
- Don’t dynamically mutate a Hook
- Don’t dynamically use Hooks

## Never call component functions directly
Components should only be used in JSX. Don’t call them as regular functions. React should call it.

React must decide when your component function is calledduring rendering. In React, you do this using JSX.

```jsx
function BlogPost() {  return <Layout><Article /></Layout>; // ✅ Good: Only use components in JSX}
```

```jsx
function BlogPost() {  return <Layout>{Article()}</Layout>; // 🔴 Bad: Never call them directly}
```

If a component contains Hooks, it’s easy to violate theRules of Hookswhen components are called directly in a loop or conditionally.

Letting React orchestrate rendering also allows a number of benefits:

- Components become more than functions.React can augment them with features likelocal statethrough Hooks that are tied to the component’s identity in the tree.
- Component types participate in reconciliation.By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering<Feed>to the<Profile>page, React won’t attempt to re-use them.
- React can enhance your user experience.For example, it can let the browser do some work between component calls so that re-rendering a large component tree doesn’t block the main thread.
- A better debugging story.If components are first-class citizens that the library is aware of, we can build rich developer tools for introspection in development.
- More efficient reconciliation.React can decide exactly which components in the tree need re-rendering and skip over the ones that don’t. That makes your app faster and more snappy.

## Never pass around Hooks as regular values
Hooks should only be called inside of components or Hooks. Never pass it around as a regular value.

Hooks allow you to augment a component with React features. They should always be called as a function, and never passed around as a regular value. This enableslocal reasoning, or the ability for developers to understand everything a component can do by looking at that component in isolation.

Breaking this rule will cause React to not automatically optimize your component.


### Don’t dynamically mutate a Hook
Hooks should be as “static” as possible. This means you shouldn’t dynamically mutate them. For example, this means you shouldn’t write higher order Hooks:

```jsx
function ChatInput() {  const useDataWithLogging = withLogging(useData); // 🔴 Bad: don't write higher order Hooks  const data = useDataWithLogging();}
```

Hooks should be immutable and not be mutated. Instead of mutating a Hook dynamically, create a static version of the Hook with the desired functionality.

```jsx
function ChatInput() {  const data = useDataWithLogging(); // ✅ Good: Create a new version of the Hook}function useDataWithLogging() {  // ... Create a new version of the Hook and inline the logic here}
```


### Don’t dynamically use Hooks
Hooks should also not be dynamically used: for example, instead of doing dependency injection in a component by passing a Hook as a value:

```jsx
function ChatInput() {  return <Button useData={useDataWithLogging} /> // 🔴 Bad: don't pass Hooks as props}
```

You should always inline the call of the Hook into that component and handle any logic in there.

```jsx
function ChatInput() {  return <Button />}function Button() {  const data = useDataWithLogging(); // ✅ Good: Use the Hook directly}function useDataWithLogging() {  // If there's any conditional logic to change the Hook's behavior, it should be inlined into  // the Hook}
```

This way,<Button />is much easier to understand and debug. When Hooks are used in dynamic ways, it increases the complexity of your app greatly and inhibits local reasoning, making your team less productive in the long term. It also makes it easier to accidentally break theRules of Hooksthat Hooks should not be called conditionally. If you find yourself needing to mock components for tests, it’s better to mock the server instead to respond with canned data. If possible, it’s also usually more effective to test your app with end-to-end tests.


--------------------------------------------------------------------------------


# Rules of Hooks
Source: https://react.dev/reference/rules/rules-of-hooks

Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.

- Only call Hooks at the top level
- Only call Hooks from React functions

## Only call Hooks at the top level
Functions whose names start withuseare calledHooksin React.

Don’t call Hooks inside loops, conditions, nested functions, ortry/catch/finallyblocks.Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:

- ✅ Call them at the top level in the body of afunction component.
- ✅ Call them at the top level in the body of acustom Hook.
```jsx
function Counter() {  // ✅ Good: top-level in a function component  const [count, setCount] = useState(0);  // ...}function useWindowWidth() {  // ✅ Good: top-level in a custom Hook  const [width, setWidth] = useState(window.innerWidth);  // ...}
```

It’snotsupported to call Hooks (functions starting withuse) in any other cases, for example:

- 🔴 Do not call Hooks inside conditions or loops.
- 🔴 Do not call Hooks after a conditionalreturnstatement.
- 🔴 Do not call Hooks in event handlers.
- 🔴 Do not call Hooks in class components.
- 🔴 Do not call Hooks inside functions passed touseMemo,useReducer, oruseEffect.
- 🔴 Do not call Hooks insidetry/catch/finallyblocks.
If you break these rules, you might see this error.

```jsx
function Bad({ cond }) {  if (cond) {    // 🔴 Bad: inside a condition (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad() {  for (let i = 0; i < 10; i++) {    // 🔴 Bad: inside a loop (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad({ cond }) {  if (cond) {    return;  }  // 🔴 Bad: after a conditional return (to fix, move it before the return!)  const theme = useContext(ThemeContext);  // ...}function Bad() {  function handleClick() {    // 🔴 Bad: inside an event handler (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad() {  const style = useMemo(() => {    // 🔴 Bad: inside useMemo (to fix, move it outside!)    const theme = useContext(ThemeContext);    return createStyle(theme);  });  // ...}class Bad extends React.Component {  render() {    // 🔴 Bad: inside a class component (to fix, write a function component instead of a class!)    useEffect(() => {})    // ...  }}function Bad() {  try {    // 🔴 Bad: inside try/catch/finally block (to fix, move it outside!)    const [x, setX] = useState(0);  } catch {    const [x, setX] = useState(1);  }}
```

You can use theeslint-plugin-react-hookspluginto catch these mistakes.


### Note
Custom Hooksmaycall other Hooks (that’s their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering.


## Only call Hooks from React functions
Don’t call Hooks from regular JavaScript functions. Instead, you can:

✅ Call Hooks from React function components.
✅ Call Hooks fromcustom Hooks.

By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.

```jsx
function FriendList() {  const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ✅}function setOnlineStatus() { // ❌ Not a component or custom Hook!  const [onlineStatus, setOnlineStatus] = useOnlineStatus();}
```


--------------------------------------------------------------------------------
