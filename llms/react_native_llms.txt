# React Native Documentation
Generated from https://reactnative.dev/sitemap.xml



# Bundled Hermes
Source: https://reactnative.dev/architecture/bundled-hermes

This page gives an overview ofhowHermes and React Nativeare built.

If you're looking into instructions on how to use Hermes in your app, you can find instructions on this other page:using Hermes

Please note that this page serves as a technical deep dive and is targeted for users which are building extensions on top of Hermes or React Native. General users of React Native should not need to know in-depth information on how React Native and Hermes interact.


## What is 'Bundled Hermes'
Starting with React Native 0.69.0, every version of React Native will bebuilt alongsideto a Hermes version. We call this distribution modelBundled Hermes.

From 0.69 on, you will always have a JS engine that has been built and tested alongside each React Native version that you can use.


## Why we moved to 'Bundled Hermes'
Historically, React Native and Hermes followed twodistinct release processeswith distinct versioning. Having distinct releases with distinct numbers created confusion in the OSS ecosystem, where it was not clear if a specific version of Hermes was compatible with a specific version of React Native (i.e. you needed to know that Hermes 0.11.0 was compatible only with React Native 0.68.0, etc.)

Both Hermes and React Native, share the JSI code (Hermes hereandReact Native here). If the two JSI copies of JSI get out of sync, a build of Hermes won't be compatible with a build of React Native. You can read more about thisABI incompatibility problem here.

To overcome this problem, we've extended the React Native release process to download and build Hermes and made sure only one copy of JSI is used when building Hermes.

Thanks to this, we can release a version of Hermes whenever we release a version of React Native, and be sure that the Hermes engine we built isfully compatiblewith the React Native version we're releasing. We're shipping this version of Hermes alongside the React Native version we're doing, hence the nameBundled Hermes.


## How this will impact app developers
As mentioned in the introduction, if you're an app developer, this changeshould not affectyou directly.

The following paragraphs describe which changes we did under the hood and explains some of the rationales, for the sake of transparency.


### iOS Users
On iOS, we've moved thehermes-engineyou're using.

Prior to React Native 0.69, users would download a pod (here you can find thepodspec).

On React Native 0.69, users would instead use a podspec that is defined inside thesdks/hermes-engine/hermes-engine.podspecfile in thereact-nativeNPM package.
That podspec relies on a pre-built tarball of Hermes that we upload to Maven and to the React Native GitHub Release, as part of the React Native release process (i.e.see the assets of this release).


### Android Users
On Android, we're going to update theandroid/app/build.gradlefile in the default template the following way:

```
dependencies {    // ...    if (enableHermes) {+       implementation("com.facebook.react:hermes-engine:+") {+           exclude group:'com.facebook.fbjni'+       }-       def hermesPath = "../../node_modules/hermes-engine/android/";-       debugImplementation files(hermesPath + "hermes-debug.aar")-       releaseImplementation files(hermesPath + "hermes-release.aar")    } else {        implementation jscFlavor    }}
```

Prior to React Native 0.69, users will be consuminghermes-debug.aarandhermes-release.aarfrom thehermes-engineNPM package.

On React Native 0.69, users will be consuming the Android multi-variant artifacts available inside theandroid/com/facebook/react/hermes-engine/folder in thereact-nativeNPM package.
Please also note that we're going toremove the dependencyonhermes-engineentirely in one of the future version of React Native.

Due to the nature of our native code build setup (i.e. how we use the NDK), users on the New Architecture will bebuilding Hermes from source.

This aligns the build mechanism of React Native and Hermes for users on the New Architecture (they will build both framework from source).
This means that such Android users might experience a performance hit at build time on their first build.

You can find instructions to optimize your build time and reduce the impact on your build on this page:Speeding up your Build phase.

Users building React Native App, with the New Architecture, on Windows machines need to follow those extra steps to let the build work correctly:

- Make sure theenvironment is configured properly, with Android SDK & node.
- Installcmakewith Chocolatey
- Install either:Build Tools for Visual Studio 2022.Visual Studio 22 Community Edition- Picking only the C++ desktop development is sufficient.
- Build Tools for Visual Studio 2022.
- Visual Studio 22 Community Edition- Picking only the C++ desktop development is sufficient.
- Make sure theVisual Studio Command Promptis configured correctly. This is required as the proper C++ compiler environment variable is configured in those command prompt.
- Run the app withnpx react-native run-androidinside a Visual Studio Command Prompt.

### Can users still use another engine?
Yes, users are free to enable/disable Hermes (with theenableHermesvariable on Android,hermes_enabledon iOS).
The 'Bundled Hermes' change will impact onlyhow Hermes is built and bundledfor you.

Starting with React Native 0.70, the default forenableHermes/hermes_enabledistrue.


## How this will impact contributor and extension developers
If you're a React Native contributor or you're building an extension on top of React Native or Hermes, please read further as we explain how Bundled Hermes works.


### How is Bundled Hermes working under the hood?
This mechanism relies ondownloading a tarballwith the Hermes source code from thefacebook/hermesrepository inside thefacebook/react-nativerepository. We have a similar mechanism in place for other native dependencies (Folly, Glog, etc.) and we aligned Hermes to follow the same setup.

When building React Native frommain, we will be fetching a tarball ofmainof facebook/hermes and building it as part of the build process of React Native.

When building React Native from a release branch (say0.69-stable), we will instead use atagon the Hermes repo tosynchronize the codebetween the two repos. The specific tag name used will then be stored inside thesdks/.hermesversionfile inside React Native in the release branch (e.g.this is the fileon the 0.69 release branch).

In a sense, you can think of this approach similarly to agit submodule.

If you're building on top of Hermes, you can rely on those tags to understand which version of Hermes was used when building React Native, as the version of React Native is specified in the tag name (e.g.hermes-2022-05-20-RNv0.69.0-ee8941b8874132b8f83e4486b63ed5c19fc3f111).

To implement this on Android, we've added a new build inside the/ReactAndroid/hermes-engineof React Native that will take care of building Hermes and packaging for consumption (See here for more context).

You can now trigger a build of Hermes engine by invoking:

```
// Build a debug version of Hermes./gradlew :ReactAndroid:hermes-engine:assembleDebug// Build a release version of Hermes./gradlew :ReactAndroid:hermes-engine:assembleRelease
```

from the React Nativemainbranch.

You won't need to install extra tools (such ascmake,ninjaorpython3) in your machine as we configured the build to use the NDK versions of those tools.

On the Gradle consumer side, we also shipped a small improvement on the consumer side: we moved fromreleaseImplementation&debugImplementationtoimplementation. This is possible because the newerhermes-engineAndroid artifact isvariant awareand will properly match a debug build of the engine with a debug build of your app. You don't need any custom configuration here (even if you usestagingor other build types/flavors).

However, this made this line necessary in the template:

```
exclude group:'com.facebook.fbjni'
```

This is needed as React Native is consumingfbjniusing the non-prefab approach (i.e. unzipping the.aarand extracting.sofiles). Hermes-engine, and other libraries, are using prefab instead to consume fbjni. We're looking intoaddressing this issuein the future so the Hermes import will be a oneliner.

The iOS implementation relies on a series of scripts that lives in the following locations:

- /scripts/hermes. Those scripts contain logic to download the Hermes tarball, unzip it, and configure the iOS build. They're invoked atpod installtime if you have thehermes_enabledfield set totrue.
- /sdks/hermes-engine. Those scripts contain the build logic that is effectively building Hermes. They were copied and adapted from thefacebook/hermesrepo to properly work within React Native. Specifically, the scripts inside theutilsfolder are responsible of building Hermes for all the Mac platforms.
Hermes is built as part of thebuild_hermes_macosJob on CircleCI. The job will produce as artifact a tarball which will be downloaded by thehermes-enginepodspec when using a published React Native release (here is an example of the artifacts created for React Native 0.69 inbuild_hermes_macos).

If there are no prebuilt artifacts for the React Native version that is being used (i.e. you may be working with React Native from themainbranch), then Hermes will need to be built from source. First, the Hermes compiler,hermesc, will be built for macOS duringpod install, then Hermes itself will be built as part of the Xcode build pipeline using thebuild-hermes-xcode.shscript.

Hermes is always built from source when using React Native from themainbranch. If you are using a stable React Native version, you can force Hermes to be built from source by setting theCIenvvar totruewhen using CocoaPods:CI=true pod install.

The prebuilt artifacts for Hermes do not contain debug symbols (dSYMs) by default. We're planning on distributing these debug symbols for each release in the future. Until then, if you need the debug symbols for Hermes, you will need to build Hermes from source. Ahermes.framework.dSYMwill be created in the build directory alongside each of the Hermes frameworks.


### I'm afraid this change is impacting me
We'd like to stress that this is essentially an organizational change onwhereHermes is built andhowthe code is synchronized between the two repositories. The change should be fully transparent to our users.

Historically, we used to cut a release of Hermes for a specific version of React Native (e.g.v0.11.0 for RN0.68.x).

With 'Bundled Hermes', you can instead rely on a tag that will represent the version used when a specific version of React Native was cut.


================================================================================


# Fabric
Source: https://reactnative.dev/architecture/fabric-renderer

Fabric is React Native's new rendering system, a conceptual evolution of the legacy render system. The core principles are to unify more render logic in C++, improve interoperability withhost platforms, and to unlock new capabilities for React Native. Development began in 2018 and in 2021, React Native in the Facebook app is backed by the new renderer.

This documentation provides an overview of thenew rendererand its concepts. It avoids platform specifics and doesn’t contain any code snippets or pointers. This documentation covers key concepts, motivation, benefits, and an overview of the render pipeline in different scenarios.


## Motivations and Benefits of the new renderer
The render architecture was created to unlock better user experiences that weren’t possible with the legacy architecture. Some examples include:

- With improved interoperability betweenhost viewsand React views, the renderer is able to measure and render React surfaces synchronously. In the legacy architecture, React Native layout was asynchronous which led to a layout “jump” issue when embedding a React Native rendered view in ahost view.
- With support of multi-priority and synchronous events, the renderer can prioritize certain user interactions to ensure they are handled in a timely manner.
- Integration with React Suspensewhich allows for more intuitive design of data fetching in React apps.
- Enable ReactConcurrent Featureson React Native.
- Easier to implement server side rendering for React Native.
The new architecture also provides benefits in code quality, performance, and extensibility:

- Type safety:code generation to ensure type safety across the JS andhost platforms. The code generation uses JavaScript component declarations as source of truth to generate C++ structs to hold the props. Mismatch between JavaScript and host component props triggers a build error.
- Shared C++ core: the renderer is implemented in C++ and the core is shared among platforms. This increases consistency and makes it easier to adopt React Native on new platforms.
- Better Host Platform Interoperability: Synchronous and thread-safe layout calculation improves user experiences when embedding host components into React Native, which means easier integration with host platform frameworks that require synchronous APIs.
- Improved Performance: With the new cross-platform implementation of the renderer system, every platform benefits from performance improvements that may have been motivated by limitations of one platform. For example, view flattening was originally a performance solution for Android and is now provided by default on both Android and iOS.
- Consistency: The new render system is cross-platform, it is easier to keep consistency among different platforms.
- Faster Startup: Host components are lazily initialized by default.
- Less serialization of data between JS and host platform: React used to transfer data between JavaScript andhost platformas serialized JSON. The new renderer improves the transfer of data by accessing JavaScript values directly usingJavaScript Interfaces (JSI).

================================================================================


# Glossary
Source: https://reactnative.dev/architecture/glossary


## Dev Menu
The in-app developer menu (available in development builds) that offers access to various development and debugging actions.Learn more about the Dev Menu in the docs.


## Fabric Renderer
React Native executes the same React framework code as React for the web. However, React Native renders to general platform views (host views) instead of DOM nodes (which can be considered web’s host views). Rendering to host views is made possible by the Fabric Renderer. Fabric lets React talk to each platform and manage its host view instances. The Fabric Renderer exists in JavaScript and targets interfaces made available by C++ code.Read more about React renderers in this blog post.


## Host platform
The platform embedding React Native (e.g., Android, iOS, macOS, Windows).


## Host View Tree (and Host View)
Tree representation of views in the host platform (e.g. Android, iOS). On Android, the host views are instances ofandroid.view.ViewGroup,android.widget.TextView, etc. which are the building blocks of the host view tree. The size and location of each host view are based onLayoutMetricscalculated with Yoga, and the style and content of each host view are based on information from the React Shadow Tree.


## JavaScript Interfaces (JSI)
A lightweight API to embed a JavaScript engine in a C++ application. Fabric uses it to communicate between Fabric’s C++ core and React.


## Java Native Interface (JNI)
AnAPI to write Java native methodsused to communicate between Fabric’s C++ core and Android, written in Java.


## React Component
A JavaScript function or class that instructs how to create a React Element.Read more about React components, elements in this blog post.


## React Composite Components
React Components withrenderimplementations that reduce to other React Composite Components or React Host Components.


## React Host Components or Host Components
React Components whose view implementation is provided by a host view (e.g.,<View>, <Text>). On the Web, ReactDOM's Host components would be components like<p>and<div>.


## React Element Tree (and React Element)
AReact Element Treeis created by React in JavaScript and consists of React Elements. AReact Elementis a plain JavaScript object that describes what should appear on the screen. It includes props, styles, and children. React Elements only exist in JavaScript and can represent instantiations of either React Composite Components or React Host Components.Read more about React components and elements in this blog post.


## React Native Framework
React Native allows developers to use theReact programming paradigmto ship applications to native targets. The React Native team is focused on creatingcore APIsandfunctionalitiesthat fit the most general use case when developing native apps.

Shipping native apps to production usually requires a set of tools and libraries that are not provided by default as part of React Native, but are still crucial to ship an app to production. Examples of such tools are: support for publishing applications to a dedicated store or support for routing and navigation mechanisms.

When those tools and libraries are collected to form a cohesive framework built on top of React Native, we define it as aReact Native Framework.

An example of Open Source React Native Framework isExpo.


## React Shadow Tree (and React Shadow Node)
AReact Shadow Treeis created by the Fabric Renderer and consists of React Shadow Nodes. A React Shadow Node is an object that represents a React Host Component to be mounted, and contains props that originate from JavaScript. They also contain layout information (x, y, width, height). In Fabric, React Shadow Node objects exist in C++. Before Fabric, these existed in the mobile runtime heap (e.g. Android JVM).


## Yoga Tree (and Yoga Node)
TheYoga Treeis used byYogato calculate layout information for a React Shadow Tree. Each React Shadow Node typically creates aYoga Nodebecause React Native employs Yoga to calculate layout. However, this is not a hard requirement. Fabric can also create React Shadow Nodes that do not use Yoga; the implementation of each React Shadow Node determines how to calculate layout.


================================================================================


# About the New Architecture
Source: https://reactnative.dev/architecture/landing-page

Since 2018, the React Native team has been redesigning the core internals of React Native to enable developers to create higher-quality experiences. As of 2024, this version of React Native has been proven at scale and powers production apps by Meta.

The termNew Architecturerefers to both the new framework architecture and the work to bring it to open source.

The New Architecture has been available for experimental opt-in as ofReact Native 0.68with continued improvements in every subsequent release. The team is now working to make this the default experience for the React Native open source ecosystem.


## Why a New Architecture?
After many years of building with React Native, the team identified a set of limitations that prevented developers from crafting certain experiences with a high polish. These limitations were fundamental to the existing design of the framework, so the New Architecture started as an investment in the future of React Native.

The New Architecture unlocks capabilities and improvements that were impossible in the legacy architecture.


### Synchronous Layout and Effects
Building adaptive UI experiences often requires measuring the size and position of your views and adjusting layout.

Today, you would use theonLayoutevent to get the layout information of a view and make any adjustments. However, state updates within theonLayoutcallback may apply after painting the previous render. This means that users may see intermediate states or visual jumps between rendering the initial layout and responding to layout measurements.

With the New Architecture, we can avoid this issue entirely with synchronous access to layout information and properly scheduled updates such that no intermediate state is visible to users.

Measuring and placing a tooltip above a view allows us to showcase what synchronous rendering unlocks. The tooltip needs to know the position of its target view to determine where it should render.In the current architecture, we useonLayoutto get the measurements of the view and then update the positioning of the tooltip based on where the view is.jsxfunctionViewWithTooltip(){// ...// We get the layout information and pass to ToolTip to position itselfconstonLayout=React.useCallback(event=>{targetRef.current?.measureInWindow((x,y,width,height)=>{// This state update is not guaranteed to run in the same commit// This results in a visual "jump" as the ToolTip repositions itselfsetTargetRect({x,y,width,height});});},[]);return(<><Viewref={targetRef}onLayout={onLayout}><Text>Some content that renders a tooltip above</Text></View><TooltiptargetRect={targetRect}/></>);}With the New Architecture, we can useuseLayoutEffectto synchronously measure and apply layout updates in a single commit, avoiding the visual "jump".jsxfunctionViewWithTooltip(){// ...useLayoutEffect(()=>{// The measurement and state update for `targetRect` happens in a single commit// allowing ToolTip to position itself without intermediate paintstargetRef.current?.measureInWindow((x,y,width,height)=>{setTargetRect({x,y,width,height});});},[setTargetRect]);return(<><Viewref={targetRef}><Text>Some content that renders a tooltip above</Text></View><TooltiptargetRect={targetRect}/></>);}Asynchronous measurement and render of the ToolTip.See code.Synchronous measurement and render of the ToolTip.See code.

In the current architecture, we useonLayoutto get the measurements of the view and then update the positioning of the tooltip based on where the view is.jsxfunctionViewWithTooltip(){// ...// We get the layout information and pass to ToolTip to position itselfconstonLayout=React.useCallback(event=>{targetRef.current?.measureInWindow((x,y,width,height)=>{// This state update is not guaranteed to run in the same commit// This results in a visual "jump" as the ToolTip repositions itselfsetTargetRect({x,y,width,height});});},[]);return(<><Viewref={targetRef}onLayout={onLayout}><Text>Some content that renders a tooltip above</Text></View><TooltiptargetRect={targetRect}/></>);}With the New Architecture, we can useuseLayoutEffectto synchronously measure and apply layout updates in a single commit, avoiding the visual "jump".jsxfunctionViewWithTooltip(){// ...useLayoutEffect(()=>{// The measurement and state update for `targetRect` happens in a single commit// allowing ToolTip to position itself without intermediate paintstargetRef.current?.measureInWindow((x,y,width,height)=>{setTargetRect({x,y,width,height});});},[setTargetRect]);return(<><Viewref={targetRef}><Text>Some content that renders a tooltip above</Text></View><TooltiptargetRect={targetRect}/></>);}Asynchronous measurement and render of the ToolTip.See code.Synchronous measurement and render of the ToolTip.See code.

```
function ViewWithTooltip() {  // ...  // We get the layout information and pass to ToolTip to position itself  const onLayout = React.useCallback(event => {    targetRef.current?.measureInWindow((x, y, width, height) => {      // This state update is not guaranteed to run in the same commit      // This results in a visual "jump" as the ToolTip repositions itself      setTargetRect({x, y, width, height});    });  }, []);  return (    <>      <View ref={targetRef} onLayout={onLayout}>        <Text>Some content that renders a tooltip above</Text>      </View>      <Tooltip targetRect={targetRect} />    </>  );}
```

With the New Architecture, we can useuseLayoutEffectto synchronously measure and apply layout updates in a single commit, avoiding the visual "jump".jsxfunctionViewWithTooltip(){// ...useLayoutEffect(()=>{// The measurement and state update for `targetRect` happens in a single commit// allowing ToolTip to position itself without intermediate paintstargetRef.current?.measureInWindow((x,y,width,height)=>{setTargetRect({x,y,width,height});});},[setTargetRect]);return(<><Viewref={targetRef}><Text>Some content that renders a tooltip above</Text></View><TooltiptargetRect={targetRect}/></>);}Asynchronous measurement and render of the ToolTip.See code.Synchronous measurement and render of the ToolTip.See code.

```
function ViewWithTooltip() {  // ...  useLayoutEffect(() => {    // The measurement and state update for `targetRect` happens in a single commit    // allowing ToolTip to position itself without intermediate paints    targetRef.current?.measureInWindow((x, y, width, height) => {      setTargetRect({x, y, width, height});    });  }, [setTargetRect]);  return (    <>      <View ref={targetRef}>        <Text>Some content that renders a tooltip above</Text>      </View>      <Tooltip targetRect={targetRect} />    </>  );}
```


### Support for Concurrent Renderer and Features
The New Architecture supports concurrent rendering and features that have shipped inReact 18and beyond. You can now use features like Suspense for data-fetching, Transitions, and other new React APIs in your React Native code, further conforming codebases and concepts between web and native React development.

The concurrent renderer also brings out-of-the-box improvements like automatic batching, which reduces re-renders in React.

With the New Architecture, you'll get automatic batching with the React 18 renderer.In this example, a slider specifies how many tiles to render. Dragging the slider from 0 to 1000 will fire off a quick succession of state updates and re-renders.In comparing the renderers for thesame code, you can visually notice the renderer provides a smoother UI, with less intermediate UI updates. State updates from native event handlers, like this native Slider component, are now batched.Rendering frequent state updates with legacy renderer.Rendering frequent state updates with React 18 renderer.

In this example, a slider specifies how many tiles to render. Dragging the slider from 0 to 1000 will fire off a quick succession of state updates and re-renders.In comparing the renderers for thesame code, you can visually notice the renderer provides a smoother UI, with less intermediate UI updates. State updates from native event handlers, like this native Slider component, are now batched.Rendering frequent state updates with legacy renderer.Rendering frequent state updates with React 18 renderer.

In comparing the renderers for thesame code, you can visually notice the renderer provides a smoother UI, with less intermediate UI updates. State updates from native event handlers, like this native Slider component, are now batched.Rendering frequent state updates with legacy renderer.Rendering frequent state updates with React 18 renderer.

New concurrent features, likeTransitions, give you the power to express the priority of UI updates. Marking an update as lower priority tells React it can "interrupt" rendering the update to handle higher priority updates to ensure a responsive user experience where it matters.

We can build on the previous example to showcase how transitions can interrupt in-progress rendering to handle a newer state update.We wrap the tile number state update withstartTransitionto indicate that rendering the tiles can be interrupted.startTransitionalso provides aisPendingflag to tell us when the transition is complete.jsxfunctionTileSlider({value,onValueChange}){const[isPending,startTransition]=useTransition();return(<><View><Text>Render{value}Tiles</Text><ActivityIndicatoranimating={isPending}/></View><Slidervalue={1}minimumValue={1}maximumValue={1000}step={1}onValueChange={newValue=>{startTransition(()=>{onValueChange(newValue);});}}/></>);}functionManyTiles(){const[value,setValue]=useState(1);consttiles=generateTileViews(value);return(<TileSlideronValueChange={setValue}value={value}/><View>{tiles}</View>)}You'll notice that with the frequent updates in a transition, React renders fewer intermediate states because it bails out of rendering the state as soon as it becomes stale. In comparison, without transitions, more intermediate states are rendered. Both examples still use automatic batching. Still, transitions give even more power to developers to batch in-progress renders.Rendering tiles with transitions to interrupt in-progress renders of stale state.See code.Rendering tiles without marking it as a transition.See code.

We wrap the tile number state update withstartTransitionto indicate that rendering the tiles can be interrupted.startTransitionalso provides aisPendingflag to tell us when the transition is complete.jsxfunctionTileSlider({value,onValueChange}){const[isPending,startTransition]=useTransition();return(<><View><Text>Render{value}Tiles</Text><ActivityIndicatoranimating={isPending}/></View><Slidervalue={1}minimumValue={1}maximumValue={1000}step={1}onValueChange={newValue=>{startTransition(()=>{onValueChange(newValue);});}}/></>);}functionManyTiles(){const[value,setValue]=useState(1);consttiles=generateTileViews(value);return(<TileSlideronValueChange={setValue}value={value}/><View>{tiles}</View>)}You'll notice that with the frequent updates in a transition, React renders fewer intermediate states because it bails out of rendering the state as soon as it becomes stale. In comparison, without transitions, more intermediate states are rendered. Both examples still use automatic batching. Still, transitions give even more power to developers to batch in-progress renders.Rendering tiles with transitions to interrupt in-progress renders of stale state.See code.Rendering tiles without marking it as a transition.See code.

```
function TileSlider({value, onValueChange}) {  const [isPending, startTransition] = useTransition();  return (    <>      <View>        <Text>          Render {value} Tiles        </Text>        <ActivityIndicator animating={isPending} />      </View>      <Slider        value={1}        minimumValue={1}        maximumValue={1000}        step={1}        onValueChange={newValue => {          startTransition(() => {            onValueChange(newValue);          });        }}      />    </>  );}function ManyTiles() {  const [value, setValue] = useState(1);  const tiles = generateTileViews(value);  return (      <TileSlider onValueChange={setValue} value={value} />      <View>        {tiles}      </View>  )}
```

You'll notice that with the frequent updates in a transition, React renders fewer intermediate states because it bails out of rendering the state as soon as it becomes stale. In comparison, without transitions, more intermediate states are rendered. Both examples still use automatic batching. Still, transitions give even more power to developers to batch in-progress renders.Rendering tiles with transitions to interrupt in-progress renders of stale state.See code.Rendering tiles without marking it as a transition.See code.


### Fast JavaScript/Native Interfacing
The New Architecture removes theasynchronous bridgebetween JavaScript and native and replaces it with JavaScript Interface (JSI). JSI is an interface that allows JavaScript to hold a reference to a C++ object and vice-versa. With a memory reference, you can directly invoke methods without serialization costs.

JSI enablesVisionCamera, a popular camera library for React Native, to process frames in real time. Typical frame buffers are ~30 MB, which amounts to roughly 2 GB of data per second, depending on the frame rate. In comparison with the serialization costs of the bridge, JSI handles that amount of interfacing data with ease. JSI can expose other complex instance-based types such as databases, images, audio samples, etc.

JSI adoption in the New Architecture removes this class of serialization work from all native-JavaScript interop. This includes initializing and re-rendering native core components likeViewandText. You can read more about ourinvestigation in rendering performancein the New Architecture and the improved benchmarks we measured.


## What can I expect from enabling the New Architecture?
While the New Architecture enables these features and improvements, enabling the New Architecture for your app or library may not immediately improve the performance or user experience.

For example, your code may need refactoring to leverage new capabilities like synchronous layout effects or concurrent features. Although JSI will minimize the overhead between JavaScript and native memory, data serialization may not have been a bottleneck for your app's performance.

Enabling the New Architecture in your app or library is opting into the future of React Native.

The team is actively researching and developing new capabilities the New Architecture unlocks. For example, web alignment is an active area of exploration at Meta that will ship to the React Native open source ecosystem.

- Updates to the event loop model
- Node and layout APIs
- Styling and layout conformance
You can follow along and contribute in our dedicateddiscussions & proposalsrepository.


## Should I use the New Architecture today?
With 0.76, The New Architecture is enabled by default in all the React Native projects.

If you find anything that is not working well, please open an issue usingthis template.

If, for any reasons, you can't use the New Architecture, you can still opt-out from it:


### Android
- Open theandroid/gradle.propertiesfile
- Toggle thenewArchEnabledflag fromtruetofalse
```
# Use this property to enable support to the new architecture.# This will allow you to use TurboModules and the Fabric render in# your application. You should enable this flag either if you want# to write custom TurboModules/Fabric components OR use libraries that# are providing them.-newArchEnabled=true+newArchEnabled=false
```


### iOS
- Open theios/Podfilefile
- AddENV['RCT_NEW_ARCH_ENABLED'] = '0'in the main scope of the Podfile (reference Podfilein the template)
```
+ ENV['RCT_NEW_ARCH_ENABLED'] = '0'# Resolve react_native_pods.rb with node to allow for hoistingrequire Pod::Executable.execute_command('node', ['-p',  'require.resolve(
```

- Install your CocoaPods dependencies with the command:
```
bundle exec pod install
```


================================================================================


# Architecture Overview
Source: https://reactnative.dev/architecture/overview

Welcome to the Architecture Overview! If you're getting started with React Native, please refer toGuidessection. Continue reading to learn how internals of React Native work!This section is a work in progress and more material will be added in the future. Please make sure to come back later to check for new information.

This section is a work in progress and more material will be added in the future. Please make sure to come back later to check for new information.

Architecture Overview is intended to share conceptual overview of how React Native's internals work. The intended audience includes library authors and core contributors. If you are an app developer, it is not a requirement to be familiar with this material to be effective with React Native. You can still benefit from the overview as it will give you insights into how React Native works under the hood. Feel free to share your feedback on thediscussion inside the working groupfor this section.


## Table of Contents
- About the New Architecture
- RenderingFabricRender, Commit, and MountCross Platform ImplementationView FlatteningThreading Model
- Fabric
- Render, Commit, and Mount
- Cross Platform Implementation
- View Flattening
- Threading Model
- Build ToolsBundled Hermes
- Bundled Hermes
- Glossary

================================================================================


# Render, Commit, and Mount
Source: https://reactnative.dev/architecture/render-pipeline

This document refers to theNew Architecture, that is in active roll-out.

The React Native renderer goes through a sequence of work to render React logic to ahost platform. This sequence of work is called the render pipeline and occurs for initial renders and updates to the UI state. This document goes over the render pipeline and how it differs in those scenarios.

The render pipeline can be broken into three general phases:

- Render:React executes product logic which creates aReact Element Treesin JavaScript. From this tree, the renderer creates aReact Shadow Treein C++.
- Commit: After a React Shadow Tree is fully created, the renderer triggers a commit. Thispromotesboth the React Element Tree and the newly created React Shadow Tree as the “next tree” to be mounted. This also schedules calculation of its layout information.
- Mount:The React Shadow Tree, now with the results of layout calculation, is transformed into aHost View Tree.
The phases of the render pipeline may occur on different threads. Refer to theThreading Modeldoc for more detail.


## Initial Render
Imagine you want to render the following:

```
function MyComponent() {  return (    <View>      <Text>Hello, World</Text>    </View>  );}// <MyComponent />
```

In the example above,<MyComponent />is aReact Element. React recursively reduces thisReact Elementto a terminalReact Host Componentby invoking it (or itsrendermethod if implemented with a JavaScript class) until everyReact Elementcannot be reduced any further. Now you have aReact Element TreeofReact Host Components.


### Phase 1. Render
During this process of element reduction, as eachReact Elementis invoked, the renderer also synchronously creates aReact Shadow Node. This happens only forReact Host Components, not forReact Composite Components. In the example above, the<View>leads to the creation of aViewShadowNodeobject, and the<Text>leads to the creation of aTextShadowNodeobject. Notably, there is never aReact Shadow Nodethat directly represents<MyComponent>.

Whenever React creates a parent-child relationship between twoReact Element Nodes, the renderer creates the same relationship between the correspondingReact Shadow Nodes. This is how theReact Shadow Treeis assembled.

Additional Details

- The operations (creation ofReact Shadow Node, creation of parent-child relationship between twoReact Shadow Nodes) are synchronous and thread-safe operations that are executed from React (JavaScript) into the renderer (C++), usually on the JavaScript thread.
- TheReact Element Tree(and its constituentReact Element Nodes) do not exist indefinitely. It is a temporal representation materialized by “fibers” in React. Each “fiber” that represents a host component stores a C++ pointer to theReact Shadow Node, made possible by JSI.Learn more about “fibers” in this document.
- TheReact Shadow Treeis immutable. In order to update anyReact Shadow Node, the renderer creates a newReact Shadow Tree. However, the renderer provides cloning operations to make state updates more performant (seeReact State Updatesfor more details).
In the example above, the result of the render phase looks like this:

After theReact Shadow Treeis complete, the renderer triggers a commit of theReact Element Tree.


### Phase 2. Commit
The commit phase consists of two operations:Layout CalculationandTree Promotion.

- Layout Calculation:This operation calculates the position and size of eachReact Shadow Node. In React Native, this involves invoking Yoga to calculate the layout of eachReact Shadow Node. The actual calculation requires eachReact Shadow Node’s styles which originate from aReact Elementin JavaScript. It also requires the layout constraints of the root of theReact Shadow Tree, which determines the amount of available space that the resulting nodes can occupy.
- Tree Promotion (New Tree → Next Tree):This operation promotes the newReact Shadow Treeas the “next tree” to be mounted. This promotion indicates that the newReact Shadow Treehas all the information to be mounted and represents the latest state of theReact Element Tree. The “next tree” mounts on the next “tick” of the UI Thread.
Additional Details

- These operations are asynchronously executed on a background thread.
- Majority of layout calculation executes entirely within C++. However, the layout calculation of some components depend on thehost platform(e.g.Text,TextInput, etc.). Size and position of text is specific to eachhost platformand needs to be calculated on thehost platformlayer. For this purpose, Yoga invokes a function defined in thehost platformto calculate the component’s layout.

### Phase 3. Mount
The mount phase transforms theReact Shadow Tree(which now contains data from layout calculation) into aHostView Treewith rendered pixels on the screen. As a reminder, theReact Element Treelooks like this:

```
<View>  <Text>Hello, World</Text></View>
```

At a high level, React Native renderer creates a correspondingHost Viewfor eachReact Shadow Nodeand mounts it on screen. In the example above, the renderer creates an instance ofandroid.view.ViewGroupfor the<View>andandroid.widget.TextViewfor<Text>and populates it with “Hello World”. Similarly for iOS aUIViewis created and text is populated with a call toNSLayoutManager. Each host view is then configured to use props from its React Shadow Node, and its size and position is configured using the calculated layout information.

In more detail, the mounting phase consists of these three steps:

- Tree Diffing:This step computes the diff between the “previously rendered tree” and the “next tree” entirely in C++. The result is a list of atomic mutation operations to be performed on host views (e.g.createView,updateView,removeView,deleteView, etc). This step is also where the React Shadow Tree is flattened to avoid creating unnecessary host views. SeeView Flatteningfor details about this algorithm.
- Tree Promotion (Next Tree → Rendered Tree): This step atomically promotes the “next tree” to “previously rendered tree” so that the next mount phase computes a diff against the proper tree.
- View Mounting: This step applies the atomic mutation operations onto corresponding host views. This step executes in thehost platformon UI thread.
Additional Details

- The operations are synchronously executed on UI thread. If the commit phase executes on background thread, the mounting phase is scheduled for the next “tick” of UI thread. On the other hand, if the commit phase executes on UI thread, mounting phase executes synchronously on the same thread.
- Scheduling, implementation, and execution of the mounting phase heavily depends on thehost platform. For example, the renderer architecture of the mounting layer currently differs between Android and iOS.
- During the initial render, the “previously rendered tree” is empty. As such, the tree diffing step will result in a list of mutation operations that consists only of creating views, setting props, and adding views to each other. Tree diffing becomes more important for performance when processingReact State Updates.
- In current production tests, aReact Shadow Treetypically consists of about 600-1000React Shadow Nodes(before view flattening), the trees get reduced to ~200 nodes after view flattening. On iPad or desktop apps, this quantity may increase 10-fold.

## React State Updates
Let’s explore each phase of the render pipeline when the state of aReact Element Treeis updated. Let’s say, you’ve rendered the following component in an initial render:

```
function MyComponent() {  return (    <View>      <View        style={{backgroundColor: 'red', height: 20, width: 20}}      />      <View        style={{backgroundColor: 'blue', height: 20, width: 20}}      />    </View>  );}
```

Applying what was described in theInitial Rendersection, you would expect the following trees to be created:

Notice thatNode 3maps to a host view with ared background, andNode 4maps to a host view with ablue background. Assume that as the result of a state update in JavaScript product logic, the background of the first nested<View>changes from'red'to'yellow'. This is what the newReact Element Treemight look:

```
<View>  <View    style={{backgroundColor: 'yellow', height: 20, width: 20}}  />  <View    style={{backgroundColor: 'blue', height: 20, width: 20}}  /></View>
```

How is this update processed by React Native?

When a state update occurs, the renderer needs to conceptually update theReact Element Treein order to update the host views that are already mounted. But in order to preserve thread safety, both theReact Element Treeas well as theReact Shadow Treemust be immutable. This means that instead of mutating the currentReact Element TreeandReact Shadow Tree, React must create a new copy of each tree which incorporates the new props, styles, and children.

Let’s explore each phase of the render pipeline during a state update.


### Phase 1. Render
When React creates a newReact Element Treethat incorporates the new state, it must clone everyReact ElementandReact Shadow Nodethat is impacted by the change. After cloning, the newReact Shadow Treeis committed.

React Native renderer leverages structural sharing to minimize the overhead of immutability. When aReact Elementis cloned to include the new state, everyReact Elementthat is on the path up to the root is cloned.React will only clone a React Element if it requires an update to its props, style, or children.AnyReact Elementsthat are unchanged by the state update are shared by the old and new trees.

In the above example, React creates the new tree using these operations:

- CloneNode(Node 3,{backgroundColor: 'yellow'}) →Node 3'
- CloneNode(Node 2) →Node 2'
- AppendChild(Node 2',Node 3')
- AppendChild(Node 2',Node 4)
- CloneNode(Node 1) →Node 1'
- AppendChild(Node 1',Node 2')
After these operations,Node 1'represents the root of the newReact Element Tree. Let's assignTto the “previously rendered tree” andT'to the “new tree”:

Notice howTandT'both shareNode 4. Structural sharing improves performance and reduces memory usage.


### Phase 2. Commit
After React creates the newReact Element TreeandReact Shadow Tree, it must commit them.

- Layout Calculation:Similar to Layout Calculation duringInitial Render. One important difference is that layout calculation may cause sharedReact Shadow Nodesto be cloned. This can happen because if the parent of a sharedReact Shadow Nodeincurs a layout change, the layout of the sharedReact Shadow Nodemay also change.
- Tree Promotion (New Tree → Next Tree):Similar to Tree Promotion duringInitial Render.

### Phase 3. Mount
- Tree Promotion (Next Tree → Rendered Tree): This step atomically promotes the “next tree” to “previously rendered tree” so that the next mount phase computes a diff against the proper tree.
- Tree Diffing:This step computes the diff between the “previously rendered tree” (T) and the “next tree” (T'). The result is a list of atomic mutation operations to be performed onhost views.In the above example, the operations consist of:UpdateView(**Node 3**, {backgroundColor: 'yellow'})The diff can be calculated for any currently mounted tree with any new tree. The renderer can skip some intermediate versions of the tree.
- In the above example, the operations consist of:UpdateView(**Node 3**, {backgroundColor: 'yellow'})
- The diff can be calculated for any currently mounted tree with any new tree. The renderer can skip some intermediate versions of the tree.
- View Mounting: This step applies the atomic mutation operations onto correspondinghost views. In the above example, only thebackgroundColorofView 3will be updated (to yellow).

## React Native Renderer State Updates
For most information in theShadow Tree, React is the single owner and single source of truth. All data originates from React and there is a single-direction flow of data.

However, there is one exception and important mechanism: components in C++ can contain state that is not directly exposed to JavaScript, and JavaScript is not the source of truth. C++ andHost Platformcontrol thisC++ State. Generally, this is only relevant if you are developing a complicatedHost Componentthat needsC++ State. The vast majority ofHost Componentsdo not need this functionality.

For example,ScrollViewuses this mechanism to let the renderer know what the current offset is. The update is triggered from thehost platform, specifically from the host view that represents theScrollViewcomponent. The information about offset is used in an API likemeasure. Since this update stems from the host platform, and does not affect the React Element Tree, this state data is held byC++ State.

Conceptually,C++ Stateupdates are similar to theReact State Updatesdescribed above.
With two important differences:

- They skip the “render phase” since React is not involved.
- The updates can originate and happen on any thread, including the main thread.

### Phase 2. Commit
When performing aC++ Stateupdate, a block of code requests an update of aShadowNode(N) to setC++ Stateto valueS. React Native renderer will repeatedly attempt to get the latest committed version ofN, clone it with a new stateS, and commitN’to the tree. If React, or anotherC++ Stateupdate, has performed another commit during this time, theC++ Statecommit will fail and the renderer will retry theC++ Stateupdate many times until a commit succeeds. This prevents source-of-truth collisions and races.


### Phase 3. Mount
TheMount Phaseis practically identical to theMount Phase of React State Updates. The renderer still needs to recompute layout, perform a tree diff, etc. See the sections above for details.


================================================================================


# Threading Model
Source: https://reactnative.dev/architecture/threading-model

This document refers to theNew Architecture, that is in active roll-out.

Here we define the threading model and provide some examples to illustrate thread usage of the render pipeline.

React Native renderer is designed to be thread safe. At a high level thread safety is guaranteed by using immutable data structures in the internals of the framework (enforced by C++ “const correctness” feature). This means that every update in React creates or clones new objects in the renderer instead of updating data structures. This allows the framework to expose thread safe and synchronous APIs to React.

The renderer uses two different threads:

- UI thread(often called main): The only thread that can manipulate host views.
- JavaScript thread: This is where React’s render phase, as well as layout, are executed.
Let’s review the supported scenarios of execution for each phase:


## Render Scenarios

### Render in a JS Thread
This is the most common scenario where most of the render pipeline happens on JavaScript thread.


### Render in the UI Thread
When there is a high priority event on the UI Thread, the renderer is able to execute all the render pipeline synchronously on the UI thread.


### Default or continuous event interruption
This scenario shows the interruption of the render phase by a low priority event in the UI thread. React and the React Native renderer are able to interrupt the render phase and merge its state with a low priority event that is executed on the UI thread. In this case the render process continues executing in the JS thread.


### Discrete event interruption
The render phase is interruptible. This scenario shows the interruption of the render phase by a high priority event in the UI thread. React and the renderer are able to interrupt the render phase and merge its state with a high priority event that was executed on the UI thread. The render phase executes synchronously on the UI thread.


### C++ State update
Update originating on UI thread and skips rendering phase. SeeReact Native Renderer State Updatesfor more details.


================================================================================


# View Flattening
Source: https://reactnative.dev/architecture/view-flattening

This document refers to theNew Architecture, that is in active roll-out.

The React API is designed to be declarative and reusable through composition. This provides a great model for intuitive development. However, in implementation, these qualities of the API lead to the creation of deepReact Element Trees, where a large majority of React Element Nodes only affect the layout of a View and don’t render anything on the screen. We call these types of nodes“Layout-Only”Nodes.

Conceptually, each of the Nodes of the React Element Tree have a 1:1 relationship with a view on the screen, therefore rendering a deep React Element Tree that is composed by a large amount of “Layout-Only” Node leads to poor performance during rendering.

Here is a common use case that is affected by the cost of "Layout Only" views.

Imagine you want to render an image and a title that is handled by theTitleComponent, and you include this component as a child of theContainerComponentthat has some margin styles. After decomposing the components, the React code would look like this:

```
function MyComponent() {  return (    <View>                          // ReactAppComponent      <View style={{margin: 10}} /> // ContainerComponent        <View style={{margin: 10}}> // TitleComponent          <Image {...} />          <Text {...}>This is a title</Text>        </View>      </View>    </View>  );}
```

As part of the render process, React Native will produce the following trees:

Note that the Views (2) and (3) are “Layout Only” views, because they are rendered on the screen but they only render amarginof10 pxon top of their children.

To improve the performance of these types of React Element Trees, the renderer implements a View Flattening mechanism that merges or flattens these types of Nodes, reducing the depth of thehost viewhierarchy that is rendered on the screen. This algorithm takes into consideration props like:margin,padding,backgroundColor,opacity, etc.

The View Flattening algorithm is integrated by design as part of the diffing stage of the renderer, which means that we don’t use extra CPU cycles to optimize the React Element Tree flattening these types of views. As the rest of the core, the View flattening algorithm is implemented in C++ and its benefits are shared by default on all supported platforms.

In the case of the previous example, the Views (2) and (3) would be flattened as part of the “diffing algorithm” and as a result their styles will be merged into the View (1):

It is important to note that this optimization allows the renderer to avoid the creation and render of two host views. From the user’s perspective there are no visible changes on the screen.


================================================================================


# Cross Platform Implementation
Source: https://reactnative.dev/architecture/xplat-implementation

This document refers to theNew Architecture, that is in active roll-out.

In the previous render system of React Native, theReact Shadow Tree, layout logic, andView Flatteningalgorithm were implemented once for each platform. The current renderer was designed to be a cross-platform solution by sharing a core C++ implementation.

The React Native team intends to incorporate an animation system into the render system and also extend the React Native render system to new platforms such as Windows, and operating systems in game consoles, televisions, and more.

Leveraging C++ for the core render system introduces several advantages. A single implementation reduces the cost of development and maintenance. It improves the performance of creating React Shadow Trees and layout calculation because the overhead of integratingYogawith the renderer is minimized on Android (i.e. no moreJNIfor Yoga). Finally, the memory footprint of each React Shadow Node is smaller in C++ than it would be if allocated from Kotlin or Swift.

The team is also leveraging C++ features that enforce immutability to ensure there are no issues related to concurrent access to shared but not protected resources.

It is important to recognize that the renderer use case for Android still incurs the cost ofJNIfor two primary use cases:

- Layout calculation of complex views (e.g.Text,TextInput, etc.) requires sending props over JNI.
- The mount phase requires sending mutation operations over JNI.
The team is exploring replacingReadableMapwith a new mechanism to serialize data usingByteBufferto reduce overhead of JNI. Our goal is to reduce overhead of JNI by 35–50%.

The renderer provides two sides of its C++ APIs:

- (i)to communicate with React
- (ii)to communicate with the host platform
For(i), React communicates with the renderer torendera React Tree and to “listen” forevents(e.g.onLayout,onKeyPress, touch, etc).

For(ii), the React Native renderer communicates with the host platform to mount host views on the screen (create, insert, update or delete of host views) and it listens foreventsthat are generated by the user on the host platform.


================================================================================


# Accessibility
Source: https://reactnative.dev/docs/accessibility

Both Android and iOS provide APIs for integrating apps with assistive technologies like the bundled screen readers VoiceOver (iOS) and TalkBack (Android). React Native has complementary APIs that let your app accommodate all users.

Android and iOS differ slightly in their approaches, and thus the React Native implementations may vary by platform.


## Accessibility properties

### accessible
Whentrue, indicates that the view is discoverable by assistive technologies such as screen readers and hardware keyboards. Note that this does not necessarily mean that the view will be focused by VoiceOver or TalkBack. There are a number of reasons for this, such as VoiceOver disallowing nested accessibility elements, or TalkBack opting to focus some parent element instead.

By default, all touchable elements are accessible.

On Android,accessiblewill be translated into nativefocusable. On iOS, it translates into nativeisAccessibilityElement.

```
<View>  <View accessible={true} />  <View /></View>
```

In the above example, accessibility focus is only available on the first child view with theaccessibleproperty, and not for the parent or sibling withoutaccessible.


### accessibilityLabel
When a view is marked as accessible, it is a good practice to set anaccessibilityLabelon the view, so that people who use VoiceOver or TalkBack know what element they have selected. A screen reader will verbalize this string when the associated element is selected.

To use, set theaccessibilityLabelproperty to a custom string on your View, Text, or Touchable:

```
<TouchableOpacity  accessible={true}  accessibilityLabel="Tap me!"  onPress={onPress}>  <View style={styles.button}>    <Text style={styles.buttonText}>Press me!</Text>  </View></TouchableOpacity>
```

In the above example, theaccessibilityLabelon the TouchableOpacity element would default to "Press me!". The label is constructed by concatenating all Text node children separated by spaces.


### accessibilityLabelledByAndroid
A reference to another elementnativeIDused to build complex forms.
The value ofaccessibilityLabelledByshould match thenativeIDof the related element:

```
<View>  <Text nativeID="formLabel">Label for Input Field</Text>  <TextInput    accessibilityLabel="input"    accessibilityLabelledBy="formLabel"  /></View>
```

In the above example, the screen reader announcesInput, Edit Box for Label for Input Fieldwhen focusing on the TextInput.


### accessibilityHint
An accessibility hint can be used to provide additional context to the user on the result of the action when it is not clear from the accessibility label alone.

Provide theaccessibilityHintproperty a custom string on your View, Text, or Touchable:

```
<TouchableOpacity  accessible={true}  accessibilityLabel="Go back"  accessibilityHint="Navigates to the previous screen"  onPress={onPress}>  <View style={styles.button}>    <Text style={styles.buttonText}>Back</Text>  </View></TouchableOpacity>
```

In the above example, VoiceOver will read the hint after the label, if the user has hints enabled in the device's VoiceOver settings. Read more about guidelines foraccessibilityHintin theiOS Developer Docs

In the above example, TalkBack will read the hint after the label. At this time, hints cannot be turned off on Android.


### accessibilityLanguageiOS
By using theaccessibilityLanguageproperty, the screen reader will understand which language to use while reading the element'slabel,value, andhint. The provided string value must follow theBCP 47 specification.

```
<View  accessible={true}  accessibilityLabel="Pizza"  accessibilityLanguage="it-IT">  <Text>🍕</Text></View>
```


### accessibilityIgnoresInvertColorsiOS
Inverting screen colors is an accessibility feature available in iOS and iPadOS for people with color blindness, low vision, or vision impairment. If there's a view you don't want to invert when this setting is on, possibly a photo, set this property totrue.


### accessibilityLiveRegionAndroid
When components dynamically change, we want TalkBack to alert the end user. This is made possible by theaccessibilityLiveRegionproperty. It can be set tonone,polite, andassertive:

- noneAccessibility services should not announce changes to this view.
- politeAccessibility services should announce changes to this view.
- assertiveAccessibility services should interrupt ongoing speech to immediately announce changes to this view.
```
<TouchableWithoutFeedback onPress={addOne}>  <View style={styles.embedded}>    <Text>Click me</Text>  </View></TouchableWithoutFeedback><Text accessibilityLiveRegion="polite">  Clicked {count} times</Text>
```

In the above example methodaddOnechanges the state variablecount. When the TouchableWithoutFeedback is triggered, TalkBack reads the text in the Text view because of itsaccessibilityLiveRegion="polite"property.


### accessibilityRole
accessibilityRolecommunicates the purpose of a component to the user of assistive technology.

accessibilityRolecan be one of the following:

- adjustableUsed when an element can be "adjusted" (e.g. a slider).
- alertUsed when an element contains important text to be presented to the user.
- buttonUsed when the element should be treated as a button.
- checkboxUsed when an element represents a checkbox that can be checked, unchecked, or have a mixed checked state.
- comboboxUsed when an element represents a combo box, which allows the user to select among several choices.
- headerUsed when an element acts as a header for a content section (e.g. the title of a navigation bar).
- imageUsed when the element should be treated as an image. Can be combined with a button or link.
- imagebuttonUsed when the element should be treated as a button and is also an image.
- keyboardkeyUsed when the element acts as a keyboard key.
- linkUsed when the element should be treated as a link.
- menuUsed when the component is a menu of choices.
- menubarUsed when a component is a container of multiple menus.
- menuitemUsed to represent an item within a menu.
- noneUsed when the element has no role.
- progressbarUsed to represent a component that indicates the progress of a task.
- radioUsed to represent a radio button.
- radiogroupUsed to represent a group of radio buttons.
- scrollbarUsed to represent a scroll bar.
- searchUsed when a text field element should also be treated as a search field.
- spinbuttonUsed to represent a button that opens a list of choices.
- summaryUsed when an element can be used to provide a quick summary of current conditions in the app when the app first launches.
- switchUsed to represent a switch that can be turned on and off.
- tabUsed to represent a tab.
- tablistUsed to represent a list of tabs.
- textUsed when the element should be treated as static text that cannot change.
- timerUsed to represent a timer.
- togglebuttonUsed to represent a toggle button. Should be used with accessibilityState checked to indicate if the button is toggled on or off.
- toolbarUsed to represent a toolbar (a container of action buttons or components).
- gridUsed with ScrollView, VirtualizedList, FlatList, or SectionList to represent a grid. Adds the in/out of grid announcements to Android's GridView.

### accessibilityShowsLargeContentVieweriOS
A boolean value that determines whether the large content viewer is shown when the user performs a long press on the element.

Available in iOS 13.0 and later.


### accessibilityLargeContentTitleiOS
A string that will be used as the title of the large content viewer when it is shown.

RequiresaccessibilityShowsLargeContentViewerto be set totrue.

```
<View  accessibilityShowsLargeContentViewer={true}  accessibilityLargeContentTitle="Home Tab">  <Text>Home</Text></View>
```


### accessibilityState
Describes the current state of a component to the assistive technology user.

accessibilityStateis an object. It contains the following fields:

To use, set theaccessibilityStateto an object with a specific definition.


### accessibilityValue
Represents the current value of a component. It can be a textual description of a component's value, or for range-based components, such as sliders and progress bars, it contains range information (minimum, current, and maximum).

accessibilityValueis an object. It contains the following fields:


### accessibilityViewIsModaliOS
A boolean value that indicates whether VoiceOver should ignore the elements within views that are siblings of the receiver.

For example, in a window that contains sibling viewsAandB, settingaccessibilityViewIsModaltotrueon viewBcauses VoiceOver to ignore the elements in viewA. On the other hand, if viewBcontains a child viewCand you setaccessibilityViewIsModaltotrueon viewC, VoiceOver does not ignore the elements in viewA.


### accessibilityElementsHiddeniOS
A boolean value indicating whether the given accessibility element, and any accessibility elements it contains, are hidden.

For example, in a window that contains sibling viewsAandB, settingaccessibilityElementsHiddentotrueon viewBcauses VoiceOver to ignore theBview and any elements it contains. This is similar to the Android propertyimportantForAccessibility="no-hide-descendants".


### aria-valuemax
Represents the maximum value for range-based components, such as sliders and progress bars.


### aria-valuemin
Represents the minimum value for range-based components, such as sliders and progress bars.


### aria-valuenow
Represents the current value for range-based components, such as sliders and progress bars.


### aria-valuetext
Represents the textual description of the component.


### aria-busy
Indicates an element is being modified and that assistive technologies may want to wait until the changes are complete before informing the user about the update.


### aria-checked
Indicates the state of a checkable element. This field can either take a boolean or the "mixed" string to represent mixed checkboxes.


### aria-disabled
Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.


### aria-expanded
Indicates whether an expandable element is currently expanded or collapsed.


### aria-hidden
Indicates whether the element is hidden from assistive technologies.

For example, in a window that contains sibling viewsAandB, settingaria-hiddentotrueon viewBcauses VoiceOver to ignore theBelement and its children.


### aria-label
Defines a string value that can be used to name an element.


### aria-labelledbyAndroid
Identifies the element that labels the element it is applied to. The value ofaria-labelledbyshould match thenativeIDof the related element:

```
<View>  <Text nativeID="formLabel">Label for Input Field</Text>  <TextInput aria-label="input" aria-labelledby="formLabel" /></View>
```


### aria-liveAndroid
Indicates that an element will be updated and describes the types of updates the user agents, assistive technologies, and user can expect from the live region.

- offAccessibility services should not announce changes to this view.
- politeAccessibility services should announce changes to this view.
- assertiveAccessibility services should interrupt ongoing speech to immediately announce changes to this view.

### aria-modaliOS
Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.


### aria-selected
Indicates whether a selectable element is currently selected or not.


### experimental_accessibilityOrder
This API is experimental.Experimental APIs may contain bugs and are likely to change in a future version of React Native. Don't use them in production.

For the sake of brevity, layout is excluded in the following examples even though it dictates the default focus order. Assume the document order matches the layout order.

experimental_accessibilityOrderlets you define the order in which assistive technologies focus descendant components. It is an array ofnativeIDsthat are set on the components whose order you are controlling. For example:

```
<View experimental_accessibilityOrder={['B', 'C', 'A']}>  <View accessible={true} nativeID="A"/>  <View accessible={true} nativeID="B"/>  <View accessible={true} nativeID="C"/></View>
```

Assistive technologies will focus theViewwithnativeIDofB, thenC, thenA.

experimental_accessibilityOrderwill not “turn on” accessibility for the components it references, that still needs to be done. So if we removeaccessible={true}onCabove like so

```
<View experimental_accessibilityOrder={['B', 'C', 'A']}>  <View accessible={true} nativeID="A"/>  <View accessible={true} nativeID="B"/>  <View nativeID="C"/></View>
```

then the new order will beBthenA, even thoughCis still inexperimental_accessibilityOrder.

experimental_accessibilityOrderwill “turn off” accessibility of components it doesn’t reference, however.

```
<View experimental_accessibilityOrder={['B', 'C', 'A']}>  <View accessible={true} nativeID="A"/>  <View accessible={true} nativeID="B"/>  <View accessible={true} nativeID="C"/>  <View accessible={true} nativeID="D"/></View>
```

The order of the above example would beB,C,A.Dwill never get focused. In this senseexperimental_accessibilityOrderisexhaustive.

There are still valid reasons to include an non-accessible component inexperimental_accessibilityOrder. Consider

```
<View experimental_accessibilityOrder={['B', 'C', 'A']}>  <View accessible={true} nativeID="A"/>  <View accessible={true} nativeID="B"/>  <View nativeID="C">    <View accessible={true} nativeID="D"/>    <View accessible={true} nativeID="E"/>    <View accessible={true} nativeID="F"/>  </View></View>
```

The focus order will beB,D,E,F,A. Even thoughD,E, andFare not directly referenced inexperimental_accessibilityOrder,Cis directly referenced. In this instanceCin anaccessibility container- it contains accessible elements, but is not accessible itself. If an accessibility container is referenced inexperimental_accessibilityOrderthen the default order of the elements it contains is applied. In this senseexperimental_accessibilityOrderisnestable.

experimental_accessibilityOrdercan also reference another component withexperimental_accessibilityOrder

```
<View experimental_accessibilityOrder={['B', 'C', 'A']}>  <View accessible={true} nativeID="A"/>  <View accessible={true} nativeID="B"/>  <View nativeID="C" experimental_accessibilityOrder={['F', 'E', 'D']}>    <View accessible={true} nativeID="D"/>    <View accessible={true} nativeID="E"/>    <View accessible={true} nativeID="F"/>  </View></View>
```

The focus order will beB,F,E,D,A.

A component cannot be both an accessibility container and an accessibility element (accessible={true}). So if we have

```
<View experimental_accessibilityOrder={['B', 'C', 'A']}>  <View accessible={true} nativeID="A"/>  <View accessible={true} nativeID="B"/>  <View accessible={true} nativeID="C" experimental_accessibilityOrder={['F', 'E', 'D']}>    <View accessible={true} nativeID="D"/>    <View accessible={true} nativeID="E"/>    <View accessible={true} nativeID="F"/>  </View></View>
```

The focus order would beB,C,A.D,E, andFare no longer in a container, so the exhaustive nature ofexperimental_accessibilityOrdermeans they will be excluded.


### importantForAccessibilityAndroid
In the case of two overlapping UI components with the same parent, default accessibility focus can have unpredictable behavior. TheimportantForAccessibilityproperty will resolve this by controlling if a view fires accessibility events and if it is reported to accessibility services. It can be set toauto,yes,noandno-hide-descendants(the last value will force accessibility services to ignore the component and all of its children).

```
<View style={styles.container}>  <View    style={[styles.layout, {backgroundColor: 'green'}]}    importantForAccessibility="yes">    <Text>First layout</Text>  </View>  <View    style={[styles.layout, {backgroundColor: 'yellow'}]}    importantForAccessibility="no-hide-descendants">    <Text>Second layout</Text>  </View></View>
```

In the above example, theyellowlayout and its descendants are completely invisible to TalkBack and all other accessibility services. So we can use overlapping views with the same parent without confusing TalkBack.


### onAccessibilityEscapeiOS
Assign this property to a custom function which will be called when someone performs the "escape" gesture, which is a two finger Z shaped gesture. An escape function should move back hierarchically in the user interface. This can mean moving up or back in a navigation hierarchy or dismissing a modal user interface. If the selected element does not have anonAccessibilityEscapefunction, the system will attempt to traverse up the view hierarchy until it finds a view that does or bonk to indicate it was unable to find one.


### onAccessibilityTapiOS
Use this property to assign a custom function to be called when someone activates an accessible element by double tapping on it while it's selected.


### onMagicTapiOS
Assign this property to a custom function which will be called when someone performs the "magic tap" gesture, which is a double-tap with two fingers. A magic tap function should perform the most relevant action a user could take on a component. In the Phone app on iPhone, a magic tap answers a phone call or ends the current one. If the selected element does not have anonMagicTapfunction, the system will traverse up the view hierarchy until it finds a view that does.


### role
rolecommunicates the purpose of a component and has precedence over theaccessibilityRoleprop.

rolecan be one of the following:

- alertUsed when an element contains important text to be presented to the user.
- buttonUsed when the element should be treated as a button.
- checkboxUsed when an element represents a checkbox that can be checked, unchecked, or have a mixed checked state.
- comboboxUsed when an element represents a combo box, which allows the user to select among several choices.
- gridUsed with ScrollView, VirtualizedList, FlatList, or SectionList to represent a grid. Adds the in/out of grid announcements to the android GridView.
- headingUsed when an element acts as a header for a content section (e.g. the title of a navigation bar).
- imgUsed when the element should be treated as an image. Can be combined with a button or link, for example.
- linkUsed when the element should be treated as a link.
- listUsed to identify a list of items.
- listitemUsed to itentify an item in a list.
- menuUsed when the component is a menu of choices.
- menubarUsed when a component is a container of multiple menus.
- menuitemUsed to represent an item within a menu.
- noneUsed when the element has no role.
- presentationUsed when the element has no role.
- progressbarUsed to represent a component that indicates the progress of a task.
- radioUsed to represent a radio button.
- radiogroupUsed to represent a group of radio buttons.
- scrollbarUsed to represent a scroll bar.
- searchboxUsed when the text field element should also be treated as a search field.
- sliderUsed when an element can be "adjusted" (e.g. a slider).
- spinbuttonUsed to represent a button that opens a list of choices.
- summaryUsed when an element can be used to provide a quick summary of current conditions in the app when the app first launches.
- switchUsed to represent a switch that can be turned on and off.
- tabUsed to represent a tab.
- tablistUsed to represent a list of tabs.
- timerUsed to represent a timer.
- toolbarUsed to represent a toolbar (a container of action buttons or components).

## Accessibility Actions
Accessibility actions allow assistive technology to programmatically invoke the action(s) of a component. To support accessibility actions, a component must do two things:

- Define the list of actions it supports via theaccessibilityActionsproperty.
- Implement anonAccessibilityActionfunction to handle action requests.
TheaccessibilityActionsproperty should contain a list of action objects. Each action object should contain the following fields:

Actions either represent standard actions, such as clicking a button or adjusting a slider, or custom actions specific to a given component such as deleting an email message. Thenamefield is required for both standard and custom actions, butlabelis optional for standard actions.

When adding support for standard actions,namemust be one of the following:

- 'magicTap'- iOS only - While VoiceOver focus is on or inside the component, the user double tapped with two fingers.
- 'escape'- iOS only - While VoiceOver focus is on or inside the component, the user performed a two-finger scrub gesture (left, right, left).
- 'activate'- Activate the component. This should perform the same action with, or without, assistive technology. Engaged when a screen reader user double taps the component.
- 'increment'- Increment an adjustable component. On iOS, VoiceOver generates this action when the component has a role of'adjustable'and the user places focus on it and swipes upward. On Android, TalkBack generates this action when the user places accessibility focus on the component and presses the volume-up button.
- 'decrement'- Decrement an adjustable component. On iOS, VoiceOver generates this action when the component has a role of'adjustable'and the user places focus on it and swipes downward. On Android, TalkBack generates this action when the user places accessibility focus on the component and presses the volume-down button.
- 'longpress'- Android only - This action is generated when the user places accessibility focus on the component, then double-taps and holds one finger on the screen. This should perform the same action with, or without, assistive technology.
- 'expand'- Android only - This action "expands" the component so that TalkBack will announce an "expanded" hint.
- 'collapse'- Android only - This action "collapses" the component so that TalkBack will announce a "collapsed" hint.
Thelabelfield is optional for standard actions and is often unused by assistive technologies. For custom actions, it is a localized string containing a description of the action to be presented to the user.

To handle action requests, a component must implement anonAccessibilityActionfunction. The only argument to this function is an event containing the name of the action to perform. The below example from RNTester shows how to create a component that defines and handles several custom actions.

```
<View  accessible={true}  accessibilityActions={[    {name: 'cut', label: 'cut'},    {name: 'copy', label: 'copy'},    {name: 'paste', label: 'paste'},  ]}  onAccessibilityAction={event => {    switch (event.nativeEvent.actionName) {      case 'cut':        Alert.alert('Alert', 'cut action success');        break;      case 'copy':        Alert.alert('Alert', 'copy action success');        break;      case 'paste':        Alert.alert('Alert', 'paste action success');        break;    }  }}/>
```


## Checking if a Screen Reader is Enabled
TheAccessibilityInfoAPI allows you to determine whether or not a screen reader is currently active. See theAccessibilityInfo documentationfor details.


## Sending Accessibility EventsAndroid
Sometimes it is useful to trigger an accessibility event on a UI component (i.e. when a custom view appears on a screen or set accessibility focus to a view). Native UIManager module exposes a method ‘sendAccessibilityEvent’ for this purpose. It takes two arguments: a view tag and a type of event. The supported event types aretypeWindowStateChanged,typeViewFocused, andtypeViewClicked.

```
import {Platform, UIManager, findNodeHandle} from 'react-native';if (Platform.OS === 'android') {  UIManager.sendAccessibilityEvent(    findNodeHandle(this),    UIManager.AccessibilityEventTypes.typeViewFocused,  );}
```


## Testing TalkBack SupportAndroid
To enable TalkBack, go to the Settings app on your Android device or emulator. Tap Accessibility, then TalkBack. Toggle the "Use service" switch to enable or disable it.

Android emulators don't have TalkBack installed by default. You can install TalkBack on your emulator via the Google Play Store. Make sure to choose an emulator with the Google Play store installed. These are available in Android Studio.

You can use the volume key shortcut to toggle TalkBack. To turn on the volume key shortcut, go to the Settings app, then Accessibility. At the top, turn on the volume key shortcut.

To use the volume key shortcut, press both volume keys for 3 seconds to start an accessibility tool.

Additionally, if you prefer, you can toggle TalkBack via the command line with:

```
# disableadb shell settings put secure enabled_accessibility_services com.android.talkback/com.google.android.marvin.talkback.TalkBackService# enableadb shell settings put secure enabled_accessibility_services com.google.android.marvin.talkback/com.google.android.marvin.talkback.TalkBackService
```


## Testing VoiceOver SupportiOS
To enable VoiceOver on your iOS or iPadOS device, go to the Settings app, tap General, then Accessibility. There you will find many tools available for people to enable their devices to be more usable, including VoiceOver. To enable VoiceOver, tap on VoiceOver under "Vision" and toggle the switch that appears at the top.

At the very bottom of the Accessibility settings, there is an "Accessibility Shortcut". You can use this to toggle VoiceOver by triple-clicking the Home button.

VoiceOver isn't available via the simulator, but you can use Accessibility Inspector from Xcode to use the macOS VoiceOver through an application. Note it's always best to test with a device as macOS's VoiceOver may result in varied experiences.


## Additional Resources
- Making React Native Apps Accessible

================================================================================


# AccessibilityInfo
Source: https://reactnative.dev/docs/accessibilityinfo

Sometimes it's useful to know whether or not the device has a screen reader that is currently active. TheAccessibilityInfoAPI is designed for this purpose. You can use it to query the current state of the screen reader as well as to register to be notified when the state of the screen reader changes.


## Example

## Methods

### addEventListener()
```
static addEventListener(  eventName: AccessibilityChangeEventName | AccessibilityAnnouncementEventName,  handler: (    event: AccessibilityChangeEvent | AccessibilityAnnouncementFinishedEvent,  ) => void,): EmitterSubscription;
```

Add an event handler. Supported events:

- announcement: The string announced by the screen reader.success: A boolean indicating whether the announcement was successfully made.
- success: A boolean indicating whether the announcement was successfully made.

### announceForAccessibility()
```
static announceForAccessibility(announcement: string);
```

Post a string to be announced by the screen reader.


### announceForAccessibilityWithOptions()
```
static announceForAccessibilityWithOptions(  announcement: string,  options: {queue?: boolean},);
```

Post a string to be announced by the screen reader with modification options. By default announcements will interrupt any existing speech, but on iOS they can be queued behind existing speech by settingqueuetotruein the options object.

Parameters:


### getRecommendedTimeoutMillis()Android
```
static getRecommendedTimeoutMillis(originalTimeout: number): Promise<number>;
```

Gets the timeout in millisecond that the user needs.
This value is set in "Time to take action (Accessibility timeout)" of "Accessibility" settings.

Parameters:


### isAccessibilityServiceEnabled()Android
```
static isAccessibilityServiceEnabled(): Promise<boolean>;
```

Check whether any accessibility service is enabled. This includes TalkBack but also any third-party accessibility app that may be installed. To only check whether TalkBack is enabled, useisScreenReaderEnabled. Returns a promise which resolves to a boolean. The result istruewhen some accessibility services is enabled andfalseotherwise.

Please useisScreenReaderEnabledif you only want to check the status of TalkBack.


### isBoldTextEnabled()iOS
```
static isBoldTextEnabled(): Promise<boolean>:
```

Query whether a bold text is currently enabled. Returns a promise which resolves to a boolean. The result istruewhen bold text is enabled andfalseotherwise.


### isGrayscaleEnabled()iOS
```
static isGrayscaleEnabled(): Promise<boolean>;
```

Query whether grayscale is currently enabled. Returns a promise which resolves to a boolean. The result istruewhen grayscale is enabled andfalseotherwise.


### isInvertColorsEnabled()iOS
```
static isInvertColorsEnabled(): Promise<boolean>;
```

Query whether invert colors is currently enabled. Returns a promise which resolves to a boolean. The result istruewhen invert colors is enabled andfalseotherwise.


### isReduceMotionEnabled()
```
static isReduceMotionEnabled(): Promise<boolean>;
```

Query whether reduce motion is currently enabled. Returns a promise which resolves to a boolean. The result istruewhen reduce motion is enabled andfalseotherwise.


### isReduceTransparencyEnabled()iOS
```
static isReduceTransparencyEnabled(): Promise<boolean>;
```

Query whether reduce transparency is currently enabled. Returns a promise which resolves to a boolean. The result istruewhen a reduce transparency is enabled andfalseotherwise.


### isScreenReaderEnabled()
```
static isScreenReaderEnabled(): Promise<boolean>;
```

Query whether a screen reader is currently enabled. Returns a promise which resolves to a boolean. The result istruewhen a screen reader is enabled andfalseotherwise.


### prefersCrossFadeTransitions()iOS
```
static prefersCrossFadeTransitions(): Promise<boolean>;
```

Query whether reduce motion and prefer cross-fade transitions settings are currently enabled. Returns a promise which resolves to a boolean. The result istruewhen prefer cross-fade transitions is enabled andfalseotherwise.


### 🗑️setAccessibilityFocus()
Prefer usingsendAccessibilityEventwith eventTypefocusinstead.

```
static setAccessibilityFocus(reactTag: number);
```

Set accessibility focus to a React component.

On Android, this callsUIManager.sendAccessibilityEventmethod with passedreactTagandUIManager.AccessibilityEventTypes.typeViewFocusedarguments.

Make sure that anyViewyou want to receive the accessibility focus hasaccessible={true}.


### sendAccessibilityEvent()
```
static sendAccessibilityEvent(host: HostInstance, eventType: AccessibilityEventTypes);
```

Imperatively trigger an accessibility event on a React component, like changing the focused element for a screen reader.

Make sure that anyViewyou want to receive the accessibility focus hasaccessible={true}.


================================================================================


# ActionSheetIOS
Source: https://reactnative.dev/docs/actionsheetios

Displays native to iOSAction Sheetcomponent.


## Example

## Methods

### showActionSheetWithOptions()
```
static showActionSheetWithOptions: (  options: ActionSheetIOSOptions,  callback: (buttonIndex: number) => void,);
```

Display an iOS action sheet. Theoptionsobject must contain one or more of:

- options(array of strings) - a list of button titles (required)
- cancelButtonIndex(int) - index of cancel button inoptions
- cancelButtonTintColor(string) - thecolorused for the change the text color of the cancel button
- destructiveButtonIndex(int or array of ints) - indices of destructive buttons inoptions
- title(string) - a title to show above the action sheet
- message(string) - a message to show below the title
- anchor(number) - the node to which the action sheet should be anchored (used for iPad)
- tintColor(string) - thecolorused for non-destructive button titles
- disabledButtonIndices(array of numbers) - a list of button indices which should be disabled
- userInterfaceStyle(string) - the interface style used for the action sheet, can be set tolightordark, otherwise the default system style will be used
The 'callback' function takes one parameter, the zero-based index of the selected item.

Minimal example:

```
ActionSheetIOS.showActionSheetWithOptions(  {    options: ['Cancel', 'Remove'],    destructiveButtonIndex: 1,    cancelButtonIndex: 0,  },  buttonIndex => {    if (buttonIndex === 1) {      /* destructive action */    }  },);
```


### dismissActionSheet()
```
static dismissActionSheet();
```

Dismisses the most upper iOS action sheet presented, if no action sheet is present a warning is displayed.


### showShareActionSheetWithOptions()
```
static showShareActionSheetWithOptions: (  options: ShareActionSheetIOSOptions,  failureCallback: (error: Error) => void,  successCallback: (success: boolean, method: string) => void,);
```

Display the iOS share sheet. Theoptionsobject should contain one or both ofmessageandurland can additionally have asubjectorexcludedActivityTypes:

- url(string) - a URL to share
- message(string) - a message to share
- subject(string) - a subject for the message
- excludedActivityTypes(array) - the activities to exclude from the ActionSheet
Ifurlpoints to a local file, or is a base64-encoded uri, the file it points to will be loaded and shared directly. In this way, you can share images, videos, PDF files, etc. Ifurlpoints to a remote file or address it must conform to URL format as described inRFC 2396. For example, a web URL without a proper protocol (HTTP/HTTPS) will not be shared.

The 'failureCallback' function takes one parameter, an error object. The only property defined on this object is an optionalstackproperty of typestring.

The 'successCallback' function takes two parameters:

- a boolean value signifying success or failure
- a string that, in the case of success, indicates the method of sharing

================================================================================


# ActivityIndicator
Source: https://reactnative.dev/docs/activityindicator

Displays a circular loading indicator.


## Example

## Props

### View Props
InheritsView Props.


### animating
Whether to show the indicator (true) or hide it (false).


### color
The foreground color of the spinner.


### hidesWhenStoppediOS
Whether the indicator should hide when not animating.


### ref
A ref setter that will be assigned anelement nodewhen mounted.


### size
Size of the indicator.


================================================================================


# Alert
Source: https://reactnative.dev/docs/alert

Launches an alert dialog with the specified title and message.

Optionally provide a list of buttons. Tapping any button will fire the respective onPress callback and dismiss the alert. By default, the only button will be an 'OK' button.

This is an API that works both on Android and iOS and can show static alerts. Alert that prompts the user to enter some information is available on iOS only.


## Example

## iOS
On iOS you can specify any number of buttons. Each button can optionally specify a style or be emphasized, available options are represented by theAlertButtonStyleenum and theisPreferredfield onAlertButton.


## Android
On Android at most three buttons can be specified. Android has a concept of a neutral, negative and a positive button:

- If you specify one button, it will be the 'positive' one (such as 'OK')
- Two buttons mean 'negative', 'positive' (such as 'Cancel', 'OK')
- Three buttons mean 'neutral', 'negative', 'positive' (such as 'Later', 'Cancel', 'OK')
Alerts on Android can be dismissed by tapping outside of the alert box. It is disabled by default and can be enabled by providing an optionalAlertOptionsparameter with the cancelable property set totruei.e.{cancelable: true}.

The cancel event can be handled by providing anonDismisscallback property inside theoptionsparameter.


### ExampleAndroid

## Methods

### alert()
```
static alert (  title: string,  message?: string,  buttons?: AlertButton[],  options?: AlertOptions,);
```

Parameters:


### prompt()iOS
```
static prompt: (  title: string,  message?: string,  callbackOrButtons?: ((text: string) => void) | AlertButton[],  type?: AlertType,  defaultValue?: string,  keyboardType?: string,);
```

Create and display a prompt to enter some text in form of Alert.

Parameters:


## Type Definitions

### AlertButtonStyleiOS
An iOS Alert button style.

Constants:


### AlertTypeiOS
An iOS Alert type.

Constants:


### AlertButton
An object describing the configuration of a button in the alert.

Objects properties:


### AlertOptions
Properties:


================================================================================


# ❌ AlertIOS
Source: https://reactnative.dev/docs/alertios

UseAlertinstead.


================================================================================


# Animated
Source: https://reactnative.dev/docs/animated

TheAnimatedlibrary is designed to make animations fluid, powerful, and painless to build and maintain.Animatedfocuses on declarative relationships between inputs and outputs, configurable transforms in between, andstart/stopmethods to control time-based animation execution.

The core workflow for creating an animation is to create anAnimated.Value, hook it up to one or more style attributes of an animated component, and then drive updates via animations usingAnimated.timing().

Don't modify the animated value directly. You can use theuseRefHookto return a mutable ref object. This ref object'scurrentproperty is initialized as the given argument and persists throughout the component lifecycle.


## Example
The following example contains aViewwhich will fade in and fade out based on the animated valuefadeAnim

Refer to theAnimationsguide to see additional examples ofAnimatedin action.


## Overview
There are two value types you can use withAnimated:

- Animated.Value()for single values
- Animated.ValueXY()for vectors
Animated.Valuecan bind to style properties or other props, and can be interpolated as well. A singleAnimated.Valuecan drive any number of properties.


### Configuring animations
Animatedprovides three types of animation types. Each animation type provides a particular animation curve that controls how your values animate from their initial value to the final value:

- Animated.decay()starts with an initial velocity and gradually slows to a stop.
- Animated.spring()provides a basic spring physics model.
- Animated.timing()animates a value over time usingeasing functions.
In most cases, you will be usingtiming(). By default, it uses a symmetric easeInOut curve that conveys the gradual acceleration of an object to full speed and concludes by gradually decelerating to a stop.


### Working with animations
Animations are started by callingstart()on your animation.start()takes a completion callback that will be called when the animation is done. If the animation finished running normally, the completion callback will be invoked with{finished: true}. If the animation is done becausestop()was called on it before it could finish (e.g. because it was interrupted by a gesture or another animation), then it will receive{finished: false}.

```
Animated.timing({}).start(({finished}) => {  /* completion callback */});
```


### Using the native driver
By using the native driver, we send everything about the animation to native before starting the animation, allowing native code to perform the animation on the UI thread without having to go through the bridge on every frame. Once the animation has started, the JS thread can be blocked without affecting the animation.

You can use the native driver by specifyinguseNativeDriver: truein your animation configuration. See theAnimationsguide to learn more.


### Animatable components
Only animatable components can be animated. These unique components do the magic of binding the animated values to the properties, and do targeted native updates to avoid the cost of the React render and reconciliation process on every frame. They also handle cleanup on unmount so they are safe by default.

- createAnimatedComponent()can be used to make a component animatable.
Animatedexports the following animatable components using the above wrapper:

- Animated.Image
- Animated.ScrollView
- Animated.Text
- Animated.View
- Animated.FlatList
- Animated.SectionList

### Composing animations
Animations can also be combined in complex ways using composition functions:

- Animated.delay()starts an animation after a given delay.
- Animated.parallel()starts a number of animations at the same time.
- Animated.sequence()starts the animations in order, waiting for each to complete before starting the next.
- Animated.stagger()starts animations in order and in parallel, but with successive delays.
Animations can also be chained together by setting thetoValueof one animation to be anotherAnimated.Value. SeeTracking dynamic valuesin the Animations guide.

By default, if one animation is stopped or interrupted, then all other animations in the group are also stopped.


### Combining animated values
You can combine two animated values via addition, subtraction, multiplication, division, or modulo to make a new animated value:

- Animated.add()
- Animated.subtract()
- Animated.divide()
- Animated.modulo()
- Animated.multiply()

### Interpolation
Theinterpolate()function allows input ranges to map to different output ranges. By default, it will extrapolate the curve beyond the ranges given, but you can also have it clamp the output value. It uses linear interpolation by default but also supports easing functions.

- interpolate()
Read more about interpolation in theAnimationguide.


### Handling gestures and other events
Gestures, like panning or scrolling, and other events can map directly to animated values usingAnimated.event(). This is done with a structured map syntax so that values can be extracted from complex event objects. The first level is an array to allow mapping across multiple args, and that array contains nested objects.

- Animated.event()
For example, when working with horizontal scrolling gestures, you would do the following in order to mapevent.nativeEvent.contentOffset.xtoscrollX(anAnimated.Value):

```
 onScroll={Animated.event(   // scrollX = e.nativeEvent.contentOffset.x   [{nativeEvent: {        contentOffset: {          x: scrollX        }      }    }] )}
```


## Methods
When the given value is a ValueXY instead of a Value, each config option may be a vector of the form{x: ..., y: ...}instead of a scalar.


### decay()
```
static decay(value, config): CompositeAnimation;
```

Animates a value from an initial velocity to zero based on a decay coefficient.

Config is an object that may have the following options:

- velocity: Initial velocity. Required.
- deceleration: Rate of decay. Default 0.997.
- isInteraction: Whether or not this animation creates an "interaction handle" on theInteractionManager. Default true.
- useNativeDriver: Uses the native driver when true. Required.

### timing()
```
static timing(value, config): CompositeAnimation;
```

Animates a value along a timed easing curve. TheEasingmodule has tons of predefined curves, or you can use your own function.

Config is an object that may have the following options:

- duration: Length of animation (milliseconds). Default 500.
- easing: Easing function to define curve. Default isEasing.inOut(Easing.ease).
- delay: Start the animation after delay (milliseconds). Default 0.
- isInteraction: Whether or not this animation creates an "interaction handle" on theInteractionManager. Default true.
- useNativeDriver: Uses the native driver when true. Required.

### spring()
```
static spring(value, config): CompositeAnimation;
```

Animates a value according to an analytical spring model based ondamped harmonic oscillation. Tracks velocity state to create fluid motions as thetoValueupdates, and can be chained together.

Config is an object that may have the following options.

Note that you can only define one of bounciness/speed, tension/friction, or stiffness/damping/mass, but not more than one:

The friction/tension or bounciness/speed options match the spring model inFacebook Pop,Rebound, andOrigami.

- friction: Controls "bounciness"/overshoot. Default 7.
- tension: Controls speed. Default 40.
- speed: Controls speed of the animation. Default 12.
- bounciness: Controls bounciness. Default 8.
Specifying stiffness/damping/mass as parameters makesAnimated.springuse an analytical spring model based on the motion equations of adamped harmonic oscillator. This behavior is slightly more precise and faithful to the physics behind spring dynamics, and closely mimics the implementation in iOS's CASpringAnimation.

- stiffness: The spring stiffness coefficient. Default 100.
- damping: Defines how the spring’s motion should be damped due to the forces of friction. Default 10.
- mass: The mass of the object attached to the end of the spring. Default 1.
Other configuration options are as follows:

- velocity: The initial velocity of the object attached to the spring. Default 0 (object is at rest).
- overshootClamping: Boolean indicating whether the spring should be clamped and not bounce. Default false.
- restDisplacementThreshold: The threshold of displacement from rest below which the spring should be considered at rest. Default 0.001.
- restSpeedThreshold: The speed at which the spring should be considered at rest in pixels per second. Default 0.001.
- delay: Start the animation after delay (milliseconds). Default 0.
- isInteraction: Whether or not this animation creates an "interaction handle" on theInteractionManager. Default true.
- useNativeDriver: Uses the native driver when true. Required.

### add()
```
static add(a: Animated, b: Animated): AnimatedAddition;
```

Creates a new Animated value composed from two Animated values added together.


### subtract()
```
static subtract(a: Animated, b: Animated): AnimatedSubtraction;
```

Creates a new Animated value composed by subtracting the second Animated value from the first Animated value.


### divide()
```
static divide(a: Animated, b: Animated): AnimatedDivision;
```

Creates a new Animated value composed by dividing the first Animated value by the second Animated value.


### multiply()
```
static multiply(a: Animated, b: Animated): AnimatedMultiplication;
```

Creates a new Animated value composed from two Animated values multiplied together.


### modulo()
```
static modulo(a: Animated, modulus: number): AnimatedModulo;
```

Creates a new Animated value that is the (non-negative) modulo of the provided Animated value


### diffClamp()
```
static diffClamp(a: Animated, min: number, max: number): AnimatedDiffClamp;
```

Create a new Animated value that is limited between 2 values. It uses the difference between the last value so even if the value is far from the bounds it will start changing when the value starts getting closer again. (value = clamp(value + diff, min, max)).

This is useful with scroll events, for example, to show the navbar when scrolling up and to hide it when scrolling down.


### delay()
```
static delay(time: number): CompositeAnimation;
```

Starts an animation after the given delay.


### sequence()
```
static sequence(animations: CompositeAnimation[]): CompositeAnimation;
```

Starts an array of animations in order, waiting for each to complete before starting the next. If the current running animation is stopped, no following animations will be started.


### parallel()
```
static parallel(  animations: CompositeAnimation[],  config?: ParallelConfig): CompositeAnimation;
```

Starts an array of animations all at the same time. By default, if one of the animations is stopped, they will all be stopped. You can override this with thestopTogetherflag.


### stagger()
```
static stagger(  time: number,  animations: CompositeAnimation[]): CompositeAnimation;
```

Array of animations may run in parallel (overlap), but are started in sequence with successive delays. Nice for doing trailing effects.


### loop()
```
static loop(  animation: CompositeAnimation[],  config?: LoopAnimationConfig): CompositeAnimation;
```

Loops a given animation continuously, so that each time it reaches the end, it resets and begins again from the start. Will loop without blocking the JS thread if the child animation is set touseNativeDriver: true. In addition, loops can preventVirtualizedList-based components from rendering more rows while the animation is running. You can passisInteraction: falsein the child animation config to fix this.

Config is an object that may have the following options:

- iterations: Number of times the animation should loop. Default-1(infinite).

### event()
```
static event(  argMapping: Mapping[],  config?: EventConfig): (...args: any[]) => void;
```

Takes an array of mappings and extracts values from each arg accordingly, then callssetValueon the mapped outputs. e.g.

```
onScroll={Animated.event(  [{nativeEvent: {contentOffset: {x: this._scrollX}}}],  {listener: (event: ScrollEvent) => console.log(event)}, // Optional async listener)} ...onPanResponderMove: Animated.event(  [    null, // raw event arg ignored    {dx: this._panX},  ], // gestureState arg  {    listener: (      event: GestureResponderEvent,      gestureState: PanResponderGestureState    ) => console.log(event, gestureState),  } // Optional async listener);
```

Config is an object that may have the following options:

- listener: Optional async listener.
- useNativeDriver: Uses the native driver when true. Required.

### forkEvent()
```
static forkEvent(event: AnimatedEvent, listener: Function): AnimatedEvent;
```

Advanced imperative API for snooping on animated events that are passed in through props. It permits to add a new javascript listener to an existingAnimatedEvent. IfanimatedEventis a javascript listener, it will merge the 2 listeners into a single one, and ifanimatedEventis null/undefined, it will assign the javascript listener directly. Use values directly where possible.


### unforkEvent()
```
static unforkEvent(event: AnimatedEvent, listener: Function);
```


### start()
```
static start(callback?: (result: {finished: boolean}) => void);
```

Animations are started by calling start() on your animation. start() takes a completion callback that will be called when the animation is done or when the animation is done because stop() was called on it before it could finish.

Parameters:

Start example with callback:

```
Animated.timing({}).start(({finished}) => {  /* completion callback */});
```


### stop()
```
static stop();
```

Stops any running animation.


### reset()
```
static reset();
```

Stops any running animation and resets the value to its original.


## Properties

### Value
Standard value class for driving animations. Typically initialized withuseAnimatedValue(0);ornew Animated.Value(0);in class components.

You can read more aboutAnimated.ValueAPI on the separatepage.


### ValueXY
2D value class for driving 2D animations, such as pan gestures.

You can read more aboutAnimated.ValueXYAPI on the separatepage.


### Interpolation
Exported to use the Interpolation type in flow.


### Node
Exported for ease of type checking. All animated values derive from this class.


### createAnimatedComponent
Make any React component Animatable. Used to createAnimated.View, etc.


### attachNativeEvent
Imperative API to attach an animated value to an event on a view. Prefer usingAnimated.eventwithuseNativeDriver: trueif possible.


================================================================================


# Animated.Value
Source: https://reactnative.dev/docs/animatedvalue

Standard value for driving animations. OneAnimated.Valuecan drive multiple properties in a synchronized fashion, but can only be driven by one mechanism at a time. Using a new mechanism (e.g. starting a new animation, or callingsetValue) will stop any previous ones.

Typically initialized withuseAnimatedValue(0);ornew Animated.Value(0);in class components.


## Methods

### setValue()
```
setValue(value: number);
```

Directly set the value. This will stop any animations running on the value and update all the bound properties.

Parameters:


### setOffset()
```
setOffset(offset: number);
```

Sets an offset that is applied on top of whatever value is set, whether viasetValue, an animation, orAnimated.event. Useful for compensating things like the start of a pan gesture.

Parameters:


### flattenOffset()
```
flattenOffset();
```

Merges the offset value into the base value and resets the offset to zero. The final output of the value is unchanged.


### extractOffset()
```
extractOffset();
```

Sets the offset value to the base value, and resets the base value to zero. The final output of the value is unchanged.


### addListener()
```
addListener(callback: (state: {value: number}) => void): string;
```

Adds an asynchronous listener to the value so you can observe updates from animations. This is useful because there is no way to synchronously read the value because it might be driven natively.

Returns a string that serves as an identifier for the listener.

Parameters:


### removeListener()
```
removeListener(id: string);
```

Unregister a listener. Theidparam shall match the identifier previously returned byaddListener().

Parameters:


### removeAllListeners()
```
removeAllListeners();
```

Remove all registered listeners.


### stopAnimation()
```
stopAnimation(callback?: (value: number) => void);
```

Stops any running animation or tracking.callbackis invoked with the final value after stopping the animation, which is useful for updating state to match the animation position with layout.

Parameters:


### resetAnimation()
```
resetAnimation(callback?: (value: number) => void);
```

Stops any animation and resets the value to its original.

Parameters:


### interpolate()
```
interpolate(config: InterpolationConfigType);
```

Interpolates the value before updating the property, e.g. mapping 0-1 to 0-10.

SeeAnimatedInterpolation.js

Parameters:

Theconfigobject is composed of the following keys:

- inputRange: an array of numbers
- outputRange: an array of numbers or strings
- easing(optional): a function that returns a number, given an input number
- extrapolate(optional): a string such as 'extend', 'identity', or 'clamp'
- extrapolateLeft(optional): a string such as 'extend', 'identity', or 'clamp'
- extrapolateRight(optional): a string such as 'extend', 'identity', or 'clamp'

### animate()
```
animate(animation, callback);
```

Typically only used internally, but could be used by a custom Animation class.

Parameters:


================================================================================


# Animated.ValueXY
Source: https://reactnative.dev/docs/animatedvaluexy

2D Value for driving 2D animations, such as pan gestures. Almost identical API to normalAnimated.Value, but multiplexed. Contains two regularAnimated.Values under the hood.


## Example

## Methods

### setValue()
```
setValue(value: {x: number; y: number});
```

Directly set the value. This will stop any animations running on the value and update all the bound properties.

Parameters:


### setOffset()
```
setOffset(offset: {x: number; y: number});
```

Sets an offset that is applied on top of whatever value is set, whether viasetValue, an animation, orAnimated.event. Useful for compensating things like the start of a pan gesture.

Parameters:


### flattenOffset()
```
flattenOffset();
```

Merges the offset value into the base value and resets the offset to zero. The final output of the value is unchanged.


### extractOffset()
```
extractOffset();
```

Sets the offset value to the base value, and resets the base value to zero. The final output of the value is unchanged.


### addListener()
```
addListener(callback: (value: {x: number; y: number}) => void);
```

Adds an asynchronous listener to the value so you can observe updates from animations. This is useful because there is no way to synchronously read the value because it might be driven natively.

Returns a string that serves as an identifier for the listener.

Parameters:


### removeListener()
```
removeListener(id: string);
```

Unregister a listener. Theidparam shall match the identifier previously returned byaddListener().

Parameters:


### removeAllListeners()
```
removeAllListeners();
```

Remove all registered listeners.


### stopAnimation()
```
stopAnimation(callback?: (value: {x: number; y: number}) => void);
```

Stops any running animation or tracking.callbackis invoked with the final value after stopping the animation, which is useful for updating state to match the animation position with layout.

Parameters:


### resetAnimation()
```
resetAnimation(callback?: (value: {x: number; y: number}) => void);
```

Stops any animation and resets the value to its original.

Parameters:


### getLayout()
```
getLayout(): {left: Animated.Value, top: Animated.Value};
```

Converts{x, y}into{left, top}for use in style, e.g.

```
style={this.state.anim.getLayout()}
```


### getTranslateTransform()
```
getTranslateTransform(): [  {translateX: Animated.Value},  {translateY: Animated.Value},];
```

Converts{x, y}into a useable translation transform, e.g.

```
style={{  transform: this.state.anim.getTranslateTransform()}}
```


================================================================================


# Animations
Source: https://reactnative.dev/docs/animations

Animations are very important to create a great user experience. Stationary objects must overcome inertia as they start moving. Objects in motion have momentum and rarely come to a stop immediately. Animations allow you to convey physically believable motion in your interface.

React Native provides two complementary animation systems:Animatedfor granular and interactive control of specific values, andLayoutAnimationfor animated global layout transactions.


## AnimatedAPI
TheAnimatedAPI is designed to concisely express a wide variety of interesting animation and interaction patterns in a very performant way.Animatedfocuses on declarative relationships between inputs and outputs, with configurable transforms in between, andstart/stopmethods to control time-based animation execution.

Animatedexports six animatable component types:View,Text,Image,ScrollView,FlatListandSectionList, but you can also create your own usingAnimated.createAnimatedComponent().

For example, a container view that fades in when it is mounted may look like this:

- TypeScriptJavaScript
- JavaScript
Let's break down what's happening here. In theFadeInViewrender method, a newAnimated.ValuecalledfadeAnimis initialized withuseRef. The opacity property on theViewis mapped to this animated value. Behind the scenes, the numeric value is extracted and used to set opacity.

When the component mounts, the opacity is set to 0. Then, an easing animation is started on thefadeAnimanimated value, which will update all of its dependent mappings (in this case, only the opacity) on each frame as the value animates to the final value of 1.

This is done in an optimized way that is faster than callingsetStateand re-rendering. Because the entire configuration is declarative, we will be able to implement further optimizations that serialize the configuration and runs the animation on a high-priority thread.


### Configuring animations
Animations are heavily configurable. Custom and predefined easing functions, delays, durations, decay factors, spring constants, and more can all be tweaked depending on the type of animation.

Animatedprovides several animation types, the most commonly used one beingAnimated.timing(). It supports animating a value over time using one of various predefined easing functions, or you can use your own. Easing functions are typically used in animation to convey gradual acceleration and deceleration of objects.

By default,timingwill use an easeInOut curve that conveys gradual acceleration to full speed and concludes by gradually decelerating to a stop. You can specify a different easing function by passing aneasingparameter. Customdurationor even adelaybefore the animation starts is also supported.

For example, if we want to create a 2-second long animation of an object that slightly backs up before moving to its final position:

```
Animated.timing(this.state.xPosition, {  toValue: 100,  easing: Easing.back(),  duration: 2000,  useNativeDriver: true,}).start();
```

Take a look at theConfiguring animationssection of theAnimatedAPI reference to learn more about all the config parameters supported by the built-in animations.


### Composing animations
Animations can be combined and played in sequence or in parallel. Sequential animations can play immediately after the previous animation has finished, or they can start after a specified delay. TheAnimatedAPI provides several methods, such assequence()anddelay(), each of which take an array of animations to execute and automatically callsstart()/stop()as needed.

For example, the following animation coasts to a stop, then it springs back while twirling in parallel:

```
Animated.sequence([  // decay, then spring to start and twirl  Animated.decay(position, {    // coast to a stop    velocity: {x: gestureState.vx, y: gestureState.vy}, // velocity from gesture release    deceleration: 0.997,    useNativeDriver: true,  }),  Animated.parallel([    // after decay, in parallel:    Animated.spring(position, {      toValue: {x: 0, y: 0}, // return to start      useNativeDriver: true,    }),    Animated.timing(twirl, {      // and twirl      toValue: 360,      useNativeDriver: true,    }),  ]),]).start(); // start the sequence group
```

If one animation is stopped or interrupted, then all other animations in the group are also stopped.Animated.parallelhas astopTogetheroption that can be set tofalseto disable this.

You can find a full list of composition methods in theComposing animationssection of theAnimatedAPI reference.


### Combining animated values
You cancombine two animated valuesvia addition, multiplication, division, or modulo to make a new animated value.

There are some cases where an animated value needs to invert another animated value for calculation. An example is inverting a scale (2x --> 0.5x):

```
const a = new Animated.Value(1);const b = Animated.divide(1, a);Animated.spring(a, {  toValue: 2,  useNativeDriver: true,}).start();
```


### Interpolation
Each property can be run through an interpolation first. An interpolation maps input ranges to output ranges, typically using a linear interpolation but also supports easing functions. By default, it will extrapolate the curve beyond the ranges given, but you can also have it clamp the output value.

A basic mapping to convert a 0-1 range to a 0-100 range would be:

```
value.interpolate({  inputRange: [0, 1],  outputRange: [0, 100],});
```

For example, you may want to think about yourAnimated.Valueas going from 0 to 1, but animate the position from 150px to 0px and the opacity from 0 to 1. This can be done by modifyingstylefrom the example above like so:

```
  style={{    opacity: this.state.fadeAnim, // Binds directly    transform: [{      translateY: this.state.fadeAnim.interpolate({        inputRange: [0, 1],        outputRange: [150, 0]  // 0 : 150, 0.5 : 75, 1 : 0      }),    }],  }}
```

interpolate()supports multiple range segments as well, which is handy for defining dead zones and other handy tricks. For example, to get a negation relationship at -300 that goes to 0 at -100, then back up to 1 at 0, and then back down to zero at 100 followed by a dead-zone that remains at 0 for everything beyond that, you could do:

```
value.interpolate({  inputRange: [-300, -100, 0, 100, 101],  outputRange: [300, 0, 1, 0, 0],});
```

Which would map like so:

```
Input | Output------|-------  -400|    450  -300|    300  -200|    150  -100|      0   -50|    0.5     0|      1    50|    0.5   100|      0   101|      0   200|      0
```

interpolate()also supports mapping to strings, allowing you to animate colors as well as values with units. For example, if you wanted to animate a rotation you could do:

```
value.interpolate({  inputRange: [0, 360],  outputRange: ['0deg', '360deg'],});
```

interpolate()also supports arbitrary easing functions, many of which are already implemented in theEasingmodule.interpolate()also has configurable behavior for extrapolating theoutputRange. You can set the extrapolation by setting theextrapolate,extrapolateLeft, orextrapolateRightoptions. The default value isextendbut you can useclampto prevent the output value from exceedingoutputRange.


### Tracking dynamic values
Animated values can also track other values by setting thetoValueof an animation to another animated value instead of a plain number. For example, a "Chat Heads" animation like the one used by Messenger on Android could be implemented with aspring()pinned on another animated value, or withtiming()and adurationof 0 for rigid tracking. They can also be composed with interpolations:

```
Animated.spring(follower, {toValue: leader}).start();Animated.timing(opacity, {  toValue: pan.x.interpolate({    inputRange: [0, 300],    outputRange: [1, 0],  }),  useNativeDriver: true,}).start();
```

Theleaderandfolloweranimated values would be implemented usingAnimated.ValueXY().ValueXYis a handy way to deal with 2D interactions, such as panning or dragging. It is a basic wrapper that contains twoAnimated.Valueinstances and some helper functions that call through to them, makingValueXYa drop-in replacement forValuein many cases. It allows us to track both x and y values in the example above.


### Tracking gestures
Gestures, like panning or scrolling, and other events can map directly to animated values usingAnimated.event. This is done with a structured map syntax so that values can be extracted from complex event objects. The first level is an array to allow mapping across multiple args, and that array contains nested objects.

For example, when working with horizontal scrolling gestures, you would do the following in order to mapevent.nativeEvent.contentOffset.xtoscrollX(anAnimated.Value):

```
 onScroll={Animated.event(   // scrollX = e.nativeEvent.contentOffset.x   [{nativeEvent: {        contentOffset: {          x: scrollX        }      }    }] )}
```

The following example implements a horizontal scrolling carousel where the scroll position indicators are animated using theAnimated.eventused in theScrollView

When usingPanResponder, you could use the following code to extract the x and y positions fromgestureState.dxandgestureState.dy. We use anullin the first position of the array, as we are only interested in the second argument passed to thePanResponderhandler, which is thegestureState.

```
onPanResponderMove={Animated.event(  [null, // ignore the native event  // extract dx and dy from gestureState  // like 'pan.x = gestureState.dx, pan.y = gestureState.dy'  {dx: pan.x, dy: pan.y}])}
```


### Responding to the current animation value
You may notice that there is no clear way to read the current value while animating. This is because the value may only be known in the native runtime due to optimizations. If you need to run JavaScript in response to the current value, there are two approaches:

- spring.stopAnimation(callback)will stop the animation and invokecallbackwith the final value. This is useful when making gesture transitions.
- spring.addListener(callback)will invokecallbackasynchronously while the animation is running, providing a recent value. This is useful for triggering state changes, for example snapping a bobble to a new option as the user drags it closer, because these larger state changes are less sensitive to a few frames of lag compared to continuous gestures like panning which need to run at 60 fps.
Animatedis designed to be fully serializable so that animations can be run in a high performance way, independent of the normal JavaScript event loop. This does influence the API, so keep that in mind when it seems a little trickier to do something compared to a fully synchronous system. Check outAnimated.Value.addListeneras a way to work around some of these limitations, but use it sparingly since it might have performance implications in the future.


### Using the native driver
TheAnimatedAPI is designed to be serializable. By using thenative driver, we send everything about the animation to native before starting the animation, allowing native code to perform the animation on the UI thread without having to go through the bridge on every frame. Once the animation has started, the JS thread can be blocked without affecting the animation.

Using the native driver for normal animations can be accomplished by settinguseNativeDriver: truein animation config when starting it. Animations without auseNativeDriverproperty will default to false for legacy reasons, but emit a warning (and typechecking error in TypeScript).

```
Animated.timing(this.state.animatedValue, {  toValue: 1,  duration: 500,  useNativeDriver: true, // <-- Set this to true}).start();
```

Animated values are only compatible with one driver so if you use native driver when starting an animation on a value, make sure every animation on that value also uses the native driver.

The native driver also works withAnimated.event. This is especially useful for animations that follow the scroll position as without the native driver, the animation will always run a frame behind the gesture due to the async nature of React Native.

```
<Animated.ScrollView // <-- Use the Animated ScrollView wrapper  onScroll={Animated.event(    [      {        nativeEvent: {          contentOffset: {y: this.state.animatedValue},        },      },    ],    {useNativeDriver: true}, // <-- Set this to true  )}>  {content}</Animated.ScrollView>
```

You can see the native driver in action by running theRNTester app, then loading the Native Animated Example. You can also take a look at thesource codeto learn how these examples were produced.

Not everything you can do withAnimatedis currently supported by the native driver. The main limitation is that you can only animate non-layout properties: things liketransformandopacitywill work, but Flexbox and position properties will not. When usingAnimated.event, it will only work with direct events and not bubbling events. This means it does not work withPanResponderbut does work with things likeScrollView#onScroll.

When an animation is running, it can preventVirtualizedListcomponents from rendering more rows. If you need to run a long or looping animation while the user is scrolling through a list, you can useisInteraction: falsein your animation's config to prevent this issue.


### Bear in mind
While using transform styles such asrotateY,rotateX, and others ensure the transform styleperspectiveis in place. At this time some animations may not render on Android without it. Example below.

```
<Animated.View  style={{    transform: [      {scale: this.state.scale},      {rotateY: this.state.rotateY},      {perspective: 1000}, // without this line this Animation will not render on Android while working fine on iOS    ],  }}/>
```


### Additional examples
The RNTester app has various examples ofAnimatedin use:

- AnimatedGratuitousApp
- NativeAnimationsExample

## LayoutAnimationAPI
LayoutAnimationallows you to globally configurecreateandupdateanimations that will be used for all views in the next render/layout cycle. This is useful for doing Flexbox layout updates without bothering to measure or calculate specific properties in order to animate them directly, and is especially useful when layout changes may affect ancestors, for example a "see more" expansion that also increases the size of the parent and pushes down the row below which would otherwise require explicit coordination between the components in order to animate them all in sync.

Note that althoughLayoutAnimationis very powerful and can be quite useful, it provides much less control thanAnimatedand other animation libraries, so you may need to use another approach if you can't getLayoutAnimationto do what you want.

Note that in order to get this to work onAndroidyou need to set the following flags viaUIManager:

```
UIManager.setLayoutAnimationEnabledExperimental(true);
```

This example uses a preset value, you can customize the animations as you need, seeLayoutAnimation.jsfor more information.


## Additional notes

### requestAnimationFrame
requestAnimationFrameis a polyfill from the browser that you might be familiar with. It accepts a function as its only argument and calls that function before the next repaint. It is an essential building block for animations that underlies all of the JavaScript-based animation APIs. In general, you shouldn't need to call this yourself - the animation APIs will manage frame updates for you.


### setNativeProps
As mentionedin the Direct Manipulation section,setNativePropsallows us to modify properties of native-backed components (components that are actually backed by native views, unlike composite components) directly, without having tosetStateand re-render the component hierarchy.

We could use this in the Rebound example to update the scale - this might be helpful if the component that we are updating is deeply nested and hasn't been optimized withshouldComponentUpdate.

If you find your animations with dropping frames (performing below 60 frames per second), look into usingsetNativePropsorshouldComponentUpdateto optimize them. Or you could run the animations on the UI thread rather than the JavaScript threadwith the useNativeDriver option. You may also want to defer any computationally intensive work until after animations are complete, using theInteractionManager. You can monitor the frame rate by using the In-App Dev Menu "FPS Monitor" tool.


================================================================================


# App Extensions
Source: https://reactnative.dev/docs/app-extensions

App extensions let you provide custom functionality and content outside of your main app. There are different types of app extensions on iOS, and they are all covered in theApp Extension Programming Guide. In this guide, we'll briefly cover how you may take advantage of app extensions on iOS.


## Memory use in extensions
As these extensions are loaded outside of the regular app sandbox, it's highly likely that several of these app extensions will be loaded simultaneously. As you might expect, these extensions have small memory usage limits. Keep these in mind when developing your app extensions. It's always highly recommended to test your application on an actual device, and more so when developing app extensions: too frequently, developers find that their extension works fine in the iOS Simulator, only to get user reports that their extension is not loading on actual devices.


### Today widget
The memory limit of a Today widget is 16 MB. As it happens, Today widget implementations using React Native may work unreliably because the memory usage tends to be too high. You can tell if your Today widget is exceeding the memory limit if it yields the message 'Unable to Load':

Always make sure to test your app extensions in a real device, but be aware that this may not be sufficient, especially when dealing with Today widgets. Debug-configured builds are more likely to exceed the memory limits, while release-configured builds don't fail right away. We highly recommend that you useXcode's Instrumentsto analyze your real world memory usage, as it's very likely that your release-configured build is very close to the 16 MB limit. In situations like these, you can quickly go over the 16 MB limit by performing common operations, such as fetching data from an API.

To experiment with the limits of React Native Today widget implementations, try extending the example project inreact-native-today-widget.


### Other app extensions
Other types of app extensions have greater memory limits than the Today widget. For instance, Custom Keyboard extensions are limited to 48 MB, and Share extensions are limited to 120 MB. Implementing such app extensions with React Native is more viable. One proof of concept example isreact-native-ios-share-extension.


================================================================================


# Appearance
Source: https://reactnative.dev/docs/appearance

```
import {Appearance} from 'react-native';
```

TheAppearancemodule exposes information about the user's appearance preferences, such as their preferred color scheme (light or dark).

- AndroidiOSWeb
- iOSWeb
- Web
TheAppearanceAPI is inspired by theMedia Queries draftfrom the W3C. The color scheme preference is modeled after theprefers-color-schemeCSS media feature.

The color scheme preference will map to the user's Light orDark themepreference on Android 10 (API level 29) devices and higher.

The color scheme preference will map to the user's Light orDark Modepreference on iOS 13 devices and higher.

When taking a screenshot, by default, the color scheme may flicker between light and dark mode. It happens because the iOS takes snapshots on both color schemes and updating the user interface with color scheme is asynchronous.


## Example
You can use theAppearancemodule to determine if the user prefers a dark color scheme:

```
const colorScheme = Appearance.getColorScheme();if (colorScheme === 'dark') {  // Use dark color scheme}
```

Although the color scheme is available immediately, this may change (e.g. scheduled color scheme change at sunrise or sunset). Any rendering logic or styles that depend on the user preferred color scheme should try to call this function on every render, rather than caching the value. For example, you may use theuseColorSchemeReact hook as it provides and subscribes to color scheme updates, or you may use inline styles rather than setting a value in aStyleSheet.


## Methods

### getColorScheme()
```
static getColorScheme(): 'light' | 'dark' | null;
```

Indicates the current user preferred color scheme. The value may be updated later, either through direct user action (e.g. theme selection in device settings or application-level selected user interface style viasetColorScheme) or on a schedule (e.g. light and dark themes that follow the day/night cycle).

Supported color schemes:

- 'light': The user prefers a light color theme.
- 'dark': The user prefers a dark color theme.
- null: The user has not indicated a preferred color theme.
See also:useColorSchemehook.

getColorScheme()will always returnlightwhen debugging with Chrome.


### setColorScheme()
```
static setColorScheme('light' | 'dark' | null): void;
```

Force the application to always adopt a light or dark interface style. The default value isnullwhich causes the application to inherit the system's interface style. If you assign a different value, the new style applies to the application and all native elements within the application (Alerts, Pickers etc).

Supported color schemes:

- light: Apply light user interface style.
- dark: Apply dark user interface style.
- null: Follow the system's interface style.
The change will not affect the system's selected interface style or any style set in other applications.


### addChangeListener()
```
static addChangeListener(  listener: (preferences: {colorScheme: 'light' | 'dark' | null}) => void,): NativeEventSubscription;
```

Add an event handler that is fired when appearance preferences change.


================================================================================


# Appendix
Source: https://reactnative.dev/docs/appendix


## I. Terminology
- Spec- TypeScript or Flow code that describes the API for a Turbo Native Module or Fabric Native component. Used byCodegento generate boilerplate code.
Spec- TypeScript or Flow code that describes the API for a Turbo Native Module or Fabric Native component. Used byCodegento generate boilerplate code.

- Native Modules- Native libraries that have no User Interface (UI) for the user. Examples would be persistent storage, notifications, network events. These are accessible to your JavaScript application code as functions and objects.
Native Modules- Native libraries that have no User Interface (UI) for the user. Examples would be persistent storage, notifications, network events. These are accessible to your JavaScript application code as functions and objects.

- Native Component- Native platform views that are available to your application JavaScript code through React Components.
Native Component- Native platform views that are available to your application JavaScript code through React Components.

- Legacy Native Components- Components which are running on the old React Native architecture.
Legacy Native Components- Components which are running on the old React Native architecture.

- Legacy Native Modules- Modules which are running on the old React Native architecture.
Legacy Native Modules- Modules which are running on the old React Native architecture.


## II. Codegen Typings
You may use the following table as a reference for which types are supported and what they map to in each platform:


### Notes:
[1]We strongly recommend using Object literals instead of Objects.

You may also find it useful to refer to the JavaScript specifications for the core modules in React Native. These are located inside theLibraries/directory in the React Native repository.


================================================================================


# AppRegistry
Source: https://reactnative.dev/docs/appregistry


### Project with Native Code Required
If you are using the managed Expo workflow there is only ever one entry component registered withAppRegistryand it is handled automatically (or throughregisterRootComponent). You do not need to use this API.

AppRegistryis the JS entry point to running all React Native apps. App root components should register themselves withAppRegistry.registerComponent, then the native system can load the bundle for the app and then actually run the app when it's ready by invokingAppRegistry.runApplication.

```
import {Text, AppRegistry} from 'react-native';const App = () => (  <View>    <Text>App1</Text>  </View>);AppRegistry.registerComponent('Appname', () => App);
```

To "stop" an application when a view should be destroyed, callAppRegistry.unmountApplicationComponentAtRootTagwith the tag that was passed intorunApplication. These should always be used as a pair.

AppRegistryshould be required early in therequiresequence to make sure the JS execution environment is setup before other modules are required.


## Methods

### getAppKeys()
```
static getAppKeys(): string[];
```

Returns an array of strings.


### getRegistry()
```
static getRegistry(): {sections: string[]; runnables: Runnable[]};
```

Returns aRegistryobject.


### getRunnable()
```
static getRunnable(appKey: string): : Runnable | undefined;
```

Returns aRunnableobject.

Parameters:


### getSectionKeys()
```
static getSectionKeys(): string[];
```

Returns an array of strings.


### getSections()
```
static getSections(): Record<string, Runnable>;
```

Returns aRunnablesobject.


### registerCancellableHeadlessTask()
```
static registerCancellableHeadlessTask(  taskKey: string,  taskProvider: TaskProvider,  taskCancelProvider: TaskCancelProvider,);
```

Register a headless task which can be cancelled. A headless task is a bit of code that runs without a UI.

Parameters:


### registerComponent()
```
static registerComponent(  appKey: string,  getComponentFunc: ComponentProvider,  section?: boolean,): string;
```

Parameters:


### registerConfig()
```
static registerConfig(config: AppConfig[]);
```

Parameters:


### registerHeadlessTask()
```
static registerHeadlessTask(  taskKey: string,  taskProvider: TaskProvider,);
```

Register a headless task. A headless task is a bit of code that runs without a UI.

This is a way to run tasks in JavaScript while your app is in the background. It can be used, for example, to sync fresh data, handle push notifications, or play music.

Parameters:


### registerRunnable()
```
static registerRunnable(appKey: string, func: Runnable): string;
```

Parameters:


### registerSection()
```
static registerSection(  appKey: string,  component: ComponentProvider,);
```

Parameters:


### runApplication()
```
static runApplication(appKey: string, appParameters: any): void;
```

Loads the JavaScript bundle and runs the app.

Parameters:


### setComponentProviderInstrumentationHook()
```
static setComponentProviderInstrumentationHook(  hook: ComponentProviderInstrumentationHook,);
```

Parameters:

A validhookfunction accepts the following as arguments:

The function must also return a React Component.


### setWrapperComponentProvider()
```
static setWrapperComponentProvider(  provider: WrapperComponentProvider,);
```

Parameters:


### startHeadlessTask()
```
static startHeadlessTask(  taskId: number,  taskKey: string,  data: any,);
```

Only called from native code. Starts a headless task.

Parameters:


### unmountApplicationComponentAtRootTag()
```
static unmountApplicationComponentAtRootTag(rootTag: number);
```

Stops an application when a view should be destroyed.

Parameters:


## Type Definitions

### AppConfig
Application configuration for theregisterConfigmethod.

Properties:

Every config is expected to set eithercomponentorrunfunction.


### Registry
Properties:


### Runnable
Properties:


### Runnables
An object with key ofappKeyand value of type ofRunnable.


### Task
ATaskis a function that accepts any data as argument and returns a Promise that resolves toundefined.


### TaskCanceller
ATaskCancelleris a function that accepts no argument and returns void.


### TaskCancelProvider
A validTaskCancelProvideris a function that returns aTaskCanceller.


### TaskProvider
A validTaskProvideris a function that returns aTask.


================================================================================


# AppState
Source: https://reactnative.dev/docs/appstate

AppStatecan tell you if the app is in the foreground or background, and notify you when the state changes.

AppState is frequently used to determine the intent and proper behavior when handling push notifications.


### App States
- active- The app is running in the foreground
- background- The app is running in the background. The user is either:in another appon the home screen[Android] on anotherActivity(even if it was launched by your app)
- in another app
- on the home screen
- [Android] on anotherActivity(even if it was launched by your app)
- [iOS]inactive- This is a state that occurs when transitioning between foreground & background, and during periods of inactivity such as entering the multitasking view, opening the Notification Center or in the event of an incoming call.
For more information, seeApple's documentation


## Basic Usage
To see the current state, you can checkAppState.currentState, which will be kept up-to-date. However,currentStatewill be null at launch whileAppStateretrieves it over the bridge.

This example will only ever appear to say "Current state is: active" because the app is only visible to the user when in theactivestate, and the null state will happen only momentarily. If you want to experiment with the code we recommend to use your own device instead of embedded preview.


## Events

### change
This event is received when the app state has changed. The listener is called with one ofthe current app state values.


### memoryWarningiOS
Fires when the app receives a memory warning from the operating system.


### focusAndroid
Received when the app gains focus (the user is interacting with the app).


### blurAndroid
Received when the user is not actively interacting with the app. Useful in situations when the user pulls down thenotification drawer.AppStatewon't change but theblurevent will get fired.


## Methods

### addEventListener()
```
static addEventListener(  type: AppStateEvent,  listener: (state: AppStateStatus) => void,): NativeEventSubscription;
```

Sets up a function that will be called whenever the specified event type on AppState occurs. Valid values foreventTypearelisted above. Returns theEventSubscription.


## Properties

### currentState
```
static currentState: AppStateStatus;
```


================================================================================


# ❌ AsyncStorage
Source: https://reactnative.dev/docs/asyncstorage

Use one of thecommunity packagesinstead.


================================================================================


# BackHandler
Source: https://reactnative.dev/docs/backhandler

The Backhandler API detects hardware button presses for back navigation, lets you register event listeners for the system's back action, and lets you control how your application responds. It is Android-only.

The event subscriptions are called in reverse order (i.e. the last registered subscription is called first).

- If one subscription returns true,then subscriptions registered earlier will not be called.
- If no subscription returns true or none are registered,it programmatically invokes the default back button functionality to exit the app.
If your app shows an openedModal,BackHandlerwill not publish any events (seeModaldocs).


## Pattern
```
const subscription = BackHandler.addEventListener(  'hardwareBackPress',  function () {    /**     * this.onMainScreen and this.goBack are just examples,     * you need to use your own implementation here.     *     * Typically you would use the navigator here to go to the last state.     */    if (!this.onMainScreen()) {      this.goBack();      /**       * When true is returned the event will not be bubbled up       * & no other back action will execute       */      return true;    }    /**     * Returning false will let the event to bubble up & let other event listeners     * or the system's default back action to be executed.     */    return false;  },);// Unsubscribe the listener on unmountsubscription.remove();
```


## Example
The following example implements a scenario where you confirm if the user wants to exit the app:

BackHandler.addEventListenercreates an event listener & returns aNativeEventSubscriptionobject which should be cleared usingNativeEventSubscription.removemethod.


## Usage with React Navigation
If you are using React Navigation to navigate across different screens, you can follow their guide onCustom Android back button behaviour


## Backhandler hook
React Native Hookshas a niceuseBackHandlerhook which will simplify the process of setting up event listeners.


## Methods

### addEventListener()
```
static addEventListener(  eventName: BackPressEventName,  handler: () => boolean | null | undefined,): NativeEventSubscription;
```


### exitApp()
```
static exitApp();
```


================================================================================


# BoxShadowValue Object Type
Source: https://reactnative.dev/docs/boxshadowvalue

TheBoxShadowValueobject is taken by theboxShadowstyle prop. It is comprised of 2-4 lengths, an optional color, and an optionalinsetboolean. These values collectively define the box shadow's color, position, size, and blurriness.


## Example
```
{  offsetX: 10,  offsetY: -3,  blurRadius: '15px',  spreadDistance: '10px',  color: 'red',  inset: true,}
```


## Keys and values

### offsetX
The offset on the x-axis. This can be positive or negative. A positive value indicates right and negative indicates left.


### offsetY
The offset on the y-axis. This can be positive or negative. A positive value indicates up and negative indicates down.


### blurRadius
Represents the radius used in theGaussian bluralgorithm. The larger the value the blurrier the shadow is. Only non-negative values are valid. The default is 0.


### spreadDistance
How much larger or smaller the shadow grows or shrinks. A positive value will grow the shadow, a negative value will shrink the shadow.


### color
The color of the shadow. The default isblack.


### inset
Whether the shadow is inset or not. Inset shadows will appear around the inside of the element's border box as opposed to the outside.


## Used by
- boxShadow

================================================================================


# Speeding up your Build phase
Source: https://reactnative.dev/docs/build-speed

Building your React Native app could beexpensiveand take several minutes of developers time.
This can be problematic as your project grows and generally in bigger organizations with multiple React Native developers.

To mitigate this performance hit, this page shares some suggestions on how toimprove your build time.

Please note that those suggestions are advanced feature that requires some amount of understanding of how the native build tools work.


## Build only one ABI during development (Android-only)
When building your android app locally, by default you build all the 4Application Binary Interfaces (ABIs):armeabi-v7a,arm64-v8a,x86&x86_64.

However, you probably don't need to build all of them if you're building locally and testing your emulator or on a physical device.

This should reduce yournative build timeby a ~75% factor.

If you're using the React Native CLI, you can add the--active-arch-onlyflag to therun-androidcommand. This flag will make sure the correct ABI is picked up from either the running emulator or the plugged in phone. To confirm that this approach is working fine, you'll see a message likeinfo Detected architectures arm64-v8aon console.

```
$ yarn react-native run-android --active-arch-only[ ... ]info Running jetifier to migrate libraries to AndroidX. You can disable it using "--no-jetifier" flag.Jetifier found 1037 file(s) to forward-jetify. Using 32 workers...info JS server already running.info Detected architectures arm64-v8ainfo Installing the app...
```

This mechanism relies on thereactNativeArchitecturesGradle property.

Therefore, if you're building directly with Gradle from the command line and without the CLI, you can specify the ABI you want to build as follows:

```
$ ./gradlew :app:assembleDebug -PreactNativeArchitectures=x86,x86_64
```

This can be useful if you wish to build your Android App on a CI and use a matrix to parallelize the build of the different architectures.

If you wish, you can also override this value locally, using thegradle.propertiesfile you have in thetop-level folderof your project:

```
# Use this property to specify which architecture you want to build.# You can also override it from the CLI using# ./gradlew <task> -PreactNativeArchitectures=x86_64reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64
```

Once you build arelease versionof your app, don't forget to remove those flags as you want to build an apk/app bundle that works for all the ABIs and not only for the one you're using in your daily development workflow.


## Enable Configuration Caching (Android-only)
Since React Native 0.79, you can also enable Gradle Configuration Caching.

When you’re running an Android build withyarn android, you will be executing a Gradle build that is composed by two steps (source):

- Configuration phase, when all the.gradlefiles are evaluated.
- Execution phase, when the tasks are actually executed so the Java/Kotlin code is compiled and so on.
You will now be able to enable Configuration Caching, which will allow you to skip the Configuration phase on subsequent builds.

This is beneficial when making frequent changes to the native code as it improves build times.

For example here you can see how rebuilding faster it is to rebuild RN-Tester after a change in the native code:

You can enable Gradle Configuration Caching by adding the following line in yourandroid/gradle.propertiesfile:

```
org.gradle.configuration-cache=true
```

Please refer to theofficial Gradle documentationfor more resources on Configuration Caching.


## Using a Maven Mirror (Android-only)
When building Android apps, your Gradle builds will need to download the necessary dependencies from Maven Central and other repositories from the internet.

If your organization is running a Maven repository mirror, you should consider using it as it will speed up your build, by downloading the artifacts from the mirror rather than from the internet.

You can configure a mirror by specifying theexclusiveEnterpriseRepositoryproperty in yourandroid/gradle.propertiesfile:

```
# Use this property to enable or disable the Hermes JS engine.# If set to false, you will be using JSC instead.hermesEnabled=true# Use this property to configure a Maven enterprise repository# that will be used exclusively to fetch all of your dependencies.+exclusiveEnterpriseRepository=https://my.internal.proxy.net/
```

By setting this property, your build will fetch dependenciesexclusivelyfrom your specified repository and not from others.


## Use a compiler cache
If you're running frequent native builds (either C++ or Objective-C), you might benefit from using acompiler cache.

Specifically you can use two type of caches: local compiler caches and distributed compiler caches.


### Local caches
The following instructions will work forboth Android & iOS.
If you're building only Android apps, you should be good to go.
If you're building also iOS apps, please follow the instructions in theXcode Specific Setupsection below.

We suggest to useccacheto cache the compilation of your native builds.
Ccache works by wrapping the C++ compilers, storing the compilation results, and skipping the compilation
if an intermediate compilation result was originally stored.

Ccache is available in the package manager for most operating systems. On macOS, we can install ccache withbrew install ccache.
Or you can follow theofficial installation instructionsto install from source.

You can then do two clean builds (e.g. on Android you can first runyarn react-native run-android, delete theandroid/app/buildfolder and run the first command once more). You will notice that the second build was way faster than the first one (it should take seconds rather than minutes).
While building, you can verify thatccacheworks correctly and check the cache hits/miss rateccache -s

```
$ ccache -sSummary:  Hits:             196 /  3068 (6.39 %)    Direct:           0 /  3068 (0.00 %)    Preprocessed:   196 /  3068 (6.39 %)  Misses:          2872    Direct:        3068    Preprocessed:  2872  Uncacheable:        1Primary storage:  Hits:             196 /  6136 (3.19 %)  Misses:          5940  Cache size (GB): 0.60 / 20.00 (3.00 %)
```

Note thatccacheaggregates the stats over all builds. You can useccache --zero-statsto reset them before a build to verify the cache-hit ratio.

Should you need to wipe your cache, you can do so withccache --clear

To make sureccacheworks correctly with iOS and Xcode, you need to enable React Native support for ccache inios/Podfile.

Openios/Podfilein your editor and uncomment theccache_enabledline.

```
  post_install do |installer|    # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202    react_native_post_install(      installer,      config[:reactNativePath],      :mac_catalyst_enabled => false,      # TODO: Uncomment the line below      :ccache_enabled => true    )  end
```

Ccache uses the/Users/$USER/Library/Caches/ccachefolder on macOS to store the cache.
Therefore you could save & restore the corresponding folder also on CI to speedup your builds.

However, there are a couple of things to be aware:

- On CI, we recommend to do a full clean build, to avoid poisoned cache problems. If you follow the approach mentioned in the previous paragraph, you should be able to parallelize the native build on 4 different ABIs and you will most likely not needccacheon CI.
On CI, we recommend to do a full clean build, to avoid poisoned cache problems. If you follow the approach mentioned in the previous paragraph, you should be able to parallelize the native build on 4 different ABIs and you will most likely not needccacheon CI.

- ccacherelies on timestamps to compute a cache hit. This doesn't work well on CI as files are re-downloaded at every CI run. To overcome this, you'll need to use thecompiler_check contentoption which relies instead onhashing the content of the file.
ccacherelies on timestamps to compute a cache hit. This doesn't work well on CI as files are re-downloaded at every CI run. To overcome this, you'll need to use thecompiler_check contentoption which relies instead onhashing the content of the file.


### Distributed caches
Similar to local caches, you might want to consider using a distributed cache for your native builds.
This could be specifically useful in bigger organizations that are doing frequent native builds.

We recommend to usesccacheto achieve this.
We defer to the sccachedistributed compilation quickstartfor instructions on how to setup and use this tool.


================================================================================


# 🗑️ Building For TV Devices
Source: https://reactnative.dev/docs/building-for-tv

TV devices support has been implemented with the intention of making existing React Native applications work on Apple TV and Android TV, with few or no changes needed in the JavaScript code for the applications.

TV support has moved to theReact Native for TVrepository. Please see theREADMEthere for information on projects for Apple TV or Android TV.


================================================================================


# Button
Source: https://reactnative.dev/docs/button

A basic button component that should render nicely on any platform. Supports a minimal level of customization.

If this button doesn't look right for your app, you can build your own button usingPressable. For inspiration, look at thesource code for the Button component.

```
<Button  onPress={onPressLearnMore}  title="Learn More"  color="#841584"  accessibilityLabel="Learn more about this purple button"/>
```


## Example

## Props

### RequiredonPress
Handler to be called when the user taps the button.


### Requiredtitle
Text to display inside the button. On Android the given title will be converted to the uppercased form.


### accessibilityLabel
Text to display for blindness accessibility features.


### accessibilityLanguageiOS
A value indicating which language should be used by the screen reader when the user interacts with the element. It should follow theBCP 47 specification.

See theiOSaccessibilityLanguagedocfor more information.


### accessibilityActions
Accessibility actions allow an assistive technology to programmatically invoke the actions of a component. TheaccessibilityActionsproperty should contain a list of action objects. Each action object should contain the field name and label.

See theAccessibility guidefor more information.


### onAccessibilityAction
Invoked when the user performs the accessibility actions. The only argument to this function is an event containing the name of the action to perform.

See theAccessibility guidefor more information.


### color
Color of the text (iOS), or background color of the button (Android).


### disabled
Iftrue, disable all interactions for this component.


### hasTVPreferredFocusTV
TV preferred focus.


### nextFocusDownAndroidTV
Designates the next view to receive focus when the user navigates down. See theAndroid documentation.


### nextFocusForwardAndroidTV
Designates the next view to receive focus when the user navigates forward. See theAndroid documentation.


### nextFocusLeftAndroidTV
Designates the next view to receive focus when the user navigates left. See theAndroid documentation.


### nextFocusRightAndroidTV
Designates the next view to receive focus when the user navigates right. See theAndroid documentation.


### nextFocusUpAndroidTV
Designates the next view to receive focus when the user navigates up. See theAndroid documentation.


### testID
Used to locate this view in end-to-end tests.


### touchSoundDisabledAndroid
Iftrue, doesn't play system sound on touch.


================================================================================


# ❌ CheckBox
Source: https://reactnative.dev/docs/checkbox

Use one of thecommunity packagesinstead.


================================================================================


# ❌ Clipboard
Source: https://reactnative.dev/docs/clipboard

Use one of thecommunity packagesinstead.


================================================================================


# Color Reference
Source: https://reactnative.dev/docs/colors

Components in React Native arestyled using JavaScript. Color properties usually match howCSS works on the web. General guides on the color usage on each platform could be found below:

- Android
- iOS

## Color APIs
React Native has several color APIs designed to allow you to take full advantage of your platform's design and user preferences.

- PlatformColorlets you reference the platform's color system.
- DynamicColorIOSis iOS specific and allows you to specify which colors should be used in light or Dark Mode.

## Color representations

### Red Green Blue (RGB)
React Native supportsrgb()andrgba()in both hexadecimal and functional notation:

- '#f0f'(#rgb)
- '#ff00ff'(#rrggbb)
- '#f0ff'(#rgba)
- '#ff00ff00'(#rrggbbaa)
- 'rgb(255, 0, 255)'
- 'rgb(255 0 255)'
- 'rgba(255, 0, 255, 1.0)'
- 'rgba(255 0 255 / 1.0)'

### Hue Saturation Lightness (HSL)
React Native supportshsl()andhsla()in functional notation:

- 'hsl(360, 100%, 100%)'
- 'hsl(360 100% 100%)'
- 'hsla(360, 100%, 100%, 1.0)'
- 'hsla(360 100% 100% / 1.0)'

### Hue Whiteness Blackness (HWB)
React Native supportshwb()in functional notation:

- 'hwb(0, 0%, 100%)'
- 'hwb(360, 100%, 100%)'
- 'hwb(0 0% 0%)'
- 'hwb(70 50% 0%)'

### Color ints
React Native supports also colors as anintvalues (in RGB color mode):

- 0xff00ff00(0xrrggbbaa)
This might appear similar to the AndroidColorints representation but on Android values are stored in SRGB color mode (0xaarrggbb).


### Named colors
In React Native you can also use color name strings as values.

React Native only supports lowercase color names. Uppercase color names are not supported.

This is a shortcut forrgba(0,0,0,0), same like inCSS3.

Named colors implementation follows theCSS3/SVG specification:

- aliceblue (#f0f8ff)
- antiquewhite (#faebd7)
- aqua (#00ffff)
- aquamarine (#7fffd4)
- azure (#f0ffff)
- beige (#f5f5dc)
- bisque (#ffe4c4)
- black (#000000)
- blanchedalmond (#ffebcd)
- blue (#0000ff)
- blueviolet (#8a2be2)
- brown (#a52a2a)
- burlywood (#deb887)
- cadetblue (#5f9ea0)
- chartreuse (#7fff00)
- chocolate (#d2691e)
- coral (#ff7f50)
- cornflowerblue (#6495ed)
- cornsilk (#fff8dc)
- crimson (#dc143c)
- cyan (#00ffff)
- darkblue (#00008b)
- darkcyan (#008b8b)
- darkgoldenrod (#b8860b)
- darkgray (#a9a9a9)
- darkgreen (#006400)
- darkgrey (#a9a9a9)
- darkkhaki (#bdb76b)
- darkmagenta (#8b008b)
- darkolivegreen (#556b2f)
- darkorange (#ff8c00)
- darkorchid (#9932cc)
- darkred (#8b0000)
- darksalmon (#e9967a)
- darkseagreen (#8fbc8f)
- darkslateblue (#483d8b)
- darkslategrey (#2f4f4f)
- darkturquoise (#00ced1)
- darkviolet (#9400d3)
- deeppink (#ff1493)
- deepskyblue (#00bfff)
- dimgray (#696969)
- dimgrey (#696969)
- dodgerblue (#1e90ff)
- firebrick (#b22222)
- floralwhite (#fffaf0)
- forestgreen (#228b22)
- fuchsia (#ff00ff)
- gainsboro (#dcdcdc)
- ghostwhite (#f8f8ff)
- gold (#ffd700)
- goldenrod (#daa520)
- gray (#808080)
- green (#008000)
- greenyellow (#adff2f)
- grey (#808080)
- honeydew (#f0fff0)
- hotpink (#ff69b4)
- indianred (#cd5c5c)
- indigo (#4b0082)
- ivory (#fffff0)
- khaki (#f0e68c)
- lavender (#e6e6fa)
- lavenderblush (#fff0f5)
- lawngreen (#7cfc00)
- lemonchiffon (#fffacd)
- lightblue (#add8e6)
- lightcoral (#f08080)
- lightcyan (#e0ffff)
- lightgoldenrodyellow (#fafad2)
- lightgray (#d3d3d3)
- lightgreen (#90ee90)
- lightgrey (#d3d3d3)
- lightpink (#ffb6c1)
- lightsalmon (#ffa07a)
- lightseagreen (#20b2aa)
- lightskyblue (#87cefa)
- lightslategrey (#778899)
- lightsteelblue (#b0c4de)
- lightyellow (#ffffe0)
- lime (#00ff00)
- limegreen (#32cd32)
- linen (#faf0e6)
- magenta (#ff00ff)
- maroon (#800000)
- mediumaquamarine (#66cdaa)
- mediumblue (#0000cd)
- mediumorchid (#ba55d3)
- mediumpurple (#9370db)
- mediumseagreen (#3cb371)
- mediumslateblue (#7b68ee)
- mediumspringgreen (#00fa9a)
- mediumturquoise (#48d1cc)
- mediumvioletred (#c71585)
- midnightblue (#191970)
- mintcream (#f5fffa)
- mistyrose (#ffe4e1)
- moccasin (#ffe4b5)
- navajowhite (#ffdead)
- navy (#000080)
- oldlace (#fdf5e6)
- olive (#808000)
- olivedrab (#6b8e23)
- orange (#ffa500)
- orangered (#ff4500)
- orchid (#da70d6)
- palegoldenrod (#eee8aa)
- palegreen (#98fb98)
- paleturquoise (#afeeee)
- palevioletred (#db7093)
- papayawhip (#ffefd5)
- peachpuff (#ffdab9)
- peru (#cd853f)
- pink (#ffc0cb)
- plum (#dda0dd)
- powderblue (#b0e0e6)
- purple (#800080)
- rebeccapurple (#663399)
- red (#ff0000)
- rosybrown (#bc8f8f)
- royalblue (#4169e1)
- saddlebrown (#8b4513)
- salmon (#fa8072)
- sandybrown (#f4a460)
- seagreen (#2e8b57)
- seashell (#fff5ee)
- sienna (#a0522d)
- silver (#c0c0c0)
- skyblue (#87ceeb)
- slateblue (#6a5acd)
- slategray (#708090)
- snow (#fffafa)
- springgreen (#00ff7f)
- steelblue (#4682b4)
- tan (#d2b48c)
- teal (#008080)
- thistle (#d8bfd8)
- tomato (#ff6347)
- turquoise (#40e0d0)
- violet (#ee82ee)
- wheat (#f5deb3)
- white (#ffffff)
- whitesmoke (#f5f5f5)
- yellow (#ffff00)
- yellowgreen (#9acd32)

================================================================================


# Communication between native and React Native
Source: https://reactnative.dev/docs/communication-android

InIntegrating with Existing Apps guideandNative UI Components guidewe learn how to embed React Native in a native component and vice versa. When we mix native and React Native components, we'll eventually find a need to communicate between these two worlds. Some ways to achieve that have been already mentioned in other guides. This article summarizes available techniques.


## Introduction
React Native is inspired by React, so the basic idea of the information flow is similar. The flow in React is one-directional. We maintain a hierarchy of components, in which each component depends only on its parent and its own internal state. We do this with properties: data is passed from a parent to its children in a top-down manner. If an ancestor component relies on the state of its descendant, one should pass down a callback to be used by the descendant to update the ancestor.

The same concept applies to React Native. As long as we are building our application purely within the framework, we can drive our app with properties and callbacks. But, when we mix React Native and native components, we need some specific, cross-language mechanisms that would allow us to pass information between them.


## Properties
Properties are the most straightforward way of cross-component communication. So we need a way to pass properties both from native to React Native, and from React Native to native.


### Passing properties from native to React Native
You can pass properties down to the React Native app by providing a custom implementation ofReactActivityDelegatein your main activity. This implementation should overridegetLaunchOptionsto return aBundlewith the desired properties.

- JavaKotlin
- Kotlin
```
public class MainActivity extends ReactActivity {  @Override  protected ReactActivityDelegate createReactActivityDelegate() {    return new ReactActivityDelegate(this, getMainComponentName()) {      @Override      protected Bundle getLaunchOptions() {        Bundle initialProperties = new Bundle();        ArrayList<String> imageList = new ArrayList<String>(Arrays.asList(                "https://dummyimage.com/600x400/ffffff/000000.png",                "https://dummyimage.com/600x400/000000/ffffff.png"        ));        initialProperties.putStringArrayList("images", imageList);        return initialProperties;      }    };  }}
```

```
class MainActivity : ReactActivity() {    override fun createReactActivityDelegate(): ReactActivityDelegate {        return object : ReactActivityDelegate(this, mainComponentName) {            override fun getLaunchOptions(): Bundle {                val imageList = arrayListOf("https://dummyimage.com/600x400/ffffff/000000.png", "https://dummyimage.com/600x400/000000/ffffff.png")                val initialProperties = Bundle().apply { putStringArrayList("images", imageList) }                return initialProperties            }        }    }}
```

```
import React from 'react';import {View, Image} from 'react-native';export default class ImageBrowserApp extends React.Component {  renderImage(imgURI) {    return <Image source={{uri: imgURI}} />;  }  render() {    return <View>{this.props.images.map(this.renderImage)}</View>;  }}
```

ReactRootViewprovides a read-write propertyappProperties. AfterappPropertiesis set, the React Native app is re-rendered with new properties. The update is only performed when the new updated properties differ from the previous ones.

- JavaKotlin
- Kotlin
```
Bundle updatedProps = mReactRootView.getAppProperties();ArrayList<String> imageList = new ArrayList<String>(Arrays.asList(        "https://dummyimage.com/600x400/ff0000/000000.png",        "https://dummyimage.com/600x400/ffffff/ff0000.png"));updatedProps.putStringArrayList("images", imageList);mReactRootView.setAppProperties(updatedProps);
```

```
var updatedProps: Bundle = reactRootView.getAppProperties()var imageList = arrayListOf("https://dummyimage.com/600x400/ff0000/000000.png", "https://dummyimage.com/600x400/ffffff/ff0000.png")
```

It is fine to update properties anytime. However, updates have to be performed on the main thread. You use the getter on any thread.

There is no way to update only a few properties at a time. We suggest that you build it into your own wrapper instead.

Currently, JS functioncomponentWillUpdatePropsof the top level RN component will not be called after a prop update. However, you can access the new props incomponentDidMountfunction.


### Passing properties from React Native to native
The problem exposing properties of native components is covered in detail inthis article. In short, properties that are to be reflected in JavaScript needs to be exposed as setter method annotated with@ReactProp, then use them in React Native as if the component was an ordinary React Native component.


### Limits of properties
The main drawback of cross-language properties is that they do not support callbacks, which would allow us to handle bottom-up data bindings. Imagine you have a small RN view that you want to be removed from the native parent view as a result of a JS action. There is no way to do that with props, as the information would need to go bottom-up.

Although we have a flavor of cross-language callbacks (described here), these callbacks are not always the thing we need. The main problem is that they are not intended to be passed as properties. Rather, this mechanism allows us to trigger a native action from JS, and handle the result of that action in JS.


## Other ways of cross-language interaction (events and native modules)
As stated in the previous chapter, using properties comes with some limitations. Sometimes properties are not enough to drive the logic of our app and we need a solution that gives more flexibility. This chapter covers other communication techniques available in React Native. They can be used for internal communication (between JS and native layers in RN) as well as for external communication (between RN and the 'pure native' part of your app).

React Native enables you to perform cross-language function calls. You can execute custom native code from JS and vice versa. Unfortunately, depending on the side we are working on, we achieve the same goal in different ways. For native - we use events mechanism to schedule an execution of a handler function in JS, while for React Native we directly call methods exported by native modules.


### Calling React Native functions from native (events)
Events are described in detail inthis article. Note that using events gives us no guarantees about execution time, as the event is handled on a separate thread.

Events are powerful, because they allow us to change React Native components without needing a reference to them. However, there are some pitfalls that you can fall into while using them:

- As events can be sent from anywhere, they can introduce spaghetti-style dependencies into your project.
- Events share namespace, which means that you may encounter some name collisions. Collisions will not be detected statically, which makes them hard to debug.
- If you use several instances of the same React Native component and you want to distinguish them from the perspective of your event, you'll likely need to introduce identifiers and pass them along with events (you can use the native view'sreactTagas an identifier).

### Calling native functions from React Native (native modules)
Native modules are Java/Kotlin classes that are available in JS. Typically one instance of each module is created per JS bridge. They can export arbitrary functions and constants to React Native. They have been covered in detail inthis article.

All native modules share the same namespace. Watch out for name collisions when creating new ones.


================================================================================


# Communication between native and React Native
Source: https://reactnative.dev/docs/communication-ios

InIntegrating with Existing Apps guideandNative UI Components guidewe learn how to embed React Native in a native component and vice versa. When we mix native and React Native components, we'll eventually find a need to communicate between these two worlds. Some ways to achieve that have been already mentioned in other guides. This article summarizes available techniques.


## Introduction
React Native is inspired by React, so the basic idea of the information flow is similar. The flow in React is one-directional. We maintain a hierarchy of components, in which each component depends only on its parent and its own internal state. We do this with properties: data is passed from a parent to its children in a top-down manner. If an ancestor component relies on the state of its descendant, one should pass down a callback to be used by the descendant to update the ancestor.

The same concept applies to React Native. As long as we are building our application purely within the framework, we can drive our app with properties and callbacks. But, when we mix React Native and native components, we need some specific, cross-language mechanisms that would allow us to pass information between them.


## Properties
Properties are the most straightforward way of cross-component communication. So we need a way to pass properties both from native to React Native, and from React Native to native.


### Passing properties from native to React Native
In order to embed a React Native view in a native component, we useRCTRootView.RCTRootViewis aUIViewthat holds a React Native app. It also provides an interface between native side and the hosted app.

RCTRootViewhas an initializer that allows you to pass arbitrary properties down to the React Native app. TheinitialPropertiesparameter has to be an instance ofNSDictionary. The dictionary is internally converted into a JSON object that the top-level JS component can reference.

```
NSArray *imageList = @[@"https://dummyimage.com/600x400/ffffff/000000.png",                       @"https://dummyimage.com/600x400/000000/ffffff.png"];NSDictionary *props = @{@"images" : imageList};RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge                                                 moduleName:@"ImageBrowserApp"                                          initialProperties:props];
```

```
import React from 'react';import {View, Image} from 'react-native';export default class ImageBrowserApp extends React.Component {  renderImage(imgURI) {    return <Image source={{uri: imgURI}} />;  }  render() {    return <View>{this.props.images.map(this.renderImage)}</View>;  }}
```

RCTRootViewalso provides a read-write propertyappProperties. AfterappPropertiesis set, the React Native app is re-rendered with new properties. The update is only performed when the new updated properties differ from the previous ones.

```
NSArray *imageList = @[@"https://dummyimage.com/600x400/ff0000/000000.png",                       @"https://dummyimage.com/600x400/ffffff/ff0000.png"];rootView.appProperties = @{@"images" : imageList};
```

It is fine to update properties anytime. However, updates have to be performed on the main thread. You use the getter on any thread.

Currently, there is a known issue where setting appProperties during the bridge startup, the change can be lost. Seehttps://github.com/facebook/react-native/issues/20115for more information.

There is no way to update only a few properties at a time. We suggest that you build it into your own wrapper instead.


### Passing properties from React Native to native
The problem exposing properties of native components is covered in detail inthis article. In short, export properties withRCT_CUSTOM_VIEW_PROPERTYmacro in your custom native component, then use them in React Native as if the component was an ordinary React Native component.


### Limits of properties
The main drawback of cross-language properties is that they do not support callbacks, which would allow us to handle bottom-up data bindings. Imagine you have a small RN view that you want to be removed from the native parent view as a result of a JS action. There is no way to do that with props, as the information would need to go bottom-up.

Although we have a flavor of cross-language callbacks (described here), these callbacks are not always the thing we need. The main problem is that they are not intended to be passed as properties. Rather, this mechanism allows us to trigger a native action from JS, and handle the result of that action in JS.


## Other ways of cross-language interaction (events and native modules)
As stated in the previous chapter, using properties comes with some limitations. Sometimes properties are not enough to drive the logic of our app and we need a solution that gives more flexibility. This chapter covers other communication techniques available in React Native. They can be used for internal communication (between JS and native layers in RN) as well as for external communication (between RN and the 'pure native' part of your app).

React Native enables you to perform cross-language function calls. You can execute custom native code from JS and vice versa. Unfortunately, depending on the side we are working on, we achieve the same goal in different ways. For native - we use events mechanism to schedule an execution of a handler function in JS, while for React Native we directly call methods exported by native modules.


### Calling React Native functions from native (events)
Events are described in detail inthis article. Note that using events gives us no guarantees about execution time, as the event is handled on a separate thread.

Events are powerful, because they allow us to change React Native components without needing a reference to them. However, there are some pitfalls that you can fall into while using them:

- As events can be sent from anywhere, they can introduce spaghetti-style dependencies into your project.
- Events share namespace, which means that you may encounter some name collisions. Collisions will not be detected statically, which makes them hard to debug.
- If you use several instances of the same React Native component and you want to distinguish them from the perspective of your event, you'll likely need to introduce identifiers and pass them along with events (you can use the native view'sreactTagas an identifier).
The common pattern we use when embedding native in React Native is to make the native component's RCTViewManager a delegate for the views, sending events back to JavaScript via the bridge. This keeps related event calls in one place.


### Calling native functions from React Native (native modules)
Native modules are Objective-C classes that are available in JS. Typically one instance of each module is created per JS bridge. They can export arbitrary functions and constants to React Native. They have been covered in detail inthis article.

The fact that native modules are singletons limits the mechanism in the context of embedding. Let's say we have a React Native component embedded in a native view and we want to update the native, parent view. Using the native module mechanism, we would export a function that not only takes expected arguments, but also an identifier of the parent native view. The identifier would be used to retrieve a reference to the parent view to update. That said, we would need to keep a mapping from identifiers to native views in the module.

Although this solution is complex, it is used inRCTUIManager, which is an internal React Native class that manages all React Native views.

Native modules can also be used to expose existing native libraries to JS. TheGeolocation libraryis a living example of the idea.

All native modules share the same namespace. Watch out for name collisions when creating new ones.


## Layout computation flow
When integrating native and React Native, we also need a way to consolidate two different layout systems. This section covers common layout problems and provides a brief description of mechanisms to address them.


### Layout of a native component embedded in React Native
This case is covered inthis article. To summarize, since all our native react views are subclasses ofUIView, most style and size attributes will work like you would expect out of the box.


### Layout of a React Native component embedded in native
The general scenario is when we have a React Native app with a fixed size, which is known to the native side. In particular, a full-screen React Native view falls into this case. If we want a smaller root view, we can explicitly set RCTRootView's frame.

For instance, to make an RN app 200 (logical) pixels high, and the hosting view's width wide, we could do:

```
- (void)viewDidLoad{  [...]  RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge                                                   moduleName:appName                                            initialProperties:props];  rootView.frame = CGRectMake(0, 0, self.view.width, 200);  [self.view addSubview:rootView];}
```

When we have a fixed size root view, we need to respect its bounds on the JS side. In other words, we need to ensure that the React Native content can be contained within the fixed-size root view. The easiest way to ensure this is to use Flexbox layout. If you use absolute positioning, and React components are visible outside the root view's bounds, you'll get overlap with native views, causing some features to behave unexpectedly. For instance, 'TouchableHighlight' will not highlight your touches outside the root view's bounds.

It's totally fine to update root view's size dynamically by re-setting its frame property. React Native will take care of the content's layout.

In some cases we'd like to render content of initially unknown size. Let's say the size will be defined dynamically in JS. We have two solutions to this problem.

- You can wrap your React Native view in aScrollViewcomponent. This guarantees that your content will always be available and it won't overlap with native views.
- React Native allows you to determine, in JS, the size of the RN app and provide it to the owner of the hostingRCTRootView. The owner is then responsible for re-laying out the subviews and keeping the UI consistent. We achieve this withRCTRootView's flexibility modes.
RCTRootViewsupports 4 different size flexibility modes:

```
typedef NS_ENUM(NSInteger, RCTRootViewSizeFlexibility) {  RCTRootViewSizeFlexibilityNone = 0,  RCTRootViewSizeFlexibilityWidth,  RCTRootViewSizeFlexibilityHeight,  RCTRootViewSizeFlexibilityWidthAndHeight,};
```

RCTRootViewSizeFlexibilityNoneis the default value, which makes a root view's size fixed (but it still can be updated withsetFrame:). The other three modes allow us to track React Native content's size updates. For instance, setting mode toRCTRootViewSizeFlexibilityHeightwill cause React Native to measure the content's height and pass that information back toRCTRootView's delegate. An arbitrary action can be performed within the delegate, including setting the root view's frame, so the content fits. The delegate is called only when the size of the content has changed.

Making a dimension flexible in both JS and native leads to undefined behavior. For example - don't make a top-level React component's width flexible (withflexbox) while you're usingRCTRootViewSizeFlexibilityWidthon the hostingRCTRootView.

Let's look at an example.

```
- (instancetype)initWithFrame:(CGRect)frame{  [...]  _rootView = [[RCTRootView alloc] initWithBridge:bridge  moduleName:@"FlexibilityExampleApp"  initialProperties:@{}];  _rootView.delegate = self;  _rootView.sizeFlexibility = RCTRootViewSizeFlexibilityHeight;  _rootView.frame = CGRectMake(0, 0, self.frame.size.width, 0);}#pragma mark - RCTRootViewDelegate- (void)rootViewDidChangeIntrinsicSize:(RCTRootView *)rootView{  CGRect newFrame = rootView.frame;  newFrame.size = rootView.intrinsicContentSize;  rootView.frame = newFrame;}
```

In the example we have aFlexibleSizeExampleViewview that holds a root view. We create the root view, initialize it and set the delegate. The delegate will handle size updates. Then, we set the root view's size flexibility toRCTRootViewSizeFlexibilityHeight, which means thatrootViewDidChangeIntrinsicSize:method will be called every time the React Native content changes its height. Finally, we set the root view's width and position. Note that we set there height as well, but it has no effect as we made the height RN-dependent.

You can checkout full source code of the examplehere.

It's fine to change root view's size flexibility mode dynamically. Changing flexibility mode of a root view will schedule a layout recalculation and the delegaterootViewDidChangeIntrinsicSize:method will be called once the content size is known.

React Native layout calculation is performed on a separate thread, while native UI view updates are done on the main thread.
This may cause temporary UI inconsistencies between native and React Native. This is a known problem and our team is working on synchronizing UI updates coming from different sources.

React Native does not perform any layout calculations until the root view becomes a subview of some other views.
If you want to hide React Native view until its dimensions are known, add the root view as a subview and make it initially hidden (useUIView'shiddenproperty). Then change its visibility in the delegate method.


================================================================================


# Core Components and APIs
Source: https://reactnative.dev/docs/components-and-apis

React Native provides a number of built-inCore Componentsready for you to use in your app. You can find them all in the left sidebar (or menu above, if you are on a narrow screen). If you're not sure where to get started, take a look at the following categories:

- Basic Components
- User Interface
- List Views
- Android-specific
- iOS-specific
- Others
You're not limited to the components and APIs bundled with React Native. React Native has a community of thousands of developers. If you're looking for a library that does something specific, please refer tothis guide about finding libraries.


## Basic Components
Most apps will end up using one or more of these basic components.


### View
The most fundamental component for building a UI.


### Text
A component for displaying text.


### Image
A component for displaying images.


### TextInput
A component for inputting text into the app via a keyboard.


### Pressable
A wrapper component that can detect various stages of press interactions on any of its children.


### ScrollView
Provides a scrolling container that can host multiple components and views.


### StyleSheet
Provides an abstraction layer similar to CSS stylesheets.


## User Interface
These common user interface controls will render on any platform.


### Button
A basic button component for handling touches that should render nicely on any platform.


### Switch
Renders a boolean input.


## List Views
Unlike the more genericScrollView, the following list view components only render elements that are currently showing on the screen. This makes them a performant choice for displaying long lists of data.


### FlatList
A component for rendering performant scrollable lists.


### SectionList
LikeFlatList, but for sectioned lists.


## Android Components and APIs
Many of the following components provide wrappers for commonly used Android classes.


### BackHandler
Detect hardware button presses for back navigation.


### DrawerLayoutAndroid
Renders aDrawerLayouton Android.


### PermissionsAndroid
Provides access to the permissions model introduced in Android M.


### ToastAndroid
Create an Android Toast alert.


## iOS Components and APIs
Many of the following components provide wrappers for commonly used UIKit classes.


### ActionSheetIOS
API to display an iOS action sheet or share sheet.


## Others
These components may be useful for certain applications. For an exhaustive list of components and APIs, check out the sidebar to the left (or menu above, if you are on a narrow screen).


### ActivityIndicator
Displays a circular loading indicator.


### Alert
Launches an alert dialog with the specified title and message.


### Animated
A library for creating fluid, powerful animations that are easy to build and maintain.


### Dimensions
Provides an interface for getting device dimensions.


### KeyboardAvoidingView
Provides a view that moves out of the way of the virtual keyboard automatically.


### Linking
Provides a general interface to interact with both incoming and outgoing app links.


### Modal
Provides a simple way to present content above an enclosing view.


### PixelRatio
Provides access to the device pixel density.


### RefreshControl
This component is used inside aScrollViewto add pull to refresh functionality.


### StatusBar
Component to control the app status bar.


================================================================================


# ❌ DatePickerAndroid
Source: https://reactnative.dev/docs/datepickerandroid

Use one of thecommunity packagesinstead.


================================================================================


# ❌ DatePickerIOS
Source: https://reactnative.dev/docs/datepickerios

Use one of thecommunity packagesinstead.


================================================================================


# Debugging Basics
Source: https://reactnative.dev/docs/debugging

Debugging features, such as the Dev Menu, LogBox, and React Native DevTools are disabled in release (production) builds.


## Opening the Dev Menu
React Native provides an in-app developer menu providing access to debugging features. You can access the Dev Menu by shaking your device or via keyboard shortcuts:

- iOS Simulator:Ctrl+Cmd ⌘+Z(or Device > Shake)
- Android emulators:Cmd ⌘+M(macOS) orCtrl+M(Windows and Linux)
Alternative (Android):adb shell input keyevent 82.


## Opening DevTools
React Native DevToolsis our built-in debugger for React Native. It allows you to inspect and understand how your JavaScript code is running, similar to a web browser.

To open DevTools, either:

- Select "Open DevTools" in the Dev Menu.
- Pressjfrom the CLI.
On first launch, DevTools will open to a welcome panel, along with an open console drawer where you can view logs and interact with the JavaScript runtime. From the top of the window, you can navigate to other panels, including the integrated React Components Inspector and Profiler.

Learn more in ourReact Native DevTools guide.


## LogBox
LogBox is an in-app tool that displays when warnings or errors are logged by your app.


### Fatal Errors
When an unrecoverable error occurs, such as a JavaScript syntax error, LogBox will open with the location of the error. In this state, LogBox is not dismissable since your code cannot be executed. LogBox will automatically dismiss once the syntax error is fixed — either via Fast Refresh or after a manual reload.


### Console Errors and Warnings
Console errors and warnings are displayed as on-screen notifications with a red or yellow badge.

- Errorswill display with a notification count. Tap the notification to see an expanded view and to paginate through other logs.
- Warningswill display a notification banner without details, prompting you to open React Native DevTools.
When React Native DevTools is open, all errors except fatal errors will be hidden to LogBox. We recommend using the Console panel within React Native DevTools as a source of truth, due to various LogBox options which can hide or adjust the level of certain logs.

LogBox can be configured via theLogBoxAPI.jsimport{LogBox}from'react-native';Ignore all logsLogBox notifications can be disabled usingLogBox.ignoreAllLogs(). This can be useful in situations such as giving product demos.jsLogBox.ignoreAllLogs();Ignore specific logsNotifications can be disabled on a per-log basis viaLogBox.ignoreLogs(). This can be useful for noisy warnings or those that cannot be fixed, e.g. in a third-party dependency.jsLogBox.ignoreLogs([// Exact message'Warning: componentWillReceiveProps has been renamed',// Substring or regex match/GraphQLerror:.*/,]);noteLogBox will treat certain errors from React as warnings, which will mean they don't display as an in-app error notification. Advanced users can change this behaviour by customising LogBox's warning filter usingLogBoxData.setWarningFilter().

```
import {LogBox} from 'react-native';
```

LogBox notifications can be disabled usingLogBox.ignoreAllLogs(). This can be useful in situations such as giving product demos.jsLogBox.ignoreAllLogs();Ignore specific logsNotifications can be disabled on a per-log basis viaLogBox.ignoreLogs(). This can be useful for noisy warnings or those that cannot be fixed, e.g. in a third-party dependency.jsLogBox.ignoreLogs([// Exact message'Warning: componentWillReceiveProps has been renamed',// Substring or regex match/GraphQLerror:.*/,]);noteLogBox will treat certain errors from React as warnings, which will mean they don't display as an in-app error notification. Advanced users can change this behaviour by customising LogBox's warning filter usingLogBoxData.setWarningFilter().

```
LogBox.ignoreAllLogs();
```

Notifications can be disabled on a per-log basis viaLogBox.ignoreLogs(). This can be useful for noisy warnings or those that cannot be fixed, e.g. in a third-party dependency.jsLogBox.ignoreLogs([// Exact message'Warning: componentWillReceiveProps has been renamed',// Substring or regex match/GraphQLerror:.*/,]);noteLogBox will treat certain errors from React as warnings, which will mean they don't display as an in-app error notification. Advanced users can change this behaviour by customising LogBox's warning filter usingLogBoxData.setWarningFilter().

```
LogBox.ignoreLogs([  // Exact message  'Warning: componentWillReceiveProps has been renamed',  // Substring or regex match  /GraphQL error: .*/,]);
```

LogBox will treat certain errors from React as warnings, which will mean they don't display as an in-app error notification. Advanced users can change this behaviour by customising LogBox's warning filter usingLogBoxData.setWarningFilter().


## Performance Monitor
On Android and iOS, an in-app performance overlay can be toggled during development by selecting"Perf Monitor"in the Dev Menu. Learn more about this featurehere.

The Performance Monitor runs in-app and is a guide. We recommend investigating the native tooling under Android Studio and Xcode for accurate performance measurements.


================================================================================


# Debugging Native Code
Source: https://reactnative.dev/docs/debugging-native-code


### Projects with Native Code Only
The following section only applies to projects with native code exposed. If you are using the managed Expo workflow, see the guide onprebuildto use this API.


## Accessing Logs
You can display the native logs for an iOS or Android app by using the following commands in a terminal while the app is running:

```
# For Android:npx react-native log-android# Or, for iOS:npx react-native log-ios
```

You may also access these through Debug > Open System Log… in the iOS Simulator or by runningadb logcat "*:S" ReactNative:V ReactNativeJS:Vin a terminal while an Android app is running on a device or emulator.

If you are writing a Native Module and want to add custom logs to your module for debugging purposes, you can use the following method:Android (Java/Kotlin)In your native module, use theLogclass to add logs that can be viewed in Logcat:javaimportandroid.util.Log;privatevoidlog(Stringmessage){Log.d("YourModuleName",message);}To view these logs in Logcat, use this command, replacingYourModuleNamewith your custom tag:shelladb logcat"*:S"ReactNative:V ReactNativeJS:V YourModuleName:DiOS (Objective-C/Swift)In your native module, useNSLogfor custom logs:objective-cNSLog(@"YourModuleName: %@", message);Or, in Swift:swiftprint("YourModuleName:\(message)")These logs will appear in the Xcode console when running the app.

In your native module, use theLogclass to add logs that can be viewed in Logcat:javaimportandroid.util.Log;privatevoidlog(Stringmessage){Log.d("YourModuleName",message);}To view these logs in Logcat, use this command, replacingYourModuleNamewith your custom tag:shelladb logcat"*:S"ReactNative:V ReactNativeJS:V YourModuleName:DiOS (Objective-C/Swift)In your native module, useNSLogfor custom logs:objective-cNSLog(@"YourModuleName: %@", message);Or, in Swift:swiftprint("YourModuleName:\(message)")These logs will appear in the Xcode console when running the app.

```
import android.util.Log;private void log(String message) {    Log.d("YourModuleName", message);}
```

To view these logs in Logcat, use this command, replacingYourModuleNamewith your custom tag:shelladb logcat"*:S"ReactNative:V ReactNativeJS:V YourModuleName:DiOS (Objective-C/Swift)In your native module, useNSLogfor custom logs:objective-cNSLog(@"YourModuleName: %@", message);Or, in Swift:swiftprint("YourModuleName:\(message)")These logs will appear in the Xcode console when running the app.

```
adb logcat "*:S" ReactNative:V ReactNativeJS:V YourModuleName:D
```

In your native module, useNSLogfor custom logs:objective-cNSLog(@"YourModuleName: %@", message);Or, in Swift:swiftprint("YourModuleName:\(message)")These logs will appear in the Xcode console when running the app.

```
NSLog(@"YourModuleName: %@", message);
```

Or, in Swift:swiftprint("YourModuleName:\(message)")These logs will appear in the Xcode console when running the app.

```
print("YourModuleName: \(message)")
```

These logs will appear in the Xcode console when running the app.


## Debugging in a Native IDE
When working with native code, such as when writing native modules, you can launch the app from Android Studio or Xcode and take advantage of the native debugging features (setting up breakpoints, etc.) as you would in case of building a standard native app.

Another option is to run your application using the React Native CLI and attach the native debugger of the native IDE (Android Studio or Xcode) to the process.


### Android Studio
On Android Studio you can do this by going on the "Run" option on the menu bar, clicking on "Attach to Process..." and selecting the running React Native app.


### Xcode
On Xcode click on "Debug" on the top menu bar, select the "Attach to process" option, and select the application in the list of "Likely Targets".


================================================================================


# Debugging Release Builds
Source: https://reactnative.dev/docs/debugging-release-builds


## Symbolicating a stack trace
If a React Native app throws an unhandled exception in a release build, the output may be obfuscated and hard to read.

```
07-15 10:58:25.820 18979 18998 E AndroidRuntime: FATAL EXCEPTION: mqt_native_modules07-15 10:58:25.820 18979 18998 E AndroidRuntime: Process: com.awesomeproject, PID: 18979 07-15 10:58:25.820 18979 18998 E AndroidRuntime: com.facebook.react.common.JavascriptException: Failed, js engine: hermes, stack:07-15 10:58:25.820 18979 18998 E AndroidRuntime: p@1:13216107-15 10:58:25.820 18979 18998 E AndroidRuntime: p@1:13208407-15 10:58:25.820 18979 18998 E AndroidRuntime: f@1:13185407-15 10:58:25.820 18979 18998 E AndroidRuntime: anonymous@1:131119
```

In the above stack trace, entries likep@1:132161are minified function names and bytecode offsets. To debug these calls, we want to translate these into file, line, and function name, e.g.AwesomeProject/App.js:54:initializeMap. This is known assymbolication.

You can symbolicate minified function names and bytecode like the above by passing the stack trace and a generated source map tometro-symbolicate.


### Enabling source maps
Source maps are required to symbolicate stack traces. Make sure that source maps are enabled within the build config for the target platform.

- AndroidiOS
- iOS
On Android, source maps areenabledby default.

To enable source map generation, ensure the followinghermesFlagsare present inandroid/app/build.gradle.groovyreact{hermesFlags=["-O","-output-source-map"]}If done correctly you should see the output location of the source map during Metro build output.textWriting bundle output to:, android/app/build/generated/assets/react/release/index.android.bundleWriting sourcemap output to:, android/app/build/intermediates/sourcemaps/react/release/index.android.bundle.packager.map

```
react {    hermesFlags = ["-O", "-output-source-map"]}
```

If done correctly you should see the output location of the source map during Metro build output.textWriting bundle output to:, android/app/build/generated/assets/react/release/index.android.bundleWriting sourcemap output to:, android/app/build/intermediates/sourcemaps/react/release/index.android.bundle.packager.map

```
Writing bundle output to:, android/app/build/generated/assets/react/release/index.android.bundleWriting sourcemap output to:, android/app/build/intermediates/sourcemaps/react/release/index.android.bundle.packager.map
```

On iOS, source maps aredisabledby default. Use the following instructions to enable them.

To enable source map generation:Open Xcode and edit the build phase "Bundle React Native code and images".Above the other exports, add aSOURCEMAP_FILEentry with the desired output path.diff+export SOURCEMAP_FILE="$(pwd)/../main.jsbundle.map"WITH_ENVIRONMENT="../node_modules/react-native/scripts/xcode/with-environment.sh"If done correctly you should see the output location of the source map during Metro build output.textWriting bundle output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundleWriting sourcemap output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle.map

- Open Xcode and edit the build phase "Bundle React Native code and images".
- Above the other exports, add aSOURCEMAP_FILEentry with the desired output path.
```
+ export SOURCEMAP_FILE="$(pwd)/../main.jsbundle.map"  WITH_ENVIRONMENT="../node_modules/react-native/scripts/xcode/with-environment.sh"
```

If done correctly you should see the output location of the source map during Metro build output.textWriting bundle output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundleWriting sourcemap output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle.map

```
Writing bundle output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundleWriting sourcemap output to:, Build/Intermediates.noindex/ArchiveIntermediates/application/BuildProductsPath/Release-iphoneos/main.jsbundle.map
```


### Usingmetro-symbolicate
With source maps being generated, we can now translate our stack traces.

```
# Print usage instructionsnpx metro-symbolicate# From a file containing the stack tracenpx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map < stacktrace.txt# From adb logcat (Android)adb logcat -d | npx metro-symbolicate android/app/build/generated/sourcemaps/react/release/index.android.bundle.map
```


### Notes on source maps
- Multiple source maps may be generated by the build process. Make sure to use the one in the location shown in the examples.
- Make sure that the source map you use corresponds to the exact commit of the crashing app. Small changes in source code can cause large differences in offsets.
- Ifmetro-symbolicateexits immediately with success, make sure the input comes from a pipe or redirection and not from a terminal.

================================================================================


# DevSettings
Source: https://reactnative.dev/docs/devsettings

TheDevSettingsmodule exposes methods for customizing settings for developers in development.


## Methods

### addMenuItem()
```
static addMenuItem(title: string, handler: () => any);
```

Add a custom menu item to the Dev Menu.

Parameters:

Example:

```
DevSettings.addMenuItem('Show Secret Dev Screen', () => {  Alert.alert('Showing secret dev screen!');});
```


### reload()
```
static reload(reason?: string): void;
```

Reload the application. Can be invoked directly or on user interaction.

Example:

```
<Button title="Reload" onPress={() => DevSettings.reload()} />
```


================================================================================


# Dimensions
Source: https://reactnative.dev/docs/dimensions

useWindowDimensionsis the preferred API for React components. UnlikeDimensions, it updates as the window's dimensions update. This works nicely with the React paradigm.

```
import {Dimensions} from 'react-native';
```

You can get the application window's width and height using the following code:

```
const windowWidth = Dimensions.get('window').width;const windowHeight = Dimensions.get('window').height;
```

Although dimensions are available immediately, they may change (e.g due to device rotation, foldable devices etc) so any rendering logic or styles that depend on these constants should try to call this function on every render, rather than caching the value (for example, using inline styles rather than setting a value in aStyleSheet).

If you are targeting foldable devices or devices which can change the screen size or app window size, you can use the event listener available in the Dimensions module as shown in the below example.


## Example

## Methods

### addEventListener()
```
static addEventListener(  type: 'change',  handler: ({    window,    screen,  }: DimensionsValue) => void,): EmitterSubscription;
```

Add an event handler. Supported events:

- change: Fires when a property within theDimensionsobject changes. The argument to the event handler is aDimensionsValuetype object.

### get()
```
static get(dim: 'window' | 'screen'): ScaledSize;
```

Initial dimensions are set beforerunApplicationis called so they should be available before any other require's are run, but may be updated later.

Example:const {height, width} = Dimensions.get('window');

Parameters:

For Android thewindowdimension will be reduced by the size of status bar (if not translucent) and bottom navigation bar.


## Type Definitions

### DimensionsValue
Properties:


### ScaledSize
Properties:


================================================================================


# Document nodes
Source: https://reactnative.dev/docs/document-nodes

Document nodes represent a complete native view tree. Apps using native navigation would provide a separate document node for each screen. Apps not using native navigation would generally provide a single document for the whole app (similar to single-page apps on Web).


## Reference

### Web-compatible API
FromDocument:

- PropertieschildElementCountchildrendocumentElementfirstElementChildlastElementChild
- childElementCount
- children
- documentElement
- firstElementChild
- lastElementChild
- MethodsgetElementById()
- getElementById()
FromNode:

- PropertieschildNodesfirstChildisConnectedlastChildnextSiblingnodeNamenodeTypenodeValueownerDocumentparentElementparentNodepreviousSiblingtextContent
- childNodes
- firstChild
- isConnected
- lastChild
- nextSibling
- nodeName
- nodeType
- nodeValue
- ownerDocument
- parentElement
- parentNode
- previousSibling
- textContent
- MethodscompareDocumentPosition()contains()getRootNode()hasChildNodes()
- compareDocumentPosition()
- contains()
- getRootNode()
- hasChildNodes()

================================================================================


# DrawerLayoutAndroid
Source: https://reactnative.dev/docs/drawerlayoutandroid

React component that wraps the platformDrawerLayout(Android only). The Drawer (typically used for navigation) is rendered withrenderNavigationViewand direct children are the main view (where your content goes). The navigation view is initially not visible on the screen, but can be pulled in from the side of the window specified by thedrawerPositionprop and its width can be set by thedrawerWidthprop.


## Example
- TypeScriptJavaScript
- JavaScript

## Props

### View Props
InheritsView Props.


### drawerBackgroundColor
Specifies the background color of the drawer. The default value iswhite. If you want to set the opacity of the drawer, use rgba. Example:

```
return (  <DrawerLayoutAndroid drawerBackgroundColor="rgba(0,0,0,0.5)" />);
```


### drawerLockMode
Specifies the lock mode of the drawer. The drawer can be locked in 3 states:

- unlocked (default), meaning that the drawer will respond (open/close) to touch gestures.
- locked-closed, meaning that the drawer will stay closed and not respond to gestures.
- locked-open, meaning that the drawer will stay opened and not respond to gestures. The drawer may still be opened and closed programmatically (openDrawer/closeDrawer).

### drawerPosition
Specifies the side of the screen from which the drawer will slide in. By default it is set toleft.


### drawerWidth
Specifies the width of the drawer, more precisely the width of the view that be pulled in from the edge of the window.


### keyboardDismissMode
Determines whether the keyboard gets dismissed in response to a drag.

- 'none' (the default), drags do not dismiss the keyboard.
- 'on-drag', the keyboard is dismissed when a drag begins.

### onDrawerClose
Function called whenever the navigation view has been closed.


### onDrawerOpen
Function called whenever the navigation view has been opened.


### onDrawerSlide
Function called whenever there is an interaction with the navigation view.


### onDrawerStateChanged
Function called when the drawer state has changed. The drawer can be in 3 states:

- idle, meaning there is no interaction with the navigation view happening at the time
- dragging, meaning there is currently an interaction with the navigation view
- settling, meaning that there was an interaction with the navigation view, and the navigation view is now finishing its closing or opening animation

### renderNavigationView
The navigation view that will be rendered to the side of the screen and can be pulled in.


### statusBarBackgroundColor
Make the drawer take the entire screen and draw the background of the status bar to allow it to open over the status bar. It will only have an effect on API 21+.


## Methods

### closeDrawer()
```
closeDrawer();
```

Closes the drawer.


### openDrawer()
```
openDrawer();
```

Opens the drawer.


================================================================================


# DropShadowValue Object Type
Source: https://reactnative.dev/docs/dropshadowvalue

TheDropShadowValueobject is taken by thefilterstyle prop for thedropShadowfunction. It is comprised of 2 or 3 lengths and an optional color. These values collectively define the drop shadow's color, position, and blurriness.


## Example
```
{  offsetX: 10,  offsetY: -3,  standardDeviation: '15px',  color: 'blue',}
```


## Keys and values

### offsetX
The offset on the x-axis. This can be positive or negative. A positive value indicates right and negative indicates left.


### offsetY
The offset on the y-axis. This can be positive or negative. A positive value indicates up and negative indicates down.


### standardDeviation
Represents the standard deviation used in theGaussian bluralgorithm. The larger the value the blurrier the shadow is. Only non-negative values are valid. The default is 0.


### color
The color of the shadow. The default isblack.


## Used by
- filter

================================================================================


# DynamicColorIOS
Source: https://reactnative.dev/docs/dynamiccolorios

TheDynamicColorIOSfunction is a platform color type specific to iOS.

```
DynamicColorIOS({  light: color,  dark: color,  highContrastLight: color, // (optional) will fallback to "light" if not provided  highContrastDark: color, // (optional) will fallback to "dark" if not provided});
```

DynamicColorIOStakes a single argument as an object with two mandatory keys:darkandlight, and two optional keyshighContrastLightandhighContrastDark. These correspond to the colors you want to use for "light mode" and "dark mode" on iOS, and when high contrast accessibility mode is enabled, high contrast version of them.

At runtime, the system will choose which of the colors to display depending on the current system appearance and accessibility settings. Dynamic colors are useful for branding colors or other app specific colors that still respond automatically to system setting changes.

- iOSWeb
- Web
If you’re familiar with@media (prefers-color-scheme: dark)in CSS, this is similar! Only instead of defining all the colors in a media query, you define which color to use under what circumstances right there where you're using it. Neat!

TheDynamicColorIOSfunction is similar to the iOS native methodsUIColor colorWithDynamicProvider:.


## Example
```
import {DynamicColorIOS} from 'react-native';const customDynamicTextColor = DynamicColorIOS({  dark: 'lightskyblue',  light: 'midnightblue',});const customContrastDynamicTextColor = DynamicColorIOS({  dark: 'darkgray',  light: 'lightgray',  highContrastDark: 'black',  highContrastLight: 'white',});
```


================================================================================


# Easing
Source: https://reactnative.dev/docs/easing

TheEasingmodule implements common easing functions. This module is used byAnimated.timing()to convey physically believable motion in animations.

You can find a visualization of some common easing functions athttps://easings.net/


### Predefined animations
TheEasingmodule provides several predefined animations through the following methods:

- backprovides a basic animation where the object goes slightly back before moving forward
- bounceprovides a bouncing animation
- easeprovides a basic inertial animation
- elasticprovides a basic spring interaction

### Standard functions
Three standard easing functions are provided:

- linear
- quad
- cubic
Thepolyfunction can be used to implement quartic, quintic, and other higher power functions.


### Additional functions
Additional mathematical functions are provided by the following methods:

- bezierprovides a cubic bezier curve
- circleprovides a circular function
- sinprovides a sinusoidal function
- expprovides an exponential function
The following helpers are used to modify other easing functions.

- inruns an easing function forwards
- inOutmakes any easing function symmetrical
- outruns an easing function backwards

## Example
- TypeScriptJavaScript
- JavaScript

## Methods

### step0()
```
static step0(n: number);
```

A stepping function, returns 1 for any positive value ofn.


### step1()
```
static step1(n: number);
```

A stepping function, returns 1 ifnis greater than or equal to 1.


### linear()
```
static linear(t: number);
```

A linear function,f(t) = t. Position correlates to elapsed time one to one.

https://cubic-bezier.com/#0,0,1,1


### ease()
```
static ease(t: number);
```

A basic inertial interaction, similar to an object slowly accelerating to speed.

https://cubic-bezier.com/#.42,0,1,1


### quad()
```
static quad(t: number);
```

A quadratic function,f(t) = t * t. Position equals the square of elapsed time.

https://easings.net/#easeInQuad


### cubic()
```
static cubic(t: number);
```

A cubic function,f(t) = t * t * t. Position equals the cube of elapsed time.

https://easings.net/#easeInCubic


### poly()
```
static poly(n: number);
```

A power function. Position is equal to the Nth power of elapsed time.

n = 4:https://easings.net/#easeInQuartn = 5:https://easings.net/#easeInQuint


### sin()
```
static sin(t: number);
```

A sinusoidal function.

https://easings.net/#easeInSine


### circle()
```
static circle(t: number);
```

A circular function.

https://easings.net/#easeInCirc


### exp()
```
static exp(t: number);
```

An exponential function.

https://easings.net/#easeInExpo


### elastic()
```
static elastic(bounciness: number);
```

A basic elastic interaction, similar to a spring oscillating back and forth.

Default bounciness is 1, which overshoots a little bit once. 0 bounciness doesn't overshoot at all, and bounciness of N > 1 will overshoot about N times.

https://easings.net/#easeInElastic


### back()
```
static back(s)
```

Use withAnimated.parallel()to create a basic effect where the object animates back slightly as the animation starts.


### bounce()
```
static bounce(t: number);
```

Provides a basic bouncing effect.

https://easings.net/#easeInBounce


### bezier()
```
static bezier(x1: number, y1: number, x2: number, y2: number);
```

Provides a cubic bezier curve, equivalent to CSS Transitions'transition-timing-function.

A useful tool to visualize cubic bezier curves can be found athttps://cubic-bezier.com/


### in()
```
static in(easing: number);
```

Runs an easing function forwards.


### out()
```
static out(easing: number);
```

Runs an easing function backwards.


### inOut()
```
static inOut(easing: number);
```

Makes any easing function symmetrical. The easing function will run forwards for half of the duration, then backwards for the rest of the duration.


================================================================================


# Element nodes
Source: https://reactnative.dev/docs/element-nodes

Element nodes represent native components in the native view tree (similar toElementnodes on Web).

They are provided by all native components, and by many built-in components, via refs:

Note that some built-in components are only a container for other components (including native components). For example,ScrollViewinternally renders a native scroll view and a native view, which are accessible through the ref it provides using methods likegetNativeScrollRef()andgetInnerViewRef().


## Reference

### Web-compatible API
FromHTMLElement:

- PropertiesoffsetHeightoffsetLeftoffsetParentoffsetTopoffsetWidth
- offsetHeight
- offsetLeft
- offsetParent
- offsetTop
- offsetWidth
- Methodsblur().focus().⚠️ Theoptionsparameter is not supported.
- blur().
- focus().⚠️ Theoptionsparameter is not supported.
- ⚠️ Theoptionsparameter is not supported.
FromElement:

- PropertieschildElementCountchildrenclientHeightclientLeftclientTopclientWidthfirstElementChildidℹ️ Returns the value of theidornativeIDprops.lastElementChildnextElementSiblingnodeNamenodeTypenodeValuepreviousElementSiblingscrollHeightscrollLeft⚠️ For built-in components, onlyScrollViewinstances can return a value other than zero.scrollTop⚠️ For built-in components, onlyScrollViewinstances can return a value other than zero.scrollWidthtagNameℹ️ Returns a normalized native component name prefixed withRN:, likeRN:View.textContent
- childElementCount
- children
- clientHeight
- clientLeft
- clientTop
- clientWidth
- firstElementChild
- idℹ️ Returns the value of theidornativeIDprops.
- ℹ️ Returns the value of theidornativeIDprops.
- lastElementChild
- nextElementSibling
- nodeName
- nodeType
- nodeValue
- previousElementSibling
- scrollHeight
- scrollLeft⚠️ For built-in components, onlyScrollViewinstances can return a value other than zero.
- ⚠️ For built-in components, onlyScrollViewinstances can return a value other than zero.
- scrollTop⚠️ For built-in components, onlyScrollViewinstances can return a value other than zero.
- ⚠️ For built-in components, onlyScrollViewinstances can return a value other than zero.
- scrollWidth
- tagNameℹ️ Returns a normalized native component name prefixed withRN:, likeRN:View.
- ℹ️ Returns a normalized native component name prefixed withRN:, likeRN:View.
- textContent
- MethodsgetBoundingClientRect()hasPointerCapture()setPointerCapture()releasePointerCapture()
- getBoundingClientRect()
- hasPointerCapture()
- setPointerCapture()
- releasePointerCapture()
FromNode:

- PropertieschildNodesfirstChildisConnectedlastChildnextSiblingnodeNamenodeTypenodeValueownerDocumentℹ️ Will return thedocument instancewhere this component was rendered.parentElementparentNodepreviousSiblingtextContent
- childNodes
- firstChild
- isConnected
- lastChild
- nextSibling
- nodeName
- nodeType
- nodeValue
- ownerDocumentℹ️ Will return thedocument instancewhere this component was rendered.
- ℹ️ Will return thedocument instancewhere this component was rendered.
- parentElement
- parentNode
- previousSibling
- textContent
- MethodscompareDocumentPosition()contains()getRootNode()ℹ️ Will return a reference to itself if the component is not mounted.hasChildNodes()
- compareDocumentPosition()
- contains()
- getRootNode()ℹ️ Will return a reference to itself if the component is not mounted.
- ℹ️ Will return a reference to itself if the component is not mounted.
- hasChildNodes()

### Legacy API
- measure()
- measureInWindow()
- measureLayout()
- setNativeProps()

================================================================================


# Get Started with React Native
Source: https://reactnative.dev/docs/environment-setup

React Native allows developers who know React to create native apps.At the same time, native developers can use React Native to gain parity between native platforms by writing common features once.

We believe that the best way to experience React Native is through aFramework, a toolbox with all the necessary APIs to let you build production ready apps.

You can also use React Native without a Framework, however we’ve found that most developers benefit from using a React Native Framework likeExpo. Expo provides features like file-based routing, high-quality universal libraries, and the ability to write plugins that modify native code without having to manage native files.

Yes. You can use React Native without a Framework.However, if you’re building a new app with React Native, we recommend using a Framework.In short, you’ll be able to spend time writing your app instead of writing an entire Framework yourself in addition to your app.The React Native community has spent years refining approaches to navigation, accessing native APIs, dealing with native dependencies, and more. Most apps need these core features. A React Native Framework provides them from the start of your app.Without a Framework, you’ll either have to write your own solutions to implement core features, or you’ll have to piece together a collection of pre-existing libraries to create a skeleton of a Framework. This takes real work, both when starting your app, then later when maintaining it.If your app has unusual constraints that are not served well by a Framework, or you prefer to solve these problems yourself, you can make a React Native app without a Framework using Android Studio, Xcode. If you’re interested in this path, learn how toset up your environmentand how toget started without a framework.

In short, you’ll be able to spend time writing your app instead of writing an entire Framework yourself in addition to your app.The React Native community has spent years refining approaches to navigation, accessing native APIs, dealing with native dependencies, and more. Most apps need these core features. A React Native Framework provides them from the start of your app.Without a Framework, you’ll either have to write your own solutions to implement core features, or you’ll have to piece together a collection of pre-existing libraries to create a skeleton of a Framework. This takes real work, both when starting your app, then later when maintaining it.If your app has unusual constraints that are not served well by a Framework, or you prefer to solve these problems yourself, you can make a React Native app without a Framework using Android Studio, Xcode. If you’re interested in this path, learn how toset up your environmentand how toget started without a framework.

The React Native community has spent years refining approaches to navigation, accessing native APIs, dealing with native dependencies, and more. Most apps need these core features. A React Native Framework provides them from the start of your app.Without a Framework, you’ll either have to write your own solutions to implement core features, or you’ll have to piece together a collection of pre-existing libraries to create a skeleton of a Framework. This takes real work, both when starting your app, then later when maintaining it.If your app has unusual constraints that are not served well by a Framework, or you prefer to solve these problems yourself, you can make a React Native app without a Framework using Android Studio, Xcode. If you’re interested in this path, learn how toset up your environmentand how toget started without a framework.

Without a Framework, you’ll either have to write your own solutions to implement core features, or you’ll have to piece together a collection of pre-existing libraries to create a skeleton of a Framework. This takes real work, both when starting your app, then later when maintaining it.If your app has unusual constraints that are not served well by a Framework, or you prefer to solve these problems yourself, you can make a React Native app without a Framework using Android Studio, Xcode. If you’re interested in this path, learn how toset up your environmentand how toget started without a framework.

If your app has unusual constraints that are not served well by a Framework, or you prefer to solve these problems yourself, you can make a React Native app without a Framework using Android Studio, Xcode. If you’re interested in this path, learn how toset up your environmentand how toget started without a framework.


## Start a new React Native project with Expo
Expo is a production-grade React Native Framework. Expo provides developer tooling that makes developing apps easier, such as file-based routing, a standard library of native modules, and much more.

Expo's Framework is free and open source, with an active community onGitHubandDiscord. The Expo team works in close collaboration with the React Native team at Meta to bring the latest React Native features to the Expo SDK.

The team at Expo also provides Expo Application Services (EAS), an optional set of services that complements Expo, the Framework, in each step of the development process.

To create a new Expo project, run the following in your terminal:

```
npx create-expo-app@latest
```

Once you’ve created your app, check out the rest of Expo’s getting started guide to start developing your app.


================================================================================


# Fabric Native Modules: Android
Source: https://reactnative.dev/docs/fabric-native-components-android

Now it's time to write some Android platform code to be able to render the web view. The steps you need to follow are:

- Running Codegen
- Write the code for theReactWebView
- Write the code for theReactWebViewManager
- Write the code for theReactWebViewPackage
- Register theReactWebViewPackagein the application

### 1. Run Codegen through Gradle
Run this once to generate boilerplate that your IDE of choice can use.

```
cd android./gradlew generateCodegenArtifactsFromSchema
```

Codegen will generate theViewManagerinterface you need to implement and theViewManagerdelegate for the web view.


### 2. Write theReactWebView
TheReactWebViewis the component that wraps the Android native view that React Native will render when using our custom Component.

Create aReactWebView.javaor aReactWebView.ktfile in theandroid/src/main/java/com/webviewfolder with this code:

- JavaKotlin
- Kotlin
```
package com.webview;import android.content.Context;import android.util.AttributeSet;import android.webkit.WebView;import android.webkit.WebViewClient;import com.facebook.react.bridge.Arguments;import com.facebook.react.bridge.WritableMap;import com.facebook.react.bridge.ReactContext;import com.facebook.react.uimanager.UIManagerHelper;import com.facebook.react.uimanager.events.Event;public class ReactWebView extends WebView {  public ReactWebView(Context context) {    super(context);    configureComponent();  }  public ReactWebView(Context context, AttributeSet attrs) {    super(context, attrs);    configureComponent();  }  public ReactWebView(Context context, AttributeSet attrs, int defStyleAttr) {    super(context, attrs, defStyleAttr);    configureComponent();  }  private void configureComponent() {    this.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));    this.setWebViewClient(new WebViewClient() {      @Override      public void onPageFinished(WebView view, String url) {        emitOnScriptLoaded(OnScriptLoadedEventResult.success);      }    });  }  public void emitOnScriptLoaded(OnScriptLoadedEventResult result) {    ReactContext reactContext = (ReactContext) context;    int surfaceId = UIManagerHelper.getSurfaceId(reactContext);    EventDispatcher eventDispatcher = UIManagerHelper.getEventDispatcherForReactTag(reactContext, getId());    WritableMap payload = Arguments.createMap();    payload.putString("result", result.name());    OnScriptLoadedEvent event = new OnScriptLoadedEvent(surfaceId, getId(), payload);    if (eventDispatcher != null) {      eventDispatcher.dispatchEvent(event);    }  }  public enum OnScriptLoadedEventResult {    success,    error  }  private class OnScriptLoadedEvent extends Event<OnScriptLoadedEvent> {    private final WritableMap payload;    OnScriptLoadedEvent(int surfaceId, int viewId, WritableMap payload) {      super(surfaceId, viewId);      this.payload = payload;    }    @Override    public String getEventName() {      return "onScriptLoaded";    }    @Override    public WritableMap getEventData() {      return payload;    }  }}
```

```
package com.webviewimport android.content.Contextimport android.util.AttributeSetimport android.webkit.WebViewimport android.webkit.WebViewClientimport com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.WritableMapimport com.facebook.react.bridge.ReactContextimport com.facebook.react.uimanager.UIManagerHelperimport com.facebook.react.uimanager.events.Eventclass ReactWebView: WebView {  constructor(context: Context) : super(context) {    configureComponent()  }  constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {    configureComponent()  }  constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {    configureComponent()  }  private fun configureComponent() {    this.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)    this.webViewClient = object : WebViewClient() {      override fun onPageFinished(view: WebView, url: String) {        emitOnScriptLoaded(OnScriptLoadedEventResult.success)      }    }  }  fun emitOnScriptLoaded(result: OnScriptLoadedEventResult) {    val reactContext = context as ReactContext    val surfaceId = UIManagerHelper.getSurfaceId(reactContext)    val eventDispatcher = UIManagerHelper.getEventDispatcherForReactTag(reactContext, id)    val payload =        Arguments.createMap().apply {          putString("result", result.name)        }    val event = OnScriptLoadedEvent(surfaceId, id, payload)    eventDispatcher?.dispatchEvent(event)  }  enum class OnScriptLoadedEventResult {    success,    error;  }  inner class OnScriptLoadedEvent(      surfaceId: Int,      viewId: Int,      private val payload: WritableMap  ) : Event<OnScriptLoadedEvent>(surfaceId, viewId) {    override fun getEventName() = "onScriptLoaded"    override fun getEventData() = payload  }}
```

TheReactWebViewextends the AndroidWebViewso you can reuse all the properties already defined by the platform with ease.

The class defines the three Android constructors but defers their actual implementation to the privateconfigureComponentfunction. This function takes care of initializing all the components specific properties: in this case you are setting the layout of theWebViewand you are defining theWebClientthat you use to customize the behavior of theWebView. In this code, theReactWebViewemits an event when the page finishes loading, by implementing theWebClient'sonPageFinishedmethod.

The code then defines a helper function to actually emit an event. To emit an event, you have to:

- grab a reference to theReactContext;
- retrieve thesurfaceIdof the view that you are presenting;
- grab a reference to theeventDispatcherassociated with the view;
- build the payload for the event using aWritableMapobject;
- create the event object that you need to send to JavaScript;
- call theeventDispatcher.dispatchEventto send the event.
The last part of the file contains the definition of the data types you need to send the event:

- TheOnScriptLoadedEventResult, with the possible outcomes of theOnScriptLoadedevent.
- The actualOnScriptLoadedEventthat needs to extend the React Native'sEventclass.

### 3. Write theWebViewManager
TheWebViewManageris the class that connects the React Native runtime with the native view.

When React receives the instruction from the app to render a specific component, React uses the registered view manager to create the view and to pass all the required properties.

This is the code of theReactWebViewManager.

- JavaKotlin
- Kotlin
```
package com.webview;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.annotations.ReactModule;import com.facebook.react.uimanager.SimpleViewManager;import com.facebook.react.uimanager.ThemedReactContext;import com.facebook.react.uimanager.ViewManagerDelegate;import com.facebook.react.uimanager.annotations.ReactProp;import com.facebook.react.viewmanagers.CustomWebViewManagerInterface;import com.facebook.react.viewmanagers.CustomWebViewManagerDelegate;import java.util.HashMap;import java.util.Map;@ReactModule(name = ReactWebViewManager.REACT_CLASS)class ReactWebViewManager extends SimpleViewManager<ReactWebView> implements CustomWebViewManagerInterface<ReactWebView> {  private final CustomWebViewManagerDelegate<ReactWebView, ReactWebViewManager> delegate =          new CustomWebViewManagerDelegate<>(this);  @Override  public ViewManagerDelegate<ReactWebView> getDelegate() {    return delegate;  }  @Override  public String getName() {    return REACT_CLASS;  }  @Override  public ReactWebView createViewInstance(ThemedReactContext context) {    return new ReactWebView(context);  }  @ReactProp(name = "sourceUrl")  @Override  public void setSourceURL(ReactWebView view, String sourceURL) {    if (sourceURL == null) {      view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error);      return;    }    view.loadUrl(sourceURL, new HashMap<>());  }  public static final String REACT_CLASS = "CustomWebView";  @Override  public Map<String, Object> getExportedCustomBubblingEventTypeConstants() {    Map<String, Object> map = new HashMap<>();    Map<String, Object> bubblingMap = new HashMap<>();    bubblingMap.put("phasedRegistrationNames", new HashMap<String, String>() {{      put("bubbled", "onScriptLoaded");      put("captured", "onScriptLoadedCapture");    }});    map.put("onScriptLoaded", bubblingMap);    return map;  }}
```

```
package com.webviewimport com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.annotations.ReactModule;import com.facebook.react.uimanager.SimpleViewManager;import com.facebook.react.uimanager.ThemedReactContext;import com.facebook.react.uimanager.ViewManagerDelegate;import com.facebook.react.uimanager.annotations.ReactProp;import com.facebook.react.viewmanagers.CustomWebViewManagerInterface;import com.facebook.react.viewmanagers.CustomWebViewManagerDelegate;@ReactModule(name = ReactWebViewManager.REACT_CLASS)class ReactWebViewManager(context: ReactApplicationContext) : SimpleViewManager<ReactWebView>(), CustomWebViewManagerInterface<ReactWebView> {  private val delegate: CustomWebViewManagerDelegate<ReactWebView, ReactWebViewManager> =    CustomWebViewManagerDelegate(this)  override fun getDelegate(): ViewManagerDelegate<ReactWebView> = delegate  override fun getName(): String = REACT_CLASS  override fun createViewInstance(context: ThemedReactContext): ReactWebView = ReactWebView(context)  @ReactProp(name = "sourceUrl")  override fun setSourceURL(view: ReactWebView, sourceURL: String?) {    if (sourceURL == null) {      view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error)      return;    }    view.loadUrl(sourceURL, emptyMap())  }  companion object {    const val REACT_CLASS = "CustomWebView"  }  override fun getExportedCustomBubblingEventTypeConstants(): Map<String, Any> =      mapOf(          "onScriptLoaded" to              mapOf(                  "phasedRegistrationNames" to                      mapOf(                          "bubbled" to "onScriptLoaded",                          "captured" to "onScriptLoadedCapture"                      )))}
```

TheReactWebViewManagerextends theSimpleViewManagerclass from React and implements theCustomWebViewManagerInterface, generated by Codegen.

It holds a reference of theCustomWebViewManagerDelegate, another element generated by Codegen.

It then overrides thegetNamefunction, which must return the same name used in the spec'scodegenNativeComponentfunction call.

ThecreateViewInstancefunction is responsible to instantiate a newReactWebView.

Then, the ViewManager needs to define how all the React's components props will update the native view. In the example, you need to decide how to handle thesourceURLproperty that React will set on theWebView.

Finally, if the component can emit an event, you need to map the event name by overriding thegetExportedCustomBubblingEventTypeConstantsfor bubbling events, or thegetExportedCustomDirectEventTypeConstantsfor direct events.


### 4. Write theReactWebViewPackage
As you do with Native Modules, Native Components also need to implement theReactPackageclass. This is an object that you can use to register the component in the React Native runtime.

This is the code for theReactWebViewPackage:

- JavaKotlin
- Kotlin
```
package com.webview;import com.facebook.react.BaseReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.model.ReactModuleInfo;import com.facebook.react.module.model.ReactModuleInfoProvider;import com.facebook.react.uimanager.ViewManager;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;public class ReactWebViewPackage extends BaseReactPackage {  @Override  public List<ViewManager<?, ?>> createViewManagers(ReactApplicationContext reactContext) {    return Collections.singletonList(new ReactWebViewManager(reactContext));  }  @Override  public NativeModule getModule(String s, ReactApplicationContext reactApplicationContext) {    if (ReactWebViewManager.REACT_CLASS.equals(s)) {      return new ReactWebViewManager(reactApplicationContext);    }    return null;  }  @Override  public ReactModuleInfoProvider getReactModuleInfoProvider() {    return new ReactModuleInfoProvider() {      @Override      public Map<String, ReactModuleInfo> getReactModuleInfos() {        Map<String, ReactModuleInfo> map = new HashMap<>();        map.put(ReactWebViewManager.REACT_CLASS, new ReactModuleInfo(                ReactWebViewManager.REACT_CLASS, // name                ReactWebViewManager.REACT_CLASS, // className                false,                           // canOverrideExistingModule                false,                           // needsEagerInit                false,                           // isCxxModule                true                             // isTurboModule        ));        return map;      }    };  }}
```

```
package com.webviewimport com.facebook.react.BaseReactPackageimport com.facebook.react.bridge.NativeModuleimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.module.model.ReactModuleInfoimport com.facebook.react.module.model.ReactModuleInfoProviderimport com.facebook.react.uimanager.ViewManagerclass ReactWebViewPackage : BaseReactPackage() {  override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {    return listOf(ReactWebViewManager(reactContext))  }  override fun getModule(s: String, reactApplicationContext: ReactApplicationContext): NativeModule? {    when (s) {      ReactWebViewManager.REACT_CLASS -> ReactWebViewManager(reactApplicationContext)    }    return null  }  override fun getReactModuleInfoProvider(): ReactModuleInfoProvider = ReactModuleInfoProvider {    mapOf(ReactWebViewManager.REACT_CLASS to ReactModuleInfo(      name = ReactWebViewManager.REACT_CLASS,      className = ReactWebViewManager.REACT_CLASS,      canOverrideExistingModule = false,      needsEagerInit = false,      isCxxModule = false,      isTurboModule = true,    )    )  }}
```

TheReactWebViewPackageextends theBaseReactPackageand implements all the methods required to properly register our component.

- thecreateViewManagersmethod is the factory method that creates theViewManagerthat manage the custom views.
- thegetModulemethod returns the proper ViewManager depending on the View that React Native needs to render.
- thegetReactModuleInfoProviderprovides all the information required when registering the module in the runtime,

### 5. Register theReactWebViewPackagein the application
Finally, you need to register theReactWebViewPackagein the application. We do that by modifying theMainApplicationfile by adding theReactWebViewPackageto the list of packages returned by thegetPackagesfunction.

```
package com.demoimport android.app.Applicationimport com.facebook.react.PackageListimport com.facebook.react.ReactApplicationimport com.facebook.react.ReactHostimport com.facebook.react.ReactNativeHostimport com.facebook.react.ReactPackageimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.loadimport com.facebook.react.defaults.DefaultReactHost.getDefaultReactHostimport com.facebook.react.defaults.DefaultReactNativeHostimport com.facebook.react.soloader.OpenSourceMergedSoMappingimport com.facebook.soloader.SoLoaderimport com.webview.ReactWebViewPackageclass MainApplication : Application(), ReactApplication {  override val reactNativeHost: ReactNativeHost =      object : DefaultReactNativeHost(this) {        override fun getPackages(): List<ReactPackage> =            PackageList(this).packages.apply {              add(ReactWebViewPackage())            }        override fun getJSMainModuleName(): String = "index"        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED      }  override val reactHost: ReactHost    get() = getDefaultReactHost(applicationContext, reactNativeHost)  override fun onCreate() {    super.onCreate()    SoLoader.init(this, OpenSourceMergedSoMapping)    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {      load()    }  }}
```


================================================================================


# Native Components
Source: https://reactnative.dev/docs/fabric-native-components-introduction

If you want to buildnewReact Native Components that wrap around aHost Componentlike a unique kind ofCheckBoxon Android, or aUIButtonon iOS, you should use a Fabric Native Component.

This guide will show you how to build Fabric Native Components, by implementing a web view component. The steps to doing this are:

- Define a JavaScript specification using Flow or TypeScript.
- Configure the dependencies management system to generate code from the provided spec and to be auto-linked.
- Implement the Native code.
- Use the Component in an App.
You're going to need a plain template generated application to use the component:

```
npx @react-native-community/cli@latest init Demo --install-pods false
```


## Creating a WebView Component
This guide will show you how to create a Web View component. We will be creating the component by using the Android'sWebViewcomponent, and the iOSWKWebViewcomponent.

Let's start by creating the folders structure to hold our component's code:

```
mkdir -p Demo/{specs,android/app/src/main/java/com/webview}
```

This gives you the following layout where you'll working:

```
Demo├── android/app/src/main/java/com/webview└── ios└── specs
```

- Theandroid/app/src/main/java/com/webviewfolder is the folder that will contain our Android code.
- Theiosfolder is the folder that will contain our iOS code.
- Thespecsfolder is the folder that will contain the Codegen's specification file.

## 1. Define Specification for Codegen
Your specification must be defined in eitherTypeScriptorFlow(seeCodegendocumentation for more details). This is used by Codegen to generate the C++, Objective-C++ and Java to connect your platform code to the JavaScript runtime that React runs in.

The specification file must be named<MODULE_NAME>NativeComponent.{ts|js}to work with Codegen. The suffixNativeComponentis not only a convention, it is actually used by Codegen to detect a spec file.

Use this specification for our WebView Component:

- TypeScriptFlow
- Flow
```
import type {  CodegenTypes,  HostComponent,  ViewProps,} from 'react-native';import {codegenNativeComponent} from 'react-native';type WebViewScriptLoadedEvent = {  result: 'success' | 'error';};export interface NativeProps extends ViewProps {  sourceURL?: string;  onScriptLoaded?: CodegenTypes.BubblingEventHandler<WebViewScriptLoadedEvent> | null;}export default codegenNativeComponent<NativeProps>(  'CustomWebView',) as HostComponent<NativeProps>;
```

```
// @flow strict-localimport type {CodegenTypes, HostComponent, ViewProps} from 'react-native';import {codegenNativeComponent} from 'react-native';type WebViewScriptLoadedEvent = $ReadOnly<{|  result: "success" | "error",|}>;type NativeProps = $ReadOnly<{|  ...ViewProps,  sourceURL?: string;  onScriptLoaded?: CodegenTypes.BubblingEventHandler<WebViewScriptLoadedEvent>?;|}>;export default (codegenNativeComponent<NativeProps>(  'CustomWebView',): HostComponent<NativeProps>);
```

This specification is composed of three main parts, excluding the imports:

- TheWebViewScriptLoadedEventis a supporting data type for the data the event needs to pass from native to JavaScript.
- TheNativePropsis a definition of the props that we can set on the component.
- ThecodegenNativeComponentstatement allows us to codegenerate the code for the custom component and that defines a name for the component used to match the native implementations.
As with Native Modules, you can have multiple specification files in thespecs/directory. For more information about the types you can use, and the platform types these map to, see theappendix.


## 2. Configure Codegen to run
The specification is used by the React Native's Codegen tools to generate platform specific interfaces and boilerplate for us. To do this, Codegen needs to know where to find our specification and what to do with it. Update yourpackage.jsonto include:

```
    "start": "react-native start",    "test": "jest"  },  "codegenConfig": {    "name": "AppSpec",    "type": "components",    "jsSrcsDir": "specs",    "android": {      "javaPackageName": "com.webview"    },    "ios": {      "componentProvider": {        "CustomWebView": "RCTWebView"      }    }  },  "dependencies": {
```

With everything wired up for Codegen, we need to prepare our native code to hook into our generated code.

Note that for iOS, we are declaratively mapping the name of the JS component that is exported by the spec (CustomWebView) with the iOS class that will implement the component natively.


## 2. Building your Native Code
Now it's time to write the native platform code so that when React requires to render a view, the platform can create the right native view and can render it on screen.

You should work through both the Android and iOS platforms.

This guide shows you how to create a Native Component that only works with the New Architecture. If you need to support both the New Architecture and the Legacy Architecture, please refer to ourbackwards compatibility guide.

- AndroidiOS
- iOS
Now it's time to write some Android platform code to be able to render the web view. The steps you need to follow are:

- Running Codegen
- Write the code for theReactWebView
- Write the code for theReactWebViewManager
- Write the code for theReactWebViewPackage
- Register theReactWebViewPackagein the application

### 1. Run Codegen through Gradle
Run this once to generate boilerplate that your IDE of choice can use.

```
cd android./gradlew generateCodegenArtifactsFromSchema
```

Codegen will generate theViewManagerinterface you need to implement and theViewManagerdelegate for the web view.


### 2. Write theReactWebView
TheReactWebViewis the component that wraps the Android native view that React Native will render when using our custom Component.

Create aReactWebView.javaor aReactWebView.ktfile in theandroid/src/main/java/com/webviewfolder with this code:

- JavaKotlin
- Kotlin
```
package com.webview;import android.content.Context;import android.util.AttributeSet;import android.webkit.WebView;import android.webkit.WebViewClient;import com.facebook.react.bridge.Arguments;import com.facebook.react.bridge.WritableMap;import com.facebook.react.bridge.ReactContext;import com.facebook.react.uimanager.UIManagerHelper;import com.facebook.react.uimanager.events.Event;public class ReactWebView extends WebView {  public ReactWebView(Context context) {    super(context);    configureComponent();  }  public ReactWebView(Context context, AttributeSet attrs) {    super(context, attrs);    configureComponent();  }  public ReactWebView(Context context, AttributeSet attrs, int defStyleAttr) {    super(context, attrs, defStyleAttr);    configureComponent();  }  private void configureComponent() {    this.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));    this.setWebViewClient(new WebViewClient() {      @Override      public void onPageFinished(WebView view, String url) {        emitOnScriptLoaded(OnScriptLoadedEventResult.success);      }    });  }  public void emitOnScriptLoaded(OnScriptLoadedEventResult result) {    ReactContext reactContext = (ReactContext) context;    int surfaceId = UIManagerHelper.getSurfaceId(reactContext);    EventDispatcher eventDispatcher = UIManagerHelper.getEventDispatcherForReactTag(reactContext, getId());    WritableMap payload = Arguments.createMap();    payload.putString("result", result.name());    OnScriptLoadedEvent event = new OnScriptLoadedEvent(surfaceId, getId(), payload);    if (eventDispatcher != null) {      eventDispatcher.dispatchEvent(event);    }  }  public enum OnScriptLoadedEventResult {    success,    error  }  private class OnScriptLoadedEvent extends Event<OnScriptLoadedEvent> {    private final WritableMap payload;    OnScriptLoadedEvent(int surfaceId, int viewId, WritableMap payload) {      super(surfaceId, viewId);      this.payload = payload;    }    @Override    public String getEventName() {      return "onScriptLoaded";    }    @Override    public WritableMap getEventData() {      return payload;    }  }}
```

```
package com.webviewimport android.content.Contextimport android.util.AttributeSetimport android.webkit.WebViewimport android.webkit.WebViewClientimport com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.WritableMapimport com.facebook.react.bridge.ReactContextimport com.facebook.react.uimanager.UIManagerHelperimport com.facebook.react.uimanager.events.Eventclass ReactWebView: WebView {  constructor(context: Context) : super(context) {    configureComponent()  }  constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {    configureComponent()  }  constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {    configureComponent()  }  private fun configureComponent() {    this.layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT)    this.webViewClient = object : WebViewClient() {      override fun onPageFinished(view: WebView, url: String) {        emitOnScriptLoaded(OnScriptLoadedEventResult.success)      }    }  }  fun emitOnScriptLoaded(result: OnScriptLoadedEventResult) {    val reactContext = context as ReactContext    val surfaceId = UIManagerHelper.getSurfaceId(reactContext)    val eventDispatcher = UIManagerHelper.getEventDispatcherForReactTag(reactContext, id)    val payload =        Arguments.createMap().apply {          putString("result", result.name)        }    val event = OnScriptLoadedEvent(surfaceId, id, payload)    eventDispatcher?.dispatchEvent(event)  }  enum class OnScriptLoadedEventResult {    success,    error;  }  inner class OnScriptLoadedEvent(      surfaceId: Int,      viewId: Int,      private val payload: WritableMap  ) : Event<OnScriptLoadedEvent>(surfaceId, viewId) {    override fun getEventName() = "onScriptLoaded"    override fun getEventData() = payload  }}
```

TheReactWebViewextends the AndroidWebViewso you can reuse all the properties already defined by the platform with ease.

The class defines the three Android constructors but defers their actual implementation to the privateconfigureComponentfunction. This function takes care of initializing all the components specific properties: in this case you are setting the layout of theWebViewand you are defining theWebClientthat you use to customize the behavior of theWebView. In this code, theReactWebViewemits an event when the page finishes loading, by implementing theWebClient'sonPageFinishedmethod.

The code then defines a helper function to actually emit an event. To emit an event, you have to:

- grab a reference to theReactContext;
- retrieve thesurfaceIdof the view that you are presenting;
- grab a reference to theeventDispatcherassociated with the view;
- build the payload for the event using aWritableMapobject;
- create the event object that you need to send to JavaScript;
- call theeventDispatcher.dispatchEventto send the event.
The last part of the file contains the definition of the data types you need to send the event:

- TheOnScriptLoadedEventResult, with the possible outcomes of theOnScriptLoadedevent.
- The actualOnScriptLoadedEventthat needs to extend the React Native'sEventclass.

### 3. Write theWebViewManager
TheWebViewManageris the class that connects the React Native runtime with the native view.

When React receives the instruction from the app to render a specific component, React uses the registered view manager to create the view and to pass all the required properties.

This is the code of theReactWebViewManager.

- JavaKotlin
- Kotlin
```
package com.webview;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.annotations.ReactModule;import com.facebook.react.uimanager.SimpleViewManager;import com.facebook.react.uimanager.ThemedReactContext;import com.facebook.react.uimanager.ViewManagerDelegate;import com.facebook.react.uimanager.annotations.ReactProp;import com.facebook.react.viewmanagers.CustomWebViewManagerInterface;import com.facebook.react.viewmanagers.CustomWebViewManagerDelegate;import java.util.HashMap;import java.util.Map;@ReactModule(name = ReactWebViewManager.REACT_CLASS)class ReactWebViewManager extends SimpleViewManager<ReactWebView> implements CustomWebViewManagerInterface<ReactWebView> {  private final CustomWebViewManagerDelegate<ReactWebView, ReactWebViewManager> delegate =          new CustomWebViewManagerDelegate<>(this);  @Override  public ViewManagerDelegate<ReactWebView> getDelegate() {    return delegate;  }  @Override  public String getName() {    return REACT_CLASS;  }  @Override  public ReactWebView createViewInstance(ThemedReactContext context) {    return new ReactWebView(context);  }  @ReactProp(name = "sourceUrl")  @Override  public void setSourceURL(ReactWebView view, String sourceURL) {    if (sourceURL == null) {      view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error);      return;    }    view.loadUrl(sourceURL, new HashMap<>());  }  public static final String REACT_CLASS = "CustomWebView";  @Override  public Map<String, Object> getExportedCustomBubblingEventTypeConstants() {    Map<String, Object> map = new HashMap<>();    Map<String, Object> bubblingMap = new HashMap<>();    bubblingMap.put("phasedRegistrationNames", new HashMap<String, String>() {{      put("bubbled", "onScriptLoaded");      put("captured", "onScriptLoadedCapture");    }});    map.put("onScriptLoaded", bubblingMap);    return map;  }}
```

```
package com.webviewimport com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.annotations.ReactModule;import com.facebook.react.uimanager.SimpleViewManager;import com.facebook.react.uimanager.ThemedReactContext;import com.facebook.react.uimanager.ViewManagerDelegate;import com.facebook.react.uimanager.annotations.ReactProp;import com.facebook.react.viewmanagers.CustomWebViewManagerInterface;import com.facebook.react.viewmanagers.CustomWebViewManagerDelegate;@ReactModule(name = ReactWebViewManager.REACT_CLASS)class ReactWebViewManager(context: ReactApplicationContext) : SimpleViewManager<ReactWebView>(), CustomWebViewManagerInterface<ReactWebView> {  private val delegate: CustomWebViewManagerDelegate<ReactWebView, ReactWebViewManager> =    CustomWebViewManagerDelegate(this)  override fun getDelegate(): ViewManagerDelegate<ReactWebView> = delegate  override fun getName(): String = REACT_CLASS  override fun createViewInstance(context: ThemedReactContext): ReactWebView = ReactWebView(context)  @ReactProp(name = "sourceUrl")  override fun setSourceURL(view: ReactWebView, sourceURL: String?) {    if (sourceURL == null) {      view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error)      return;    }    view.loadUrl(sourceURL, emptyMap())  }  companion object {    const val REACT_CLASS = "CustomWebView"  }  override fun getExportedCustomBubblingEventTypeConstants(): Map<String, Any> =      mapOf(          "onScriptLoaded" to              mapOf(                  "phasedRegistrationNames" to                      mapOf(                          "bubbled" to "onScriptLoaded",                          "captured" to "onScriptLoadedCapture"                      )))}
```

TheReactWebViewManagerextends theSimpleViewManagerclass from React and implements theCustomWebViewManagerInterface, generated by Codegen.

It holds a reference of theCustomWebViewManagerDelegate, another element generated by Codegen.

It then overrides thegetNamefunction, which must return the same name used in the spec'scodegenNativeComponentfunction call.

ThecreateViewInstancefunction is responsible to instantiate a newReactWebView.

Then, the ViewManager needs to define how all the React's components props will update the native view. In the example, you need to decide how to handle thesourceURLproperty that React will set on theWebView.

Finally, if the component can emit an event, you need to map the event name by overriding thegetExportedCustomBubblingEventTypeConstantsfor bubbling events, or thegetExportedCustomDirectEventTypeConstantsfor direct events.


### 4. Write theReactWebViewPackage
As you do with Native Modules, Native Components also need to implement theReactPackageclass. This is an object that you can use to register the component in the React Native runtime.

This is the code for theReactWebViewPackage:

- JavaKotlin
- Kotlin
```
package com.webview;import com.facebook.react.BaseReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.model.ReactModuleInfo;import com.facebook.react.module.model.ReactModuleInfoProvider;import com.facebook.react.uimanager.ViewManager;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;public class ReactWebViewPackage extends BaseReactPackage {  @Override  public List<ViewManager<?, ?>> createViewManagers(ReactApplicationContext reactContext) {    return Collections.singletonList(new ReactWebViewManager(reactContext));  }  @Override  public NativeModule getModule(String s, ReactApplicationContext reactApplicationContext) {    if (ReactWebViewManager.REACT_CLASS.equals(s)) {      return new ReactWebViewManager(reactApplicationContext);    }    return null;  }  @Override  public ReactModuleInfoProvider getReactModuleInfoProvider() {    return new ReactModuleInfoProvider() {      @Override      public Map<String, ReactModuleInfo> getReactModuleInfos() {        Map<String, ReactModuleInfo> map = new HashMap<>();        map.put(ReactWebViewManager.REACT_CLASS, new ReactModuleInfo(                ReactWebViewManager.REACT_CLASS, // name                ReactWebViewManager.REACT_CLASS, // className                false,                           // canOverrideExistingModule                false,                           // needsEagerInit                false,                           // isCxxModule                true                             // isTurboModule        ));        return map;      }    };  }}
```

```
package com.webviewimport com.facebook.react.BaseReactPackageimport com.facebook.react.bridge.NativeModuleimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.module.model.ReactModuleInfoimport com.facebook.react.module.model.ReactModuleInfoProviderimport com.facebook.react.uimanager.ViewManagerclass ReactWebViewPackage : BaseReactPackage() {  override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {    return listOf(ReactWebViewManager(reactContext))  }  override fun getModule(s: String, reactApplicationContext: ReactApplicationContext): NativeModule? {    when (s) {      ReactWebViewManager.REACT_CLASS -> ReactWebViewManager(reactApplicationContext)    }    return null  }  override fun getReactModuleInfoProvider(): ReactModuleInfoProvider = ReactModuleInfoProvider {    mapOf(ReactWebViewManager.REACT_CLASS to ReactModuleInfo(      name = ReactWebViewManager.REACT_CLASS,      className = ReactWebViewManager.REACT_CLASS,      canOverrideExistingModule = false,      needsEagerInit = false,      isCxxModule = false,      isTurboModule = true,    )    )  }}
```

TheReactWebViewPackageextends theBaseReactPackageand implements all the methods required to properly register our component.

- thecreateViewManagersmethod is the factory method that creates theViewManagerthat manage the custom views.
- thegetModulemethod returns the proper ViewManager depending on the View that React Native needs to render.
- thegetReactModuleInfoProviderprovides all the information required when registering the module in the runtime,

### 5. Register theReactWebViewPackagein the application
Finally, you need to register theReactWebViewPackagein the application. We do that by modifying theMainApplicationfile by adding theReactWebViewPackageto the list of packages returned by thegetPackagesfunction.

```
package com.demoimport android.app.Applicationimport com.facebook.react.PackageListimport com.facebook.react.ReactApplicationimport com.facebook.react.ReactHostimport com.facebook.react.ReactNativeHostimport com.facebook.react.ReactPackageimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.loadimport com.facebook.react.defaults.DefaultReactHost.getDefaultReactHostimport com.facebook.react.defaults.DefaultReactNativeHostimport com.facebook.react.soloader.OpenSourceMergedSoMappingimport com.facebook.soloader.SoLoaderimport com.webview.ReactWebViewPackageclass MainApplication : Application(), ReactApplication {  override val reactNativeHost: ReactNativeHost =      object : DefaultReactNativeHost(this) {        override fun getPackages(): List<ReactPackage> =            PackageList(this).packages.apply {              add(ReactWebViewPackage())            }        override fun getJSMainModuleName(): String = "index"        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED      }  override val reactHost: ReactHost    get() = getDefaultReactHost(applicationContext, reactNativeHost)  override fun onCreate() {    super.onCreate()    SoLoader.init(this, OpenSourceMergedSoMapping)    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {      load()    }  }}
```

Now it's time to write some iOS platform code to be able to render the web view. The steps you need to follow are:

- Run Codegen.
- Write the code for theRCTWebView
- Register theRCTWebViewin the application

### 1. Run Codegen
You canmanually runthe Codegen, however it's simpler to use the application you're going to demo the component in to do this for you.

```
cd iosbundle installbundle exec pod install
```

Importantly you will see logging output from Codegen, which we're going to use in Xcode to build our WebView native component.

You should be careful about committing generated code to your repository. Generated code is specific to each version of React Native. Use npmpeerDependenciesto restrict compatibility with version of React Native.


### 3. Write theRCTWebView
We need to prepare your iOS project using Xcode by completing these5 steps:

- Open the CocoaPods generated Xcode Workspace:
```
cd iosopen Demo.xcworkspace
```

- Right click on app and selectNew Group, call the new groupWebView.
- In theWebViewgroup, createNew→File from Template.
- Use theObjective-C Filetemplate, and name itRCTWebView.
- Repeat step 4 and create a header file namedRCTWebView.h.
Repeat step 4 and create a header file namedRCTWebView.h.

- RenameRCTWebView.m→RCTWebView.mmmaking it an Objective-C++ file.
RenameRCTWebView.m→RCTWebView.mmmaking it an Objective-C++ file.

```
Podfile...Demo├── AppDelegate.swift...├── RCTWebView.h└── RCTWebView.mm
```

After creating the header file and the implementation file, you can start implementing them.

This is the code for theRCTWebView.hfile, which declares the component interface.

```
#import <React/RCTViewComponentView.h>#import <UIKit/UIKit.h>NS_ASSUME_NONNULL_BEGIN@interface RCTWebView : RCTViewComponentView// You would declare native methods you'd want to access from the view here@endNS_ASSUME_NONNULL_END
```

This class defines anRCTWebViewwhich extends theRCTViewComponentViewclass. This is the base class for all the native components and it is provided by React Native.

The code for the implementation file (RCTWebView.mm) is the following:

```
#import "RCTWebView.h"#import <react/renderer/components/AppSpec/ComponentDescriptors.h>#import <react/renderer/components/AppSpec/EventEmitters.h>#import <react/renderer/components/AppSpec/Props.h>#import <react/renderer/components/AppSpec/RCTComponentViewHelpers.h>#import <WebKit/WebKit.h>using namespace facebook::react;@interface RCTWebView () <RCTCustomWebViewViewProtocol, WKNavigationDelegate>@end@implementation RCTWebView {  NSURL * _sourceURL;  WKWebView * _webView;}-(instancetype)init{  if(self = [super init]) {    _webView = [WKWebView new];    _webView.navigationDelegate = self;    [self addSubview:_webView];  }  return self;}- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps{  const auto &oldViewProps = *std::static_pointer_cast<CustomWebViewProps const>(_props);  const auto &newViewProps = *std::static_pointer_cast<CustomWebViewProps const>(props);  // Handle your props here  if (oldViewProps.sourceURL != newViewProps.sourceURL) {    NSString *urlString = [NSString stringWithCString:newViewProps.sourceURL.c_str() encoding:NSUTF8StringEncoding];    _sourceURL = [NSURL URLWithString:urlString];    if ([self urlIsValid:newViewProps.sourceURL]) {      [_webView loadRequest:[NSURLRequest requestWithURL:_sourceURL]];    }  }  [super updateProps:props oldProps:oldProps];}-(void)layoutSubviews{  [super layoutSubviews];  _webView.frame = self.bounds;}#pragma mark - WKNavigationDelegate-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation{  CustomWebViewEventEmitter::OnScriptLoaded result = CustomWebViewEventEmitter::OnScriptLoaded{CustomWebViewEventEmitter::OnScriptLoadedResult::Success};  self.eventEmitter.onScriptLoaded(result);}- (BOOL)urlIsValid:(std::string)propString{  if (propString.length() > 0 && !_sourceURL) {    CustomWebViewEventEmitter::OnScriptLoaded result = CustomWebViewEventEmitter::OnScriptLoaded{CustomWebViewEventEmitter::OnScriptLoadedResult::Error};    self.eventEmitter.onScriptLoaded(result);    return NO;  }  return YES;}// Event emitter convenience method- (const CustomWebViewEventEmitter &)eventEmitter{  return static_cast<const CustomWebViewEventEmitter &>(*_eventEmitter);}+ (ComponentDescriptorProvider)componentDescriptorProvider{  return concreteComponentDescriptorProvider<CustomWebViewComponentDescriptor>();}@end
```

This code is written in Objective-C++ and contains various details:

- the@interfaceimplements two protocols:RCTCustomWebViewViewProtocol, generated by Codegen;WKNavigationDelegate, provided by the WebKit framework to handle the web view navigation events;
- RCTCustomWebViewViewProtocol, generated by Codegen;
- WKNavigationDelegate, provided by the WebKit framework to handle the web view navigation events;
- theinitmethod that instantiates theWKWebView, adds it to the subviews and that sets thenavigationDelegate;
- theupdatePropsmethod that is called by React Native when the component's props change;
- thelayoutSubviewsmethod that describes how the custom view needs to be laid out;
- thewebView:didFinishNavigation:method that lets you handle what to do when theWKWebViewfinishes loading the page;
- theurlIsValid:(std::string)propStringmethod that checks whether the URL received as prop is valid;
- theeventEmittermethod which is a utility to retrieve a strongly typedeventEmitterinstance
- thecomponentDescriptorProviderwhich returns theComponentDescriptorgenerated by Codegen;
This step is only required because we are creating a Web view. Web components on iOS needs to be linked against the WebKit framework provided by Apple. If your component doesn't need to access web-specific features, you can skip this step.

A web view requires access to some features that Apple provides through one of the frameworks shipped with Xcode and the devices: WebKit.
You can see it in the native code by the#import <WebKit/WebKit.h>line added in theRCTWebView.mm.

To link the WebKit framework in your app, follow these steps:

- In Xcode, Click on your project
- Select the app target
- Select the General tab
- Scroll down until you find the"Frameworks, Libraries, and Embedded Contents"section, and press the+button
- In the search bar, filter for WebKit
- Select the WebKit framework
- Click on Add.

## 3. Use your Native Component
Finally, you can use the new component in your app. Update your generatedApp.tsxto:

```
import React from 'react';import {Alert, StyleSheet, View} from 'react-native';import WebView from './specs/WebViewNativeComponent';function App(): React.JSX.Element {  return (    <View style={styles.container}>      <WebView        sourceURL="https://react.dev/"        style={styles.webview}        onScriptLoaded={() => {          Alert.alert('Page Loaded');        }}      />    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    alignItems: 'center',    alignContent: 'center',  },  webview: {    width: '100%',    height: '100%',  },});export default App;
```

This code creates an app that uses the newWebViewcomponent we created to load thereact.devwebsite.

The app also shows an alert when the web page is loaded.


## 4. Run your App using the WebView Component
- AndroidiOS
- iOS
```
yarn run android
```

```
yarn run ios
```


================================================================================


# Fabric Native Components: iOS
Source: https://reactnative.dev/docs/fabric-native-components-ios

Now it's time to write some iOS platform code to be able to render the web view. The steps you need to follow are:

- Run Codegen.
- Write the code for theRCTWebView
- Register theRCTWebViewin the application

### 1. Run Codegen
You canmanually runthe Codegen, however it's simpler to use the application you're going to demo the component in to do this for you.

```
cd iosbundle installbundle exec pod install
```

Importantly you will see logging output from Codegen, which we're going to use in Xcode to build our WebView native component.

You should be careful about committing generated code to your repository. Generated code is specific to each version of React Native. Use npmpeerDependenciesto restrict compatibility with version of React Native.


### 3. Write theRCTWebView
We need to prepare your iOS project using Xcode by completing these5 steps:

- Open the CocoaPods generated Xcode Workspace:
```
cd iosopen Demo.xcworkspace
```

- Right click on app and selectNew Group, call the new groupWebView.
- In theWebViewgroup, createNew→File from Template.
- Use theObjective-C Filetemplate, and name itRCTWebView.
- Repeat step 4 and create a header file namedRCTWebView.h.
Repeat step 4 and create a header file namedRCTWebView.h.

- RenameRCTWebView.m→RCTWebView.mmmaking it an Objective-C++ file.
RenameRCTWebView.m→RCTWebView.mmmaking it an Objective-C++ file.

```
Podfile...Demo├── AppDelegate.swift...├── RCTWebView.h└── RCTWebView.mm
```

After creating the header file and the implementation file, you can start implementing them.

This is the code for theRCTWebView.hfile, which declares the component interface.

```
#import <React/RCTViewComponentView.h>#import <UIKit/UIKit.h>NS_ASSUME_NONNULL_BEGIN@interface RCTWebView : RCTViewComponentView// You would declare native methods you'd want to access from the view here@endNS_ASSUME_NONNULL_END
```

This class defines anRCTWebViewwhich extends theRCTViewComponentViewclass. This is the base class for all the native components and it is provided by React Native.

The code for the implementation file (RCTWebView.mm) is the following:

```
#import "RCTWebView.h"#import <react/renderer/components/AppSpec/ComponentDescriptors.h>#import <react/renderer/components/AppSpec/EventEmitters.h>#import <react/renderer/components/AppSpec/Props.h>#import <react/renderer/components/AppSpec/RCTComponentViewHelpers.h>#import <WebKit/WebKit.h>using namespace facebook::react;@interface RCTWebView () <RCTCustomWebViewViewProtocol, WKNavigationDelegate>@end@implementation RCTWebView {  NSURL * _sourceURL;  WKWebView * _webView;}-(instancetype)init{  if(self = [super init]) {    _webView = [WKWebView new];    _webView.navigationDelegate = self;    [self addSubview:_webView];  }  return self;}- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps{  const auto &oldViewProps = *std::static_pointer_cast<CustomWebViewProps const>(_props);  const auto &newViewProps = *std::static_pointer_cast<CustomWebViewProps const>(props);  // Handle your props here  if (oldViewProps.sourceURL != newViewProps.sourceURL) {    NSString *urlString = [NSString stringWithCString:newViewProps.sourceURL.c_str() encoding:NSUTF8StringEncoding];    _sourceURL = [NSURL URLWithString:urlString];    if ([self urlIsValid:newViewProps.sourceURL]) {      [_webView loadRequest:[NSURLRequest requestWithURL:_sourceURL]];    }  }  [super updateProps:props oldProps:oldProps];}-(void)layoutSubviews{  [super layoutSubviews];  _webView.frame = self.bounds;}#pragma mark - WKNavigationDelegate-(void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation{  CustomWebViewEventEmitter::OnScriptLoaded result = CustomWebViewEventEmitter::OnScriptLoaded{CustomWebViewEventEmitter::OnScriptLoadedResult::Success};  self.eventEmitter.onScriptLoaded(result);}- (BOOL)urlIsValid:(std::string)propString{  if (propString.length() > 0 && !_sourceURL) {    CustomWebViewEventEmitter::OnScriptLoaded result = CustomWebViewEventEmitter::OnScriptLoaded{CustomWebViewEventEmitter::OnScriptLoadedResult::Error};    self.eventEmitter.onScriptLoaded(result);    return NO;  }  return YES;}// Event emitter convenience method- (const CustomWebViewEventEmitter &)eventEmitter{  return static_cast<const CustomWebViewEventEmitter &>(*_eventEmitter);}+ (ComponentDescriptorProvider)componentDescriptorProvider{  return concreteComponentDescriptorProvider<CustomWebViewComponentDescriptor>();}@end
```

This code is written in Objective-C++ and contains various details:

- the@interfaceimplements two protocols:RCTCustomWebViewViewProtocol, generated by Codegen;WKNavigationDelegate, provided by the WebKit framework to handle the web view navigation events;
- RCTCustomWebViewViewProtocol, generated by Codegen;
- WKNavigationDelegate, provided by the WebKit framework to handle the web view navigation events;
- theinitmethod that instantiates theWKWebView, adds it to the subviews and that sets thenavigationDelegate;
- theupdatePropsmethod that is called by React Native when the component's props change;
- thelayoutSubviewsmethod that describes how the custom view needs to be laid out;
- thewebView:didFinishNavigation:method that lets you handle what to do when theWKWebViewfinishes loading the page;
- theurlIsValid:(std::string)propStringmethod that checks whether the URL received as prop is valid;
- theeventEmittermethod which is a utility to retrieve a strongly typedeventEmitterinstance
- thecomponentDescriptorProviderwhich returns theComponentDescriptorgenerated by Codegen;
This step is only required because we are creating a Web view. Web components on iOS needs to be linked against the WebKit framework provided by Apple. If your component doesn't need to access web-specific features, you can skip this step.

A web view requires access to some features that Apple provides through one of the frameworks shipped with Xcode and the devices: WebKit.
You can see it in the native code by the#import <WebKit/WebKit.h>line added in theRCTWebView.mm.

To link the WebKit framework in your app, follow these steps:

- In Xcode, Click on your project
- Select the app target
- Select the General tab
- Scroll down until you find the"Frameworks, Libraries, and Embedded Contents"section, and press the+button
- In the search bar, filter for WebKit
- Select the WebKit framework
- Click on Add.

================================================================================


# Fast Refresh
Source: https://reactnative.dev/docs/fast-refresh

Fast Refresh is a React Native feature that allows you to get near-instant feedback for changes in your React components. Fast Refresh is enabled by default, and you can toggle "Enable Fast Refresh" in theReact Native Dev Menu. With Fast Refresh enabled, most edits should be visible within a second or two.


## How It Works
- If you edit a module thatonly exports React component(s), Fast Refresh will update the code only for that module, and re-render your component. You can edit anything in that file, including styles, rendering logic, event handlers, or effects.
- If you edit a module with exports thataren'tReact components, Fast Refresh will re-run both that module, and the other modules importing it. So if bothButton.jsandModal.jsimportTheme.js, editingTheme.jswill update both components.
- Finally, if youedit a filethat'simported by modules outside of the React tree, Fast Refreshwill fall back to doing a full reload. You might have a file which renders a React component but also exports a value that is imported by anon-React component. For example, maybe your component also exports a constant, and a non-React utility module imports it. In that case, consider migrating the constant to a separate file and importing it into both files. This will re-enable Fast Refresh to work. Other cases can usually be solved in a similar way.

## Error Resilience
If you make asyntax errorduring a Fast Refresh session, you can fix it and save the file again. The redbox will disappear. Modules with syntax errors are prevented from running, so you won't need to reload the app.

If you make aruntime error during the module initialization(for example, typingStyle.createinstead ofStyleSheet.create), the Fast Refresh session will continue once you fix the error. The redbox will disappear, and the module will be updated.

If you make a mistake that leads to aruntime error inside your component, the Fast Refresh session willalsocontinue after you fix the error. In that case, React will remount your application using the updated code.

If you haveerror boundariesin your app (which is a good idea for graceful failures in production), they will retry rendering on the next edit after a redbox. In that sense, having an error boundary can prevent you from always getting kicked out to the root app screen. However, keep in mind that error boundaries shouldn't betoogranular. They are used by React in production, and should always be designed intentionally.


## Limitations
Fast Refresh tries to preserve local React state in the component you're editing, but only if it's safe to do so. Here's a few reasons why you might see local state being reset on every edit to a file:

- Local state is not preserved for class components (only function components and Hooks preserve state).
- The module you're editing might haveotherexports in addition to a React component.
- Sometimes, a module would export the result of calling higher-order component likecreateNavigationContainer(MyScreen). If the returned component is a class, state will be reset.
In the longer term, as more of your codebase moves to function components and Hooks, you can expect state to be preserved in more cases.


## Tips
- Fast Refresh preserves React local state in function components (and Hooks) by default.
- Sometimes you might want toforcethe state to be reset, and a component to be remounted. For example, this can be handy if you're tweaking an animation that only happens on mount. To do this, you can add// @refresh resetanywhere in the file you're editing. This directive is local to the file, and instructs Fast Refresh to remount components defined in that file on every edit.

## Fast Refresh and Hooks
When possible, Fast Refresh attempts to preserve the state of your component between edits. In particular,useStateanduseRefpreserve their previous values as long as you don't change their arguments or the order of the Hook calls.

Hooks with dependencies—such asuseEffect,useMemo, anduseCallback—willalwaysupdate during Fast Refresh. Their list of dependencies will be ignored while Fast Refresh is happening.

For example, when you edituseMemo(() => x * 2, [x])touseMemo(() => x * 10, [x]), it will re-run even thoughx(the dependency) has not changed. If React didn't do that, your edit wouldn't reflect on the screen!

Sometimes, this can lead to unexpected results. For example, even auseEffectwith an empty array of dependencies would still re-run once during Fast Refresh. However, writing code resilient to an occasional re-running ofuseEffectis a good practice even without Fast Refresh. This makes it easier for you to later introduce new dependencies to it.


================================================================================


# FlatList
Source: https://reactnative.dev/docs/flatlist

A performant interface for rendering basic, flat lists, supporting the most handy features:

- Fully cross-platform.
- Optional horizontal mode.
- Configurable viewability callbacks.
- Header support.
- Footer support.
- Separator support.
- Pull to Refresh.
- Scroll loading.
- ScrollToIndex support.
- Multiple column support.
If you need section support, use<SectionList>.


## Example
- TypeScriptJavaScript
- JavaScript
To render multiple columns, use thenumColumnsprop. Using this approach instead of aflexWraplayout can prevent conflicts with the item height logic.

More complex, selectable example below.

- By passingextraData={selectedId}toFlatListwe make sureFlatListitself will re-render when the state changes. Without setting this prop,FlatListwould not know it needs to re-render any items because it is aPureComponentand the prop comparison will not show any changes.
- keyExtractortells the list to use theids for the react keys instead of the defaultkeyproperty.
- TypeScriptJavaScript
- JavaScript
This is a convenience wrapper around<VirtualizedList>, and thus inherits its props (as well as those of<ScrollView>) that aren't explicitly listed here, along with the following caveats:

- Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.
- This is aPureComponentwhich means that it will not re-render ifpropsremain shallow-equal. Make sure that everything yourrenderItemfunction depends on is passed as a prop (e.g.extraData) that is not===after updates, otherwise your UI may not update on changes. This includes thedataprop and parent component state.
- In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate and momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.
- By default, the list looks for akeyprop on each item and uses that for the React key. Alternatively, you can provide a customkeyExtractorprop.

## Props

### VirtualizedList Props
InheritsVirtualizedList Props.


### RequiredrenderItem
```
renderItem({  item: ItemT,  index: number,  separators: {    highlight: () => void;    unhighlight: () => void;    updateProps: (select: 'leading' | 'trailing', newProps: any) => void;  }}): JSX.Element;
```

Takes an item fromdataand renders it into the list.

Provides additional metadata likeindexif you need it, as well as a more genericseparators.updatePropsfunction which let you set whatever props you want to change the rendering of either the leading separator or trailing separator in case the more commonhighlightandunhighlight(which set thehighlighted: booleanprop) are insufficient for your use case.

- item(Object): The item fromdatabeing rendered.
- index(number): The index corresponding to this item in thedataarray.
- separators(Object)highlight(Function)unhighlight(Function)updateProps(Function)select(enum('leading', 'trailing'))newProps(Object)
- highlight(Function)
- unhighlight(Function)
- updateProps(Function)select(enum('leading', 'trailing'))newProps(Object)
- select(enum('leading', 'trailing'))
- newProps(Object)
Example usage:

```
<FlatList  ItemSeparatorComponent={    Platform.OS !== 'android' &&    (({highlighted}) => (      <View        style={[style.separator, highlighted && {marginLeft: 0}]}      />    ))  }  data={[{title: 'Title Text', key: 'item1'}]}  renderItem={({item, index, separators}) => (    <TouchableHighlight      key={item.key}      onPress={() => this._onPress(item)}      onShowUnderlay={separators.highlight}      onHideUnderlay={separators.unhighlight}>      <View style={{backgroundColor: 'white'}}>        <Text>{item.title}</Text>      </View>    </TouchableHighlight>  )}/>
```


### Requireddata
An array (or array-like list) of items to render. Other data types can be used by targetingVirtualizedListdirectly.


### ItemSeparatorComponent
Rendered in between each item, but not at the top or bottom. By default,highlightedandleadingItemprops are provided.renderItemprovidesseparators.highlight/unhighlightwhich will update thehighlightedprop, but you can also add custom props withseparators.updateProps. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListEmptyComponent
Rendered when the list is empty. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListFooterComponent
Rendered at the bottom of all the items. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListFooterComponentStyle
Styling for internal View forListFooterComponent.


### ListHeaderComponent
Rendered at the top of all the items. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListHeaderComponentStyle
Styling for internal View forListHeaderComponent.


### columnWrapperStyle
Optional custom style for multi-item rows generated whennumColumns > 1.


### extraData
A marker property for telling the list to re-render (since it implementsPureComponent). If any of yourrenderItem, Header, Footer, etc. functions depend on anything outside of thedataprop, stick it here and treat it immutably.


### getItemLayout
```
(data, index) => {length: number, offset: number, index: number}
```

getItemLayoutis an optional optimization that allows skipping the measurement of dynamic content if you know the size (height or width) of items ahead of time.getItemLayoutis efficient if you have fixed size items, for example:

```
  getItemLayout={(data, index) => (    {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}  )}
```

AddinggetItemLayoutcan be a great performance boost for lists of several hundred items. Remember to include separator length (height or width) in your offset calculation if you specifyItemSeparatorComponent.


### horizontal
Iftrue, renders items next to each other horizontally instead of stacked vertically.


### initialNumToRender
How many items to render in the initial batch. This should be enough to fill the screen but not much more. Note these items will never be unmounted as part of the windowed rendering in order to improve perceived performance of scroll-to-top actions.


### initialScrollIndex
Instead of starting at the top with the first item, start atinitialScrollIndex. This disables the "scroll to top" optimization that keeps the firstinitialNumToRenderitems always rendered and immediately renders the items starting at this initial index. RequiresgetItemLayoutto be implemented.


### inverted
Reverses the direction of scroll. Uses scale transforms of-1.


### keyExtractor
```
(item: ItemT, index: number) => string;
```

Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checksitem.key, thenitem.id, and then falls back to using the index, like React does.


### numColumns
Multiple columns can only be rendered withhorizontal={false}and will zig-zag like aflexWraplayout. Items should all be the same height - masonry layouts are not supported.


### onRefresh
```
() => void;
```

If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality. Make sure to also set therefreshingprop correctly.


### onViewableItemsChanged
Called when the viewability of rows changes, as defined by theviewabilityConfigprop.


### progressViewOffset
Set this when offset is needed for the loading indicator to show correctly.


### refreshing
Set this true while waiting for new data from a refresh.


### removeClippedSubviews
Using this property may lead to bugs (missing content) in some circumstances - use at your own risk.

Whentrue, offscreen child views are removed from their native backing superview when offscreen. This may improve scroll performance for large lists. On Android the default value istrue.


### viewabilityConfig
SeeViewabilityHelper.jsfor flow type and further documentation.

viewabilityConfigtakes a typeViewabilityConfigan object with following properties

At least one of theviewAreaCoveragePercentThresholdoritemVisiblePercentThresholdis required. This needs to be done in theconstructorto avoid following error (ref):

```
  Error: Changing viewabilityConfig on the fly is not supported
```

```
constructor (props) {  super(props)  this.viewabilityConfig = {      waitForInteraction: true,      viewAreaCoveragePercentThreshold: 95  }}
```

```
<FlatList    viewabilityConfig={this.viewabilityConfig}  ...
```

Minimum amount of time (in milliseconds) that an item must be physically viewable before the viewability callback will be fired. A high number means that scrolling through content without stopping will not mark the content as viewable.

Percent of viewport that must be covered for a partially occluded item to count as "viewable", 0-100. Fully visible items are always considered viewable. A value of 0 means that a single pixel in the viewport makes the item viewable, and a value of 100 means that an item must be either entirely visible or cover the entire viewport to count as viewable.

Similar toviewAreaCoveragePercentThreshold, but considers the percent of the item that is visible, rather than the fraction of the viewable area it covers.

Nothing is considered viewable until the user scrolls orrecordInteractionis called after render.


### viewabilityConfigCallbackPairs
List ofViewabilityConfig/onViewableItemsChangedpairs. A specificonViewableItemsChangedwill be called when its correspondingViewabilityConfig's conditions are met. SeeViewabilityHelper.jsfor flow type and further documentation.


## Methods

### flashScrollIndicators()
```
flashScrollIndicators();
```

Displays the scroll indicators momentarily.


### getNativeScrollRef()
```
getNativeScrollRef(): React.ElementRef<typeof ScrollViewComponent>;
```

Provides a reference to the underlying scroll component


### getScrollResponder()
```
getScrollResponder(): ScrollResponderMixin;
```

Provides a handle to the underlying scroll responder.


### getScrollableNode()
```
getScrollableNode(): any;
```

Provides a handle to the underlying scroll node.


### scrollToEnd()
```
scrollToEnd(params?: {animated?: boolean});
```

Scrolls to the end of the content. May be janky withoutgetItemLayoutprop.

Parameters:

Validparamskeys are:

- 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults totrue.

### scrollToIndex()
```
scrollToIndex: (params: {  index: number;  animated?: boolean;  viewOffset?: number;  viewPosition?: number;});
```

Scrolls to the item at the specified index such that it is positioned in the viewable area such thatviewPosition0 places it at the top, 1 at the bottom, and 0.5 centered in the middle.

Cannot scroll to locations outside the render window without specifying thegetItemLayoutprop.

Parameters:

Validparamskeys are:

- 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults totrue.
- 'index' (number) - The index to scroll to. Required.
- 'viewOffset' (number) - A fixed number of pixels to offset the final target position.
- 'viewPosition' (number) - A value of0places the item specified by index at the top,1at the bottom, and0.5centered in the middle.

### scrollToItem()
```
scrollToItem(params: {  animated?: ?boolean,  item: Item,  viewPosition?: number,});
```

Requires linear scan through data - usescrollToIndexinstead if possible.

Cannot scroll to locations outside the render window without specifying thegetItemLayoutprop.

Parameters:

Validparamskeys are:

- 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults totrue.
- 'item' (object) - The item to scroll to. Required.
- 'viewPosition' (number)

### scrollToOffset()
```
scrollToOffset(params: {  offset: number;  animated?: boolean;});
```

Scroll to a specific content pixel offset in the list.

Parameters:

Validparamskeys are:

- 'offset' (number) - The offset to scroll to. In case ofhorizontalbeing true, the offset is the x-value, in any other case the offset is the y-value. Required.
- 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults totrue.

================================================================================


# Layout with Flexbox
Source: https://reactnative.dev/docs/flexbox

A component can specify the layout of its children using the Flexbox algorithm. Flexbox is designed to provide a consistent layout on different screen sizes.

You will normally use a combination offlexDirection,alignItems, andjustifyContentto achieve the right layout.

Flexbox works the same way in React Native as it does in CSS on the web, with a few exceptions.
The defaults are different, withflexDirectiondefaulting tocolumninstead ofrow,alignContentdefaulting toflex-startinstead ofstretch,flexShrinkdefaulting to0instead of1, theflexparameter only supporting a single number.


## Flex
flexwill define how your items are going to“fill”over the available space along your main axis. Space will be divided according to each element's flex property.

In the following example, the red, orange, and green views are all children in the container view that hasflex: 1set. The red view usesflex: 1, the orange view usesflex: 2, and the green view usesflex: 3.1+2+3 = 6, which means that the red view will get1/6of the space, the orange2/6of the space, and the green3/6of the space.


## Flex Direction
flexDirectioncontrols the direction in which the children of a node are laid out. This is also referred to as the main axis. The cross axis is the axis perpendicular to the main axis, or the axis which the wrapping lines are laid out in.

- column(default value) Align children from top to bottom. If wrapping is enabled, then the next line will start to the right of the first item on the top of the container.
column(default value) Align children from top to bottom. If wrapping is enabled, then the next line will start to the right of the first item on the top of the container.

- rowAlign children from left to right. If wrapping is enabled, then the next line will start under the first item on the left of the container.
rowAlign children from left to right. If wrapping is enabled, then the next line will start under the first item on the left of the container.

- column-reverseAlign children from bottom to top. If wrapping is enabled, then the next line will start to the right of the first item on the bottom of the container.
column-reverseAlign children from bottom to top. If wrapping is enabled, then the next line will start to the right of the first item on the bottom of the container.

- row-reverseAlign children from right to left. If wrapping is enabled, then the next line will start under the first item on the right of the container.
row-reverseAlign children from right to left. If wrapping is enabled, then the next line will start under the first item on the right of the container.

You can learn morehere.

- TypeScriptJavaScript
- JavaScript

## Layout Direction
Layoutdirectionspecifies the direction in which children and text in a hierarchy should be laid out. Layout direction also affects what edgestartandendrefer to. By default, React Native lays out with LTR layout direction. In this modestartrefers to left andendrefers to right.

- LTR(default value) Text and children are laid out from left to right. Margin and padding applied to the start of an element are applied on the left side.
LTR(default value) Text and children are laid out from left to right. Margin and padding applied to the start of an element are applied on the left side.

- RTLText and children are laid out from right to left. Margin and padding applied to the start of an element are applied on the right side.
RTLText and children are laid out from right to left. Margin and padding applied to the start of an element are applied on the right side.

- TypeScriptJavaScript
- JavaScript

## Justify Content
justifyContentdescribes how to align children within the main axis of their container. For example, you can use this property to center a child horizontally within a container withflexDirectionset torowor vertically within a container withflexDirectionset tocolumn.

- flex-start(default value) Align children of a container to the start of the container's main axis.
flex-start(default value) Align children of a container to the start of the container's main axis.

- flex-endAlign children of a container to the end of the container's main axis.
flex-endAlign children of a container to the end of the container's main axis.

- centerAlign children of a container in the center of the container's main axis.
centerAlign children of a container in the center of the container's main axis.

- space-betweenEvenly space off children across the container's main axis, distributing the remaining space between the children.
space-betweenEvenly space off children across the container's main axis, distributing the remaining space between the children.

- space-aroundEvenly space off children across the container's main axis, distributing the remaining space around the children. Compared tospace-between, usingspace-aroundwill result in space being distributed to the beginning of the first child and end of the last child.
space-aroundEvenly space off children across the container's main axis, distributing the remaining space around the children. Compared tospace-between, usingspace-aroundwill result in space being distributed to the beginning of the first child and end of the last child.

- space-evenlyEvenly distribute children within the alignment container along the main axis. The spacing between each pair of adjacent items, the main-start edge and the first item, and the main-end edge and the last item, are all exactly the same.
space-evenlyEvenly distribute children within the alignment container along the main axis. The spacing between each pair of adjacent items, the main-start edge and the first item, and the main-end edge and the last item, are all exactly the same.

You can learn morehere.

- TypeScriptJavaScript
- JavaScript

## Align Items
alignItemsdescribes how to align children along the cross axis of their container. It is very similar tojustifyContentbut instead of applying to the main axis,alignItemsapplies to the cross axis.

- stretch(default value) Stretch children of a container to match theheightof the container's cross axis.
stretch(default value) Stretch children of a container to match theheightof the container's cross axis.

- flex-startAlign children of a container to the start of the container's cross axis.
flex-startAlign children of a container to the start of the container's cross axis.

- flex-endAlign children of a container to the end of the container's cross axis.
flex-endAlign children of a container to the end of the container's cross axis.

- centerAlign children of a container in the center of the container's cross axis.
centerAlign children of a container in the center of the container's cross axis.

- baselineAlign children of a container along a common baseline. Individual children can be set to be the reference baseline for their parents.
baselineAlign children of a container along a common baseline. Individual children can be set to be the reference baseline for their parents.

Forstretchto have an effect, children must not have a fixed dimension along the secondary axis. In the following example, settingalignItems: stretchdoes nothing until thewidth: 50is removed from the children.

You can learn morehere.

- TypeScriptJavaScript
- JavaScript

## Align Self
alignSelfhas the same options and effect asalignItemsbut instead of affecting the children within a container, you can apply this property to a single child to change its alignment within its parent.alignSelfoverrides any option set by the parent withalignItems.

- TypeScriptJavaScript
- JavaScript

## Align Content
alignContentdefines the distribution of lines along the cross-axis. This only has effect when items are wrapped to multiple lines usingflexWrap.

- flex-start(default value) Align wrapped lines to the start of the container's cross axis.
flex-start(default value) Align wrapped lines to the start of the container's cross axis.

- flex-endAlign wrapped lines to the end of the container's cross axis.
flex-endAlign wrapped lines to the end of the container's cross axis.

- stretch(default value when using Yoga on the web) Stretch wrapped lines to match the height of the container's cross axis.
stretch(default value when using Yoga on the web) Stretch wrapped lines to match the height of the container's cross axis.

- centerAlign wrapped lines in the center of the container's cross axis.
centerAlign wrapped lines in the center of the container's cross axis.

- space-betweenEvenly space wrapped lines across the container's cross axis, distributing the remaining space between the lines.
space-betweenEvenly space wrapped lines across the container's cross axis, distributing the remaining space between the lines.

- space-aroundEvenly space wrapped lines across the container's cross axis, distributing the remaining space around the lines. Each end of the container has a half-sized space compared to the space between items.
space-aroundEvenly space wrapped lines across the container's cross axis, distributing the remaining space around the lines. Each end of the container has a half-sized space compared to the space between items.

- space-evenlyEvenly space wrapped lines across the container's cross axis, distributing the remaining space around the lines. Each space is the same size.
space-evenlyEvenly space wrapped lines across the container's cross axis, distributing the remaining space around the lines. Each space is the same size.

You can learn morehere.

- TypeScriptJavaScript
- JavaScript

## Flex Wrap
TheflexWrapproperty is set on containers and it controls what happens when children overflow the size of the container along the main axis. By default, children are forced into a single line (which can shrink elements). If wrapping is allowed, items are wrapped into multiple lines along the main axis if needed.

When wrapping lines,alignContentcan be used to specify how the lines are placed in the container. Learn morehere.

- TypeScriptJavaScript
- JavaScript

## Flex Basis, Grow, and Shrink
- flexBasisis an axis-independent way of providing the default size of an item along the main axis. Setting theflexBasisof a child is similar to setting thewidthof that child if its parent is a container withflexDirection: rowor setting theheightof a child if its parent is a container withflexDirection: column. TheflexBasisof an item is the default size of that item, the size of the item before anyflexGrowandflexShrinkcalculations are performed.
flexBasisis an axis-independent way of providing the default size of an item along the main axis. Setting theflexBasisof a child is similar to setting thewidthof that child if its parent is a container withflexDirection: rowor setting theheightof a child if its parent is a container withflexDirection: column. TheflexBasisof an item is the default size of that item, the size of the item before anyflexGrowandflexShrinkcalculations are performed.

- flexGrowdescribes how much space within a container should be distributed among its children along the main axis. After laying out its children, a container will distribute any remaining space according to the flex grow values specified by its children.flexGrowaccepts any floating point value >= 0, with 0 being the default value. A container will distribute any remaining space among its children weighted by the children’sflexGrowvalues.
flexGrowdescribes how much space within a container should be distributed among its children along the main axis. After laying out its children, a container will distribute any remaining space according to the flex grow values specified by its children.

flexGrowaccepts any floating point value >= 0, with 0 being the default value. A container will distribute any remaining space among its children weighted by the children’sflexGrowvalues.

- flexShrinkdescribes how to shrink children along the main axis in the case in which the total size of the children overflows the size of the container on the main axis.flexShrinkis very similar toflexGrowand can be thought of in the same way if any overflowing size is considered to be negative remaining space. These two properties also work well together by allowing children to grow and shrink as needed.flexShrinkaccepts any floating point value >= 0, with 0 being the default value (on the web, the default is 1). A container will shrink its children weighted by the children’sflexShrinkvalues.
flexShrinkdescribes how to shrink children along the main axis in the case in which the total size of the children overflows the size of the container on the main axis.flexShrinkis very similar toflexGrowand can be thought of in the same way if any overflowing size is considered to be negative remaining space. These two properties also work well together by allowing children to grow and shrink as needed.

flexShrinkaccepts any floating point value >= 0, with 0 being the default value (on the web, the default is 1). A container will shrink its children weighted by the children’sflexShrinkvalues.

You can learn morehere.

- TypeScriptJavaScript
- JavaScript

## Row Gap, Column Gap and Gap
- rowGapsets the size of the gap (gutter) between an element's rows.
rowGapsets the size of the gap (gutter) between an element's rows.

- columnGapsets the size of the gap (gutter) between an element's columns.
columnGapsets the size of the gap (gutter) between an element's columns.

- gapsets the size of the gap (gutter) between rows and columns. It is a shorthand forrowGapandcolumnGap.
gapsets the size of the gap (gutter) between rows and columns. It is a shorthand forrowGapandcolumnGap.

You can useflexWrapandalignContentalong withgapto add consistent spacing between items.

- TypeScriptJavaScript
- JavaScript

## Width and Height
Thewidthproperty specifies the width of an element's content area. Similarly, theheightproperty specifies the height of an element's content area.

Bothwidthandheightcan take the following values:

- auto(default value) React Native calculates the width/height for the element based on its content, whether that is other children, text, or an image.
auto(default value) React Native calculates the width/height for the element based on its content, whether that is other children, text, or an image.

- pixelsDefines the width/height in absolute pixels. Depending on other styles set on the component, this may or may not be the final dimension of the node.
pixelsDefines the width/height in absolute pixels. Depending on other styles set on the component, this may or may not be the final dimension of the node.

- percentageDefines the width or height in percentage of its parent's width or height, respectively.
percentageDefines the width or height in percentage of its parent's width or height, respectively.

- TypeScriptJavaScript
- JavaScript

## Position
Thepositiontype of an element defines how it is positioned relative to either itself, its parent, or itscontaining block.

- relative(default value) By default, an element is positioned relatively. This means an element is positioned according to the normal flow of the layout, and then offset relative to that position based on the values oftop,right,bottom, andleft. The offset does not affect the position of any sibling or parent elements.
relative(default value) By default, an element is positioned relatively. This means an element is positioned according to the normal flow of the layout, and then offset relative to that position based on the values oftop,right,bottom, andleft. The offset does not affect the position of any sibling or parent elements.

- absoluteWhen positioned absolutely, an element doesn't take part in the normal layout flow. It is instead laid out independent of its siblings. The position is determined based on thetop,right,bottom, andleftvalues. These values will position the element relative to its containing block.
absoluteWhen positioned absolutely, an element doesn't take part in the normal layout flow. It is instead laid out independent of its siblings. The position is determined based on thetop,right,bottom, andleftvalues. These values will position the element relative to its containing block.

- staticWhen positioned statically, an element is positioned according to the normal flow of layout, and will ignore thetop,right,bottom, andleftvalues. Thispositionwill also cause the element to not form a containing block for absolute descendants, unless some other superceding style prop is present (e.g.transform). This allowsabsoluteelements to be positioned to something that is not their parent. Note thatstaticis only available on the New Architecture.
staticWhen positioned statically, an element is positioned according to the normal flow of layout, and will ignore thetop,right,bottom, andleftvalues. Thispositionwill also cause the element to not form a containing block for absolute descendants, unless some other superceding style prop is present (e.g.transform). This allowsabsoluteelements to be positioned to something that is not their parent. Note thatstaticis only available on the New Architecture.

- TypeScriptJavaScript
- JavaScript

## The Containing Block
The containing block of an element is an ancestor element which controls its position and size.
The way containing blocks work in React Native is very similar tohow they work on the web, with some simplifications due to the lack of some web features.

Thetop,right,bottom, andleftvalues of an absolutely positioned element will be
relative to its containing block.

Percentage lengths (e.g.:width: '50%'orpadding: '10%') applied to absolutely positioned elements will be calculated relatively to the size of its containing block. For example, if the containing block is 100 points wide, thenwidth: 50%on an absolutely positioned element will cause it to be 50 points wide.

The following list will help you determine the containing block of any given element:

- If that element has apositiontype ofrelativeorstatic, then its containing block is its parent.
- If that element has apositiontype ofabsolute, then its containing block is the nearest ancestor in which one of the following is true:It has apositiontype other thanstaticIt has atransform
- It has apositiontype other thanstatic
- It has atransform

## Going Deeper
Check out the interactiveyoga playgroundthat you can use to get a better understanding of flexbox.

We've covered the basics, but there are many other styles you may need for layouts. The full list of props that control layout is documentedhere.

Additionally, you can see some examples fromWix Engineers.


================================================================================


# Gesture Responder System
Source: https://reactnative.dev/docs/gesture-responder-system

The gesture responder system manages the lifecycle of gestures in your app. A touch can go through several phases as the app determines what the user's intention is. For example, the app needs to determine if the touch is scrolling, sliding on a widget, or tapping. This can even change during the duration of a touch. There can also be multiple simultaneous touches.

The touch responder system is needed to allow components to negotiate these touch interactions without any additional knowledge about their parent or child components.


### Best Practices
To make your app feel great, every action should have the following attributes:

- Feedback/highlighting- show the user what is handling their touch, and what will happen when they release the gesture
- Cancel-ability- when making an action, the user should be able to abort it mid-touch by dragging their finger away
These features make users more comfortable while using an app, because it allows people to experiment and interact without fear of making mistakes.


### TouchableHighlight and Touchable*
The responder system can be complicated to use. So we have provided an abstractTouchableimplementation for things that should be "tappable". This uses the responder system and allows you to configure tap interactions declaratively. UseTouchableHighlightanywhere where you would use a button or link on web.


## Responder Lifecycle
A view can become the touch responder by implementing the correct negotiation methods. There are two methods to ask the view if it wants to become responder:

- View.props.onStartShouldSetResponder: evt => true,- Does this view want to become responder on the start of a touch?
- View.props.onMoveShouldSetResponder: evt => true,- Called for every touch move on the View when it is not the responder: does this view want to "claim" touch responsiveness?
If the View returns true and attempts to become the responder, one of the following will happen:

- View.props.onResponderGrant: evt => {}- The View is now responding for touch events. This is the time to highlight and show the user what is happening
- View.props.onResponderReject: evt => {}- Something else is the responder right now and will not release it
If the view is responding, the following handlers can be called:

- View.props.onResponderMove: evt => {}- The user is moving their finger
- View.props.onResponderRelease: evt => {}- Fired at the end of the touch, ie "touchUp"
- View.props.onResponderTerminationRequest: evt => true- Something else wants to become responder. Should this view release the responder? Returning true allows release
- View.props.onResponderTerminate: evt => {}- The responder has been taken from the View. Might be taken by other views after a call toonResponderTerminationRequest, or might be taken by the OS without asking (happens with control center/ notification center on iOS)
evtis a synthetic touch event with the following form:

- nativeEventchangedTouches- Array of all touch events that have changed since the last eventidentifier- The ID of the touchlocationX- The X position of the touch, relative to the elementlocationY- The Y position of the touch, relative to the elementpageX- The X position of the touch, relative to the root elementpageY- The Y position of the touch, relative to the root elementtarget- The node id of the element receiving the touch eventtimestamp- A time identifier for the touch, useful for velocity calculationtouches- Array of all current touches on the screen
- changedTouches- Array of all touch events that have changed since the last event
- identifier- The ID of the touch
- locationX- The X position of the touch, relative to the element
- locationY- The Y position of the touch, relative to the element
- pageX- The X position of the touch, relative to the root element
- pageY- The Y position of the touch, relative to the root element
- target- The node id of the element receiving the touch event
- timestamp- A time identifier for the touch, useful for velocity calculation
- touches- Array of all current touches on the screen

### Capture ShouldSet Handlers
onStartShouldSetResponderandonMoveShouldSetResponderare called with a bubbling pattern, where the deepest node is called first. That means that the deepest component will become responder when multiple Views return true for*ShouldSetResponderhandlers. This is desirable in most cases, because it makes sure all controls and buttons are usable.

However, sometimes a parent will want to make sure that it becomes responder. This can be handled by using the capture phase. Before the responder system bubbles up from the deepest component, it will do a capture phase, firingon*ShouldSetResponderCapture. So if a parent View wants to prevent the child from becoming responder on a touch start, it should have aonStartShouldSetResponderCapturehandler which returns true.

- View.props.onStartShouldSetResponderCapture: evt => true,
- View.props.onMoveShouldSetResponderCapture: evt => true,

### PanResponder
For higher-level gesture interpretation, check outPanResponder.


================================================================================


# Introduction
Source: https://reactnative.dev/docs/getting-started

Welcome to the very start of your React Native journey! If you're looking for getting started instructions, they've moved totheir own section. Continue reading for an introduction to the documentation, Native Components, React, and more!

Many different kinds of people use React Native: from advanced iOS developers to React beginners, to people getting started programming for the first time in their career. These docs were written for all learners, no matter their experience level or background.


## How to use these docs
You can start here and read through these docs linearly like a book; or you can read the specific sections you need. Already familiar with React? You can skipthat section—or read it for a light refresher.


## Prerequisites
To work with React Native, you will need to have an understanding of JavaScript fundamentals. If you’re new to JavaScript or need a refresher, you candive inorbrush upat Mozilla Developer Network.

While we do our best to assume no prior knowledge of React, Android, or iOS development, these are valuable topics of study for the aspiring React Native developer. Where sensible, we have linked to resources and articles that go more in depth.


## Interactive examples
This introduction lets you get started immediately in your browser with interactive examples like this one:

The above is a Snack Player. It’s a handy tool created by Expo to embed and run React Native projects and share how they render in platforms like Android and iOS. The code is live and editable, so you can play directly with it in your browser. Go ahead and try changing the "Try editing me!" text above to "Hello, world!"

Optionally, if you want to set up a local development environment,you can follow our guide to setting up your environment on your local machineand paste the code examples into your project. (If you are a web developer, you may already have a local environment set up for mobile browser testing!)


## Developer Notes
People from many different development backgrounds are learning React Native. You may have experience with a range of technologies, from web to Android to iOS and more. We try to write for developers from all backgrounds. Sometimes we provide explanations specific to one platform or another like so:

- AndroidiOSWeb
- iOSWeb
- Web
Android developers may be familiar with this concept.

iOS developers may be familiar with this concept.

Web developers may be familiar with this concept.


## Formatting
Menu paths are written in bold and use carets to navigate submenus. Example:Android Studio > Preferences

Now that you know how this guide works, it's time to get to know the foundation of React Native:Native Components.


================================================================================


# Get Started Without a Framework
Source: https://reactnative.dev/docs/getting-started-without-a-framework

If you have constraints that are not served well by aFramework, or you prefer to write your own Framework, you can create a React Native app without using a Framework.

To do so, you'll first need toset up your environment. Once you're set up, continue with the steps below to create an application and start developing.


### Step 1: Creating a new application
If you previously installed a globalreact-native-clipackage, please remove it as it may cause unexpected issues:shellnpmuninstall-greact-native-cli @react-native-community/cli

```
npm uninstall -g react-native-cli @react-native-community/cli
```

You can useReact Native Community CLIto generate a new project. Let's create a new React Native project called "AwesomeProject":

```
npx @react-native-community/cli@latest init AwesomeProject
```

This is not necessary if you are integrating React Native into an existing application, or if you've installedExpoin your project, or if you're adding Android support to an existing React Native project (seeIntegration with Existing Apps). You can also use a third-party CLI to set up your React Native app, such asIgnite CLI.

If you are having trouble with iOS, try to reinstall the dependencies by running:cd iosto navigate to theiosfolder.bundle installto installBundlerbundle exec pod installto install the iOS dependencies managed by CocoaPods.

- cd iosto navigate to theiosfolder.
- bundle installto installBundler
- bundle exec pod installto install the iOS dependencies managed by CocoaPods.
If you want to start a new project with a specific React Native version, you can use the--versionargument:

```
npx @react-native-community/cli@X.XX.X init AwesomeProject --version X.XX.X
```

You can also start a project with a custom React Native template with the--templateargument, read morehere.


### Step 2: Start Metro
Metrois the JavaScript build tool for React Native. To start the Metro development server, run the following from your project folder:

- npmYarn
- Yarn
```
npm start
```

```
yarn start
```

If you're familiar with web development, Metro is similar to bundlers such as Vite and webpack, but is designed end-to-end for React Native. For instance, Metro usesBabelto transform syntax such as JSX into executable JavaScript.


### Step 3: Start your application
Let Metro Bundler run in its own terminal. Open a new terminal inside your React Native project folder. Run the following:

- npmYarn
- Yarn
```
npm run android
```

```
yarn android
```

If everything is set up correctly, you should see your new app running in your Android emulator shortly.

This is one way to run your app - you can also run it directly from within Android Studio.

If you can't get this to work, see theTroubleshootingpage.


### Step 4: Modifying your app
Now that you have successfully run the app, let's modify it.

- OpenApp.tsxin your text editor of choice and edit some lines.
- Press theRkey twice or selectReloadfrom the Dev Menu (Ctrl+M) to see your changes!

### That's it!
Congratulations! You've successfully run and modified your first barebone React Native app.


### Now what?
- If you want to add this new React Native code to an existing application, check out theIntegration guide.
- If you're curious to learn more about React Native, check out theIntroduction to React Native.

================================================================================


# AbortController
Source: https://reactnative.dev/docs/global-AbortController

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalAbortControllerclass, as defined in Web specifications.


================================================================================


# AbortSignal
Source: https://reactnative.dev/docs/global-AbortSignal

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalAbortSignalclass, as defined in Web specifications.


================================================================================


# Blob
Source: https://reactnative.dev/docs/global-Blob

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalBlobclass, as defined in Web specifications.


================================================================================


# EventCounts
Source: https://reactnative.dev/docs/global-EventCounts

The globalEventCountsclass, as defined in Web specifications.


================================================================================


# File
Source: https://reactnative.dev/docs/global-File

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalFileclass, as defined in Web specifications.


================================================================================


# FileReader
Source: https://reactnative.dev/docs/global-FileReader

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalFileReaderclass, as defined in Web specifications.


================================================================================


# FormData
Source: https://reactnative.dev/docs/global-FormData

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalFormDataclass, as defined in Web specifications.


================================================================================


# Headers
Source: https://reactnative.dev/docs/global-Headers

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalHeadersclass, as defined in Web specifications.


================================================================================


# PerformanceEntry
Source: https://reactnative.dev/docs/global-PerformanceEntry

The globalPerformanceEntryclass, as defined in Web specifications.


================================================================================


# PerformanceEventTiming
Source: https://reactnative.dev/docs/global-PerformanceEventTiming

The globalPerformanceEventTimingclass, as defined in Web specifications.

Thecancelableandtargetproperties are not supported yet.


================================================================================


# PerformanceLongTaskTiming
Source: https://reactnative.dev/docs/global-PerformanceLongTaskTiming

The globalPerformanceLongTaskTimingclass, as defined in Web specifications.

The value for theattributionproperty is always an empty array.


================================================================================


# PerformanceMark
Source: https://reactnative.dev/docs/global-PerformanceMark

The globalPerformanceMarkclass, as defined in Web specifications.


================================================================================


# PerformanceMeasure
Source: https://reactnative.dev/docs/global-PerformanceMeasure

The globalPerformanceMeasureclass, as defined in Web specifications.


================================================================================


# PerformanceObserver
Source: https://reactnative.dev/docs/global-PerformanceObserver

The globalPerformanceObserverclass, as defined in Web specifications.


## Example
```
const observer = new PerformanceObserver(  (list, observer, options) => {    for (const entry of list.getEntries()) {      console.log(        'Received entry with type',        entry.entryType,        'and name',        entry.name,        'that started at',        entry.startTime,        'and took',        entry.duration,        'ms',      );    }  },);observer.observe({entryTypes: ['mark', 'measure']});
```


## Constructor

### PerformanceObserver()
Seedocumentation in MDN.


## Static properties

### supportedEntryTypes
Seedocumentation in MDN.

Returns['mark', 'measure', 'event', 'longtask'].


## Instance methods

### observe()
Seedocumentation in MDN.


### disconnect()
Seedocumentation in MDN.


================================================================================


# PerformanceObserverEntryList
Source: https://reactnative.dev/docs/global-PerformanceObserverEntryList

The globalPerformanceObserverEntryListclass, as defined in Web specifications.


================================================================================


# PerformanceResourceTiming
Source: https://reactnative.dev/docs/global-PerformanceResourceTiming

The globalPerformanceResourceTimingclass, as defined in Web specifications.

React Native implements the followingPerformanceResourceTimingproperties only:fetchStartrequestStartconnectStartconnectEndresponseStartresponseEndresponseStatuscontentTypeencodedBodySizedecodedBodySize

- fetchStart
- requestStart
- connectStart
- connectEnd
- responseStart
- responseEnd
- responseStatus
- contentType
- encodedBodySize
- decodedBodySize

================================================================================


# Request
Source: https://reactnative.dev/docs/global-Request

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalRequestclass, as defined in Web specifications.


================================================================================


# Response
Source: https://reactnative.dev/docs/global-Response

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalResponseclass, as defined in Web specifications.


================================================================================


# URL
Source: https://reactnative.dev/docs/global-URL

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalURLclass, as defined in Web specifications.


================================================================================


# URLSearchParams
Source: https://reactnative.dev/docs/global-URLSearchParams

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.\

The globalURLSearchParamsclass, as defined in Web specifications.


================================================================================


# WebSocket
Source: https://reactnative.dev/docs/global-WebSocket

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalWebSocketclass, as defined in Web specifications.


================================================================================


# XMLHttpRequest
Source: https://reactnative.dev/docs/global-XMLHttpRequest

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalXMLHttpRequestclass, as defined in Web specifications.


================================================================================


# ✨ __DEV__
Source: https://reactnative.dev/docs/global-__DEV__

You can use the__DEV__pseudo-global variable in the codebase to guard development-only blocks of code.

It is inlined during compilation and gets completely stripped out with theifblocks it guards in the minified build.


================================================================================


# alert
Source: https://reactnative.dev/docs/global-alert

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalalertfunction, as defined in Web specifications.


================================================================================


# cancelAnimationFrame
Source: https://reactnative.dev/docs/global-cancelAnimationFrame

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalcancelAnimationFramefunction, as defined in Web specifications.


================================================================================


# cancelIdleCallback
Source: https://reactnative.dev/docs/global-cancelIdleCallback

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalcancelIdleCallbackfunction, as defined in Web specifications.


================================================================================


# clearInterval
Source: https://reactnative.dev/docs/global-clearInterval

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalclearIntervalfunction, as defined in Web specifications.


================================================================================


# clearTimeout
Source: https://reactnative.dev/docs/global-clearTimeout

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalclearTimeoutfunction, as defined in Web specifications.


================================================================================


# console
Source: https://reactnative.dev/docs/global-console

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalconsoleobject, as defined in Web specifications.


## Methods

### timeStamp()
```
console.timeStamp(  label: string,  start?: string | number,  end?: string | number,  trackName?: string,  trackGroup?: string,  color?: DevToolsColor): void;
```

Theconsole.timeStampAPI allows you to add custom timing entries in the Performance panel timeline.

Parameters:

- If string, the name of a previously recorded timestamp withconsole.timeStamp.If number, theDOMHighResTimeStamp. For example, fromperformance.now().If undefined, the current time is used.
- If number, theDOMHighResTimeStamp. For example, fromperformance.now().If undefined, the current time is used.
- If undefined, the current time is used.
- If string, the name of a previously recorded timestamp withconsole.timeStamp.If number, theDOMHighResTimeStamp. For example, fromperformance.now().If undefined, the current time is used.
- If number, theDOMHighResTimeStamp. For example, fromperformance.now().If undefined, the current time is used.
- If undefined, the current time is used.
```
type DevToolsColor =  | 'primary'  | 'primary-light'  | 'primary-dark'  | 'secondary'  | 'secondary-light'  | 'secondary-dark'  | 'tertiary'  | 'tertiary-light'  | 'tertiary-dark'  | 'warning'  | 'error';
```


================================================================================


# fetch
Source: https://reactnative.dev/docs/global-fetch

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalfetchfunction, as defined in Web specifications.


================================================================================


# global
Source: https://reactnative.dev/docs/global-global

globalis a legacy alias forglobalThis, as defined in Node.js.

The use ofglobalThisis recommended overglobal.


================================================================================


# IntersectionObserver 🧪
Source: https://reactnative.dev/docs/global-intersectionobserver

This API is currently only available in React Native’s Canary and Experimental channels.If you want to try it out, pleaseenable the Canary Channelin your app.

If you want to try it out, pleaseenable the Canary Channelin your app.

The globalIntersectionObserverinterface, as defined in Web specifications. It provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.


## Constructor

### IntersectionObserver()
Seedocumentation in MDN.

Creates a newIntersectionObserverobject which will execute a specified callback function when it detects that a target element's visibility has crossed one or morethresholdorrnRootThresholdvalues.

```
new IntersectionObserver(callback, options?)
```

callback

A function which is called when the percentage of the target element is visible crosses a threshold. The callback receives two parameters:

- entries: An array ofIntersectionObserverEntryobjects, each representing one threshold which was crossed, either becoming more or less visible than the percentage specified by that threshold.
- observer: TheIntersectionObserverinstance which invoked the callback.
options(optional)

An optional object with the following properties:


## Instance properties

### root
Seedocumentation in MDN.

The element or document whose bounds are used as the bounding box when testing for intersection.


### rootMargin
Seedocumentation in MDN.

An offset rectangle applied to the root's bounding box when calculating intersections.


### rnRootThresholds⚠️
This is a React Native specific extension.

A list of root thresholds, sorted in increasing numeric order, where each threshold is a ratio of intersection area to bounding box area of the specified root view, which defaults to the viewport.

Notifications for a target are generated when any of the thresholds specified inrnRootThresholdsorthresholdsare crossed for that target.

```
get rnRootThresholds(): ReadonlyArray<number> | null;
```


### thresholds
Seedocumentation in MDN.

A list of thresholds, sorted in increasing numeric order, where each threshold is a ratio of intersection area to bounding box area of an observed target.

Notifications for a target are generated when any of the thresholds specified inrnRootThresholdsorthresholdsare crossed for that target.


## Instance methods

### disconnect()
Seedocumentation in MDN.

Stops theIntersectionObserverobject from observing any target.


### observe()
Seedocumentation in MDN.

Tells theIntersectionObserverto begin observing a target element.


### takeRecords()
Seedocumentation in MDN.

Returns an array ofIntersectionObserverEntryobjects for all observed targets.


### unobserve()
Seedocumentation in MDN.

Tells theIntersectionObserverto stop observing a particular target element.


================================================================================


# IntersectionObserverEntry 🧪
Source: https://reactnative.dev/docs/global-intersectionobserverentry

This API is currently only available in React Native’s Canary and Experimental channels.If you want to try it out, pleaseenable the Canary Channelin your app.

If you want to try it out, pleaseenable the Canary Channelin your app.

TheIntersectionObserverEntryinterface, as defined in Web specifications. It describes the intersection between the target element and its root container at a specific moment of transition.

Instances ofIntersectionObserverEntryare delivered to anIntersectionObservercallback in itsentriesparameter.


## Instance properties

### boundingClientRect
Seedocumentation in MDN.

Returns the bounds rectangle of the target element as aDOMRectReadOnly.


### intersectionRatio
Seedocumentation in MDN.

Returns the ratio of theintersectionRectto theboundingClientRect.


### intersectionRect
Seedocumentation in MDN.

Returns aDOMRectReadOnlyrepresenting the target's visible area.


### isIntersecting
Seedocumentation in MDN.

A Boolean value which istrueif the target element intersects with the intersection observer's root. If this istrue, then theIntersectionObserverEntrydescribes a transition into a state of intersection; if it'sfalse, then you know the transition is from intersecting to not-intersecting.


### rnRootIntersectionRatio⚠️
This is a React Native specific extension.

Returns the ratio of theintersectionRectto therootBounds.

```
get rnRootIntersectionRatio(): number;
```

This is analogous tointersectionRatio, but computed relative to the root's bounding box instead of the target's bounding box. This corresponds to thernRootThresholdoption and allows you to determine what percentage of the root area is covered by the target element.


### rootBounds
Seedocumentation in MDN.

Returns aDOMRectReadOnlyfor the intersection observer's root.


### target
Seedocumentation in MDN.

TheElementwhose intersection with the root changed.


### time
Seedocumentation in MDN.

ADOMHighResTimeStampindicating the time at which the intersection was recorded, relative to theIntersectionObserver's time origin.


================================================================================


# navigator
Source: https://reactnative.dev/docs/global-navigator

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalnavigatorobject, as defined in Web specifications.


================================================================================


# performance
Source: https://reactnative.dev/docs/global-performance

The globalperformanceobject, as defined in Web specifications.


## Instance properties

### eventCounts
Seedocumentation in MDN.


### memory
Seedocumentation in MDN.


### rnStartupTiming⚠️
This is a React Native specific extension.

Provides information about the startup time of the application.

```
get rnStartupTiming(): ReactNativeStartupTiming;
```

TheReactNativeStartupTiminginterface provides the following fields:


### timeOrigin
Provides the number of milliseconds from the UNIX epoch until system boot, instead of the number of milliseconds from the UNIX epoch until app startup.

Seedocumentation in MDN.


## Instance methods

### clearMarks()
Seedocumentation in MDN.


### clearMeasures()
Seedocumentation in MDN.


### getEntries()
Seedocumentation in MDN.


### getEntriesByName()
Seedocumentation in MDN.


### getEntriesByType()
Seedocumentation in MDN.


### mark()
Seedocumentation in MDN.


### measure()
Seedocumentation in MDN.


### now()
Provides the number of milliseconds from system boot, instead of the number of milliseconds from app startup.

Seedocumentation in MDN.


================================================================================


# process
Source: https://reactnative.dev/docs/global-process

🚧 This page is work in progress.

The globalprocessobject, as defined in Node.js.


================================================================================


# queueMicrotask
Source: https://reactnative.dev/docs/global-queueMicrotask

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalqueueMicrotaskfunction, as defined in Web specifications.


================================================================================


# requestAnimationFrame
Source: https://reactnative.dev/docs/global-requestAnimationFrame

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalrequestAnimationFramefunction, as defined in Web specifications.


================================================================================


# requestIdleCallback
Source: https://reactnative.dev/docs/global-requestIdleCallback

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalrequestIdleCallbackfunction, as defined in Web specifications.


================================================================================


# self
Source: https://reactnative.dev/docs/global-self

selfis an alias forglobalThis, as defined in Web specifications.

The use ofglobalThisis recommended overself.


================================================================================


# setInterval
Source: https://reactnative.dev/docs/global-setInterval

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalsetIntervalfunction, as defined in Web specifications.


================================================================================


# setTimeout
Source: https://reactnative.dev/docs/global-setTimeout

🚧 This page is work in progress, so please refer to theMDN documentationfor more information.

The globalsetTimeoutfunction, as defined in Web specifications.


================================================================================


# window
Source: https://reactnative.dev/docs/global-window

windowis an alias forglobalThis, as defined in Web specifications.

The use ofglobalThisis recommended overwindow.


================================================================================


# Handling Text Input
Source: https://reactnative.dev/docs/handling-text-input

TextInputis aCore Componentthat allows the user to enter text. It has anonChangeTextprop that takes a function to be called every time the text changed, and anonSubmitEditingprop that takes a function to be called when the text is submitted.

For example, let's say that as the user types, you're translating their words into a different language. In this new language, every single word is written the same way: 🍕. So the sentence "Hello there Bob" would be translated as "🍕 🍕 🍕".

In this example, we storetextin the state, because it changes over time.

There are a lot more things you might want to do with a text input. For example, you could validate the text inside while the user types. For more detailed examples, see theReact docs on controlled components, or thereference docs for TextInput.

ATextInputis one of many ways for the user to interact with your app. For examples of other ways to handle input, see the documentation onhow to handle touches.

Now, let's take a look atScrollView, another Core Component.


================================================================================


# Handling Touches
Source: https://reactnative.dev/docs/handling-touches

Users interact with mobile apps mainly through touch. They can use a combination of gestures, such as tapping on a button, scrolling a list, or zooming on a map. React Native provides components to handle all sorts of common gestures, as well as a comprehensivegesture responder systemto allow for more advanced gesture recognition, but the one component you will most likely be interested in is the basic Button.


## Displaying a basic button
Buttonprovides a basic button component that is rendered nicely on all platforms. The minimal example to display a button looks like this:

```
<Button  onPress={() => {    console.log('You tapped the button!');  }}  title="Press Me"/>
```

This will render a blue label on iOS, and a blue rounded rectangle with light text on Android. Pressing the button will call the "onPress" function, which in this case displays an alert popup. If you like, you can specify a "color" prop to change the color of your button.

Go ahead and play around with theButtoncomponent using the example below. You can select which platform your app is previewed in by clicking on the toggle in the bottom right and then clicking on "Tap to Play" to preview the app.


## Touchables
If the basic button doesn't look right for your app, you can build your own button using any of the "Touchable" components provided by React Native. These components provide the capability to capture tapping gestures and can display feedback when a gesture is recognized. However, these components do not provide any default styling, so you will need to do a bit of work to get them looking nice in your app.

Which "Touchable" component you use will depend on what kind of feedback you want to provide:

- Generally, you can useTouchableHighlightanywhere you would use a button or link on web. The view's background will be darkened when the user presses down on the button.
Generally, you can useTouchableHighlightanywhere you would use a button or link on web. The view's background will be darkened when the user presses down on the button.

- You may consider usingTouchableNativeFeedbackon Android to display ink surface reaction ripples that respond to the user's touch.
You may consider usingTouchableNativeFeedbackon Android to display ink surface reaction ripples that respond to the user's touch.

- TouchableOpacitycan be used to provide feedback by reducing the opacity of the button, allowing the background to be seen through while the user is pressing down.
TouchableOpacitycan be used to provide feedback by reducing the opacity of the button, allowing the background to be seen through while the user is pressing down.

- If you need to handle a tap gesture but you don't want any feedback to be displayed, useTouchableWithoutFeedback.
If you need to handle a tap gesture but you don't want any feedback to be displayed, useTouchableWithoutFeedback.

In some cases, you may want to detect when a user presses and holds a view for a set amount of time. These long presses can be handled by passing a function to theonLongPressprops of any of the "Touchable" components.

Let's see all of these in action:


## Scrolling and swiping
Gestures commonly used on devices with touchable screens include swipes and pans. These allow the user to scroll through a list of items, or swipe through pages of content. For these, check out theScrollViewCore Component.


## Known issues
- react-native#29308: The touch area never extends past the parent view bounds and on Android negative margin is not supported.

================================================================================


# Headless JS
Source: https://reactnative.dev/docs/headless-js-android

Headless JS is a way to run tasks in JavaScript while your app is in the background. It can be used, for example, to sync fresh data, handle push notifications, or play music.


## The JS API
A task is an async function that you register onAppRegistry, similar to registering React applications:

```
import {AppRegistry} from 'react-native';AppRegistry.registerHeadlessTask('SomeTaskName', () =>  require('SomeTaskName'),);
```

Then, inSomeTaskName.js:

```
module.exports = async taskData => {  // do stuff};
```

You can do anything in your task such as network requests, timers and so on, as long as it doesn't touch UI. Once your task completes (i.e. the promise is resolved), React Native will go into "paused" mode (unless there are other tasks running, or there is a foreground app).


## The Platform API
Yes, this does still require some native code, but it's pretty thin. You need to extendHeadlessJsTaskServiceand overridegetTaskConfig, e.g.:

- JavaKotlin
- Kotlin
```
package com.your_application_name;import android.content.Intent;import android.os.Bundle;import com.facebook.react.HeadlessJsTaskService;import com.facebook.react.bridge.Arguments;import com.facebook.react.jstasks.HeadlessJsTaskConfig;import javax.annotation.Nullable;public class MyTaskService extends HeadlessJsTaskService {  @Override  protected @Nullable HeadlessJsTaskConfig getTaskConfig(Intent intent) {    Bundle extras = intent.getExtras();    if (extras != null) {      return new HeadlessJsTaskConfig(          "SomeTaskName",          Arguments.fromBundle(extras),          5000, // timeout in milliseconds for the task          false // optional: defines whether or not the task is allowed in foreground. Default is false        );    }    return null;  }}
```

```
package com.your_application_name;import android.content.Intentimport com.facebook.react.HeadlessJsTaskServiceimport com.facebook.react.bridge.Argumentsimport com.facebook.react.jstasks.HeadlessJsTaskConfigclass MyTaskService : HeadlessJsTaskService() {    override fun getTaskConfig(intent: Intent?): HeadlessJsTaskConfig? {        return intent.extras?.let {            HeadlessJsTaskConfig(                "SomeTaskName",                Arguments.fromBundle(it),                5000, // timeout for the task                false // optional: defines whether or not the task is allowed in foreground.                // Default is false            )        }    }}
```

Then add the service to yourAndroidManifest.xmlfile inside theapplicationtag:

```
<service android:name="com.example.MyTaskService" />
```

Now, whenever youstart your service, e.g. as a periodic task or in response to some system event / broadcast, JS will spin up, run your task, then spin down.

Example:

- JavaKotlin
- Kotlin
```
Intent service = new Intent(getApplicationContext(), MyTaskService.class);Bundle bundle = new Bundle();bundle.putString("foo", "bar");service.putExtras(bundle);getApplicationContext().startForegroundService(service);
```

```
val service = Intent(applicationContext, MyTaskService::class.java)val bundle = Bundle()bundle.putString("foo", "bar")service.putExtras(bundle)applicationContext.startForegroundService(service)
```


## Retries
By default, the headless JS task will not perform any retries. In order to do so, you need to create aHeadlessJsRetryPolicyand throw a specificError.

LinearCountingRetryPolicyis an implementation ofHeadlessJsRetryPolicythat allows you to specify a maximum number of retries with a fixed delay between each attempt. If that does not suit your needs then you can implement your ownHeadlessJsRetryPolicy. These policies can be passed as an extra argument to theHeadlessJsTaskConfigconstructor, e.g.

- JavaKotlin
- Kotlin
```
HeadlessJsRetryPolicy retryPolicy = new LinearCountingRetryPolicy(  3, // Max number of retry attempts  1000 // Delay between each retry attempt);return new HeadlessJsTaskConfig(  'SomeTaskName',  Arguments.fromBundle(extras),  5000,  false,  retryPolicy);
```

```
val retryPolicy: HeadlessJsTaskRetryPolicy =    LinearCountingRetryPolicy(        3, // Max number of retry attempts        1000 // Delay between each retry attempt    )return HeadlessJsTaskConfig("SomeTaskName", Arguments.fromBundle(extras), 5000, false, retryPolicy)
```

A retry attempt will only be made when a specificErroris thrown. Inside a headless JS task, you can import the error and throw it when a retry attempt is required.

Example:

```
import {HeadlessJsTaskError} from 'HeadlessJsTask';module.exports = async taskData => {  const condition = ...;  if (!condition) {    throw new HeadlessJsTaskError();  }};
```

If you wish all errors to cause a retry attempt, you will need to catch them and throw the above error.


## Caveats
- By default, your app will crash if you try to run a task while the app is in the foreground. This is to prevent developers from shooting themselves in the foot by doing a lot of work in a task and slowing the UI. You can pass a fourthbooleanargument to control this behaviour.
- If you start your service from aBroadcastReceiver, make sure to callHeadlessJsTaskService.acquireWakeLockNow()before returning fromonReceive().

## Example Usage
Service can be started from Java API. First you need to decide when the service should be started and implement your solution accordingly. Here is an example that reacts to network connection change.

Following lines shows part of Android manifest file for registering broadcast receiver.

```
<receiver android:name=".NetworkChangeReceiver" >  <intent-filter>    <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />  </intent-filter></receiver>
```

Broadcast receiver then handles intent that was broadcasted in onReceive function. This is a great place to check whether your app is on foreground or not. If app is not on foreground we can prepare our intent to be started, with no information or additional information bundled usingputExtra(keep in mind bundle can handle only parcelable values). In the end service is started and wakelock is acquired.

- JavaKotlin
- Kotlin
```
import android.app.ActivityManager;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.net.ConnectivityManager;import android.net.Network;import android.net.NetworkCapabilities;import android.net.NetworkInfo;import android.os.Build;import com.facebook.react.HeadlessJsTaskService;public class NetworkChangeReceiver extends BroadcastReceiver {    @Override    public void onReceive(final Context context, final Intent intent) {        /**         This part will be called every time network connection is changed         e.g. Connected -> Not Connected         **/        if (!isAppOnForeground((context))) {            /**             We will start our service and send extra info about             network connections             **/            boolean hasInternet = isNetworkAvailable(context);            Intent serviceIntent = new Intent(context, MyTaskService.class);            serviceIntent.putExtra("hasInternet", hasInternet);            context.startForegroundService(serviceIntent);            HeadlessJsTaskService.acquireWakeLockNow(context);        }    }    private boolean isAppOnForeground(Context context) {        /**         We need to check if app is in foreground otherwise the app will crash.         https://stackoverflow.com/questions/8489993/check-android-application-is-in-foreground-or-not         **/        ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);        List<ActivityManager.RunningAppProcessInfo> appProcesses =                activityManager.getRunningAppProcesses();        if (appProcesses == null) {            return false;        }        final String packageName = context.getPackageName();        for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) {            if (appProcess.importance ==                    ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&                    appProcess.processName.equals(packageName)) {                return true;            }        }        return false;    }    public static boolean isNetworkAvailable(Context context) {        ConnectivityManager cm = (ConnectivityManager)                context.getSystemService(Context.CONNECTIVITY_SERVICE);        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            Network networkCapabilities = cm.getActiveNetwork();            if(networkCapabilities == null) {                return false;            }            NetworkCapabilities actNw = cm.getNetworkCapabilities(networkCapabilities);            if(actNw == null) {                return false;            }            if(actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) || actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) || actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET)) {                return true;            }            return false;        }        // deprecated in API level 29        NetworkInfo netInfo = cm.getActiveNetworkInfo();        return (netInfo != null && netInfo.isConnected());    }}
```

```
import android.app.ActivityManagerimport android.app.ActivityManager.RunningAppProcessInfoimport android.content.BroadcastReceiverimport android.content.Contextimport android.content.Intentimport android.net.ConnectivityManagerimport android.net.NetworkCapabilitiesimport android.os.Buildimport com.facebook.react.HeadlessJsTaskServiceclass NetworkChangeReceiver : BroadcastReceiver() {    override fun onReceive(context: Context, intent: Intent?) {        /**         * This part will be called every time network connection is changed e.g. Connected -> Not         * Connected         */        if (!isAppOnForeground(context)) {            /** We will start our service and send extra info about network connections */            val hasInternet = isNetworkAvailable(context)            val serviceIntent = Intent(context, MyTaskService::class.java)            serviceIntent.putExtra("hasInternet", hasInternet)            context.startForegroundService(serviceIntent)            HeadlessJsTaskService.acquireWakeLockNow(context)        }    }    private fun isAppOnForeground(context: Context): Boolean {        /**         * We need to check if app is in foreground otherwise the app will crash.         * https://stackoverflow.com/questions/8489993/check-android-application-is-in-foreground-or-not         */        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager        val appProcesses = activityManager.runningAppProcesses ?: return false        val packageName: String = context.getPackageName()        for (appProcess in appProcesses) {            if (appProcess.importance == RunningAppProcessInfo.IMPORTANCE_FOREGROUND &&                    appProcess.processName == packageName            ) {                return true            }        }        return false    }    companion object {        fun isNetworkAvailable(context: Context): Boolean {            val cm = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager            var result = false            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {                val networkCapabilities = cm.activeNetwork ?: return false                val actNw = cm.getNetworkCapabilities(networkCapabilities) ?: return false                result =                    when {                        actNw.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) -> true                        actNw.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) -> true                        actNw.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET) -> true                        else -> false                    }                return result            } else {                cm.run {                    // deprecated in API level 29                    cm.activeNetworkInfo?.run {                        result =                            when (type) {                                ConnectivityManager.TYPE_WIFI -> true                                ConnectivityManager.TYPE_MOBILE -> true                                ConnectivityManager.TYPE_ETHERNET -> true                                else -> false                            }                    }                }            }            return result        }    }}
```


================================================================================


# Height and Width
Source: https://reactnative.dev/docs/height-and-width

A component's height and width determine its size on the screen.


## Fixed Dimensions
The general way to set the dimensions of a component is by adding a fixedwidthandheightto style. All dimensions in React Native are unitless, and represent density-independent pixels.

Setting dimensions this way is common for components whose size should always be fixed to a number of points and not calculated based on screen size.

There is no universal mapping from points to physical units of measurement. This means that a component with fixed dimensions might not have the same physical size, across different devices and screen sizes. However, this difference is unnoticeable for most use cases.


## Flex Dimensions
Useflexin a component's style to have the component expand and shrink dynamically based on available space. Normally you will useflex: 1, which tells a component to fill all available space, shared evenly amongst other components with the same parent. The larger theflexgiven, the higher the ratio of space a component will take compared to its siblings.

A component can only expand to fill available space if its parent has dimensions greater than0. If a parent does not have either a fixedwidthandheightorflex, the parent will have dimensions of0and theflexchildren will not be visible.

After you can control a component's size, the next step is tolearn how to lay it out on the screen.


## Percentage Dimensions
If you want to fill a certain portion of the screen, but youdon'twant to use theflexlayout, youcanusepercentage valuesin the component's style. Similar to flex dimensions, percentage dimensions require parent with a defined size.


================================================================================


# Using Hermes
Source: https://reactnative.dev/docs/hermes

Hermesis an open-source JavaScript engine optimized for React Native. For many apps, using Hermes will result in improved start-up time, decreased memory usage, and smaller app size when compared to JavaScriptCore.
Hermes is used by default by React Native and no additional configuration is required to enable it.


## Bundled Hermes
React Native comes with abundled versionof Hermes.
We are building a version of Hermes for you whenever we release a new version of React Native. This will make sure you're consuming a version of Hermes which is fully compatible with the version of React Native you're using.

This change is fully transparent to users of React Native. You can still disable Hermes using the command described in this page.
You canread more about the technical implementation on this page.


## Confirming Hermes is in use
If you've recently created a new app from scratch, you should see if Hermes is enabled in the welcome view:

AHermesInternalglobal variable will be available in JavaScript that can be used to verify that Hermes is in use:

```
const isHermes = () => !!global.HermesInternal;
```

If you are using a non-standard way of loading the JS bundle, it is possible that theHermesInternalvariable is available but you aren't using the highly optimised pre-compiled bytecode.
Confirm that you are using the.hbcfile and also benchmark the before/after as detailed below.

To see the benefits of Hermes, try making a release build/deployment of your app to compare. For example; from the root of your project:

- AndroidiOS
- iOS
- npmYarn
- Yarn
```
npm run android -- --mode="release"
```

```
yarn android --mode release
```

- npmYarn
- Yarn
```
npm run ios -- --mode="Release"
```

```
yarn ios --mode Release
```

This will compile JavaScript to Hermes Bytecode during build time which will improve your app's startup speed on device.


## Switching back to JavaScriptCore
React Native also supports using JavaScriptCore as theJavaScript engine. Follow the instructionsfrom the community repositoryto opt-out of Hermes.


================================================================================


# I18nManager
Source: https://reactnative.dev/docs/i18nmanager

TheI18nManagermodule provides utilities for managing Right-to-Left (RTL) layout support for languages like Arabic, Hebrew, and others. It provides methods to control RTL behavior and check the current layout direction.


## Examples

### Change positions and animations based on RTL
If you absolutely position elements to align with other flexbox elements, they may not align in RTL languages. UsingisRTLcan be used to adjust alignment or animations.


### During Development

## Properties

### isRTL
```
static isRTL: boolean;
```

A boolean value indicating whether the app is currently in RTL layout mode.

The value ofisRTLis determined by the following logic:

- IfforceRTListrue,isRTLreturnstrue
- IfallowRTLisfalse,isRTLreturnsfalse
- Otherwise,isRTLwill betruegiven the following:iOS:The user-preferred language on the device is an RTL languageThe application-defined localizations include the user-chosen language (as defined in the Xcode project file (knownRegions = (...))Android:The user-preferred language on the device is an RTL languageThe application'sAndroidManifest.xmldefinesandroid:supportsRTL="true"on the<application>element
- iOS:The user-preferred language on the device is an RTL languageThe application-defined localizations include the user-chosen language (as defined in the Xcode project file (knownRegions = (...))
- The user-preferred language on the device is an RTL language
- The application-defined localizations include the user-chosen language (as defined in the Xcode project file (knownRegions = (...))
- Android:The user-preferred language on the device is an RTL languageThe application'sAndroidManifest.xmldefinesandroid:supportsRTL="true"on the<application>element
- The user-preferred language on the device is an RTL language
- The application'sAndroidManifest.xmldefinesandroid:supportsRTL="true"on the<application>element

### doLeftAndRightSwapInRTL
```
static doLeftAndRightSwapInRTL: boolean;
```

A boolean value indicating whether left and right style properties should be automatically swapped when in RTL mode. When enabled, left becomes right and right becomes left in RTL layouts.


## Methods

### allowRTL()
```
static allowRTL: (allowRTL: boolean) => void;
```

Enables or disables RTL layout support for the application.

Parameters:

- allowRTL(boolean): Whether to allow RTL layout
Important Notes:

- Changes take effect on the next application start, not immediately
- This setting is persisted across app restarts

### forceRTL()
```
static forceRTL: (forced: boolean) => void;
```

Forces the app to use RTL layout regardless of the device language settings. This is primarily useful for testing RTL layouts during development.

Avoid forcing RTL in production apps as it requires a full app restart to take effect, which makes for a poor user-experience.

Parameters:

- forced(boolean): Whether to force RTL layout
Important Notes:

- Changes take full effect on the next application start, not immediately
- The setting is persisted across app restarts
- Only meant for development and testing. In production, you should either disallow RTL fully or handle it appropriately (seeisRTL)

### swapLeftAndRightInRTL()
```
static swapLeftAndRightInRTL: (swapLeftAndRight: boolean) => void;
```

Swap left and right style properties in RTL mode. When enabled, left becomes right and right becomes left in RTL layouts. Does not affect the value ofisRTL.


================================================================================


# Image
Source: https://reactnative.dev/docs/image

A React component for displaying different types of images, including network images, static resources, temporary local images, and images from local disk, such as the camera roll.

This example shows fetching and displaying an image from local storage as well as one from network and even from data provided in the'data:'uri scheme.

For network and data images, you will need to manually specify the dimensions of your image!


## Examples
You can also addstyleto an image:


## GIF and WebP support on Android
When building your own native code, GIF and WebP are not supported by default on Android.

You will need to add some optional modules inandroid/app/build.gradle, depending on the needs of your app.

```
dependencies {  // If your app supports Android versions before Ice Cream Sandwich (API level 14)  implementation 'com.facebook.fresco:animated-base-support:1.3.0'  // For animated GIF support  implementation 'com.facebook.fresco:animated-gif:3.6.0'  // For WebP support, including animated WebP  implementation 'com.facebook.fresco:animated-webp:3.6.0'  implementation 'com.facebook.fresco:webpsupport:3.6.0'  // For WebP support, without animations  implementation 'com.facebook.fresco:webpsupport:3.6.0'}
```

The version listed above may not be updated in time. Please checkpackages/react-native/gradle/libs.versions.tomlin the main repo to see which fresco version is being used in a specific tagged version.


## Props

### View Props
InheritsView Props.


### accessible
When true, indicates the image is an accessibility element.


### accessibilityLabel
The text that's read by the screen reader when the user interacts with the image.


### alt
A string that defines an alternative text description of the image, which will be read by the screen reader when the user interacts with it. Using this will automatically mark this element as accessible.


### blurRadius
blurRadius: the blur radius of the blur filter added to the image.

On IOS, you will need to increaseblurRadiusby more than5.


### capInsetsiOS
When the image is resized, the corners of the size specified bycapInsetswill stay a fixed size, but the center content and borders of the image will be stretched. This is useful for creating resizable rounded buttons, shadows, and other resizable assets. More info in theofficial Apple documentation.


### crossOrigin
A string of a keyword specifying the CORS mode to use when fetching the image resource. It works similar to crossorigin attribute in HTML.

- anonymous: No exchange of user credentials in the image request.
- use-credentials: SetsAccess-Control-Allow-Credentialsheader value totruein the image request.

### defaultSource
A static image to display while loading the image source.

On Android, the default source prop is ignored on debug builds.


### fadeDurationAndroid
Fade animation duration in milliseconds.


### height
Height of the image component.


### loadingIndicatorSource
Similarly tosource, this property represents the resource used to render the loading indicator for the image. The loading indicator is displayed until image is ready to be displayed, typically after the image is downloaded.


### onError
Invoked on load error.


### onLayout
Invoked on mount and on layout changes.


### onLoad
Invoked when load completes successfully.

Example:onLoad={({nativeEvent: {source: {width, height}}}) => setImageRealSize({width, height})}


### onLoadEnd
Invoked when load either succeeds or fails.


### onLoadStart
Invoked on load start.

Example:onLoadStart={() => this.setState({loading: true})}


### onPartialLoadiOS
Invoked when a partial load of the image is complete. The definition of what constitutes a "partial load" is loader specific though this is meant for progressive JPEG loads.


### onProgress
Invoked on download progress.


### progressiveRenderingEnabledAndroid
Whentrue, enables progressive jpeg streaming -https://frescolib.org/docs/progressive-jpegs.


### referrerPolicy
A string indicating which referrer to use when fetching the resource. Sets the value forReferrer-Policyheader in the image request. Works similar toreferrerpolicyattribute in HTML.


### ref
A ref setter that will be assigned anelement nodewhen mounted.


### resizeMethodAndroid
The mechanism that should be used to resize the image when the image's dimensions differ from the image view's dimensions. Defaults toauto.

- auto: Use heuristics to pick betweenresizeandscale.
auto: Use heuristics to pick betweenresizeandscale.

- resize: A software operation which changes the encoded image in memory before it gets decoded. This should be used instead ofscalewhen the image is much larger than the view.
resize: A software operation which changes the encoded image in memory before it gets decoded. This should be used instead ofscalewhen the image is much larger than the view.

- scale: The image gets drawn downscaled or upscaled. Compared toresize,scaleis faster (usually hardware accelerated) and produces higher quality images. This should be used if the image is smaller than the view. It should also be used if the image is slightly bigger than the view.
scale: The image gets drawn downscaled or upscaled. Compared toresize,scaleis faster (usually hardware accelerated) and produces higher quality images. This should be used if the image is smaller than the view. It should also be used if the image is slightly bigger than the view.

- none: No sampling is performed and the image is displayed in its full resolution. This should only be used in rare circumstances because it is considered unsafe as Android will throw a runtime exception when trying to render images that consume too much memory.
none: No sampling is performed and the image is displayed in its full resolution. This should only be used in rare circumstances because it is considered unsafe as Android will throw a runtime exception when trying to render images that consume too much memory.

More details aboutresizeandscalecan be found athttps://frescolib.org/docs/resizing.


### resizeMode
Determines how to resize the image when the frame doesn't match the raw image dimensions. Defaults tocover.

- cover: Scale the image uniformly (maintain the image's aspect ratio) so thatboth dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding)at least one dimension of the scaled image will be equal to the corresponding dimension of the view (minus padding)
cover: Scale the image uniformly (maintain the image's aspect ratio) so that

- both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding)
- at least one dimension of the scaled image will be equal to the corresponding dimension of the view (minus padding)
- contain: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).
contain: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).

- stretch: Scale width and height independently, This may change the aspect ratio of the src.
stretch: Scale width and height independently, This may change the aspect ratio of the src.

- repeat: Repeat the image to cover the frame of the view. The image will keep its size and aspect ratio, unless it is larger than the view, in which case it will be scaled down uniformly so that it is contained in the view.
repeat: Repeat the image to cover the frame of the view. The image will keep its size and aspect ratio, unless it is larger than the view, in which case it will be scaled down uniformly so that it is contained in the view.

- center: Center the image in the view along both dimensions. If the image is larger than the view, scale it down uniformly so that it is contained in the view.
center: Center the image in the view along both dimensions. If the image is larger than the view, scale it down uniformly so that it is contained in the view.


### resizeMultiplierAndroid
When theresizeMethodis set toresize, the destination dimensions are multiplied by this value. Thescalemethod is used to perform the remainder of the resize. A default of1.0means the bitmap size is designed to fit the destination dimensions. A multiplier greater than1.0will set the resize options larger than that of the destination dimensions, and the resulting bitmap will be scaled down from the hardware size. Defaults to1.0.

This prop is most useful in cases where the destination dimensions are quite small and the source image is significantly larger. Theresizeresize method performs downsampling and significant image quality is lost between the source and destination image sizes, often resulting in a blurry image. By using a multiplier, the decoded image is slightly larger than the target size but smaller than the source image (if the source image is large enough). This allows aliasing artifacts to produce faux quality through scaling operations on the multiplied image.

If you have a source image with dimensions 200x200 and destination dimensions of 24x24, a resizeMultiplier of2.0will tell Fresco to downsample the image to 48x48. Fresco picks the closest power of 2 (so, 50x50) and decodes the image into a bitmap of that size. Without the multiplier, the closest power of 2 would be 25x25. The resultant image is scaled down by the system.


### source
The image source (either a remote URL or a local file resource).

This prop can also contain several remote URLs, specified together with their width and height and potentially with scale/other URI arguments. The native side will then choose the besturito display based on the measured size of the image container. Acacheproperty can be added to control how networked request interacts with the local cache. (For more information seeCache Control for Images).

The currently supported formats arepng,jpg,jpeg,bmp,gif,webp,psd(iOS only). In addition, iOS supports several RAW image formats. Refer to Apple's documentation for the current list of supported camera models (for iOS 12, seehttps://support.apple.com/en-ca/HT208967).

Please note that thewebpformat is supported on iOSonlywhen bundled with the JavaScript code.


### src
A string representing the remote URL of the image. This prop has precedence oversourceprop.

Example:src={'https://reactnative.dev/img/tiny_logo.png'}


### srcSet
A string representing comma separated list of possible candidate image source. Each image source contains a URL of an image and a pixel density descriptor. If no descriptor is specified, it defaults to descriptor of1x.

IfsrcSetdoes not contain a1xdescriptor, the value insrcis used as image source with1xdescriptor (if provided).

This prop has precedence over both thesrcandsourceprops.

Example:srcSet={'https://reactnative.dev/img/tiny_logo.png 1x, https://reactnative.dev/img/header_logo.svg 2x'}


### style

### testID
A unique identifier for this element to be used in UI Automation testing scripts.


### tintColor
Changes the color of all non-transparent pixels to thetintColor.


### width
Width of the image component.


## Methods

### abortPrefetch()Android
```
static abortPrefetch(requestId: number);
```

Abort prefetch request.

Parameters:


### getSize()
```
static getSize(uri: string): Promise<{width: number, height: number}>;
```

Retrieve the width and height (in pixels) of an image prior to displaying it. This method can fail if the image cannot be found, or fails to download.

In order to retrieve the image dimensions, the image may first need to be loaded or downloaded, after which it will be cached. This means that in principle you could use this method to preload images, however it is not optimized for that purpose, and may in future be implemented in a way that does not fully load/download the image data. A proper, supported way to preload images will be provided as a separate API.

Parameters:


### getSizeWithHeaders()
```
static getSizeWithHeaders(  uri: string,  headers: {[index: string]: string}): Promise<{width: number, height: number}>;
```

Retrieve the width and height (in pixels) of an image prior to displaying it with the ability to provide the headers for the request. This method can fail if the image cannot be found, or fails to download. It also does not work for static image resources.

In order to retrieve the image dimensions, the image may first need to be loaded or downloaded, after which it will be cached. This means that in principle you could use this method to preload images, however it is not optimized for that purpose, and may in future be implemented in a way that does not fully load/download the image data. A proper, supported way to preload images will be provided as a separate API.

Parameters:


### prefetch()
```
await Image.prefetch(url);
```

Prefetches a remote image for later use by downloading it to the disk cache. Returns a promise which resolves to a boolean.

Parameters:


### queryCache()
```
static queryCache(  urls: string[],): Promise<Record<string, 'memory' | 'disk' | 'disk/memory'>>;
```

Perform cache interrogation. Returns a promise which resolves to a mapping from URL to cache status, such as "disk", "memory" or "disk/memory". If a requested URL is not in the mapping, it means it's not in the cache.

Parameters:


### resolveAssetSource()
```
static resolveAssetSource(source: ImageSourcePropType): {  height: number;  width: number;  scale: number;  uri: string;};
```

Resolves an asset reference into an object which has the propertiesuri,scale,width, andheight.

Parameters:


## Type Definitions

### ImageCacheEnumiOS
Enum which can be used to set the cache handling or strategy for the potentially cached responses.

- default: Use the native platforms default strategy.
- reload: The data for the URL will be loaded from the originating source. No existing cache data should be used to satisfy a URL load request.
- force-cache: The existing cached data will be used to satisfy the request, regardless of its age or expiration date. If there is no existing data in the cache corresponding the request, the data is loaded from the originating source.
- only-if-cached: The existing cache data will be used to satisfy a request, regardless of its age or expiration date. If there is no existing data in the cache corresponding to a URL load request, no attempt is made to load the data from the originating source, and the load is considered to have failed.

### ImageLoadEvent
Object returned in theonLoadcallback.

Properties:

Properties:


### ImageSource
Properties (if passing as object or array of objects):

If passing a number:

- number- opaque type returned by something likerequire('./image.jpg').

================================================================================


# Image Style Props
Source: https://reactnative.dev/docs/image-style-props


## Examples

### Image Resize Mode

### Image Border

### Image Border Radius

### Image Tint

## Props

### backfaceVisibility
The property defines whether or not the back face of a rotated image should be visible.


### backgroundColor

### borderBottomLeftRadius

### borderBottomRightRadius

### borderColor

### borderRadius

### borderTopLeftRadius

### borderTopRightRadius

### borderWidth

### opacity
Set an opacity value for the image. The number should be in the range from0.0to1.0.


### overflow

### overlayColorAndroid
When the image has rounded corners, specifying an overlayColor will cause the remaining space in the corners to be filled with a solid color. This is useful in cases which are not supported by the Android implementation of rounded corners:

- Certain resize modes, such as'contain'
- Animated GIFs
A typical way to use this prop is with images displayed on a solid background and setting theoverlayColorto the same color as the background.

For details of how this works under the hood, seeFresco documentation.


### resizeMode
Determines how to resize the image when the frame doesn't match the raw image dimensions. Defaults tocover.

- cover: Scale the image uniformly (maintain the image's aspect ratio) so that:Both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding)At least one dimension of the scaled image will be equal to the corresponding dimension of the view (minus padding)
cover: Scale the image uniformly (maintain the image's aspect ratio) so that:

- Both dimensions (width and height) of the image will be equal to or larger than the corresponding dimension of the view (minus padding)
- At least one dimension of the scaled image will be equal to the corresponding dimension of the view (minus padding)
- contain: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).
contain: Scale the image uniformly (maintain the image's aspect ratio) so that both dimensions (width and height) of the image will be equal to or less than the corresponding dimension of the view (minus padding).

- stretch: Scale width and height independently, This may change the aspect ratio of the src.
stretch: Scale width and height independently, This may change the aspect ratio of the src.

- repeat: Repeat the image to cover the frame of the view. The image will keep its size and aspect ratio, unless it is larger than the view, in which case it will be scaled down uniformly so that it is contained in the view.
repeat: Repeat the image to cover the frame of the view. The image will keep its size and aspect ratio, unless it is larger than the view, in which case it will be scaled down uniformly so that it is contained in the view.

- center: Center the image in the view along both dimensions. If the image is larger than the view, scale it down uniformly so that it is contained in the view.
center: Center the image in the view along both dimensions. If the image is larger than the view, scale it down uniformly so that it is contained in the view.


### objectFit
Determines how to resize the image when the frame doesn't match the raw image dimensions.


### tintColor
Changes the color of all the non-transparent pixels to the tintColor.


================================================================================


# ImageBackground
Source: https://reactnative.dev/docs/imagebackground

A common feature request from developers familiar with the web isbackground-image. To handle this use case, you can use the<ImageBackground>component, which has the same props as<Image>, and add whatever children to it you would like to layer on top of it.

You might not want to use<ImageBackground>in some cases, since the implementation is basic. Refer to<ImageBackground>'ssource codefor more insight, and create your own custom component when needed.

Note that you must specify some width and height style attributes.


## Example

## Props

### Image Props
InheritsImage Props.


### imageStyle

### imageRef
A ref setter that will be assigned theelement nodeof the innerImagecomponent when mounted.


### style

================================================================================


# ❌ ImagePickerIOS
Source: https://reactnative.dev/docs/imagepickerios

Use one of thecommunity packagesinstead.


================================================================================


# Images
Source: https://reactnative.dev/docs/images


## Static Image Resources
React Native provides a unified way of managing images and other media assets in your Android and iOS apps. To add a static image to your app, place it somewhere in your source code tree and reference it like this:

```
<Image source={require('./my-icon.png')} />
```

The image name is resolved the same way JS modules are resolved. In the example above, the bundler will look formy-icon.pngin the same folder as the component that requires it.

You can use the@2xand@3xsuffixes to provide images for different screen densities. If you have the following file structure:

```
.├── button.js└── img    ├── check.png    ├── check@2x.png    └── check@3x.png
```

...andbutton.jscode contains:

```
<Image source={require('./img/check.png')} />
```

...the bundler will bundle and serve the image corresponding to device's screen density. For example,check@2x.png, will be used on an iPhone 7, whilecheck@3x.pngwill be used on an iPhone 7 Plus or a Nexus 5. If there is no image matching the screen density, the closest best option will be selected.

On Windows, you might need to restart the bundler if you add new images to your project.

Here are some benefits that you get:

- Same system on Android and iOS.
- Images live in the same folder as your JavaScript code. Components are self-contained.
- No global namespace, i.e. you don't have to worry about name collisions.
- Only the images that are actually used will be packaged into your app.
- Adding and changing images doesn't require app recompilation, you can refresh the simulator as you normally do.
- The bundler knows the image dimensions, no need to duplicate it in the code.
- Images can be distributed vianpmpackages.
In order for this to work, the image name inrequirehas to be known statically.

```
// GOOD<Image source={require('./my-icon.png')} />;// BADconst icon = this.props.active  ? 'my-icon-active'  : 'my-icon-inactive';<Image source={require('./' + icon + '.png')} />;// GOODconst icon = this.props.active  ? require('./my-icon-active.png')  : require('./my-icon-inactive.png');<Image source={icon} />;
```

Note that image sources required this way include size (width, height) info for the Image. If you need to scale the image dynamically (i.e. via flex), you may need to manually set{width: undefined, height: undefined}on the style attribute.


## Static Non-Image Resources
Therequiresyntax described above can be used to statically include audio, video or document files in your project as well. Most common file types are supported including.mp3,.wav,.mp4,.mov,.html,.pdfand more. Seebundler defaultsfor the full list.

You can add support for other types by adding anassetExtsresolver optionin yourMetro configuration.

A caveat is that videos must use absolute positioning instead offlexGrow, since size info is not currently passed for non-image assets. This limitation doesn't occur for videos that are linked directly into Xcode or the Assets folder for Android.


## Images From Hybrid App's Resources
If you are building a hybrid app (some UIs in React Native, some UIs in platform code) you can still use images that are already bundled into the app.

For images included via Xcode asset catalogs or in the Android drawable folder, use the image name without the extension:

```
<Image  source={{uri: 'app_icon'}}  style={{width: 40, height: 40}}/>
```

For images in the Android assets folder, use theasset:/scheme:

```
<Image  source={{uri: 'asset:/app_icon.png'}}  style={{width: 40, height: 40}}/>
```

These approaches provide no safety checks. It's up to you to guarantee that those images are available in the application. Also you have to specify image dimensions manually.


## Network Images
Many of the images you will display in your app will not be available at compile time, or you will want to load some dynamically to keep the binary size down. Unlike with static resources,you will need to manually specify the dimensions of your image. It's highly recommended that you use https as well in order to satisfyApp Transport Securityrequirements on iOS.

```
// GOOD<Image source={{uri: 'https://reactjs.org/logo-og.png'}}       style={{width: 400, height: 400}} />// BAD<Image source={{uri: 'https://reactjs.org/logo-og.png'}} />
```


### Network Requests for Images
If you would like to set such things as the HTTP-Verb, Headers or a Body along with the image request, you may do this by defining these properties on the source object:

```
<Image  source={{    uri: 'https://reactjs.org/logo-og.png',    method: 'POST',    headers: {      Pragma: 'no-cache',    },    body: 'Your Body goes here',  }}  style={{width: 400, height: 400}}/>
```


## URI Data Images
Sometimes, you might be getting encoded image data from a REST API call. You can use the'data:'URI scheme to use these images. Same as for network resources,you will need to manually specify the dimensions of your image.

This is recommended for very small and dynamic images only, like icons in a list from a DB.

```
// include at least width and height!<Image  style={{    width: 51,    height: 51,    resizeMode: 'contain',  }}  source={{    uri: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==',  }}/>
```


### Cache Control
In some cases you might only want to display an image if it is already in the local cache, i.e. a low resolution placeholder until a higher resolution is available. In other cases you do not care if the image is outdated and are willing to display an outdated image to save bandwidth. Thecachesource property gives you control over how the network layer interacts with the cache.

- default: Use the native platforms default strategy.
- reload: The data for the URL will be loaded from the originating source. No existing cache data should be used to satisfy a URL load request.
- force-cache: The existing cached data will be used to satisfy the request, regardless of its age or expiration date. If there is no existing data in the cache corresponding the request, the data is loaded from the originating source.
- only-if-cached: The existing cache data will be used to satisfy a request, regardless of its age or expiration date. If there is no existing data in the cache corresponding to a URL load request, no attempt is made to load the data from the originating source, and the load is considered to have failed.
```
<Image  source={{    uri: 'https://reactjs.org/logo-og.png',    cache: 'only-if-cached',  }}  style={{width: 400, height: 400}}/>
```


## Local Filesystem Images
SeeCameraRollfor an example of using local resources that are outside ofImages.xcassets.


### Drawable resources
Android supports loadingdrawable resourcesvia thexmlfile type. This means you can usevector drawablesfor rendering icons orshape drawablesfor, well, drawing shapes! You can import and use these resource types the same as any otherstatic resourceorhybrid resource. You have to specify image dimensions manually.

For static drawables that live alongside your JS code, use therequireorimportsyntax (both work the same):

```
<Image  source={require('./img/my_icon.xml')}  style={{width: 40, height: 40}}/>
```

For drawables included in the Android drawable folder (i.e.res/drawable), use the resource name without the extension:

```
<Image  source={{uri: 'my_icon'}}  style={{width: 40, height: 40}}/>
```

The one key difference between drawable resources and other image types is that the asset must be referenced at compile-time of the Android application as Android needs to run theAndroid Asset Packaging Tool (AAPT)to package the asset. Binary XML, the file format AAPT creates, cannot be loaded over the network by Metro. If you change the directory or name of an asset, you will need to rebuild the Android application each time.

Android provides comprehensive documentation on each of the supported drawable resource types in itsDrawable resourcesguide, along with examples of raw XML files. You can utilize tools from Android Studio like theVector Asset Studioto create vector drawables from Scalable Vector Graphic (SVG) and Adobe Photoshop Document (PSD) files.

You should try to avoid referencing other resources in the XML file you create if you want to treat your XML file as a static image resource (i.e. with animportorrequirestatement). If you wish to utilize references to other drawables or attributes, likecolor state listsordimension resources, you should include your drawable as ahybrid resourceand import it by name.


### Best Camera Roll Image
iOS saves multiple sizes for the same image in your Camera Roll, it is very important to pick the one that's as close as possible for performance reasons. You wouldn't want to use the full quality 3264x2448 image as source when displaying a 200x200 thumbnail. If there's an exact match, React Native will pick it, otherwise it's going to use the first one that's at least 50% bigger in order to avoid blur when resizing from a close size. All of this is done by default so you don't have to worry about writing the tedious (and error prone) code to do it yourself.


## Why Not Automatically Size Everything?
In the browserif you don't give a size to an image, the browser is going to render a 0x0 element, download the image, and then render the image based with the correct size. The big issue with this behavior is that your UI is going to jump all around as images load, this makes for a very bad user experience. This is calledCumulative Layout Shift.

In React Nativethis behavior is intentionally not implemented. It is more work for the developer to know the dimensions (or aspect ratio) of the remote image in advance, but we believe that it leads to a better user experience. Static images loaded from the app bundle via therequire('./my-icon.png')syntaxcan be automatically sizedbecause their dimensions are available immediately at the time of mounting.

For example, the result ofrequire('./my-icon.png')might be:

```
{"__packager_asset":true,"uri":"my-icon.png","width":591,"height":573}
```


## Source as an object
In React Native, one interesting decision is that thesrcattribute is namedsourceand doesn't take a string but an object with auriattribute.

```
<Image source={{uri: 'something.jpg'}} />
```

On the infrastructure side, the reason is that it allows us to attach metadata to this object. For example if you are usingrequire('./my-icon.png'), then we add information about its actual location and size (don't rely on this fact, it might change in the future!). This is also future proofing, for example we may want to support sprites at some point, instead of outputting{uri: ...}, we can output{uri: ..., crop: {left: 10, top: 50, width: 20, height: 40}}and transparently support spriting on all the existing call sites.

On the user side, this lets you annotate the object with useful attributes such as the dimension of the image in order to compute the size it's going to be displayed in. Feel free to use it as your data structure to store more information about your image.


## Background Image via Nesting
A common feature request from developers familiar with the web isbackground-image. To handle this use case, you can use the<ImageBackground>component, which has the same props as<Image>, and add whatever children to it you would like to layer on top of it.

You might not want to use<ImageBackground>in some cases, since the implementation is basic. Refer to<ImageBackground>'sdocumentationfor more insight, and create your own custom component when needed.

```
return (  <ImageBackground source={...} style={{width: '100%', height: '100%'}}>    <Text>Inside</Text>  </ImageBackground>);
```

Note that you must specify some width and height style attributes.


## iOS Border Radius Styles
Please note that the following corner specific, border radius style properties might be ignored by iOS's image component:

- borderTopLeftRadius
- borderTopRightRadius
- borderBottomLeftRadius
- borderBottomRightRadius

## Off-thread Decoding
Image decoding can take more than a frame-worth of time. This is one of the major sources of frame drops on the web because decoding is done in the main thread. In React Native, image decoding is done in a different thread. In practice, you already need to handle the case when the image is not downloaded yet, so displaying the placeholder for a few more frames while it is decoding does not require any code change.


## Configuring iOS Image Cache Limits
On iOS, we expose an API to override React Native's default image cache limits. This should be called from within your native AppDelegate code (e.g. withindidFinishLaunchingWithOptions).

```
RCTSetImageCacheLimits(4*1024*1024, 200*1024*1024);
```

Parameters:

In the above code example the image size limit is set to 4 MB and the total cost limit is set to 200 MB.


================================================================================


# Improving User Experience
Source: https://reactnative.dev/docs/improvingux


## Configure text inputs
Entering text on touch phone is a challenge - small screen, software keyboard. But based on what kind of data you need, you can make it easier by properly configuring the text inputs:

- Focus the first field automatically
- Use placeholder text as an example of expected data format
- Enable or disable autocapitalization and autocorrect
- Choose keyboard type (e.g. email, numeric)
- Make sure the return button focuses the next field or submits the form
Check outTextInputdocsfor more configuration options.

- TypeScriptJavaScript
- JavaScript

## Manage layout when keyboard is visible
Software keyboard takes almost half of the screen. If you have interactive elements that can get covered by the keyboard, make sure they are still accessible by using theKeyboardAvoidingViewcomponent.

- TypeScriptJavaScript
- JavaScript

## Make tappable areas larger
On mobile phones it's hard to be very precise when pressing buttons. Make sure all interactive elements are 44x44 or larger. One way to do this is to leave enough space for the element,padding,minWidthandminHeightstyle values can be useful for that. Alternatively, you can usehitSloppropto increase interactive area without affecting the layout. Here's a demo:


## Use Android Ripple
Android API 21+ uses the material design ripple to provide user with feedback when they touch an interactable area on the screen. React Native exposes this through theTouchableNativeFeedbackcomponent. Using this touchable effect instead of opacity or highlight will often make your app feel much more fitting on the platform. That said, you need to be careful when using it because it doesn't work on iOS or on Android API < 21, so you will need to fallback to using one of the other Touchable components on iOS. You can use a library likereact-native-platform-touchableto handle the platform differences for you.


## Screen orientation lock
Multiple screen orientations should work fine by default unless you're usingDimensionsAPI and don't handle orientation changes. If you don't want to support multiple screen orientations, you can lock the screen orientation to either portrait or landscape.

On iOS, in the General tab and Deployment Info section of Xcode enable the Device Orientation you want to support (ensure you have selected iPhone from the Devices menu when making the changes). For Android, open the AndroidManifest.xml file and within the activity element add'android:screenOrientation="portrait"'to lock to portrait or'android:screenOrientation="landscape"'to lock to landscape.

Material DesignandHuman Interface Guidelinesare great resources for learning more about designing for mobile platforms.


================================================================================


# InputAccessoryView
Source: https://reactnative.dev/docs/inputaccessoryview

A component which enables customization of the keyboard input accessory view on iOS. The input accessory view is displayed above the keyboard whenever aTextInputhas focus. This component can be used to create custom toolbars.

To use this component wrap your custom toolbar with the InputAccessoryView component, and set anativeID. Then, pass thatnativeIDas theinputAccessoryViewIDof whateverTextInputyou desire. A basic example:

This component can also be used to create sticky text inputs (text inputs which are anchored to the top of the keyboard). To do this, wrap aTextInputwith theInputAccessoryViewcomponent, and don't set anativeID. For an example, look atInputAccessoryViewExample.js.


## Props

### backgroundColor

### nativeID
An ID which is used to associate thisInputAccessoryViewto specified TextInput(s).


### style
- react-native#18997: Doesn't support multilineTextInput
- react-native#20157: Can't use with a bottom tab bar

================================================================================


# Integration with an Android Fragment
Source: https://reactnative.dev/docs/integration-with-android-fragment

The guide forIntegration with Existing Appsdetails how to integrate a full-screen React Native app into an existing Android app as anActivity.

To use React Native components withinFragmentsin an existing app requires some additional setup.


### 1. Add React Native to your app
Follow the guide forIntegration with Existing Appsuntil the end to make sure you can safely run your React Native app in a full screen Activity.


### 2. Add a FrameLayout for the React Native Fragment
In this example, we're going to use aFrameLayoutto add a React Native Fragment to an Activity. This approach is flexible enough and can be adapted to use React Native in other layouts such as Bottom Sheets or Tab Layouts.

First add a<FrameLayout>with an id, width and height to your Activity's layout (e.g.main_activity.xmlin theres/layoutsfolder). This is the layout you will find to render your React Native Fragment.

```
<FrameLayout    android:id="@+id/react_native_fragment"    android:layout_width="match_parent"    android:layout_height="match_parent" />
```


### 3. Make your host Activity implementDefaultHardwareBackBtnHandler
As your host activity is not aReactActivity, you need to implement theDefaultHardwareBackBtnHandlerinterface to handle the back button press event.
This is required by React Native to handle the back button press event.

Go into your host activity and make sure it implements theDefaultHardwareBackBtnHandlerinterface:

Activity.onBackPressed()has beendeprecatedsince API level 33. Android 16 devices with apps targeting API level 36 this willno longer be calledandOnBackPressedDispatchershould be used instead.

- JavaKotlin
- Kotlin
```
package <your-package-here>import android.os.Bundleimport androidx.appcompat.app.AppCompatActivity+import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler+class MainActivity : AppCompatActivity() {+class MainActivity : AppCompatActivity(), DefaultHardwareBackBtnHandler {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.main_activity)        findViewById<Button>(R.id.sample_button).setOnClickListener {            // Handle button click        }    }+   override fun invokeDefaultOnBackPressed() {+       onBackPressedDispatcher.onBackPressed()+   }}
```

```
package <your-package-here>;import android.os.Bundle;import androidx.appcompat.app.AppCompatActivity;+import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler;-class MainActivity extends AppCompatActivity {+class MainActivity extends AppCompatActivity implements DefaultHardwareBackBtnHandler {    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main_activity);        findViewById(R.id.button_appcompose).setOnClickListener(button -> {            // Handle button click        });    }+   @Override+   public void invokeDefaultOnBackPressed() {+       getOnBackPressedDispatcher().onBackPressed();+   }}
```


### 4. Add a React Native Fragment to the FrameLayout
Finally, we can update the Activity to add a React Native Fragment to the FrameLayout.
In this specific example, we're going to assume that your Activity has a button with idsample_buttonthat when clicked will render a React Native Fragment into the FrameLayout.

Update your Activity'sonCreatemethod as follows:

- JavaKotlin
- Kotlin
```
package <your-package-here>import android.os.Bundleimport androidx.appcompat.app.AppCompatActivity+import com.facebook.react.ReactFragmentimport com.facebook.react.modules.core.DefaultHardwareBackBtnHandlerpublic class MainActivity : AppCompatActivity(), DefaultHardwareBackBtnHandler {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.main_activity)        findViewById<Button>(R.id.sample_button).setOnClickListener {+           val reactNativeFragment = ReactFragment.Builder()+               .setComponentName("HelloWorld")+               .setLaunchOptions(Bundle().apply { putString("message", "my value") })+               .build()+           supportFragmentManager+               .beginTransaction()+               .add(R.id.react_native_fragment, reactNativeFragment)+               .commit()        }    }   override fun invokeDefaultOnBackPressed() {       super.onBackPressed()   }}
```

```
package <your-package-here>;import android.os.Bundle;import androidx.appcompat.app.AppCompatActivity;+import com.facebook.react.ReactFragment;import com.facebook.react.modules.core.DefaultHardwareBackBtnHandler;public class MainActivity extends AppCompatActivity implements DefaultHardwareBackBtnHandler {    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main_activity);        findViewById(R.id.button_appcompose).setOnClickListener(button -> {+           Bundle launchOptions = new Bundle();+           launchOptions.putString("message", "my value");++           ReactFragment fragment = new ReactFragment.Builder()+                   .setComponentName("HelloWorld")+                   .setLaunchOptions(launchOptions)+                   .build();+           getSupportFragmentManager()+                   .beginTransaction()+                   .add(R.id.react_native_fragment, fragment)+                   .commit();        });    }    @Override    public void invokeDefaultOnBackPressed() {        super.onBackPressed();    }}
```

Let's look at the code above.

TheReactFragment.Builder()is used to create a newReactFragmentand then we use thesupportFragmentManagerto add that Fragment to theFrameLayout.

Inside the builder you can customize how the fragment is created:

- setComponentNameis the name of the component you want to render. It's the same string specified in yourindex.jsinside theregisterComponentmethod.
- setLaunchOptionsis an optional method to pass initial props to your component. This is optional and you can remove it if you don't use it.

### 5. Test your integration
Make sure you runyarn startto run the bundler and then run your android app in Android Studio. The app should load the JavaScript/TypeScript code from the development server and display it in your React Native Fragment in the Activity.

Your app should look like this one:


================================================================================


# Integration with Existing Apps
Source: https://reactnative.dev/docs/integration-with-existing-apps

React Native is great when you are starting a new mobile app from scratch. However, it also works well for adding a single view or user flow to existing native applications. With a few steps, you can add new React Native based features, screens, views, etc.

The specific steps are different depending on what platform you're targeting.

- Android (Java & Kotlin)iOS (Objective-C and Swift)
- iOS (Objective-C and Swift)

## Key Concepts
The keys to integrating React Native components into your Android application are to:

- Set up the correct directory structure.
- Install the necessary NPM dependencies.
- Adding React Native to your Gradle configuration.
- Writing the TypeScript code for your first React Native screen.
- Integrate React Native with your Android code using a ReactActivity.
- Testing your integration by running the bundler and seeing your app in action.

## Using the Community Template
While you follow this guide, we suggest you to use theReact Native Community Templateas reference. The template contains aminimal Android appand will help you understanding how to integrate React Native into an existing Android app.


## Prerequisites
Follow the guide onsetting up your development environmentand usingReact Native without a frameworkto configure your development environment for building React Native apps for Android.
This guide also assumes you're familiar with the basics of Android development such as creating Activities and editing theAndroidManifest.xmlfile.


## 1. Set up directory structure
To ensure a smooth experience, create a new folder for your integrated React Native project, thenmove your existing Android projectto the/androidsubfolder.


## 2. Install NPM dependencies
Go to the root directory and run the following command:

```
curl -O https://raw.githubusercontent.com/react-native-community/template/refs/heads/0.83-stable/template/package.json
```

This will copy thepackage.jsonfile from the Community templateto your project.

Next, install the NPM packages by running:

- npmYarn
- Yarn
```
npm install
```

```
yarn install
```

Installation process has created a newnode_modulesfolder. This folder stores all the JavaScript dependencies required to build your project.

Addnode_modules/to your.gitignorefile (here theCommunity default one).


## 3. Adding React Native to your app

### Configuring Gradle
React Native uses the React Native Gradle Plugin to configure your dependencies and project setup.

First, let's edit yoursettings.gradlefile by adding those lines (as suggested from theCommunity template):

```
// Configures the React Native Gradle Settings plugin used for autolinkingpluginManagement { includeBuild("../node_modules/@react-native/gradle-plugin") }plugins { id("com.facebook.react.settings") }extensions.configure(com.facebook.react.ReactSettingsExtension){ ex -> ex.autolinkLibrariesFromCommand() }// If using .gradle.kts files:// extensions.configure<com.facebook.react.ReactSettingsExtension> { autolinkLibrariesFromCommand() }includeBuild("../node_modules/@react-native/gradle-plugin")// Include your existing Gradle modules here.// include(":app")
```

Then you need to open your top levelbuild.gradleand include this line (as suggested from theCommunity template):

```
buildscript {    repositories {        google()        mavenCentral()    }    dependencies {        classpath("com.android.tools.build:gradle:7.3.1")+       classpath("com.facebook.react:react-native-gradle-plugin")    }}
```

This makes sure the React Native Gradle Plugin (RNGP) is available inside your project.
Finally, add those lines inside your Applications'sbuild.gradlefile (it's a differentbuild.gradlefile usually inside yourappfolder - you can use theCommunity template file as reference):

```
apply plugin: "com.android.application"+apply plugin: "com.facebook.react"repositories {    mavenCentral()}dependencies {    // Other dependencies here+   // Note: we intentionally don't specify the version number here as RNGP will take care of it.+   // If you don't use the RNGP, you'll have to specify version manually.+   implementation("com.facebook.react:react-android")+   implementation("com.facebook.react:hermes-android")}+react {+   // Needed to enable Autolinking - https://github.com/react-native-community/cli/blob/master/docs/autolinking.md+   autolinkLibrariesWithApp()+}
```

Finally, open your applicationgradle.propertiesfiles and add the following line (here theCommunity template file as reference):

```
+reactNativeArchitectures=armeabi-v7a,arm64-v8a,x86,x86_64+newArchEnabled=true+hermesEnabled=true
```


### Configuring your manifest
First, make sure you have the Internet permission in yourAndroidManifest.xml:

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">+   <uses-permission android:name="android.permission.INTERNET" />    <application      android:name=".MainApplication">    </application></manifest>
```

Then you need to enablecleartext trafficin yourdebugAndroidManifest.xml:

```
<?xml version="1.0" encoding="utf-8"?><manifest xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools">    <application+       android:usesCleartextTraffic="true"+       tools:targetApi="28"    /></manifest>
```

As usual, here the AndroidManifest.xml file from the Community template to use as a reference:mainanddebug.

This is needed as your application will communicate with your local bundler,Metro, via HTTP.

Make sure you add this only to yourdebugmanifest.


## 4. Writing the TypeScript Code
Now we will actually modify the native Android application to integrate React Native.

The first bit of code we will write is the actual React Native code for the new screen that will be integrated into our application.


### Create aindex.jsfile
First, create an emptyindex.jsfile in the root of your React Native project.

index.jsis the starting point for React Native applications, and it is always required. It can be a small file thatimports other file that are part of your React Native component or application, or it can contain all the code that is needed for it.

Our index.js should look as follows (here theCommunity template file as reference):

```
import {AppRegistry} from 'react-native';import App from './App';AppRegistry.registerComponent('HelloWorld', () => App);
```


### Create aApp.tsxfile
Let's create anApp.tsxfile. This is aTypeScriptfile that can haveJSXexpressions. It contains the root React Native component that we will integrate into our Android application (link):

```
import React from 'react';import {  SafeAreaView,  ScrollView,  StatusBar,  StyleSheet,  Text,  useColorScheme,  View,} from 'react-native';import {  Colors,  DebugInstructions,  Header,  ReloadInstructions,} from 'react-native/Libraries/NewAppScreen';function App(): React.JSX.Element {  const isDarkMode = useColorScheme() === 'dark';  const backgroundStyle = {    backgroundColor: isDarkMode ? Colors.darker : Colors.lighter,  };  return (    <SafeAreaView style={backgroundStyle}>      <StatusBar        barStyle={isDarkMode ? 'light-content' : 'dark-content'}        backgroundColor={backgroundStyle.backgroundColor}      />      <ScrollView        contentInsetAdjustmentBehavior="automatic"        style={backgroundStyle}>        <Header />        <View          style={{            backgroundColor: isDarkMode              ? Colors.black              : Colors.white,            padding: 24,          }}>          <Text style={styles.title}>Step One</Text>          <Text>            Edit <Text style={styles.bold}>App.tsx</Text> to            change this screen and see your edits.          </Text>          <Text style={styles.title}>See your changes</Text>          <ReloadInstructions />          <Text style={styles.title}>Debug</Text>          <DebugInstructions />        </View>      </ScrollView>    </SafeAreaView>  );}const styles = StyleSheet.create({  title: {    fontSize: 24,    fontWeight: '600',  },  bold: {    fontWeight: '700',  },});export default App;
```

Here is theCommunity template file as reference.


## 5. Integrating with your Android code
We now need to add some native code in order to start the React Native runtime and tell it to render our React components.


### Updating your Application class
First, we need to update yourApplicationclass to properly initialize React Native as follows:

- JavaKotlin
- Kotlin
```
package <your-package-here>;import android.app.Application;+import com.facebook.react.PackageList;+import com.facebook.react.ReactApplication;+import com.facebook.react.ReactHost;+import com.facebook.react.ReactNativeHost;+import com.facebook.react.ReactPackage;+import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;+import com.facebook.react.defaults.DefaultReactHost;+import com.facebook.react.defaults.DefaultReactNativeHost;+import com.facebook.soloader.SoLoader;+import com.facebook.react.soloader.OpenSourceMergedSoMapping+import java.util.List;-class MainApplication extends Application {+class MainApplication extends Application implements ReactApplication {+ @Override+ public ReactNativeHost getReactNativeHost() {+   return new DefaultReactNativeHost(this) {+     @Override+     protected List<ReactPackage> getPackages() { return new PackageList(this).getPackages(); }+     @Override+     protected String getJSMainModuleName() { return "index"; }+     @Override+     public boolean getUseDeveloperSupport() { return BuildConfig.DEBUG; }+     @Override+     protected boolean isNewArchEnabled() { return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED; }+     @Override+     protected Boolean isHermesEnabled() { return BuildConfig.IS_HERMES_ENABLED; }+   };+ }+ @Override+ public ReactHost getReactHost() {+   return DefaultReactHost.getDefaultReactHost(getApplicationContext(), getReactNativeHost());+ }  @Override  public void onCreate() {    super.onCreate();+   SoLoader.init(this, OpenSourceMergedSoMapping);+   if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {+     DefaultNewArchitectureEntryPoint.load();+   }  }}
```

```
// package <your-package-here>import android.app.Application+import com.facebook.react.PackageList+import com.facebook.react.ReactApplication+import com.facebook.react.ReactHost+import com.facebook.react.ReactNativeHost+import com.facebook.react.ReactPackage+import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load+import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost+import com.facebook.react.defaults.DefaultReactNativeHost+import com.facebook.soloader.SoLoader+import com.facebook.react.soloader.OpenSourceMergedSoMapping-class MainApplication : Application() {+class MainApplication : Application(), ReactApplication {+ override val reactNativeHost: ReactNativeHost =+      object : DefaultReactNativeHost(this) {+        override fun getPackages(): List<ReactPackage> = PackageList(this).packages+        override fun getJSMainModuleName(): String = "index"+        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG+        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED+        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED+      }+ override val reactHost: ReactHost+   get() = getDefaultReactHost(applicationContext, reactNativeHost)  override fun onCreate() {    super.onCreate()+   SoLoader.init(this, OpenSourceMergedSoMapping)+   if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {+     load()+   }  }}
```

As usual, here theMainApplication.ktCommunity template file as reference.

Finally, we need to create a newActivitythat will extendReactActivityand host the React Native code. This activity will be responsible for starting the React Native runtime and rendering the React component.

- JavaKotlin
- Kotlin
```
// package <your-package-here>;import com.facebook.react.ReactActivity;import com.facebook.react.ReactActivityDelegate;import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;import com.facebook.react.defaults.DefaultReactActivityDelegate;public class MyReactActivity extends ReactActivity {    @Override    protected String getMainComponentName() {        return "HelloWorld";    }    @Override    protected ReactActivityDelegate createReactActivityDelegate() {        return new DefaultReactActivityDelegate(this, getMainComponentName(), DefaultNewArchitectureEntryPoint.getFabricEnabled());    }}
```

```
// package <your-package-here>import com.facebook.react.ReactActivityimport com.facebook.react.ReactActivityDelegateimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.fabricEnabledimport com.facebook.react.defaults.DefaultReactActivityDelegateclass MyReactActivity : ReactActivity() {    override fun getMainComponentName(): String = "HelloWorld"    override fun createReactActivityDelegate(): ReactActivityDelegate =        DefaultReactActivityDelegate(this, mainComponentName, fabricEnabled)}
```

As usual, here theMainActivity.ktCommunity template file as reference.

Whenever you create a new Activity, you need to add it to yourAndroidManifest.xmlfile. You also need set the theme ofMyReactActivitytoTheme.AppCompat.Light.NoActionBar(or to any non-ActionBar theme) as otherwise your application will render an ActionBar on top of your React Native screen:

```
<manifest xmlns:android="http://schemas.android.com/apk/res/android">    <uses-permission android:name="android.permission.INTERNET" />    <application      android:name=".MainApplication">+     <activity+       android:name=".MyReactActivity"+       android:label="@string/app_name"+       android:theme="@style/Theme.AppCompat.Light.NoActionBar">+     </activity>    </application></manifest>
```

Now your activity is ready to run some JavaScript code.


## 6. Test your integration
You have completed all the basic steps to integrate React Native with your application. Now we will start theMetro bundlerto build your TypeScript application code into a bundle. Metro's HTTP server shares the bundle fromlocalhoston your developer environment to a simulator or device. This allows forhot reloading.

First, you need to create ametro.config.jsfile in the root of your project as follows:

```
const {getDefaultConfig} = require('@react-native/metro-config');module.exports = getDefaultConfig(__dirname);
```

You can checkout themetro.config.jsfilefrom the Community template file as reference.

Once you have the configuration file in place, you can run the bundler. Run the following command in the root directory of your project:

- npmYarn
- Yarn
```
npm start
```

```
yarn start
```

Now build and run your Android app as normal.

Once you reach your React-powered Activity inside the app, it should load the JavaScript code from the development server and display:


### Creating a release build in Android Studio
You can use Android Studio to create your release builds too! It’s as quick as creating release builds of your previously-existing native Android app.

The React Native Gradle Plugin will take care of bundling the JS code inside your APK/App Bundle.

If you're not using Android Studio, you can create a release build with:

```
cd android# For a Release APK./gradlew :app:assembleRelease# For a Release AAB./gradlew :app:bundleRelease
```


### Now what?
At this point you can continue developing your app as usual. Refer to ourdebugginganddeploymentdocs to learn more about working with React Native.


## Key Concepts
The keys to integrating React Native components into your iOS application are to:

- Set up the correct directory structure.
- Install the necessary NPM dependencies.
- Adding React Native to your Podfile configuration.
- Writing the TypeScript code for your first React Native screen.
- Integrate React Native with your iOS code using aRCTRootView.
- Testing your integration by running the bundler and seeing your app in action.

## Using the Community Template
While you follow this guide, we suggest you to use theReact Native Community Templateas reference. The template contains aminimal iOS appand will help you understanding how to integrate React Native into an existing iOS app.


## Prerequisites
Follow the guide onsetting up your development environmentand usingReact Native without a frameworkto configure your development environment for building React Native apps for iOS.
This guide also assumes you're familiar with the basics of iOS development such as creating aUIViewControllerand editing thePodfilefile.


### 1. Set up directory structure
To ensure a smooth experience, create a new folder for your integrated React Native project, thenmove your existing iOS projectto the/iossubfolder.


## 2. Install NPM dependencies
Go to the root directory and run the following command:

```
curl -O https://raw.githubusercontent.com/react-native-community/template/refs/heads/0.83-stable/template/package.json
```

This will copy thepackage.jsonfile from the Community templateto your project.

Next, install the NPM packages by running:

- npmYarn
- Yarn
```
npm install
```

```
yarn install
```

Installation process has created a newnode_modulesfolder. This folder stores all the JavaScript dependencies required to build your project.

Addnode_modules/to your.gitignorefile (here theCommunity default one).


### 3. Install Development tools

### Command Line Tools for Xcode
Install the Command Line Tools. ChooseSettings... (or Preferences...)in the Xcode menu. Go to the Locations panel and install the tools by selecting the most recent version in the Command Line Tools dropdown.


### CocoaPods
CocoaPodsis a package management tool for iOS and macOS development. We use it to add the actual React Native framework code locally into your current project.

We recommend installing CocoaPods usingHomebrew:

```
brew install cocoapods
```


## 4. Adding React Native to your app

### Configuring CocoaPods
To configure CocoaPods, we need two files:

- AGemfilethat defines which Ruby dependencies we need.
- APodfilethat defines how to properly install our dependencies.
For theGemfile, go to the root directory of your project and run this command

```
curl -O https://raw.githubusercontent.com/react-native-community/template/refs/heads/0.83-stable/template/Gemfile
```

This will download the Gemfile from the template.

If you created your project with Xcode 16, you need to update the Gemfile as it follows:diff-gem 'cocoapods', '>= 1.13', '!= 1.15.0', '!= 1.15.1'+gem 'cocoapods', '1.16.2'gem 'activesupport', '>= 6.1.7.5', '!= 7.1.0'-gem 'xcodeproj', '< 1.26.0'+gem 'xcodeproj', '1.27.0'Xcode 16 generates a project in a slightly different ways from previous versions of Xcode, and you need the latest CocoaPods and Xcodeproj gems to make it work properly.

```
-gem 'cocoapods', '>= 1.13', '!= 1.15.0', '!= 1.15.1'+gem 'cocoapods', '1.16.2'gem 'activesupport', '>= 6.1.7.5', '!= 7.1.0'-gem 'xcodeproj', '< 1.26.0'+gem 'xcodeproj', '1.27.0'
```

Xcode 16 generates a project in a slightly different ways from previous versions of Xcode, and you need the latest CocoaPods and Xcodeproj gems to make it work properly.

Similarly, for thePodfile, go to theiosfolder of your project and run

```
curl -O https://raw.githubusercontent.com/react-native-community/template/refs/heads/0.83-stable/template/ios/Podfile
```

Please use the Community Template as a reference point for theGemfileand for thePodfile.

Remember to changethis line.

Now, we need to run a couple of extra commands to install the Ruby gems and the Pods.
Navigate to theiosfolder and run the following commands:

```
bundle installbundle exec pod install
```

The first command will install the Ruby dependencies and the second command will actually integrate the React Native code in your application so that your iOS files can import the React Native headers.


## 5. Writing the TypeScript Code
Now we will actually modify the native iOS application to integrate React Native.

The first bit of code we will write is the actual React Native code for the new screen that will be integrated into our application.


### Create aindex.jsfile
First, create an emptyindex.jsfile in the root of your React Native project.

index.jsis the starting point for React Native applications, and it is always required. It can be a small file thatimports other file that are part of your React Native component or application, or it can contain all the code that is needed for it.

Ourindex.jsshould look as follows (here theCommunity template file as reference):

```
import {AppRegistry} from 'react-native';import App from './App';AppRegistry.registerComponent('HelloWorld', () => App);
```


### Create aApp.tsxfile
Let's create anApp.tsxfile. This is aTypeScriptfile that can haveJSXexpressions. It contains the root React Native component that we will integrate into our iOS application (link):

```
import React from 'react';import {  SafeAreaView,  ScrollView,  StatusBar,  StyleSheet,  Text,  useColorScheme,  View,} from 'react-native';import {  Colors,  DebugInstructions,  Header,  ReloadInstructions,} from 'react-native/Libraries/NewAppScreen';function App(): React.JSX.Element {  const isDarkMode = useColorScheme() === 'dark';  const backgroundStyle = {    backgroundColor: isDarkMode ? Colors.darker : Colors.lighter,  };  return (    <SafeAreaView style={backgroundStyle}>      <StatusBar        barStyle={isDarkMode ? 'light-content' : 'dark-content'}        backgroundColor={backgroundStyle.backgroundColor}      />      <ScrollView        contentInsetAdjustmentBehavior="automatic"        style={backgroundStyle}>        <Header />        <View          style={{            backgroundColor: isDarkMode              ? Colors.black              : Colors.white,            padding: 24,          }}>          <Text style={styles.title}>Step One</Text>          <Text>            Edit <Text style={styles.bold}>App.tsx</Text> to            change this screen and see your edits.          </Text>          <Text style={styles.title}>See your changes</Text>          <ReloadInstructions />          <Text style={styles.title}>Debug</Text>          <DebugInstructions />        </View>      </ScrollView>    </SafeAreaView>  );}const styles = StyleSheet.create({  title: {    fontSize: 24,    fontWeight: '600',  },  bold: {    fontWeight: '700',  },});export default App;
```

Here is theCommunity template file as reference.


## 5. Integrating with your iOS code
We now need to add some native code in order to start the React Native runtime and tell it to render our React components.


### Requirements
React Native initialization is now unbound to any specific part of an iOS app.

React Native can be initialized using a class calledRCTReactNativeFactory, that takes care of handling the React Native lifecycle for you.

Once the class is initialized, you can either start a React Native view providing aUIWindowobject, or you can ask for the factory to generate aUIViewthat you can load in anyUIViewController.

In the following example, we will create a ViewController that can load a React Native view as it'sview.

Create a new file from template (⌘+N) and choose the Cocoa Touch Class template.

Make sure to selectUIViewControlleras the "Subclass of" field.

- ObjectiveCSwift
- Swift
Now open theReactViewController.mfile and apply the following changesReactViewController.m#import "ReactViewController.h"+#import <React/RCTBundleURLProvider.h>+#import <RCTReactNativeFactory.h>+#import <RCTDefaultReactNativeFactoryDelegate.h>+#import <RCTAppDependencyProvider.h>@interface ReactViewController ()@end+@interface ReactNativeFactoryDelegate: RCTDefaultReactNativeFactoryDelegate+@end-@implementation ReactViewController+@implementation ReactViewController {+RCTReactNativeFactory *_factory;+id<RCTReactNativeFactoryDelegate> _factoryDelegate;+}- (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view.+_factoryDelegate = [ReactNativeFactoryDelegate new];+_factoryDelegate.dependencyProvider = [RCTAppDependencyProvider new];+_factory = [[RCTReactNativeFactory alloc] initWithDelegate:_factoryDelegate];+self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld"];}@end+@implementation ReactNativeFactoryDelegate++- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge+{+return [self bundleURL];+}++- (NSURL *)bundleURL+{+#if DEBUG+return [RCTBundleURLProvider.sharedSettings jsBundleURLForBundleRoot:@"index"];+#else+return [NSBundle.mainBundle URLForResource:@"main" withExtension:@"jsbundle"];+#endif+}@end

```
#import "ReactViewController.h"+#import <React/RCTBundleURLProvider.h>+#import <RCTReactNativeFactory.h>+#import <RCTDefaultReactNativeFactoryDelegate.h>+#import <RCTAppDependencyProvider.h>@interface ReactViewController ()@end+@interface ReactNativeFactoryDelegate: RCTDefaultReactNativeFactoryDelegate+@end-@implementation ReactViewController+@implementation ReactViewController {+  RCTReactNativeFactory *_factory;+  id<RCTReactNativeFactoryDelegate> _factoryDelegate;+} - (void)viewDidLoad {     [super viewDidLoad];     // Do any additional setup after loading the view.+    _factoryDelegate = [ReactNativeFactoryDelegate new];+    _factoryDelegate.dependencyProvider = [RCTAppDependencyProvider new];+    _factory = [[RCTReactNativeFactory alloc] initWithDelegate:_factoryDelegate];+    self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld"]; }@end+@implementation ReactNativeFactoryDelegate++- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge+{+  return [self bundleURL];+}++- (NSURL *)bundleURL+{+#if DEBUG+  return [RCTBundleURLProvider.sharedSettings jsBundleURLForBundleRoot:@"index"];+#else+  return [NSBundle.mainBundle URLForResource:@"main" withExtension:@"jsbundle"];+#endif+}@end
```

Now open theReactViewController.swiftfile and apply the following changesReactViewController.swiftimport UIKit+import React+import React_RCTAppDelegate+import ReactAppDependencyProviderclass ReactViewController: UIViewController {+var reactNativeFactory: RCTReactNativeFactory?+var reactNativeFactoryDelegate: RCTReactNativeFactoryDelegate?override func viewDidLoad() {super.viewDidLoad()+reactNativeFactoryDelegate = ReactNativeDelegate()+reactNativeFactoryDelegate!.dependencyProvider = RCTAppDependencyProvider()+reactNativeFactory = RCTReactNativeFactory(delegate: reactNativeFactoryDelegate!)+view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld")}}+class ReactNativeDelegate: RCTDefaultReactNativeFactoryDelegate {+override func sourceURL(for bridge: RCTBridge) -> URL? {+self.bundleURL()+}++override func bundleURL() -> URL? {+#if DEBUG+RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")+#else+Bundle.main.url(forResource: "main", withExtension: "jsbundle")+#endif+}++}

```
import UIKit+import React+import React_RCTAppDelegate+import ReactAppDependencyProviderclass ReactViewController: UIViewController {+  var reactNativeFactory: RCTReactNativeFactory?+  var reactNativeFactoryDelegate: RCTReactNativeFactoryDelegate?  override func viewDidLoad() {    super.viewDidLoad()+    reactNativeFactoryDelegate = ReactNativeDelegate()+    reactNativeFactoryDelegate!.dependencyProvider = RCTAppDependencyProvider()+    reactNativeFactory = RCTReactNativeFactory(delegate: reactNativeFactoryDelegate!)+    view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld")  }}+class ReactNativeDelegate: RCTDefaultReactNativeFactoryDelegate {+    override func sourceURL(for bridge: RCTBridge) -> URL? {+      self.bundleURL()+    }++    override func bundleURL() -> URL? {+      #if DEBUG+      RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")+      #else+      Bundle.main.url(forResource: "main", withExtension: "jsbundle")+      #endif+    }++}
```

Finally, we can present our React Native view. To do so, we need a new View Controller that can host a view in which we can load the JS content.
We already have the initialViewController, and we can make it present theReactViewController. There are several ways to do so, depending on your app. For this example, we assume that you have a button that presents React Native modally.

- ObjectiveCSwift
- Swift
```
#import "ViewController.h"+#import "ReactViewController.h"@interface ViewController ()@end- @implementation ViewController+@implementation ViewController {+  ReactViewController *reactViewController;+} - (void)viewDidLoad {   [super viewDidLoad];   // Do any additional setup after loading the view.   self.view.backgroundColor = UIColor.systemBackgroundColor;+  UIButton *button = [UIButton new];+  [button setTitle:@"Open React Native" forState:UIControlStateNormal];+  [button setTitleColor:UIColor.systemBlueColor forState:UIControlStateNormal];+  [button setTitleColor:UIColor.blueColor forState:UIControlStateHighlighted];+  [button addTarget:self action:@selector(presentReactNative) forControlEvents:UIControlEventTouchUpInside];+  [self.view addSubview:button];+  button.translatesAutoresizingMaskIntoConstraints = NO;+  [NSLayoutConstraint activateConstraints:@[+    [button.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],+    [button.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],+    [button.centerYAnchor constraintEqualToAnchor:self.view.centerYAnchor],+    [button.centerXAnchor constraintEqualToAnchor:self.view.centerXAnchor],+  ]]; }+- (void)presentReactNative+{+  if (reactViewController == NULL) {+    reactViewController = [ReactViewController new];+  }+  [self presentViewController:reactViewController animated:YES];+}@end
```

```
import UIKitclass ViewController: UIViewController {+  var reactViewController: ReactViewController?  override func viewDidLoad() {    super.viewDidLoad()    // Do any additional setup after loading the view.    self.view.backgroundColor = .systemBackground+    let button = UIButton()+    button.setTitle("Open React Native", for: .normal)+    button.setTitleColor(.systemBlue, for: .normal)+    button.setTitleColor(.blue, for: .highlighted)+    button.addAction(UIAction { [weak self] _ in+      guard let self else { return }+      if reactViewController == nil {+       reactViewController = ReactViewController()+      }+      present(reactViewController!, animated: true)+    }, for: .touchUpInside)+    self.view.addSubview(button)++    button.translatesAutoresizingMaskIntoConstraints = false+    NSLayoutConstraint.activate([+      button.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),+      button.trailingAnchor.constraint(equalTo: self.view.trailingAnchor),+      button.centerXAnchor.constraint(equalTo: self.view.centerXAnchor),+      button.centerYAnchor.constraint(equalTo: self.view.centerYAnchor),+    ])  }}
```

Make sure to disable the Sandbox scripting. To achieve this, in Xcode, click on your app, then on build settings. Filter for script and set theUser Script SandboxingtoNO. This step is needed to properly switch between the Debug and Release version of theHermes enginethat we ship with React Native.

Finally, make sure to add theUIViewControllerBasedStatusBarAppearancekey into yourInfo.plistfile, with value ofNO.


## 6. Test your integration
You have completed all the basic steps to integrate React Native with your application. Now we will start theMetro bundlerto build your TypeScript application code into a bundle. Metro's HTTP server shares the bundle fromlocalhoston your developer environment to a simulator or device. This allows forhot reloading.

First, you need to create ametro.config.jsfile in the root of your project as follows:

```
const {getDefaultConfig} = require('@react-native/metro-config');module.exports = getDefaultConfig(__dirname);
```

You can checkout themetro.config.jsfilefrom the Community template file as reference.

Then, you need to create a.watchmanconfigfile in the root of your project. The file must contain an empty json object:

```
echo {} > .watchmanconfig
```

Once you have the configuration file in place, you can run the bundler. Run the following command in the root directory of your project:

- npmYarn
- Yarn
```
npm start
```

```
yarn start
```

Now build and run your iOS app as normal.

Once you reach your React-powered Activity inside the app, it should load the JavaScript code from the development server and display:


### Creating a release build in Xcode
You can use Xcode to create your release builds too! The only additional step is to add a script that is executed when the app is built to package your JS and images into the iOS application.

- In Xcode, select your application
- Click onBuild Phases
- Click on the+in the top left corner and selectNew Run Script Phase
- Click on theRun Scriptline and rename the Script toBundle React Native code and images
- Paste in the text box the following script
```
set -eWITH_ENVIRONMENT="$REACT_NATIVE_PATH/scripts/xcode/with-environment.sh"REACT_NATIVE_XCODE="$REACT_NATIVE_PATH/scripts/react-native-xcode.sh"/bin/sh -c "$WITH_ENVIRONMENT $REACT_NATIVE_XCODE"
```

- Drag and drop the script before the one called[CP] Embed Pods Frameworks.
Now, if you build your app for Release, it will work as expected.


## 7. Passing initial props to the React Native view
In some case, you'd like to pass some information from the Native app to JavaScript. For example, you might want to pass the user id of the currently logged user to React Native, together with a token that can be used to retrieve information from a database.

This is possible by using theinitialPropertiesparameter of theview(withModuleName:initialProperty)overload of theRCTReactNativeFactoryclass. The following steps shows you how to do it.


### Update the App.tsx file to read the initial properties.
Open theApp.tsxfile and add the following code:

```
import {  Colors,  DebugInstructions,  Header,  ReloadInstructions,} from 'react-native/Libraries/NewAppScreen';-function App(): React.JSX.Element {+function App(props): React.JSX.Element {  const isDarkMode = useColorScheme() === 'dark';  const backgroundStyle = {    backgroundColor: isDarkMode ? Colors.darker : Colors.lighter,  };  return (    <SafeAreaView style={backgroundStyle}>      <StatusBar        barStyle={isDarkMode ? 'light-content' : 'dark-content'}        backgroundColor={backgroundStyle.backgroundColor}      />      <ScrollView        contentInsetAdjustmentBehavior="automatic"        style={backgroundStyle}>        <Header />-       <View-         style={{-           backgroundColor: isDarkMode-             ? Colors.black-             : Colors.white,-           padding: 24,-         }}>-         <Text style={styles.title}>Step One</Text>-         <Text>-           Edit <Text style={styles.bold}>App.tsx</Text> to-           change this screen and see your edits.-         </Text>-         <Text style={styles.title}>See your changes</Text>-         <ReloadInstructions />-         <Text style={styles.title}>Debug</Text>-         <DebugInstructions />+         <Text style={styles.title}>UserID: {props.userID}</Text>+         <Text style={styles.title}>Token: {props.token}</Text>        </View>      </ScrollView>    </SafeAreaView>  );}const styles = StyleSheet.create({  title: {    fontSize: 24,    fontWeight: '600',+   marginLeft: 20,  },  bold: {    fontWeight: '700',  },});export default App;
```

These changes will tell React Native that your App component is now accepting some properties. TheRCTreactNativeFactorywill take care of passing them to the component when it's rendered.


### Update the Native code to pass the initial properties to JavaScript.
- ObjectiveCSwift
- Swift
Modify theReactViewController.mmto pass the initial properties to JavaScript.ReactViewController.mm- (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view._factoryDelegate = [ReactNativeFactoryDelegate new];_factoryDelegate.dependencyProvider = [RCTAppDependencyProvider new];_factory = [[RCTReactNativeFactory alloc] initWithDelegate:_factoryDelegate];-self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld"];+self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld" initialProperties:@{+@"userID": @"12345678",+@"token": @"secretToken"+}];}

```
 - (void)viewDidLoad {   [super viewDidLoad];   // Do any additional setup after loading the view.   _factoryDelegate = [ReactNativeFactoryDelegate new];   _factoryDelegate.dependencyProvider = [RCTAppDependencyProvider new];   _factory = [[RCTReactNativeFactory alloc] initWithDelegate:_factoryDelegate];-  self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld"];+  self.view = [_factory.rootViewFactory viewWithModuleName:@"HelloWorld" initialProperties:@{+    @"userID": @"12345678",+    @"token": @"secretToken"+  }];}
```

Modify theReactViewController.swiftto pass the initial properties to the React Native view.ReactViewController.swiftoverride func viewDidLoad() {super.viewDidLoad()reactNativeFactoryDelegate = ReactNativeDelegate()reactNativeFactoryDelegate!.dependencyProvider = RCTAppDependencyProvider()reactNativeFactory = RCTReactNativeFactory(delegate: reactNativeFactoryDelegate!)-view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld")+view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld" initialProperties: [+"userID": "12345678",+"token": "secretToken"+])}}

```
  override func viewDidLoad() {    super.viewDidLoad()    reactNativeFactoryDelegate = ReactNativeDelegate()    reactNativeFactoryDelegate!.dependencyProvider = RCTAppDependencyProvider()    reactNativeFactory = RCTReactNativeFactory(delegate: reactNativeFactoryDelegate!)-   view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld")+   view = reactNativeFactory!.rootViewFactory.view(withModuleName: "HelloWorld" initialProperties: [+     "userID": "12345678",+     "token": "secretToken"+])  }}
```

- Run your app once again. You should see the following screen after you present theReactViewController:

## Now what?
At this point you can continue developing your app as usual. Refer to ourdebugginganddeploymentdocs to learn more about working with React Native.


================================================================================


# 🗑️ InteractionManager
Source: https://reactnative.dev/docs/interactionmanager

Avoid long-running work and userequestIdleCallbackinstead.

InteractionManager allows long-running work to be scheduled after any interactions/animations have completed. In particular, this allows JavaScript animations to run smoothly.

Applications can schedule tasks to run after interactions with the following:

```
InteractionManager.runAfterInteractions(() => {  // ...long-running synchronous task...});
```

Compare this to other scheduling alternatives:

- requestAnimationFrame()for code that animates a view over time.
- setImmediate/setTimeout()run code later, note this may delay animations.
- runAfterInteractions()run code later, without delaying active animations.
The touch handling system considers one or more active touches to be an 'interaction' and will delayrunAfterInteractions()callbacks until all touches have ended or been cancelled.

InteractionManager also allows applications to register animations by creating an interaction 'handle' on animation start, and clearing it upon completion:

```
const handle = InteractionManager.createInteractionHandle();// run animation... (`runAfterInteractions` tasks are queued)// later, on animation completion:InteractionManager.clearInteractionHandle(handle);// queued tasks run if all handles were cleared
```

runAfterInteractionstakes either a plain callback function, or aPromiseTaskobject with agenmethod that returns aPromise. If aPromiseTaskis supplied, then it is fully resolved (including asynchronous dependencies that also schedule more tasks viarunAfterInteractions) before starting on the next task that might have been queued up synchronously earlier.

By default, queued tasks are executed together in a loop in onesetImmediatebatch. IfsetDeadlineis called with a positive number, then tasks will only be executed until the deadline (in terms of js event loop run time) approaches, at which point execution will yield via setTimeout, allowing events such as touches to start interactions and block queued tasks from executing, making apps more responsive.


## Example

### Basic
- TypeScriptJavaScript
- JavaScript

### Advanced
- TypeScriptJavaScript
- JavaScript

## Methods

### runAfterInteractions()
```
static runAfterInteractions(task?: (() => any) | SimpleTask | PromiseTask);
```

Schedule a function to run after all interactions have completed. Returns a cancellable "promise".


### createInteractionHandle()
```
static createInteractionHandle(): Handle;
```

Notify manager that an interaction has started.


### clearInteractionHandle()
```
static clearInteractionHandle(handle: Handle);
```

Notify manager that an interaction has completed.


### setDeadline()
```
static setDeadline(deadline: number);
```

A positive number will use setTimeout to schedule any tasks after the eventLoopRunningTime hits the deadline value, otherwise all tasks will be executed in one setImmediate batch (default).


================================================================================


# React Fundamentals
Source: https://reactnative.dev/docs/intro-react

React Native runs onReact, a popular open source library for building user interfaces with JavaScript. To make the most of React Native, it helps to understand React itself. This section can get you started or can serve as a refresher course.

We’re going to cover the core concepts behind React:

- components
- JSX
- props
- state
If you want to dig deeper, we encourage you to check outReact’s official documentation.


## Your first component
The rest of this introduction to React uses cats in its examples: friendly, approachable creatures that need names and a cafe to work in. Here is your very first Cat component:

Here is how you do it: To define yourCatcomponent, first use JavaScript’simportto import React and React Native’sTextCore Component:

```
import React from 'react';import {Text} from 'react-native';
```

Your component starts as a function:

```
const Cat = () => {};
```

You can think of components as blueprints. Whatever a function component returns is rendered as aReact element.React elements let you describe what you want to see on the screen.

Here theCatcomponent will render a<Text>element:

```
const Cat = () => {  return <Text>Hello, I am your cat!</Text>;};
```

You can export your function component with JavaScript’sexport defaultfor use throughout your app like so:

```
const Cat = () => {  return <Text>Hello, I am your cat!</Text>;};export default Cat;
```

This is one of many ways to export your component. This kind of export works well with the Snack Player. However, depending on your app’s file structure, you might need to use a different convention. Thishandy cheatsheet on JavaScript imports and exportscan help.

Now take a closer look at thatreturnstatement.<Text>Hello, I am your cat!</Text>is using a kind of JavaScript syntax that makes writing elements convenient: JSX.


## JSX
React and React Native useJSX,a syntax that lets you write elements inside JavaScript like so:<Text>Hello, I am your cat!</Text>. The React docs havea comprehensive guide to JSXyou can refer to learn even more. Because JSX is JavaScript, you can use variables inside it. Here you are declaring a name for the cat,name, and embedding it with curly braces inside<Text>.

Any JavaScript expression will work between curly braces, including function calls like{getFullName("Rum", "Tum", "Tugger")}:

- TypeScriptJavaScript
- JavaScript
You can think of curly braces as creating a portal into JS functionality in your JSX!

Because JSX is included in the React library, it won’t work if you don’t haveimport React from 'react'at the top of your file!


## Custom Components
You’ve already metReact Native’s Core Components. React lets you nest these components inside each other to create new components. These nestable, reusable components are at the heart of the React paradigm.

For example, you can nestTextandTextInputinside aViewbelow, and React Native will render them together:

- AndroidWeb
- Web
If you’re familiar with web development,<View>and<Text>might remind you of HTML! You can think of them as the<div>and<p>tags of application development.

On Android, you usually put your views insideLinearLayout,FrameLayout,RelativeLayout, etc. to define how the view’s children will be arranged on the screen. In React Native,Viewuses Flexbox for its children’s layout. You can learn more inour guide to layout with Flexbox.

You can render this component multiple times and in multiple places without repeating your code by using<Cat>:

Any component that renders other components is aparent component.Here,Cafeis the parent component and eachCatis achild component.

You can put as many cats in your cafe as you like. Each<Cat>renders a unique element—which you can customize with props.


## Props
Propsis short for “properties”. Props let you customize React components. For example, here you pass each<Cat>a differentnameforCatto render:

- TypeScriptJavaScript
- JavaScript
Most of React Native’s Core Components can be customized with props, too. For example, when usingImage, you pass it a prop namedsourceto define what image it shows:

Imagehasmany different props, includingstyle, which accepts a JS object of design and layout related property-value pairs.

Notice the double curly braces{{ }}surroundingstyle‘s width and height. In JSX, JavaScript values are referenced with{}. This is handy if you are passing something other than a string as props, like an array or number:<Cat food={["fish", "kibble"]} age={2} />. However, JS objects arealsodenoted with curly braces:{width: 200, height: 200}. Therefore, to pass a JS object in JSX, you must wrap the object inanother pairof curly braces:{{width: 200, height: 200}}

You can build many things with props and the Core ComponentsText,Image, andView! But to build something interactive, you’ll need state.


## State
While you can think of props as arguments you use to configure how components render,stateis like a component’s personal data storage. State is useful for handling data that changes over time or that comes from user interaction. State gives your components memory!

As a general rule, use props to configure a component when it renders. Use state to keep track of any component data that you expect to change over time.

The following example takes place in a cat cafe where two hungry cats are waiting to be fed. Their hunger, which we expect to change over time (unlike their names), is stored as state. To feed the cats, press their buttons—which will update their state.

You can add state to a component by callingReact’suseStateHook. A Hook is a kind of function that lets you “hook into” React features. For example,useStateis a Hook that lets you add state to function components. You can learn more aboutother kinds of Hooks in the React documentation.

- TypeScriptJavaScript
- JavaScript
First, you will want to importuseStatefrom React like so:

```
import React, {useState} from 'react';
```

Then you declare the component’s state by callinguseStateinside its function. In this example,useStatecreates anisHungrystate variable:

```
const Cat = (props: CatProps) => {  const [isHungry, setIsHungry] = useState(true);  // ...};
```

You can useuseStateto track any kind of data: strings, numbers, Booleans, arrays, objects. For example, you can track the number of times a cat has been petted withconst [timesPetted, setTimesPetted] = useState(0)!

CallinguseStatedoes two things:

- it creates a “state variable” with an initial value—in this case the state variable isisHungryand its initial value istrue
- it creates a function to set that state variable’s value—setIsHungry
It doesn’t matter what names you use. But it can be handy to think of the pattern as[<getter>, <setter>] = useState(<initialValue>).

Next you add theButtonCore Component and give it anonPressprop:

```
<Button  onPress={() => {    setIsHungry(false);  }}  //../>
```

Now, when someone presses the button,onPresswill fire, calling thesetIsHungry(false). This sets the state variableisHungrytofalse. WhenisHungryis false, theButton’sdisabledprop is set totrueand itstitlealso changes:

```
<Button  //..  disabled={!isHungry}  title={isHungry ? 'Give me some food, please!' : 'Thank you!'}/>
```

You might’ve noticed that althoughisHungryis aconst, it is seemingly reassignable! What is happening is when a state-setting function likesetIsHungryis called, its component will re-render. In this case theCatfunction will run again—and this time,useStatewill give us the next value ofisHungry.

Finally, put your cats inside aCafecomponent:

```
const Cafe = () => {  return (    <>      <Cat name="Munkustrap" />      <Cat name="Spot" />    </>  );};
```

See the<>and</>above? These bits of JSX arefragments. Adjacent JSX elements must be wrapped in an enclosing tag. Fragments let you do that without nesting an extra, unnecessary wrapping element likeView.

Now that you’ve covered both React and React Native’s Core Components, let’s dive deeper on some of these core components by looking athandling<TextInput>.


================================================================================


# Core Components and Native Components
Source: https://reactnative.dev/docs/intro-react-native-components

React Native is an open source framework for building Android and iOS applications usingReactand the app platform’s native capabilities. With React Native, you use JavaScript to access your platform’s APIs as well as to describe the appearance and behavior of your UI using React components: bundles of reusable, nestable code. You can learn more about React in the next section. But first, let’s cover how components work in React Native.


## Views and mobile development
In Android and iOS development, aviewis the basic building block of UI: a small rectangular element on the screen which can be used to display text, images, or respond to user input. Even the smallest visual elements of an app, like a line of text or a button, are kinds of views. Some kinds of views can contain other views. It’s views all the way down!


## Native Components
In Android development, you write views in Kotlin or Java; in iOS development, you use Swift or Objective-C. With React Native, you can invoke these views with JavaScript using React components. At runtime, React Native creates the corresponding Android and iOS views for those components. Because React Native components are backed by the same views as Android and iOS, React Native apps look, feel, and perform like any other apps. We call these platform-backed componentsNative Components.

React Native comes with a set of essential, ready-to-use Native Components you can use to start building your app today. These are React Native'sCore Components.

This documentation references a legacy set of API and needs to be updated to reflect the New Architecture

React Native also lets you build your own Native Components forAndroidandiOSto suit your app’s unique needs. We also have a thriving ecosystem of thesecommunity-contributed components.Check outNative Directoryto find what the community has been creating.


## Core Components
React Native has many Core Components for everything from controls to activity indicators. You can find them alldocumented in the API section. You will mostly work with the following Core Components:

In the next section, you will start combining these Core Components to learn about how React works. Have a play with them here now!

Because React Native uses the same API structure as React components, you’ll need to understand React component APIs to get started. Thenext sectionmakes for a quick introduction or refresher on the topic. However, if you’re already familiar with React, feel free toskip ahead.


================================================================================


# JavaScript Environment
Source: https://reactnative.dev/docs/javascript-environment


## JavaScript Runtime
When using React Native, you're going to be running your JavaScript code in up to three environments:

- In most cases, React Native will useHermes, an open-source JavaScript engine optimized for React Native.
- If Hermes is disabled, React Native will useJavaScriptCore, the JavaScript engine that powers Safari. Note that on iOS, JavaScriptCore does not use JIT due to the absence of writable executable memory in iOS apps.
- When using Chrome debugging, all JavaScript code runs within Chrome itself, communicating with native code via WebSockets. Chrome usesV8as its JavaScript engine.
While these environments are very similar, you may end up hitting some inconsistencies. It is best to avoid relying on specifics of any runtime.


## JavaScript Syntax Transformers
Syntax transformers make writing code more enjoyable by allowing you to use new JavaScript syntax without having to wait for support on all interpreters.

React Native ships with theBabel JavaScript compiler. CheckBabel documentationon its supported transformations for more details.

A full list of React Native's enabled transformations can be found in@react-native/babel-preset.

```
promise.catch(function() {...});
```

```
<C onPress={() => this.setState({pressed: true})} />
```

```
let greeting = 'hi';
```

```
Math.max(...array);
```

```
class C extends React.Component {render() { return <View />; }}
```

```
const key = 'abc'; const obj = {[key]: 10};
```

```
const answer = 42;
```

```
const {isActive, style} = this.props;
```

```
for (var num of [1, 2, 3]) {...};
```

```
let number = x => x;
```

```
const b = 0b11; const o = 0o7; const u = 'Hello\u{000A}\u{0009}!';
```

```
import React, {Component} from 'react';
```

```
const obj = {method() { return 10; }};
```

```
const name = 'vjeux'; const obj = {name};
```

```
function test(x = 'hello', {a, b}, ...args) {}
```

```
function(type, ...args) {};
```

```
const o = {a, b, c};
```

```
const a = /o+/y;
```

```
const who = 'world'; const str = `Hello ${who}`;
```

```
const string = 'foo💩bar'; const match = string.match(/foo(.)bar/u);
```

```
let x = 10 ** 2;
```

```
async function doStuffAsync() {const foo = await doOtherStuffAsync();};
```

```
function f(a, b, c,) {};
```

```
const extended = {...obj, a: 10};
```

```
try {throw 0; } catch { doSomethingWhichDoesNotCareAboutTheValueThrown();}
```

```
const package = await import('package'); package.function()
```

```
const foo = object.foo ?? 'default';
```

```
const name = obj.user?.name;
```

```
class Bork {static a = 'foo'; static b; x = 'bar'; y;}
```

```
export v from 'mod';
```

```
template(`const %%importName%% = require(%%source%%);`);
```

```
function foo(x: ?number): string {};
```

```
export default 42;
```

```
<View style={{color: 'red'}} />
```

```
Object.assign(a, b);
```

```
const bar = createReactClass({});
```

```
function foo(x: {hello: true, target: 'react native!'}): string {};
```


## Polyfills
Many standard functions are also available on all the supported JavaScript runtimes.

- CommonJSrequire
- console.{log, warn, error, info, debug, trace, table, group, groupCollapsed, groupEnd}
- XMLHttpRequest,fetch
- {set, clear}{Timeout, Interval, Immediate}, {request, cancel}AnimationFrame
- Array.from
- Array.prototype.{find,findIndex}
- Object.assign
- String.prototype.{startsWith,endsWith,repeat,includes}
- Array.prototype.includes
- Object.{entries,values}
- __DEV__

================================================================================


# Keyboard
Source: https://reactnative.dev/docs/keyboard

Keyboardmodule to control keyboard events.


### Usage
The Keyboard module allows you to listen for native events and react to them, as well as make changes to the keyboard, like dismissing it.


## Methods

### addListener()
```
static addListener: (  eventType: KeyboardEventName,  listener: KeyboardEventListener,) => EmitterSubscription;
```

TheaddListenerfunction connects a JavaScript function to an identified native keyboard notification event.

This function then returns the reference to the listener.

Parameters:

eventName

This can be any of the following:

- keyboardWillShow
- keyboardDidShow
- keyboardWillHide
- keyboardDidHide
- keyboardWillChangeFrame
- keyboardDidChangeFrame
OnlykeyboardDidShowandkeyboardDidHideevents are available on Android. The events will not be fired when using Android 10 or below if your activity hasandroid:windowSoftInputModeset toadjustResizeoradjustNothing.


### dismiss()
```
static dismiss();
```

Dismisses the active keyboard and removes focus.


### scheduleLayoutAnimation
```
static scheduleLayoutAnimation(event: KeyboardEvent);
```

Useful for syncing TextInput (or other keyboard accessory view) size of position changes with keyboard movements.


### isVisible()
```
static isVisible(): boolean;
```

Whether the keyboard is last known to be visible.


### metrics()
```
static metrics(): KeyboardMetrics | undefined;
```

Return the metrics of the soft-keyboard if visible.


================================================================================


# KeyboardAvoidingView
Source: https://reactnative.dev/docs/keyboardavoidingview

This component will automatically adjust its height, position, or bottom padding based on the keyboard height to remain visible while the virtual keyboard is displayed.


## Example

## Props

### View Props
InheritsView Props.


### behavior
Specify how to react to the presence of the keyboard.

Android and iOS both interact with this prop differently. On both iOS and Android, settingbehavioris recommended.


### contentContainerStyle
The style of the content container (View) when behavior is'position'.


### enabled
Enabled or disabled KeyboardAvoidingView.


### keyboardVerticalOffset
This is the distance between the top of the user screen and the react native view, may be non-zero in some use cases.


================================================================================


# Layout Props
Source: https://reactnative.dev/docs/layout-props

More detailed examples about those properties can be found on theLayout with Flexboxpage.


### Example
The following example shows how different properties can affect or shape a React Native layout. You can try for example to add or remove squares from the UI while changing the values of the propertyflexWrap.

- TypeScriptJavaScript
- JavaScript

## Props

### alignContent
alignContentcontrols how rows align in the cross direction, overriding thealignContentof the parent.

SeeMDN CSS Referencefor more details.


### alignItems
alignItemsaligns children in the cross direction. For example, if children are flowing vertically,alignItemscontrols how they align horizontally. It works likealign-itemsin CSS (default: stretch).

SeeMDN CSS Referencefor more details.


### alignSelf
alignSelfcontrols how a child aligns in the cross direction, overriding thealignItemsof the parent. It works likealign-selfin CSS (default: auto).

SeeMDN CSS Referencefor more details.


### aspectRatio
Aspect ratio controls the size of the undefined dimension of a node.

- On a node with a set width/height, aspect ratio controls the size of the unset dimension
- On a node with a set flex basis, aspect ratio controls the size of the node in the cross axis if unset
- On a node with a measure function, aspect ratio works as though the measure function measures the flex basis
- On a node with flex grow/shrink, aspect ratio controls the size of the node in the cross axis if unset
- Aspect ratio takes min/max dimensions into account
SeeMDN CSS Referencefor more details.


### borderBottomWidth
borderBottomWidthworks likeborder-bottom-widthin CSS.

SeeMDN CSS Referencefor more details.


### borderEndWidth
When direction isltr,borderEndWidthis equivalent toborderRightWidth. When direction isrtl,borderEndWidthis equivalent toborderLeftWidth.


### borderLeftWidth
borderLeftWidthworks likeborder-left-widthin CSS.

SeeMDN CSS Referencefor more details.


### borderRightWidth
borderRightWidthworks likeborder-right-widthin CSS.

SeeMDN CSS Referencefor more details.


### borderStartWidth
When direction isltr,borderStartWidthis equivalent toborderLeftWidth. When direction isrtl,borderStartWidthis equivalent toborderRightWidth.


### borderTopWidth
borderTopWidthworks likeborder-top-widthin CSS.

SeeMDN CSS Referencefor more details.


### borderWidth
borderWidthworks likeborder-widthin CSS.

SeeMDN CSS Referencefor more details.


### bottom
bottomis the number of logical pixels to offset the bottom edge of this component.

It works similarly tobottomin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details of howbottomaffects layout.


### boxSizing
boxSizingdefines how the element's various sizing props (width,height,minWidth,minHeight, etc.) are computed. IfboxSizingisborder-box, these sizes apply to the border box of the element. If it iscontent-box, they apply to the content box of the element. The default value isborder-box. Theweb documentationis a good source of information if you wish to learn more about how this prop works.


### columnGap
columnGapworks likecolumn-gapin CSS. Only pixel units are supported in React Native.

SeeMDN CSS Referencefor more details.


### direction
directionspecifies the directional flow of the user interface. The default isinherit, except for root node which will have value based on the current locale.

SeeMDN CSS Referencefor more details.


### display
displaysets the display type of this component.

It works similarly todisplayin CSS but only supports the values 'flex', 'none', and 'contents'. The default isflex.


### end
When the direction isltr,endis equivalent toright. When the direction isrtl,endis equivalent toleft.

This style takes precedence over theleftandrightstyles.


### flex
In React Nativeflexdoes not work the same way that it does in CSS.flexis a number rather than a string, and it works according to theYogalayout engine.

Whenflexis a positive number, it makes the component flexible, and it will be sized proportional to its flex value. So a component withflexset to2will take twice the space as a component withflexset to 1.flex: <positive number>equates toflexGrow: <positive number>, flexShrink: 1, flexBasis: 0.

Whenflexis0, the component is sized according towidthandheight, and it is inflexible.

Whenflexis-1, the component is normally sized according towidthandheight. However, if there's not enough space, the component will shrink to itsminWidthandminHeight.

flexGrow,flexShrink, andflexBasiswork the same as in CSS.


### flexBasis
flexBasisis an axis-independent way of providing the default size of an item along the main axis. Setting theflexBasisof a child is similar to setting thewidthof that child if its parent is a container withflexDirection: rowor setting theheightof a child if its parent is a container withflexDirection: column. TheflexBasisof an item is the default size of that item, the size of the item before anyflexGrowandflexShrinkcalculations are performed.


### flexDirection
flexDirectioncontrols which directions children of a container go.rowgoes left to right,columngoes top to bottom, and you may be able to guess what the other two do. It works likeflex-directionin CSS, except the default iscolumn.

SeeMDN CSS Referencefor more details.


### flexGrow
flexGrowdescribes how any space within a container should be distributed among its children along the main axis. After laying out its children, a container will distribute any remaining space according to the flex grow values specified by its children.

flexGrowaccepts any floating point value >= 0, with 0 being the default value. A container will distribute any remaining space among its children weighted by the children’sflexGrowvalues.


### flexShrink
flexShrinkdescribes how to shrink children along the main axis in the case in which the total size of the children overflows the size of the container on the main axis.flexShrinkis very similar toflexGrowand can be thought of in the same way if any overflowing size is considered to be negative remaining space. These two properties also work well together by allowing children to grow and shrink as needed.

flexShrinkaccepts any floating point value >= 0, with 0 being the default value. A container will shrink its children weighted by the children’sflexShrinkvalues.


### flexWrap
flexWrapcontrols whether children can wrap around after they hit the end of a flex container. It works likeflex-wrapin CSS (default: nowrap).

Note it does not work anymore withalignItems: stretch(the default), so you may want to usealignItems: flex-startfor example (breaking change details:https://github.com/facebook/react-native/releases/tag/v0.28.0).

SeeMDN CSS Referencefor more details.


### gap
gapworks likegapin CSS. Only pixel units are supported in React Native.

SeeMDN CSS Referencefor more details.


### height
heightsets the height of this component.

It works similarly toheightin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details.


### inset
insetis only available on theNew Architecture

Settinginsethas the same effect as setting each oftop,bottom,rightandleftprops.

SeeMDN CSS Referencefor more details.


### insetBlock
insetBlockis only available on theNew Architecture

Equivalent totopandbottom.

SeeMDN CSS Referencefor more details.


### insetBlockEnd
insetBlockEndis only available on theNew Architecture

Equivalent tobottom.

SeeMDN CSS Referencefor more details.


### insetBlockStart
insetBlockStartis only available on theNew Architecture

Equivalent totop.

SeeMDN CSS Referencefor more details.


### insetInline
insetInlineis only available on theNew Architecture

Equivalent torightandleft.

SeeMDN CSS Referencefor more details.


### insetInlineEnd
insetInlineEndis only available on theNew Architecture

When direction isltr,insetInlineEndis equivalent toright. When direction isrtl,insetInlineEndis equivalent toleft.

SeeMDN CSS Referencefor more details.


### insetInlineStart
insetInlineStartis only available on theNew Architecture

When direction isltr,insetInlineStartis equivalent toleft. When direction isrtl,insetInlineStartis equivalent toright.

SeeMDN CSS Referencefor more details.


### isolation
isolationis only available on theNew Architecture

isolationlets you form astacking context.

There are two values:

- auto(default): Does nothing.
- isolate: Forms a stacking context.

### justifyContent
justifyContentaligns children in the main direction. For example, if children are flowing vertically,justifyContentcontrols how they align vertically. It works likejustify-contentin CSS (default: flex-start).

SeeMDN CSS Referencefor more details.


### left
leftis the number of logical pixels to offset the left edge of this component.

It works similarly toleftin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details of howleftaffects layout.


### margin
Settingmarginhas the same effect as setting each ofmarginTop,marginLeft,marginBottom, andmarginRight.

SeeMDN CSS Referencefor more details.


### marginBottom
marginBottomworks likemargin-bottomin CSS. SeeMDN CSS Referencefor more details.


### marginBlock
Equivalent tomarginVertical.

SeeMDN CSS Referencefor more details.


### marginBlockEnd
Equivalent tomarginBottom.

SeeMDN CSS Referencefor more details.


### marginBlockStart
Equivalent tomarginTop.

SeeMDN CSS Referencefor more details.


### marginEnd
When direction isltr,marginEndis equivalent tomarginRight. When direction isrtl,marginEndis equivalent tomarginLeft.


### marginHorizontal
SettingmarginHorizontalhas the same effect as setting bothmarginLeftandmarginRight.


### marginInline
Equivalent tomarginHorizontal.

SeeMDN CSS Referencefor more details.


### marginInlineEnd
When direction isltr,marginInlineEndis equivalent tomarginEnd(i.e.marginRight). When direction isrtl,marginInlineEndis equivalent tomarginEnd(i.e.marginLeft).

SeeMDN CSS Referencefor more details.


### marginInlineStart
When direction isltr,marginInlineStartis equivalent tomarginStart(i.e.marginLeft). When direction isrtl,marginInlineStartis equivalent tomarginStart(i.e.marginRight).

SeeMDN CSS Referencefor more details.


### marginLeft
marginLeftworks likemargin-leftin CSS. SeeMDN CSS Referencefor more details.


### marginRight
marginRightworks likemargin-rightin CSS.

SeeMDN CSS Referencefor more details.


### marginStart
When direction isltr,marginStartis equivalent tomarginLeft. When direction isrtl,marginStartis equivalent tomarginRight.


### marginTop
marginTopworks likemargin-topin CSS.

SeeMDN CSS Referencefor more details.


### marginVertical
SettingmarginVerticalhas the same effect as setting bothmarginTopandmarginBottom.


### maxHeight
maxHeightis the maximum height for this component, in logical pixels.

It works similarly tomax-heightin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details.


### maxWidth
maxWidthis the maximum width for this component, in logical pixels.

It works similarly tomax-widthin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details.


### minHeight
minHeightis the minimum height for this component, in logical pixels.

It works similarly tomin-heightin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details.


### minWidth
minWidthis the minimum width for this component, in logical pixels.

It works similarly tomin-widthin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details.


### overflow
overflowcontrols how children are measured and displayed.overflow: hiddencauses views to be clipped whileoverflow: scrollcauses views to be measured independently of their parents' main axis. It works likeoverflowin CSS (default: visible).

SeeMDN CSS Referencefor more details.


### padding
Settingpaddinghas the same effect as setting each ofpaddingTop,paddingBottom,paddingLeft, andpaddingRight.

SeeMDN CSS Referencefor more details.


### paddingBottom
paddingBottomworks likepadding-bottomin CSS.

SeeMDN CSS Referencefor more details.


### paddingBlock
Equivalent topaddingVertical.

SeeMDN CSS Referencefor more details.


### paddingBlockEnd
Equivalent topaddingBottom.

SeeMDN CSS Referencefor more details.


### paddingBlockStart
Equivalent topaddingTop.

SeeMDN CSS Referencefor more details.


### paddingEnd
When direction isltr,paddingEndis equivalent topaddingRight. When direction isrtl,paddingEndis equivalent topaddingLeft.


### paddingHorizontal
SettingpaddingHorizontalis like setting both ofpaddingLeftandpaddingRight.


### paddingInline
Equivalent topaddingHorizontal.

SeeMDN CSS Referencefor more details.


### paddingInlineEnd
When direction isltr,paddingInlineEndis equivalent topaddingEnd(i.e.paddingRight). When direction isrtl,paddingInlineEndis equivalent topaddingEnd(i.e.paddingLeft).

SeeMDN CSS Referencefor more details.


### paddingInlineStart
When direction isltr,paddingInlineStartis equivalent topaddingStart(i.e.paddingLeft). When direction isrtl,paddingInlineStartis equivalent topaddingStart(i.e.paddingRight).

SeeMDN CSS Referencefor more details.


### paddingLeft
paddingLeftworks likepadding-leftin CSS.

SeeMDN CSS Referencefor more details.


### paddingRight
paddingRightworks likepadding-rightin CSS.

SeeMDN CSS Referencefor more details.


### paddingStart
When direction isltr,paddingStartis equivalent topaddingLeft. When direction isrtl,paddingStartis equivalent topaddingRight.


### paddingTop
paddingTopworks likepadding-topin CSS.

SeeMDN CSS Referencefor more details.


### paddingVertical
SettingpaddingVerticalis like setting both ofpaddingTopandpaddingBottom.


### position
positionin React Native is similar toregular CSS, but everything is set torelativeby default.

relativewill position an element according to the normal flow of the layout. Insets (top,bottom,left,right) will offset relative to this layout.

absolutetakes the element out of the normal flow of the layout. Insets will offset relative to itscontaining block.

staticwill position an element according to the normal flow of the layout. Insets will have no effect.staticelements do not form a containing block for absolute descendants.

For more information, see theLayout with Flexbox docs. Also,the Yoga documentationhas more details on howpositiondiffers between React Native and CSS.


### right
rightis the number of logical pixels to offset the right edge of this component.

It works similarly torightin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details of howrightaffects layout.


### rowGap
rowGapworks likerow-gapin CSS. Only pixel units are supported in React Native.

SeeMDN CSS Referencefor more details.


### start
When the direction isltr,startis equivalent toleft. When the direction isrtl,startis equivalent toright.

This style takes precedence over theleft,right, andendstyles.


### top
topis the number of logical pixels to offset the top edge of this component.

It works similarly totopin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details of howtopaffects layout.


### width
widthsets the width of this component.

It works similarly towidthin CSS, but in React Native you must use points or percentages. Ems and other units are not supported.

SeeMDN CSS Referencefor more details.


### zIndex
zIndexcontrols which components display on top of others. Normally, you don't usezIndex. Components render according to their order in the document tree, so later components draw over earlier ones.zIndexmay be useful if you have animations or custom modal interfaces where you don't want this behavior.

It works like the CSSz-indexproperty - components with a largerzIndexwill render on top. Think of the z-direction like it's pointing from the phone into your eyeball.

On iOS,zIndexmay requireViews to be siblings of each other for it to work as expected.

SeeMDN CSS Referencefor more details.


================================================================================


# LayoutAnimation
Source: https://reactnative.dev/docs/layoutanimation

Automatically animates views to their new positions when the next layout happens.

A common way to use this API is to call it before updating the state hook in functional components and callingsetStatein class components.

Note that in order to get this to work onAndroidyou need to set the following flags viaUIManager:

```
if (Platform.OS === 'android') {  if (UIManager.setLayoutAnimationEnabledExperimental) {    UIManager.setLayoutAnimationEnabledExperimental(true);  }}
```


## Example

## Methods

### configureNext()
```
static configureNext(  config: LayoutAnimationConfig,  onAnimationDidEnd?: () => void,  onAnimationDidFail?: () => void,);
```

Schedules an animation to happen on the next layout.

Theconfigparameter is an object with the keys below.createreturns a valid object forconfig, and thePresetsobjects can also all be passed as theconfig.

- durationin milliseconds
- create, optional config for animating in new views
- update, optional config for animating views that have been updated
- delete, optional config for animating views as they are removed
The config that's passed tocreate,update, ordeletehas the following keys:

- type, theanimation typeto use
- property, thelayout propertyto animate (optional, but recommended forcreateanddelete)
- springDamping(number, optional and only for use withtype: Type.spring)
- initialVelocity(number, optional)
- delay(number, optional)
- duration(number, optional)

### create()
```
static create(duration, type, creationProp)
```

Helper that creates an object (withcreate,update, anddeletefields) to pass intoconfigureNext. Thetypeparameter is ananimation type, and thecreationPropparameter is alayout property.

Example:


## Properties

### Types
An enumeration of animation types to be used in thecreatemethod, or in thecreate/update/deleteconfigs forconfigureNext. (example usage:LayoutAnimation.Types.easeIn)


### Properties
An enumeration of layout properties to be animated to be used in thecreatemethod, or in thecreate/update/deleteconfigs forconfigureNext. (example usage:LayoutAnimation.Properties.opacity)


### Presets
A set of predefined animation configs to pass intoconfigureNext.


### easeInEaseOut
CallsconfigureNext()withPresets.easeInEaseOut.


### linear
CallsconfigureNext()withPresets.linear.


### spring
CallsconfigureNext()withPresets.spring.

Example:


================================================================================


# LayoutEvent Object Type
Source: https://reactnative.dev/docs/layoutevent

LayoutEventobject is returned in the callback as a result of component layout change, for exampleonLayoutinViewcomponent.


## Example
```
{    layout: {        width: 520,        height: 70.5,        x: 0,        y: 42.5    },    target: 1127}
```


## Keys and values

### height
Height of the component after the layout changes.


### width
Width of the component after the layout changes.


### x
Component X coordinate inside the parent component.


### y
Component Y coordinate inside the parent component.


### target
The node id of the element receiving the LayoutEvent.


## Used by
- Image
- Pressable
- ScrollView
- Text
- TextInput
- TouchableWithoutFeedback
- View

================================================================================


# Direct Manipulation
Source: https://reactnative.dev/docs/legacy/direct-manipulation

It is sometimes necessary to make changes directly to a component without using state/props to trigger a re-render of the entire subtree. When using React in the browser for example, you sometimes need to directly modify a DOM node, and the same is true for views in mobile apps.setNativePropsis the React Native equivalent to setting properties directly on a DOM node.

UsesetNativePropswhen frequent re-rendering creates a performance bottleneck!Direct manipulation will not be a tool that you reach for frequently. You will typically only be using it for creating continuous animations to avoid the overhead of rendering the component hierarchy and reconciling many views.setNativePropsis imperative and stores state in the native layer (DOM, UIView, etc.) and not within your React components, which makes your code more difficult to reason about.Before you use it, try to solve your problem withsetStateandshouldComponentUpdate.

Direct manipulation will not be a tool that you reach for frequently. You will typically only be using it for creating continuous animations to avoid the overhead of rendering the component hierarchy and reconciling many views.setNativePropsis imperative and stores state in the native layer (DOM, UIView, etc.) and not within your React components, which makes your code more difficult to reason about.Before you use it, try to solve your problem withsetStateandshouldComponentUpdate.

Before you use it, try to solve your problem withsetStateandshouldComponentUpdate.


## setNativeProps with TouchableOpacity
TouchableOpacityusessetNativePropsinternally to update the opacity of its child component:

```
const viewRef = useRef<View>();const setOpacityTo = useCallback(value => {  // Redacted: animation related code  viewRef.current.setNativeProps({    opacity: value,  });}, []);
```

This allows us to write the following code and know that the child will have its opacity updated in response to taps, without the child having any knowledge of that fact or requiring any changes to its implementation:

```
<TouchableOpacity onPress={handlePress}>  <View>    <Text>Press me!</Text>  </View></TouchableOpacity>
```

Let's imagine thatsetNativePropswas not available. One way that we might implement it with that constraint is to store the opacity value in the state, then update that value wheneveronPressis fired:

```
const [buttonOpacity, setButtonOpacity] = useState(1);return (  <TouchableOpacity    onPressIn={() => setButtonOpacity(0.5)}    onPressOut={() => setButtonOpacity(1)}>    <View style={{opacity: buttonOpacity}}>      <Text>Press me!</Text>    </View>  </TouchableOpacity>);
```

This is computationally intensive compared to the original example - React needs to re-render the component hierarchy each time the opacity changes, even though other properties of the view and its children haven't changed. Usually this overhead isn't a concern but when performing continuous animations and responding to gestures, judiciously optimizing your components can improve your animations' fidelity.

If you look at the implementation ofsetNativePropsinNativeMethodsMixinyou will notice that it is a wrapper aroundRCTUIManager.updateView- this is the exact same function call that results from re-rendering - seereceiveComponent in ReactNativeBaseComponent.


## Composite components and setNativeProps
Composite components are not backed by a native view, so you cannot callsetNativePropson them. Consider this example:

- TypeScriptJavaScript
- JavaScript
If you run this you will immediately see this error:Touchable child must either be native or forward setNativeProps to a native component. This occurs becauseMyButtonisn't directly backed by a native view whose opacity should be set. You can think about it like this: if you define a component withcreateReactClassyou would not expect to be able to set a style prop on it and have that work - you would need to pass the style prop down to a child, unless you are wrapping a native component. Similarly, we are going to forwardsetNativePropsto a native-backed child component.

Since thesetNativePropsmethod exists on any ref to aViewcomponent, it is enough to forward a ref on your custom component to one of the<View />components that it renders. This means that a call tosetNativePropson the custom component will have the same effect as if you calledsetNativePropson the wrappedViewcomponent itself.

- TypeScriptJavaScript
- JavaScript
You can now useMyButtoninside ofTouchableOpacity!

You may have noticed that we passed all of the props down to the child view using{...props}. The reason for this is thatTouchableOpacityis actually a composite component, and so in addition to depending onsetNativePropson its child, it also requires that the child perform touch handling. To do this, it passes onvarious propsthat call back to theTouchableOpacitycomponent.TouchableHighlight, in contrast, is backed by a native view and only requires that we implementsetNativeProps.


## setNativeProps to edit TextInput value
Another very common use case ofsetNativePropsis to edit the value of the TextInput. Thecontrolledprop of TextInput can sometimes drop characters when thebufferDelayis low and the user types very quickly. Some developers prefer to skip this prop entirely and instead usesetNativePropsto directly manipulate the TextInput value when necessary. For example, the following code demonstrates editing the input when you tap a button:

- TypeScriptJavaScript
- JavaScript
You can use theclearmethod to clear theTextInputwhich clears the current input text using the same approach.


## Avoiding conflicts with the render function
If you update a property that is also managed by the render function, you might end up with some unpredictable and confusing bugs because anytime the component re-renders and that property changes, whatever value was previously set fromsetNativePropswill be completely ignored and overridden.


## setNativeProps & shouldComponentUpdate
Byintelligently applyingshouldComponentUpdateyou can avoid the unnecessary overhead involved in reconciling unchanged component subtrees, to the point where it may be performant enough to usesetStateinstead ofsetNativeProps.


## Other native methods
The methods described here are available on most of the default components provided by React Native. Note, however, that they arenotavailable on composite components that aren't directly backed by a native view. This will generally include most components that you define in your own app.


### measure(callback)
Determines the location on screen, width, and height in the viewport of the given view and returns the values via an async callback. If successful, the callback will be called with the following arguments:

- x
- y
- width
- height
- pageX
- pageY
Note that these measurements are not available until after the rendering has been completed in native. If you need the measurements as soon as possible and you don't needpageXandpageY, consider using theonLayoutproperty instead.

Also the width and height returned bymeasure()are the width and height of the component in the viewport. If you need the actual size of the component, consider using theonLayoutproperty instead.


### measureInWindow(callback)
Determines the location of the given view in the window and returns the values via an async callback. If the React root view is embedded in another native view, this will give you the absolute coordinates. If successful, the callback will be called with the following arguments:

- x
- y
- width
- height

### measureLayout(relativeToNativeComponentRef, onSuccess, onFail)
Likemeasure(), but measures the view relative to an ancestor, specified withrelativeToNativeComponentRefreference. This means that the returned coordinates are relative to the originx,yof the ancestor view.

This method can also be called with arelativeToNativeNodehandler (instead of reference), but this variant is obsolete with the new architecture.

- TypeScriptJavaScript
- JavaScript

### focus()
Requests focus for the given input or view. The exact behavior triggered will depend on the platform and type of view.


### blur()
Removes focus from an input or view. This is the opposite offocus().


================================================================================


# Local libraries setup
Source: https://reactnative.dev/docs/legacy/local-library-setup

A local library is a library containing views or modules that's local to your app and not published to a registry. This is different from the traditional setup for view and modules in the sense that a local library is decoupled from your app's native code.

The local library is created outside of theandroid/andios/folders and makes use of autolinking to integrate with your app. The structure with a local library may look like this:

```
MyApp├── node_modules├── modules <-- folder for your local libraries│ └── awesome-module <-- your local library├── android├── ios├── src├── index.js└── package.json
```

Since a local library's code exists outside ofandroid/andios/folders, it makes it easier to upgrade React Native versions in the future, copy to other projects etc.

To create local library we will usecreate-react-native-library. This tool contains all the necessary templates.


### Getting Started
Inside your React Native application's root folder, run the following command:

```
npx create-react-native-library@latest awesome-module
```

Whereawesome-moduleis the name you would like for the new module. After going through the prompts, you will have a new folder calledmodulesin your project's root directory which contains the new module.


### Linking
By default, the generated library is automatically linked to the project usinglink:protocol when using Yarn andfile:when using npm:

- npmYarn
- Yarn
```
"dependencies": {  "awesome-module": "file:./modules/awesome-module"}
```

```
"dependencies": {  "awesome-module": "link:./modules/awesome-module"}
```

This creates a symlink to the library undernode_moduleswhich makes autolinking work.


### Installing dependencies
To link the module you need to install dependencies:

- npmYarn
- Yarn
```
npm install
```

```
yarn install
```


### Using module inside your app
To use the module inside your app, you can import it by its name:

```
import {multiply} from 'awesome-module';
```


================================================================================


# Android Native UI Components
Source: https://reactnative.dev/docs/legacy/native-components-android

Native Module and Native Components are our stable technologies used by the legacy architecture.
They will be deprecated in the future when the New Architecture will be stable. The New Architecture usesTurbo Native ModuleandFabric Native Componentsto achieve similar results.

There are tons of native UI widgets out there ready to be used in the latest apps - some of them are part of the platform, others are available as third-party libraries, and still more might be in use in your very own portfolio. React Native has several of the most critical platform components already wrapped, likeScrollViewandTextInput, but not all of them, and certainly not ones you might have written yourself for a previous app. Fortunately, we can wrap up these existing components for seamless integration with your React Native application.

Like the native module guide, this too is a more advanced guide that assumes you are somewhat familiar with Android SDK programming. This guide will show you how to build a native UI component, walking you through the implementation of a subset of the existingImageViewcomponent available in the core React Native library.

You can also setup local library containing native component with one command. Read the guide toLocal libraries setupfor more details.


## ImageView example
For this example we are going to walk through the implementation requirements to allow the use of ImageViews in JavaScript.

Native views are created and manipulated by extendingViewManageror more commonlySimpleViewManager. ASimpleViewManageris convenient in this case because it applies common properties such as background color, opacity, and Flexbox layout.

These subclasses are essentially singletons - only one instance of each is created by the bridge. They send native views to theNativeViewHierarchyManager, which delegates back to them to set and update the properties of the views as necessary. TheViewManagersare also typically the delegates for the views, sending events back to JavaScript via the bridge.

To send a view:

- Create the ViewManager subclass.
- Implement thecreateViewInstancemethod
- Expose view property setters using@ReactProp(or@ReactPropGroup) annotation
- Register the manager increateViewManagersof the applications package.
- Implement the JavaScript module

### 1. Create theViewManagersubclass
In this example we create view manager classReactImageManagerthat extendsSimpleViewManagerof typeReactImageView.ReactImageViewis the type of object managed by the manager, this will be the custom native view. Name returned bygetNameis used to reference the native view type from JavaScript.

- JavaKotlin
- Kotlin
```
class ReactImageManager(    private val callerContext: ReactApplicationContext) : SimpleViewManager<ReactImageView>() {  override fun getName() = REACT_CLASS  companion object {    const val REACT_CLASS = "RCTImageView"  }}
```

```
public class ReactImageManager extends SimpleViewManager<ReactImageView> {  public static final String REACT_CLASS = "RCTImageView";  ReactApplicationContext mCallerContext;  public ReactImageManager(ReactApplicationContext reactContext) {    mCallerContext = reactContext;  }  @Override  public String getName() {    return REACT_CLASS;  }}
```


### 2. Implement methodcreateViewInstance
Views are created in thecreateViewInstancemethod, the view should initialize itself in its default state, any properties will be set via a follow up call toupdateView.

- JavaKotlin
- Kotlin
```
  override fun createViewInstance(context: ThemedReactContext) =      ReactImageView(context, Fresco.newDraweeControllerBuilder(), null, callerContext)
```

```
  @Override  public ReactImageView createViewInstance(ThemedReactContext context) {    return new ReactImageView(context, Fresco.newDraweeControllerBuilder(), null, mCallerContext);  }
```


### 3. Expose view property setters using@ReactProp(or@ReactPropGroup) annotation
Properties that are to be reflected in JavaScript needs to be exposed as setter method annotated with@ReactProp(or@ReactPropGroup). Setter method should take view to be updated (of the current view type) as a first argument and property value as a second argument. Setter should be public and not return a value (i.e. return type should bevoidin Java orUnitin Kotlin). Property type sent to JS is determined automatically based on the type of value argument of the setter. The following type of values are currently supported (in Java):boolean,int,float,double,String,Boolean,Integer,ReadableArray,ReadableMap. The corresponding types in Kotlin areBoolean,Int,Float,Double,String,ReadableArray,ReadableMap.

Annotation@ReactProphas one obligatory argumentnameof typeString. Name assigned to the@ReactPropannotation linked to the setter method is used to reference the property on JS side.

Except fromname,@ReactPropannotation may take following optional arguments:defaultBoolean,defaultInt,defaultFloat. Those arguments should be of the corresponding type (accordinglyboolean,int,floatin Java andBoolean,Int,Floatin Kotlin) and the value provided will be passed to the setter method in case when the property that the setter is referencing has been removed from the component. Note that "default" values are only provided for primitive types, in case when setter is of some complex type,nullwill be provided as a default value in case when corresponding property gets removed.

Setter declaration requirements for methods annotated with@ReactPropGroupare different than for@ReactProp, please refer to the@ReactPropGroupannotation class docs for more information about it.IMPORTANT!in ReactJS updating the property value will result in setter method call. Note that one of the ways we can update component is by removing properties that have been set before. In that case setter method will be called as well to notify view manager that property has changed. In that case "default" value will be provided (for primitive types "default" value can be specified usingdefaultBoolean,defaultFloat, etc. arguments of@ReactPropannotation, for complex types setter will be called with value set tonull).

- JavaKotlin
- Kotlin
```
  @ReactProp(name = "src")  fun setSrc(view: ReactImageView, sources: ReadableArray?) {    view.setSource(sources)  }  @ReactProp(name = "borderRadius", defaultFloat = 0f)  override fun setBorderRadius(view: ReactImageView, borderRadius: Float) {    view.setBorderRadius(borderRadius)  }  @ReactProp(name = ViewProps.RESIZE_MODE)  fun setResizeMode(view: ReactImageView, resizeMode: String?) {    view.setScaleType(ImageResizeMode.toScaleType(resizeMode))  }
```

```
  @ReactProp(name = "src")  public void setSrc(ReactImageView view, @Nullable ReadableArray sources) {    view.setSource(sources);  }  @ReactProp(name = "borderRadius", defaultFloat = 0f)  public void setBorderRadius(ReactImageView view, float borderRadius) {    view.setBorderRadius(borderRadius);  }  @ReactProp(name = ViewProps.RESIZE_MODE)  public void setResizeMode(ReactImageView view, @Nullable String resizeMode) {    view.setScaleType(ImageResizeMode.toScaleType(resizeMode));  }
```


### 4. Register theViewManager
The final step is to register the ViewManager to the application, this happens in a similar way toNative Modules, via the applications package member functioncreateViewManagers.

- JavaKotlin
- Kotlin
```
  override fun createViewManagers(      reactContext: ReactApplicationContext  ) = listOf(ReactImageManager(reactContext))
```

```
  @Override  public List<ViewManager> createViewManagers(                            ReactApplicationContext reactContext) {    return Arrays.<ViewManager>asList(      new ReactImageManager(reactContext)    );  }
```


### 5. Implement the JavaScript module
The very final step is to create the JavaScript module that defines the interface layer between Java/Kotlin and JavaScript for the users of your new view. It is recommended for you to document the component interface in this module (e.g. using TypeScript, Flow, or plain old comments).

```
import {requireNativeComponent} from 'react-native';/** * Composes `View`. * * - src: Array<{url: string}> * - borderRadius: number * - resizeMode: 'cover' | 'contain' | 'stretch' */export default requireNativeComponent('RCTImageView');
```

TherequireNativeComponentfunction takes the name of the native view. Note that if your component needs to do anything more sophisticated (e.g. custom event handling), you should wrap the native component in another React component. This is illustrated in theMyCustomViewexample below.


## Events
So now we know how to expose native view components that we can control freely from JS, but how do we deal with events from the user, like pinch-zooms or panning? When a native event occurs the native code should issue an event to the JavaScript representation of the View, and the two views are linked with the value returned from thegetId()method.

- JavaKotlin
- Kotlin
```
class MyCustomView(context: Context) : View(context) {  ...  fun onReceiveNativeEvent() {    val event = Arguments.createMap().apply {      putString("message", "MyMessage")    }    val reactContext = context as ReactContext    reactContext        .getJSModule(RCTEventEmitter::class.java)        .receiveEvent(id, "topChange", event)  }}
```

```
class MyCustomView extends View {   ...   public void onReceiveNativeEvent() {      WritableMap event = Arguments.createMap();      event.putString("message", "MyMessage");      ReactContext reactContext = (ReactContext)getContext();      reactContext          .getJSModule(RCTEventEmitter.class)          .receiveEvent(getId(), "topChange", event);    }}
```

To map thetopChangeevent name to theonChangecallback prop in JavaScript, register it by overriding thegetExportedCustomBubblingEventTypeConstantsmethod in yourViewManager:

- JavaKotlin
- Kotlin
```
class ReactImageManager : SimpleViewManager<MyCustomView>() {  ...  override fun getExportedCustomBubblingEventTypeConstants(): Map<String, Any> {    return mapOf(      "topChange" to mapOf(        "phasedRegistrationNames" to mapOf(          "bubbled" to "onChange"        )      )    )  }}
```

```
public class ReactImageManager extends SimpleViewManager<MyCustomView> {    ...    public Map getExportedCustomBubblingEventTypeConstants() {        return MapBuilder.builder().put(            "topChange",            MapBuilder.of(                "phasedRegistrationNames",                MapBuilder.of("bubbled", "onChange")            )        ).build();    }}
```

This callback is invoked with the raw event, which we typically process in the wrapper component to make a simpler API:

```
import {useCallback} from 'react';import {requireNativeComponent} from 'react-native';const RCTMyCustomView = requireNativeComponent('RCTMyCustomView');export default function MyCustomView(props: {  // ...  /**   * Callback that is called continuously when the user is dragging the map.   */  onChangeMessage: (message: string) => unknown;}) {  const onChange = useCallback(    event => {      props.onChangeMessage?.(event.nativeEvent.message);    },    [props.onChangeMessage],  );  return <RCTMyCustomView {...props} onChange={onChange} />;}
```


## Integration with an Android Fragment example
In order to integrate existing Native UI elements to your React Native app, you might need to use Android Fragments to give you a more granular control over your native component than returning aViewfrom yourViewManager. You will need this if you want to add custom logic that is tied to your view with the help oflifecycle methods, such asonViewCreated,onPause,onResume. The following steps will show you how to do it:


### 1. Create an example custom view
First, let's create aCustomViewclass which extendsFrameLayout(the content of this view can be any view that you'd like to render)

- JavaKotlin
- Kotlin
```
// replace with your packagepackage com.mypackageimport android.content.Contextimport android.graphics.Colorimport android.widget.FrameLayoutimport android.widget.TextViewclass CustomView(context: Context) : FrameLayout(context) {  init {    // set padding and background color    setPadding(16,16,16,16)    setBackgroundColor(Color.parseColor("#5FD3F3"))    // add default text view    addView(TextView(context).apply {      text = "Welcome to Android Fragments with React Native."    })  }}
```

```
// replace with your packagepackage com.mypackage;import android.content.Context;import android.graphics.Color;import android.widget.FrameLayout;import android.widget.ImageView;import android.widget.TextView;import androidx.annotation.NonNull;public class CustomView extends FrameLayout {  public CustomView(@NonNull Context context) {    super(context);    // set padding and background color    this.setPadding(16,16,16,16);    this.setBackgroundColor(Color.parseColor("#5FD3F3"));    // add default text view    TextView text = new TextView(context);    text.setText("Welcome to Android Fragments with React Native.");    this.addView(text);  }}
```


### 2. Create aFragment
- JavaKotlin
- Kotlin
```
// replace with your packagepackage com.mypackageimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport androidx.fragment.app.Fragment// replace with your view's importimport com.mypackage.CustomViewclass MyFragment : Fragment() {  private lateinit var customView: CustomView  override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {    super.onCreateView(inflater, container, savedInstanceState)    customView = CustomView(requireNotNull(context))    return customView // this CustomView could be any view that you want to render  }  override fun onViewCreated(view: View, savedInstanceState: Bundle?) {    super.onViewCreated(view, savedInstanceState)    // do any logic that should happen in an `onCreate` method, e.g:    // customView.onCreate(savedInstanceState);  }  override fun onPause() {    super.onPause()    // do any logic that should happen in an `onPause` method    // e.g.: customView.onPause();  }  override fun onResume() {    super.onResume()    // do any logic that should happen in an `onResume` method    // e.g.: customView.onResume();  }  override fun onDestroy() {    super.onDestroy()    // do any logic that should happen in an `onDestroy` method    // e.g.: customView.onDestroy();  }}
```

```
// replace with your packagepackage com.mypackage;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.fragment.app.Fragment;// replace with your view's importimport com.mypackage.CustomView;public class MyFragment extends Fragment {    CustomView customView;    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup parent, Bundle savedInstanceState) {        super.onCreateView(inflater, parent, savedInstanceState);        customView = new CustomView(this.getContext());        return customView; // this CustomView could be any view that you want to render    }    @Override    public void onViewCreated(View view, Bundle savedInstanceState) {        super.onViewCreated(view, savedInstanceState);        // do any logic that should happen in an `onCreate` method, e.g:        // customView.onCreate(savedInstanceState);    }    @Override    public void onPause() {        super.onPause();        // do any logic that should happen in an `onPause` method        // e.g.: customView.onPause();    }    @Override    public void onResume() {        super.onResume();       // do any logic that should happen in an `onResume` method       // e.g.: customView.onResume();    }    @Override    public void onDestroy() {        super.onDestroy();        // do any logic that should happen in an `onDestroy` method        // e.g.: customView.onDestroy();    }}
```


### 3. Create theViewManagersubclass
- JavaKotlin
- Kotlin
```
// replace with your packagepackage com.mypackageimport android.view.Choreographerimport android.view.Viewimport android.view.ViewGroupimport android.widget.FrameLayoutimport androidx.fragment.app.FragmentActivityimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.bridge.ReadableArrayimport com.facebook.react.uimanager.ThemedReactContextimport com.facebook.react.uimanager.ViewGroupManagerimport com.facebook.react.uimanager.annotations.ReactPropGroupclass MyViewManager(    private val reactContext: ReactApplicationContext) : ViewGroupManager<FrameLayout>() {  private var propWidth: Int? = null  private var propHeight: Int? = null  override fun getName() = REACT_CLASS  /**   * Return a FrameLayout which will later hold the Fragment   */  override fun createViewInstance(reactContext: ThemedReactContext) =      FrameLayout(reactContext)  /**   * Map the "create" command to an integer   */  override fun getCommandsMap() = mapOf("create" to COMMAND_CREATE)  /**   * Handle "create" command (called from JS) and call createFragment method   */  override fun receiveCommand(      root: FrameLayout,      commandId: String,      args: ReadableArray?  ) {    super.receiveCommand(root, commandId, args)    val reactNativeViewId = requireNotNull(args).getInt(0)    when (commandId.toInt()) {      COMMAND_CREATE -> createFragment(root, reactNativeViewId)    }  }  @ReactPropGroup(names = ["width", "height"], customType = "Style")  fun setStyle(view: FrameLayout, index: Int, value: Int) {    if (index == 0) propWidth = value    if (index == 1) propHeight = value  }  /**   * Replace your React Native view with a custom fragment   */  fun createFragment(root: FrameLayout, reactNativeViewId: Int) {    val parentView = root.findViewById<ViewGroup>(reactNativeViewId)    setupLayout(parentView)    val myFragment = MyFragment()    val activity = reactContext.currentActivity as FragmentActivity    activity.supportFragmentManager        .beginTransaction()        .replace(reactNativeViewId, myFragment, reactNativeViewId.toString())        .commit()  }  fun setupLayout(view: View) {    Choreographer.getInstance().postFrameCallback(object: Choreographer.FrameCallback {      override fun doFrame(frameTimeNanos: Long) {        manuallyLayoutChildren(view)        view.viewTreeObserver.dispatchOnGlobalLayout()        Choreographer.getInstance().postFrameCallback(this)      }    })  }  /**   * Layout all children properly   */  private fun manuallyLayoutChildren(view: View) {    // propWidth and propHeight coming from react-native props    val width = requireNotNull(propWidth)    val height = requireNotNull(propHeight)    view.measure(        View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),        View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY))    view.layout(0, 0, width, height)  }  companion object {    private const val REACT_CLASS = "MyViewManager"    private const val COMMAND_CREATE = 1  }}
```

```
// replace with your packagepackage com.mypackage;import android.view.Choreographer;import android.view.View;import android.view.ViewGroup;import android.widget.FrameLayout;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.fragment.app.FragmentActivity;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReadableArray;import com.facebook.react.common.MapBuilder;import com.facebook.react.uimanager.annotations.ReactProp;import com.facebook.react.uimanager.annotations.ReactPropGroup;import com.facebook.react.uimanager.ViewGroupManager;import com.facebook.react.uimanager.ThemedReactContext;import java.util.Map;public class MyViewManager extends ViewGroupManager<FrameLayout> {  public static final String REACT_CLASS = "MyViewManager";  public final int COMMAND_CREATE = 1;  private int propWidth;  private int propHeight;  ReactApplicationContext reactContext;  public MyViewManager(ReactApplicationContext reactContext) {    this.reactContext = reactContext;  }  @Override  public String getName() {    return REACT_CLASS;  }  /**   * Return a FrameLayout which will later hold the Fragment   */  @Override  public FrameLayout createViewInstance(ThemedReactContext reactContext) {    return new FrameLayout(reactContext);  }  /**   * Map the "create" command to an integer   */  @Nullable  @Override  public Map<String, Integer> getCommandsMap() {    return MapBuilder.of("create", COMMAND_CREATE);  }  /**   * Handle "create" command (called from JS) and call createFragment method   */  @Override  public void receiveCommand(    @NonNull FrameLayout root,    String commandId,    @Nullable ReadableArray args  ) {    super.receiveCommand(root, commandId, args);    int reactNativeViewId = args.getInt(0);    int commandIdInt = Integer.parseInt(commandId);    switch (commandIdInt) {      case COMMAND_CREATE:        createFragment(root, reactNativeViewId);        break;      default: {}    }  }  @ReactPropGroup(names = {"width", "height"}, customType = "Style")  public void setStyle(FrameLayout view, int index, Integer value) {    if (index == 0) {      propWidth = value;    }    if (index == 1) {      propHeight = value;    }  }  /**   * Replace your React Native view with a custom fragment   */  public void createFragment(FrameLayout root, int reactNativeViewId) {    ViewGroup parentView = (ViewGroup) root.findViewById(reactNativeViewId);    setupLayout(parentView);    final MyFragment myFragment = new MyFragment();    FragmentActivity activity = (FragmentActivity) reactContext.getCurrentActivity();    activity.getSupportFragmentManager()            .beginTransaction()            .replace(reactNativeViewId, myFragment, String.valueOf(reactNativeViewId))            .commit();  }  public void setupLayout(View view) {    Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {      @Override      public void doFrame(long frameTimeNanos) {        manuallyLayoutChildren(view);        view.getViewTreeObserver().dispatchOnGlobalLayout();        Choreographer.getInstance().postFrameCallback(this);      }    });  }  /**   * Layout all children properly   */  public void manuallyLayoutChildren(View view) {      // propWidth and propHeight coming from react-native props      int width = propWidth;      int height = propHeight;      view.measure(              View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY),              View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY));      view.layout(0, 0, width, height);  }}
```


### 4. Register theViewManager
- JavaKotlin
- Kotlin
```
// replace with your packagepackage com.mypackageimport com.facebook.react.ReactPackageimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.uimanager.ViewManagerclass MyPackage : ReactPackage {  ...  override fun createViewManagers(      reactContext: ReactApplicationContext  ) = listOf(MyViewManager(reactContext))}
```

```
// replace with your packagepackage com.mypackage;import com.facebook.react.ReactPackage;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.uimanager.ViewManager;import java.util.Arrays;import java.util.List;public class MyPackage implements ReactPackage {   @Override   public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {       return Arrays.<ViewManager>asList(            new MyViewManager(reactContext)       );   }}
```


### 5. Register thePackage
- JavaKotlin
- Kotlin
```
override fun getPackages(): List<ReactPackage> =    PackageList(this).packages.apply {        // Packages that cannot be autolinked yet can be added manually here, for example:        // add(MyReactNativePackage())        add(MyAppPackage())    }
```

```
@Overrideprotected List<ReactPackage> getPackages() {    List<ReactPackage> packages = new PackageList(this).getPackages();    // Packages that cannot be autolinked yet can be added manually here, for example:    // packages.add(new MyReactNativePackage());    packages.add(new MyAppPackage());    return packages;}
```


### 6. Implement the JavaScript module
I. Start with custom View manager:

```
import {requireNativeComponent} from 'react-native';export const MyViewManager =  requireNativeComponent('MyViewManager');
```

II. Then implement custom View calling thecreatemethod:

```
import React, {useEffect, useRef} from 'react';import {  PixelRatio,  UIManager,  findNodeHandle,} from 'react-native';import {MyViewManager} from './my-view-manager';const createFragment = viewId =>  UIManager.dispatchViewManagerCommand(    viewId,    // we are calling the 'create' command    UIManager.MyViewManager.Commands.create.toString(),    [viewId],  );export const MyView = () => {  const ref = useRef(null);  useEffect(() => {    const viewId = findNodeHandle(ref.current);    createFragment(viewId);  }, []);  return (    <MyViewManager      style={{        // converts dpi to px, provide desired height        height: PixelRatio.getPixelSizeForLayoutSize(200),        // converts dpi to px, provide desired width        width: PixelRatio.getPixelSizeForLayoutSize(200),      }}      ref={ref}    />  );};
```

If you want to expose property setters using@ReactProp(or@ReactPropGroup) annotation see theImageView exampleabove.


================================================================================


# iOS Native UI Components
Source: https://reactnative.dev/docs/legacy/native-components-ios

Native Module and Native Components are our stable technologies used by the legacy architecture.
They will be deprecated in the future when the New Architecture will be stable. The New Architecture usesTurbo Native ModuleandFabric Native Componentsto achieve similar results.

There are tons of native UI widgets out there ready to be used in the latest apps - some of them are part of the platform, others are available as third-party libraries, and still more might be in use in your very own portfolio. React Native has several of the most critical platform components already wrapped, likeScrollViewandTextInput, but not all of them, and certainly not ones you might have written yourself for a previous app. Fortunately, we can wrap up these existing components for seamless integration with your React Native application.

Like the native module guide, this too is a more advanced guide that assumes you are somewhat familiar with iOS programming. This guide will show you how to build a native UI component, walking you through the implementation of a subset of the existingMapViewcomponent available in the core React Native library.


## iOS MapView example
Let's say we want to add an interactive Map to our app - might as well useMKMapView, we only need to make it usable from JavaScript.

Native views are created and manipulated by subclasses ofRCTViewManager. These subclasses are similar in function to view controllers, but are essentially singletons - only one instance of each is created by the bridge. They expose native views to theRCTUIManager, which delegates back to them to set and update the properties of the views as necessary. TheRCTViewManagers are also typically the delegates for the views, sending events back to JavaScript via the bridge.

To expose a view you can:

- SubclassRCTViewManagerto create a manager for your component.
- Add theRCT_EXPORT_MODULE()marker macro.
- Implement the-(UIView *)viewmethod.
```
#import <MapKit/MapKit.h>#import <React/RCTViewManager.h>@interface RNTMapManager : RCTViewManager@end@implementation RNTMapManagerRCT_EXPORT_MODULE(RNTMap)- (UIView *)view{  return [[MKMapView alloc] init];}@end
```

Do not attempt to set theframeorbackgroundColorproperties on theUIViewinstance that you expose through the-viewmethod.
React Native will overwrite the values set by your custom class in order to match your JavaScript component's layout props.
If you need this granularity of control it might be better to wrap theUIViewinstance you want to style in anotherUIViewand return the wrapperUIViewinstead.
SeeIssue 2948for more context.

In the example above, we prefixed our class name withRNT. Prefixes are used to avoid name collisions with other frameworks.
Apple frameworks use two-letter prefixes, and React Native usesRCTas a prefix. In order to avoid name collisions, we recommend using a three-letter prefix other thanRCTin your own classes.

Then you need a little bit of JavaScript to make this a usable React component:

```
import {requireNativeComponent} from 'react-native';export default requireNativeComponent('RNTMap');
```

TherequireNativeComponentfunction automatically resolvesRNTMaptoRNTMapManagerand exports our native view for use in JavaScript.

```
import MapView from './MapView.tsx';export default function MyApp() {  return <MapView style={{flex: 1}} />;}
```

When rendering, don't forget to stretch the view, otherwise you'll be staring at a blank screen.

This is now a fully-functioning native map view component in JavaScript, complete with pinch-zoom and other native gesture support. We can't really control it from JavaScript yet, though.


## Properties
The first thing we can do to make this component more usable is to bridge over some native properties. Let's say we want to be able to disable zooming and specify the visible region. Disabling zoom is a boolean, so we add this one line:

```
RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)
```

Note that we explicitly specify the type asBOOL- React Native usesRCTConvertunder the hood to convert all sorts of different data types when talking over the bridge, and bad values will show convenient "RedBox" errors to let you know there is an issue ASAP. When things are straightforward like this, the whole implementation is taken care of for you by this macro.

Now to actually disable zooming, we set the property in JavaScript:

```
import MapView from './MapView.tsx';export default function MyApp() {  return <MapView zoomEnabled={false} style={{flex: 1}} />;}
```

To document the properties (and which values they accept) of our MapView component we'll add a wrapper component and document the interface with TypeScript:

```
import {requireNativeComponent} from 'react-native';const RNTMap = requireNativeComponent('RNTMap');export default function MapView(props: {  /**   * Whether the user may use pinch gestures to zoom in and out.   */  zoomEnabled?: boolean;}) {  return <RNTMap {...props} />;}
```

Now we have a nicely documented wrapper component to work with.

Next, let's add the more complexregionprop. We start by adding the native code:

```
RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, MKMapView){  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];}
```

Ok, this is more complicated than theBOOLcase we had before. Now we have aMKCoordinateRegiontype that needs a conversion function, and we have custom code so that the view will animate when we set the region from JS. Within the function body that we provide,jsonrefers to the raw value that has been passed from JS. There is also aviewvariable which gives us access to the manager's view instance, and adefaultViewthat we use to reset the property back to the default value if JS sends us a null sentinel.

You could write any conversion function you want for your view - here is the implementation forMKCoordinateRegionvia a category onRCTConvert. It uses an already existing category of ReactNativeRCTConvert+CoreLocation:

```
#import "RCTConvert+Mapkit.h"
```

```
#import <MapKit/MapKit.h>#import <React/RCTConvert.h>#import <CoreLocation/CoreLocation.h>#import <React/RCTConvert+CoreLocation.h>@interface RCTConvert (Mapkit)+ (MKCoordinateSpan)MKCoordinateSpan:(id)json;+ (MKCoordinateRegion)MKCoordinateRegion:(id)json;@end@implementation RCTConvert(MapKit)+ (MKCoordinateSpan)MKCoordinateSpan:(id)json{  json = [self NSDictionary:json];  return (MKCoordinateSpan){    [self CLLocationDegrees:json[@"latitudeDelta"]],    [self CLLocationDegrees:json[@"longitudeDelta"]]  };}+ (MKCoordinateRegion)MKCoordinateRegion:(id)json{  return (MKCoordinateRegion){    [self CLLocationCoordinate2D:json],    [self MKCoordinateSpan:json]  };}@end
```

These conversion functions are designed to safely process any JSON that the JS might throw at them by displaying "RedBox" errors and returning standard initialization values when missing keys or other developer errors are encountered.

To finish up support for theregionprop, we can document it with TypeScript:

```
import {requireNativeComponent} from 'react-native';const RNTMap = requireNativeComponent('RNTMap');export default function MapView(props: {  /**   * The region to be displayed by the map.   *   * The region is defined by the center coordinates and the span of   * coordinates to display.   */  region?: {    /**     * Coordinates for the center of the map.     */    latitude: number;    longitude: number;    /**     * Distance between the minimum and the maximum latitude/longitude     * to be displayed.     */    latitudeDelta: number;    longitudeDelta: number;  };  /**   * Whether the user may use pinch gestures to zoom in and out.   */  zoomEnabled?: boolean;}) {  return <RNTMap {...props} />;}
```

We can now supply theregionprop toMapView:

```
import MapView from './MapView.tsx';export default function MyApp() {  const region = {    latitude: 37.48,    longitude: -122.16,    latitudeDelta: 0.1,    longitudeDelta: 0.1,  };  return (    <MapView      region={region}      zoomEnabled={false}      style={{flex: 1}}    />  );}
```


## Events
So now we have a native map component that we can control freely from JS, but how do we deal with events from the user, like pinch-zooms or panning to change the visible region?

Until now we've only returned aMKMapViewinstance from our manager's-(UIView *)viewmethod. We can't add new properties toMKMapViewso we have to create a new subclass fromMKMapViewwhich we use for our View. We can then add aonRegionChangecallback on this subclass:

```
#import <MapKit/MapKit.h>#import <React/RCTComponent.h>@interface RNTMapView: MKMapView@property (nonatomic, copy) RCTBubblingEventBlock onRegionChange;@end
```

```
#import "RNTMapView.h"@implementation RNTMapView@end
```

Note that allRCTBubblingEventBlockmust be prefixed withon. Next, declare an event handler property onRNTMapManager, make it a delegate for all the views it exposes, and forward events to JS by calling the event handler block from the native view.

```
#import <MapKit/MapKit.h>#import <React/RCTViewManager.h>#import "RNTMapView.h"#import "RCTConvert+Mapkit.h"@interface RNTMapManager : RCTViewManager <MKMapViewDelegate>@end@implementation RNTMapManagerRCT_EXPORT_MODULE()RCT_EXPORT_VIEW_PROPERTY(zoomEnabled, BOOL)RCT_EXPORT_VIEW_PROPERTY(onRegionChange, RCTBubblingEventBlock)RCT_CUSTOM_VIEW_PROPERTY(region, MKCoordinateRegion, MKMapView){  [view setRegion:json ? [RCTConvert MKCoordinateRegion:json] : defaultView.region animated:YES];}- (UIView *)view{  RNTMapView *map = [RNTMapView new];  map.delegate = self;  return map;}#pragma mark MKMapViewDelegate- (void)mapView:(RNTMapView *)mapView regionDidChangeAnimated:(BOOL)animated{  if (!mapView.onRegionChange) {    return;  }  MKCoordinateRegion region = mapView.region;  mapView.onRegionChange(@{    @"region": @{      @"latitude": @(region.center.latitude),      @"longitude": @(region.center.longitude),      @"latitudeDelta": @(region.span.latitudeDelta),      @"longitudeDelta": @(region.span.longitudeDelta),    }  });}@end
```

In the delegate method-mapView:regionDidChangeAnimated:the event handler block is called on the corresponding view with the region data. Calling theonRegionChangeevent handler block results in calling the same callback prop in JavaScript. This callback is invoked with the raw event, which we typically process in the wrapper component to simplify the API:

```
// ...type RegionChangeEvent = {  nativeEvent: {    latitude: number;    longitude: number;    latitudeDelta: number;    longitudeDelta: number;  };};export default function MapView(props: {  // ...  /**   * Callback that is called continuously when the user is dragging the map.   */  onRegionChange: (event: RegionChangeEvent) => unknown;}) {  return <RNTMap {...props} onRegionChange={onRegionChange} />;}
```

```
import MapView from './MapView.tsx';export default function MyApp() {  // ...  const onRegionChange = useCallback(event => {    const {region} = event.nativeEvent;    // Do something with `region.latitude`, etc.  });  return (    <MapView      // ...      onRegionChange={onRegionChange}    />  );}
```


## Handling multiple native views
A React Native view can have more than one child view in the view tree eg.

```
<View>  <MyNativeView />  <MyNativeView />  <Button /></View>
```

In this example, the classMyNativeViewis a wrapper for aNativeComponentand exposes methods, which will be called on the iOS platform.MyNativeViewis defined inMyNativeView.ios.jsand contains proxy methods ofNativeComponent.

When the user interacts with the component, like clicking the button, thebackgroundColorofMyNativeViewchanges. In this caseUIManagerwould not know whichMyNativeViewshould be handled and which one should changebackgroundColor. Below you will find a solution to this problem:

```
<View>  <MyNativeView ref={this.myNativeReference} />  <MyNativeView ref={this.myNativeReference2} />  <Button    onPress={() => {      this.myNativeReference.callNativeMethod();    }}  /></View>
```

Now the above component has a reference to a particularMyNativeViewwhich allows us to use a specific instance ofMyNativeView. Now the button can control whichMyNativeViewshould change itsbackgroundColor. In this example let's assume thatcallNativeMethodchangesbackgroundColor.

```
class MyNativeView extends React.Component {  callNativeMethod = () => {    UIManager.dispatchViewManagerCommand(      ReactNative.findNodeHandle(this),      UIManager.getViewManagerConfig('RNCMyNativeView').Commands        .callNativeMethod,      [],    );  };  render() {    return <NativeComponent ref={NATIVE_COMPONENT_REF} />;  }}
```

callNativeMethodis our custom iOS method which for example changes thebackgroundColorwhich is exposed throughMyNativeView. This method usesUIManager.dispatchViewManagerCommandwhich needs 3 parameters:

- (nonnull NSNumber \*)reactTag-  id of react view.
- commandID:(NSInteger)commandID-  Id of the native method that should be called
- commandArgs:(NSArray<id> \*)commandArgs-  Args of the native method that we can pass from JS to native.
```
#import <React/RCTViewManager.h>#import <React/RCTUIManager.h>#import <React/RCTLog.h>RCT_EXPORT_METHOD(callNativeMethod:(nonnull NSNumber*) reactTag) {    [self.bridge.uiManager addUIBlock:^(RCTUIManager *uiManager, NSDictionary<NSNumber *,UIView *> *viewRegistry) {        NativeView *view = viewRegistry[reactTag];        if (!view || ![view isKindOfClass:[NativeView class]]) {            RCTLogError(@"Cannot find NativeView with tag #%@", reactTag);            return;        }        [view callNativeMethod];    }];}
```

Here thecallNativeMethodis defined in theRNCMyNativeViewManager.mfile and contains only one parameter which is(nonnull NSNumber*) reactTag. This exported function will find a particular view usingaddUIBlockwhich contains theviewRegistryparameter and returns the component based onreactTagallowing it to call the method on the correct component.


## Styles
Since all our native react views are subclasses ofUIView, most style attributes will work like you would expect out of the box. Some components will want a default style, however, for exampleUIDatePickerwhich is a fixed size. This default style is important for the layout algorithm to work as expected, but we also want to be able to override the default style when using the component.DatePickerIOSdoes this by wrapping the native component in an extra view, which has flexible styling, and using a fixed style (which is generated with constants passed in from native) on the inner native component:

```
import {UIManager} from 'react-native';const RCTDatePickerIOSConsts = UIManager.RCTDatePicker.Constants;...  render: function() {    return (      <View style={this.props.style}>        <RCTDatePickerIOS          ref={DATEPICKER}          style={styles.rkDatePickerIOS}          ...        />      </View>    );  }});const styles = StyleSheet.create({  rkDatePickerIOS: {    height: RCTDatePickerIOSConsts.ComponentHeight,    width: RCTDatePickerIOSConsts.ComponentWidth,  },});
```

TheRCTDatePickerIOSConstsconstants are exported from native by grabbing the actual frame of the native component like so:

```
- (NSDictionary *)constantsToExport{  UIDatePicker *dp = [[UIDatePicker alloc] init];  [dp layoutIfNeeded];  return @{    @"ComponentHeight": @(CGRectGetHeight(dp.frame)),    @"ComponentWidth": @(CGRectGetWidth(dp.frame)),    @"DatePickerModes": @{      @"time": @(UIDatePickerModeTime),      @"date": @(UIDatePickerModeDate),      @"datetime": @(UIDatePickerModeDateAndTime),    }  };}
```

This guide covered many of the aspects of bridging over custom native components, but there is even more you might need to consider, such as custom hooks for inserting and laying out subviews. If you want to go even deeper, check out thesource codeof some of the implemented components.


================================================================================


# Android Native Modules
Source: https://reactnative.dev/docs/legacy/native-modules-android

Native Module and Native Components are our stable technologies used by the legacy architecture.
They will be deprecated in the future when the New Architecture will be stable. The New Architecture usesTurbo Native ModuleandFabric Native Componentsto achieve similar results.

Welcome to Native Modules for Android. Please start by reading theNative Modules Introfor an intro to what native modules are.


## Create a Calendar Native Module
In the following guide you will create a native module,CalendarModule, that will allow you to access Android’s calendar APIs from JavaScript. By the end, you will be able to callCalendarModule.createCalendarEvent('Dinner Party', 'My House');from JavaScript, invoking a Java/Kotlin method that creates a calendar event.


### Setup
To get started, open up the Android project within your React Native application in Android Studio. You can find your Android project here within a React Native app:

We recommend using Android Studio to write your native code. Android Studio is an IDE built for Android development and using it will help you resolve minor issues like code syntax errors quickly.

We also recommend enablingGradle Daemonto speed up builds as you iterate on Java/Kotlin code.


### Create A Custom Native Module File
The first step is to create the (CalendarModule.javaorCalendarModule.kt) Java/Kotlin file insideandroid/app/src/main/java/com/your-app-name/folder (the folder is the same for both Kotlin and Java). This Java/Kotlin file will contain your native module Java/Kotlin class.

Then add the following content:

- JavaKotlin
- Kotlin
```
package com.your-apps-package-name; // replace your-apps-package-name with your app’s package nameimport com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.bridge.ReactContext;import com.facebook.react.bridge.ReactContextBaseJavaModule;import com.facebook.react.bridge.ReactMethod;import java.util.Map;import java.util.HashMap;public class CalendarModule extends ReactContextBaseJavaModule {   CalendarModule(ReactApplicationContext context) {       super(context);   }}
```

```
package com.your-apps-package-name; // replace your-apps-package-name with your app’s package nameimport com.facebook.react.bridge.NativeModuleimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.bridge.ReactContextimport com.facebook.react.bridge.ReactContextBaseJavaModuleimport com.facebook.react.bridge.ReactMethodclass CalendarModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {...}
```

As you can see, yourCalendarModuleclass extends theReactContextBaseJavaModuleclass. For Android, Java/Kotlin native modules are written as classes that extendReactContextBaseJavaModuleand implement the functionality required by JavaScript.

It is worth noting that technically Java/Kotlin classes only need to extend theBaseJavaModuleclass or implement theNativeModuleinterface to be considered a Native Module by React Native.However we recommend that you useReactContextBaseJavaModule, as shown above.ReactContextBaseJavaModulegives access to theReactApplicationContext(RAC), which is useful for Native Modules that need to hook into activity lifecycle methods. UsingReactContextBaseJavaModulewill also make it easier to make your native module type-safe in the future. For native module type-safety, which is coming in future releases, React Native looks at each native module's JavaScript spec and generates an abstract base class that extendsReactContextBaseJavaModule.

However we recommend that you useReactContextBaseJavaModule, as shown above.ReactContextBaseJavaModulegives access to theReactApplicationContext(RAC), which is useful for Native Modules that need to hook into activity lifecycle methods. UsingReactContextBaseJavaModulewill also make it easier to make your native module type-safe in the future. For native module type-safety, which is coming in future releases, React Native looks at each native module's JavaScript spec and generates an abstract base class that extendsReactContextBaseJavaModule.


### Module Name
All Java/Kotlin native modules in Android need to implement thegetName()method. This method returns a string, which represents the name of the native module. The native module can then be accessed in JavaScript using its name. For example, in the below code snippet,getName()returns"CalendarModule".

- JavaKotlin
- Kotlin
```
// add to CalendarModule.java@Overridepublic String getName() {   return "CalendarModule";}
```

```
// add to CalendarModule.ktoverride fun getName() = "CalendarModule"
```

The native module can then be accessed in JS like this:

```
const {CalendarModule} = ReactNative.NativeModules;
```


### Export a Native Method to JavaScript
Next you will need to add a method to your native module that will create calendar events and can be invoked in JavaScript. All native module methods meant to be invoked from JavaScript must be annotated with@ReactMethod.

Set up a methodcreateCalendarEvent()forCalendarModulethat can be invoked in JS throughCalendarModule.createCalendarEvent(). For now, the method will take in a name and location as strings. Argument type options will be covered shortly.

- JavaKotlin
- Kotlin
```
@ReactMethodpublic void createCalendarEvent(String name, String location) {}
```

```
@ReactMethod fun createCalendarEvent(name: String, location: String) {}
```

Add a debug log in the method to confirm it has been invoked when you call it from your application. Below is an example of how you can import and use theLogclass from the Android util package:

- JavaKotlin
- Kotlin
```
import android.util.Log;@ReactMethodpublic void createCalendarEvent(String name, String location) {   Log.d("CalendarModule", "Create event called with name: " + name   + " and location: " + location);}
```

```
import android.util.Log@ReactMethodfun createCalendarEvent(name: String, location: String) {    Log.d("CalendarModule", "Create event called with name: $name and location: $location")}
```

Once you finish implementing the native module and hook it up in JavaScript, you can followthese stepsto view the logs from your app.


### Synchronous Methods
You can passisBlockingSynchronousMethod = trueto a native method to mark it as a synchronous method.

- JavaKotlin
- Kotlin
```
@ReactMethod(isBlockingSynchronousMethod = true)
```

```
@ReactMethod(isBlockingSynchronousMethod = true)
```

At the moment, we do not recommend this, since calling methods synchronously can have strong performance penalties and introduce threading-related bugs to your native modules. Additionally, please note that if you choose to enableisBlockingSynchronousMethod, your app can no longer use the Google Chrome debugger. This is because synchronous methods require the JS VM to share memory with the app. For the Google Chrome debugger, React Native runs inside the JS VM in Google Chrome, and communicates asynchronously with the mobile devices via WebSockets.


### Register the Module (Android Specific)
Once a native module is written, it needs to be registered with React Native. In order to do so, you need to add your native module to aReactPackageand register theReactPackagewith React Native. During initialization, React Native will loop over all packages, and for eachReactPackage, register each native module within.

React Native invokes the methodcreateNativeModules()on aReactPackagein order to get the list of native modules to register. For Android, if a module is not instantiated and returned in createNativeModules it will not be available from JavaScript.

To add your Native Module toReactPackage, first create a new Java/Kotlin Class named (MyAppPackage.javaorMyAppPackage.kt) that implementsReactPackageinside theandroid/app/src/main/java/com/your-app-name/folder:

Then add the following content:

- JavaKotlin
- Kotlin
```
package com.your-app-name; // replace your-app-name with your app’s nameimport com.facebook.react.ReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.uimanager.ViewManager;import java.util.ArrayList;import java.util.Collections;import java.util.List;public class MyAppPackage implements ReactPackage {   @Override   public List<ViewManager> createViewManagers(ReactApplicationContext reactContext) {       return Collections.emptyList();   }   @Override   public List<NativeModule> createNativeModules(           ReactApplicationContext reactContext) {       List<NativeModule> modules = new ArrayList<>();       modules.add(new CalendarModule(reactContext));       return modules;   }}
```

```
package com.your-app-name // replace your-app-name with your app’s nameimport android.view.Viewimport com.facebook.react.ReactPackageimport com.facebook.react.bridge.NativeModuleimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.uimanager.ReactShadowNodeimport com.facebook.react.uimanager.ViewManagerclass MyAppPackage : ReactPackage {    override fun createViewManagers(        reactContext: ReactApplicationContext    ): MutableList<ViewManager<View, ReactShadowNode<*>>> = mutableListOf()    override fun createNativeModules(        reactContext: ReactApplicationContext    ): MutableList<NativeModule> = listOf(CalendarModule(reactContext)).toMutableList()}
```

This file imports the native module you created,CalendarModule. It then instantiatesCalendarModulewithin thecreateNativeModules()function and returns it as a list ofNativeModulesto register. If you add more native modules down the line, you can also instantiate them and add them to the list returned here.

It is worth noting that this way of registering native modules eagerly initializes all native modules when the application starts, which adds to the startup time of an application. You can useTurboReactPackageas an alternative. Instead ofcreateNativeModules, which return a list of instantiated native module objects, TurboReactPackage implements agetModule(String name, ReactApplicationContext rac)method that creates the native module object, when required. TurboReactPackage is a bit more complicated to implement at the moment. In addition to implementing agetModule()method, you have to implement agetReactModuleInfoProvider()method, which returns a list of all the native modules the package can instantiate along with a function that instantiates them, examplehere. Again, using TurboReactPackage will allow your application to have a faster startup time, but it is currently a bit cumbersome to write. So proceed with caution if you choose to use TurboReactPackages.

To register theCalendarModulepackage, you must addMyAppPackageto the list of packages returned in ReactNativeHost'sgetPackages()method. Open up yourMainApplication.javaorMainApplication.ktfile, which can be found in the following path:android/app/src/main/java/com/your-app-name/.

Locate ReactNativeHost’sgetPackages()method and add your package to the packages listgetPackages()returns:

- JavaKotlin
- Kotlin
```
@Overrideprotected List<ReactPackage> getPackages() {    List<ReactPackage> packages = new PackageList(this).getPackages();    // Packages that cannot be autolinked yet can be added manually here, for example:    // packages.add(new MyReactNativePackage());    packages.add(new MyAppPackage());    return packages;}
```

```
override fun getPackages(): List<ReactPackage> =    PackageList(this).packages.apply {        // Packages that cannot be autolinked yet can be added manually here, for example:        // add(MyReactNativePackage())        add(MyAppPackage())    }
```

You have now successfully registered your native module for Android!


### Test What You Have Built
At this point, you have set up the basic scaffolding for your native module in Android. Test that out by accessing the native module and invoking its exported method in JavaScript.

Find a place in your application where you would like to add a call to the native module’screateCalendarEvent()method. Below is an example of a component,NewModuleButtonyou can add in your app. You can invoke the native module insideNewModuleButton'sonPress()function.

```
import React from 'react';import {NativeModules, Button} from 'react-native';const NewModuleButton = () => {  const onPress = () => {    console.log('We will invoke the native module here!');  };  return (    <Button      title="Click to invoke your native module!"      color="#841584"      onPress={onPress}    />  );};export default NewModuleButton;
```

In order to access your native module from JavaScript you need to first importNativeModulesfrom React Native:

```
import {NativeModules} from 'react-native';
```

You can then access theCalendarModulenative module off ofNativeModules.

```
const {CalendarModule} = NativeModules;
```

Now that you have the CalendarModule native module available, you can invoke your native methodcreateCalendarEvent(). Below it is added to theonPress()method inNewModuleButton:

```
const onPress = () => {  CalendarModule.createCalendarEvent('testName', 'testLocation');};
```

The final step is to rebuild the React Native app so that you can have the latest native code (with your new native module!) available. In your command line, where the react native application is located, run the following:

- npmYarn
- Yarn
```
npm run android
```

```
yarn android
```


### Building as You Iterate
As you work through these guides and iterate on your native module, you will need to do a native rebuild of your application to access your most recent changes from JavaScript. This is because the code that you are writing sits within the native part of your application. While React Native’s metro bundler can watch for changes in JavaScript and rebuild on the fly for you, it will not do so for native code. So if you want to test your latest native changes you need to rebuild by using the above command.


### Recap✨
You should now be able to invoke yourcreateCalendarEvent()method on your native module in the app. In our example this occurs by pressing theNewModuleButton. You can confirm this by viewing the log you set up in yourcreateCalendarEvent()method. You can followthese stepsto view ADB logs in your app. You should then be able to search for yourLog.dmessage (in our example “Create event called with name: testName and location: testLocation”) and see your message logged each time you invoke your native module method.

At this point you have created an Android native module and invoked its native method from JavaScript in your React Native application. You can read on to learn more about things like argument types available to a native module method and how to setup callbacks and promises.


## Beyond a Calendar Native Module

### Better Native Module Export
Importing your native module by pulling it off ofNativeModuleslike above is a bit clunky.

To save consumers of your native module from needing to do that each time they want to access your native module, you can create a JavaScript wrapper for the module. Create a new JavaScript file namedCalendarModule.jswith the following content:

```
/*** This exposes the native CalendarModule module as a JS module. This has a* function 'createCalendarEvent' which takes the following parameters:* 1. String name: A string representing the name of the event* 2. String location: A string representing the location of the event*/import {NativeModules} from 'react-native';const {CalendarModule} = NativeModules;export default CalendarModule;
```

This JavaScript file also becomes a good location for you to add any JavaScript side functionality. For example, if you use a type system like TypeScript you can add type annotations for your native module here. While React Native does not yet support Native to JS type safety, all your JS code will be type safe. Doing so will also make it easier for you to switch to type-safe native modules down the line. Below is an example of adding type safety to the CalendarModule:

```
/** * This exposes the native CalendarModule module as a JS module. This has a * function 'createCalendarEvent' which takes the following parameters: * * 1. String name: A string representing the name of the event * 2. String location: A string representing the location of the event */import {NativeModules} from 'react-native';const {CalendarModule} = NativeModules;interface CalendarInterface {  createCalendarEvent(name: string, location: string): void;}export default CalendarModule as CalendarInterface;
```

In your other JavaScript files you can access the native module and invoke its method like this:

```
import CalendarModule from './CalendarModule';CalendarModule.createCalendarEvent('foo', 'bar');
```

This assumes that the place you are importingCalendarModuleis in the same hierarchy asCalendarModule.js. Please update the relative import as necessary.


### Argument Types
When a native module method is invoked in JavaScript, React Native converts the arguments from JS objects to their Java/Kotlin object analogues. So for example, if your Java Native Module method accepts a double, in JS you need to call the method with a number. React Native will handle the conversion for you. Below is a list of the argument types supported for native module methods and the JavaScript equivalents they map to.

The following types are currently supported but will not be supported in TurboModules. Please avoid using them:Integer Java/Kotlin -> ?numberFloat Java/Kotlin -> ?numberint Java -> numberfloat Java -> number

- Integer Java/Kotlin -> ?number
- Float Java/Kotlin -> ?number
- int Java -> number
- float Java -> number
For argument types not listed above, you will need to handle the conversion yourself. For example, in Android,Dateconversion is not supported out of the box. You can handle the conversion to theDatetype within the native method yourself like so:

- JavaKotlin
- Kotlin
```
    String dateFormat = "yyyy-MM-dd";    SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);    Calendar eStartDate = Calendar.getInstance();    try {        eStartDate.setTime(sdf.parse(startDate));    }
```

```
    val dateFormat = "yyyy-MM-dd"    val sdf = SimpleDateFormat(dateFormat, Locale.US)    val eStartDate = Calendar.getInstance()    try {        sdf.parse(startDate)?.let {            eStartDate.time = it        }    }
```


### Exporting Constants
A native module can export constants by implementing the native methodgetConstants(), which is available in JS. Below you will implementgetConstants()and return a Map that contains aDEFAULT_EVENT_NAMEconstant you can access in JavaScript:

- JavaKotlin
- Kotlin
```
@Overridepublic Map<String, Object> getConstants() {   final Map<String, Object> constants = new HashMap<>();   constants.put("DEFAULT_EVENT_NAME", "New Event");   return constants;}
```

```
override fun getConstants(): MutableMap<String, Any> =    hashMapOf("DEFAULT_EVENT_NAME" to "New Event")
```

The constant can then be accessed by invokinggetConstantson the native module in JS:

```
const {DEFAULT_EVENT_NAME} = CalendarModule.getConstants();console.log(DEFAULT_EVENT_NAME);
```

Technically it is possible to access constants exported ingetConstants()directly off the native module object. This will no longer be supported with TurboModules, so we encourage the community to switch to the above approach to avoid necessary migration down the line.

That currently constants are exported only at initialization time, so if you change getConstants values at runtime it won't affect the JavaScript environment. This will change with Turbomodules. With Turbomodules,getConstants()will become a regular native module method, and each invocation will hit the native side.


### Callbacks
Native modules also support a unique kind of argument: a callback. Callbacks are used to pass data from Java/Kotlin to JavaScript for asynchronous methods. They can also be used to asynchronously execute JavaScript from the native side.

In order to create a native module method with a callback, first import theCallbackinterface, and then add a new parameter to your native module method of typeCallback. There are a couple of nuances with callback arguments that will soon be lifted with TurboModules. First off, you can only have two callbacks in your function arguments- a successCallback and a failureCallback. In addition, the last argument to a native module method call, if it's a function, is treated as the successCallback, and the second to last argument to a native module method call, if it's a function, is treated as the failure callback.

- JavaKotlin
- Kotlin
```
import com.facebook.react.bridge.Callback;@ReactMethodpublic void createCalendarEvent(String name, String location, Callback callBack) {}
```

```
import com.facebook.react.bridge.Callback@ReactMethod fun createCalendarEvent(name: String, location: String, callback: Callback) {}
```

You can invoke the callback in your Java/Kotlin method, providing whatever data you want to pass to JavaScript. Please note that you can only pass serializable data from native code to JavaScript. If you need to pass back a native object you can useWriteableMaps, if you need to use a collection useWritableArrays. It is also important to highlight that the callback is not invoked immediately after the native function completes. Below the ID of an event created in an earlier call is passed to the callback.

- JavaKotlin
- Kotlin
```
  @ReactMethod   public void createCalendarEvent(String name, String location, Callback callBack) {       Integer eventId = ...       callBack.invoke(eventId);   }
```

```
  @ReactMethod  fun createCalendarEvent(name: String, location: String, callback: Callback) {      val eventId = ...      callback.invoke(eventId)  }
```

This method could then be accessed in JavaScript using:

```
const onPress = () => {  CalendarModule.createCalendarEvent(    'Party',    'My House',    eventId => {      console.log(`Created a new event with id ${eventId}`);    },  );};
```

Another important detail to note is that a native module method can only invoke one callback, one time. This means that you can either call a success callback or a failure callback, but not both, and each callback can only be invoked at most one time. A native module can, however, store the callback and invoke it later.

There are two approaches to error handling with callbacks. The first is to follow Node’s convention and treat the first argument passed to the callback as an error object.

- JavaKotlin
- Kotlin
```
  @ReactMethod   public void createCalendarEvent(String name, String location, Callback callBack) {       Integer eventId = ...       callBack.invoke(null, eventId);   }
```

```
  @ReactMethod  fun createCalendarEvent(name: String, location: String, callback: Callback) {      val eventId = ...      callback.invoke(null, eventId)  }
```

In JavaScript, you can then check the first argument to see if an error was passed through:

```
const onPress = () => {  CalendarModule.createCalendarEvent(    'testName',    'testLocation',    (error, eventId) => {      if (error) {        console.error(`Error found! ${error}`);      }      console.log(`event id ${eventId} returned`);    },  );};
```

Another option is to use an onSuccess and onFailure callback:

- JavaKotlin
- Kotlin
```
@ReactMethodpublic void createCalendarEvent(String name, String location, Callback myFailureCallback, Callback mySuccessCallback) {}
```

```
@ReactMethod  fun createCalendarEvent(      name: String,      location: String,      myFailureCallback: Callback,      mySuccessCallback: Callback  ) {}
```

Then in JavaScript you can add a separate callback for error and success responses:

```
const onPress = () => {  CalendarModule.createCalendarEvent(    'testName',    'testLocation',    error => {      console.error(`Error found! ${error}`);    },    eventId => {      console.log(`event id ${eventId} returned`);    },  );};
```


### Promises
Native modules can also fulfill aPromise, which can simplify your JavaScript, especially when using ES2016'sasync/awaitsyntax. When the last parameter of a native module Java/Kotlin method is a Promise, its corresponding JS method will return a JS Promise object.

Refactoring the above code to use a promise instead of callbacks looks like this:

- JavaKotlin
- Kotlin
```
import com.facebook.react.bridge.Promise;@ReactMethodpublic void createCalendarEvent(String name, String location, Promise promise) {    try {        Integer eventId = ...        promise.resolve(eventId);    } catch(Exception e) {        promise.reject("Create Event Error", e);    }}
```

```
import com.facebook.react.bridge.Promise@ReactMethodfun createCalendarEvent(name: String, location: String, promise: Promise) {    try {        val eventId = ...        promise.resolve(eventId)    } catch (e: Throwable) {        promise.reject("Create Event Error", e)    }}
```

Similar to callbacks, a native module method can either reject or resolve a promise (but not both) and can do so at most once. This means that you can either call a success callback or a failure callback, but not both, and each callback can only be invoked at most one time. A native module can, however, store the callback and invoke it later.

The JavaScript counterpart of this method returns a Promise. This means you can use theawaitkeyword within an async function to call it and wait for its result:

```
const onSubmit = async () => {  try {    const eventId = await CalendarModule.createCalendarEvent(      'Party',      'My House',    );    console.log(`Created a new event with id ${eventId}`);  } catch (e) {    console.error(e);  }};
```

The reject method takes different combinations of the following arguments:

- JavaKotlin
- Kotlin
```
String code, String message, WritableMap userInfo, Throwable throwable
```

```
code: String, message: String, userInfo: WritableMap, throwable: Throwable
```

For more detail, you can find thePromise.javainterfacehere. IfuserInfois not provided, ReactNative will set it to null. For the rest of the parameters React Native will use a default value. Themessageargument provides the errormessageshown at the top of an error call stack. Below is an example of the error message shown in JavaScript from the following reject call in Java/Kotlin.

Java/Kotlin reject call:

- JavaKotlin
- Kotlin
```
promise.reject("Create Event error", "Error parsing date", e);
```

```
promise.reject("Create Event error", "Error parsing date", e)
```

Error message in React Native App when promise is rejected:


### Sending Events to JavaScript
Native modules can signal events to JavaScript without being invoked directly. For example, you might want to signal to JavaScript a reminder that a calendar event from the native Android calendar app will occur soon. The easiest way to do this is to use theRCTDeviceEventEmitterwhich can be obtained from theReactContextas in the code snippet below.

- JavaKotlin
- Kotlin
```
...import com.facebook.react.modules.core.DeviceEventManagerModule;import com.facebook.react.bridge.WritableMap;import com.facebook.react.bridge.Arguments;...private void sendEvent(ReactContext reactContext,                      String eventName,                      @Nullable WritableMap params) { reactContext     .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)     .emit(eventName, params);}private int listenerCount = 0;@ReactMethodpublic void addListener(String eventName) {  if (listenerCount == 0) {    // Set up any upstream listeners or background tasks as necessary  }  listenerCount += 1;}@ReactMethodpublic void removeListeners(Integer count) {  listenerCount -= count;  if (listenerCount == 0) {    // Remove upstream listeners, stop unnecessary background tasks  }}...WritableMap params = Arguments.createMap();params.putString("eventProperty", "someValue");...sendEvent(reactContext, "EventReminder", params);
```

```
...import com.facebook.react.bridge.WritableMapimport com.facebook.react.bridge.Argumentsimport com.facebook.react.modules.core.DeviceEventManagerModule...private fun sendEvent(reactContext: ReactContext, eventName: String, params: WritableMap?) {    reactContext      .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)      .emit(eventName, params)}private var listenerCount = 0@ReactMethodfun addListener(eventName: String) {  if (listenerCount == 0) {    // Set up any upstream listeners or background tasks as necessary  }  listenerCount += 1}@ReactMethodfun removeListeners(count: Int) {  listenerCount -= count  if (listenerCount == 0) {    // Remove upstream listeners, stop unnecessary background tasks  }}...val params = Arguments.createMap().apply {    putString("eventProperty", "someValue")}...sendEvent(reactContext, "EventReminder", params)
```

JavaScript modules can then register to receive events byaddListeneron theNativeEventEmitterclass.

```
import {NativeEventEmitter, NativeModules} from 'react-native';...useEffect(() => {    const eventEmitter = new NativeEventEmitter(NativeModules.ToastExample);    let eventListener = eventEmitter.addListener('EventReminder', event => {      console.log(event.eventProperty) // "someValue"    });    // Removes the listener once unmounted    return () => {      eventListener.remove();    };  }, []);
```


### Getting Activity Result from startActivityForResult
You'll need to listen toonActivityResultif you want to get results from an activity you started withstartActivityForResult. To do this, you must extendBaseActivityEventListeneror implementActivityEventListener. The former is preferred as it is more resilient to API changes. Then, you need to register the listener in the module's constructor like so:

- JavaKotlin
- Kotlin
```
reactContext.addActivityEventListener(mActivityResultListener);
```

```
reactContext.addActivityEventListener(mActivityResultListener);
```

Now you can listen toonActivityResultby implementing the following method:

- JavaKotlin
- Kotlin
```
@Overridepublic void onActivityResult( final Activity activity, final int requestCode, final int resultCode, final Intent intent) { // Your logic here}
```

```
override fun onActivityResult(    activity: Activity?,    requestCode: Int,    resultCode: Int,    intent: Intent?) {    // Your logic here}
```

Let's implement a basic image picker to demonstrate this. The image picker will expose the methodpickImageto JavaScript, which will return the path of the image when called.

- JavaKotlin
- Kotlin
```
public class ImagePickerModule extends ReactContextBaseJavaModule {  private static final int IMAGE_PICKER_REQUEST = 1;  private static final String E_ACTIVITY_DOES_NOT_EXIST = "E_ACTIVITY_DOES_NOT_EXIST";  private static final String E_PICKER_CANCELLED = "E_PICKER_CANCELLED";  private static final String E_FAILED_TO_SHOW_PICKER = "E_FAILED_TO_SHOW_PICKER";  private static final String E_NO_IMAGE_DATA_FOUND = "E_NO_IMAGE_DATA_FOUND";  private Promise mPickerPromise;  private final ActivityEventListener mActivityEventListener = new BaseActivityEventListener() {    @Override    public void onActivityResult(Activity activity, int requestCode, int resultCode, Intent intent) {      if (requestCode == IMAGE_PICKER_REQUEST) {        if (mPickerPromise != null) {          if (resultCode == Activity.RESULT_CANCELED) {            mPickerPromise.reject(E_PICKER_CANCELLED, "Image picker was cancelled");          } else if (resultCode == Activity.RESULT_OK) {            Uri uri = intent.getData();            if (uri == null) {              mPickerPromise.reject(E_NO_IMAGE_DATA_FOUND, "No image data found");            } else {              mPickerPromise.resolve(uri.toString());            }          }          mPickerPromise = null;        }      }    }  };  ImagePickerModule(ReactApplicationContext reactContext) {    super(reactContext);    // Add the listener for `onActivityResult`    reactContext.addActivityEventListener(mActivityEventListener);  }  @Override  public String getName() {    return "ImagePickerModule";  }  @ReactMethod  public void pickImage(final Promise promise) {    Activity currentActivity = getCurrentActivity();    if (currentActivity == null) {      promise.reject(E_ACTIVITY_DOES_NOT_EXIST, "Activity doesn't exist");      return;    }    // Store the promise to resolve/reject when picker returns data    mPickerPromise = promise;    try {      final Intent galleryIntent = new Intent(Intent.ACTION_PICK);      galleryIntent.setType("image/*");      final Intent chooserIntent = Intent.createChooser(galleryIntent, "Pick an image");      currentActivity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST);    } catch (Exception e) {      mPickerPromise.reject(E_FAILED_TO_SHOW_PICKER, e);      mPickerPromise = null;    }  }}
```

```
class ImagePickerModule(reactContext: ReactApplicationContext) :    ReactContextBaseJavaModule(reactContext) {    private var pickerPromise: Promise? = null    private val activityEventListener =        object : BaseActivityEventListener() {            override fun onActivityResult(                activity: Activity?,                requestCode: Int,                resultCode: Int,                intent: Intent?            ) {                if (requestCode == IMAGE_PICKER_REQUEST) {                    pickerPromise?.let { promise ->                        when (resultCode) {                            Activity.RESULT_CANCELED ->                                promise.reject(E_PICKER_CANCELLED, "Image picker was cancelled")                            Activity.RESULT_OK -> {                                val uri = intent?.data                                uri?.let { promise.resolve(uri.toString())}                                    ?: promise.reject(E_NO_IMAGE_DATA_FOUND, "No image data found")                            }                        }                        pickerPromise = null                    }                }            }        }    init {        reactContext.addActivityEventListener(activityEventListener)    }    override fun getName() = "ImagePickerModule"    @ReactMethod    fun pickImage(promise: Promise) {        val activity = currentActivity        if (activity == null) {            promise.reject(E_ACTIVITY_DOES_NOT_EXIST, "Activity doesn't exist")            return        }        pickerPromise = promise        try {            val galleryIntent = Intent(Intent.ACTION_PICK).apply { type = "image\/*" }            val chooserIntent = Intent.createChooser(galleryIntent, "Pick an image")            activity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST)        } catch (t: Throwable) {            pickerPromise?.reject(E_FAILED_TO_SHOW_PICKER, t)            pickerPromise = null        }    }    companion object {        const val IMAGE_PICKER_REQUEST = 1        const val E_ACTIVITY_DOES_NOT_EXIST = "E_ACTIVITY_DOES_NOT_EXIST"        const val E_PICKER_CANCELLED = "E_PICKER_CANCELLED"        const val E_FAILED_TO_SHOW_PICKER = "E_FAILED_TO_SHOW_PICKER"        const val E_NO_IMAGE_DATA_FOUND = "E_NO_IMAGE_DATA_FOUND"    }}
```


### Listening to Lifecycle Events
Listening to the activity's LifeCycle events such asonResume,onPauseetc. is very similar to howActivityEventListenerwas implemented. The module must implementLifecycleEventListener. Then, you need to register a listener in the module's constructor like so:

- JavaKotlin
- Kotlin
```
reactContext.addLifecycleEventListener(this);
```

```
reactContext.addLifecycleEventListener(this)
```

Now you can listen to the activity's LifeCycle events by implementing the following methods:

- JavaKotlin
- Kotlin
```
@Overridepublic void onHostResume() {   // Activity `onResume`}@Overridepublic void onHostPause() {   // Activity `onPause`}@Overridepublic void onHostDestroy() {   // Activity `onDestroy`}
```

```
override fun onHostResume() {    // Activity `onResume`}override fun onHostPause() {    // Activity `onPause`}override fun onHostDestroy() {    // Activity `onDestroy`}
```


### Threading
To date, on Android, all native module async methods execute on one thread. Native modules should not have any assumptions about what thread they are being called on, as the current assignment is subject to change in the future. If a blocking call is required, the heavy work should be dispatched to an internally managed worker thread, and any callbacks distributed from there.


================================================================================


# Native Modules Intro
Source: https://reactnative.dev/docs/legacy/native-modules-intro

Native Module and Native Components are our stable technologies used by the legacy architecture.
They will be deprecated in the future when the New Architecture will be stable. The New Architecture usesTurbo Native ModuleandFabric Native Componentsto achieve similar results.

Sometimes a React Native app needs to access a native platform API that is not available by default in JavaScript, for example the native APIs to access Apple or Google Pay. Maybe you want to reuse some existing Objective-C, Swift, Java or C++ libraries without having to reimplement it in JavaScript, or write some high performance, multi-threaded code for things like image processing.

The NativeModule system exposes instances of Java/Objective-C/C++ (native) classes to JavaScript (JS) as JS objects, thereby allowing you to execute arbitrary native code from within JS. While we don't expect this feature to be part of the usual development process, it is essential that it exists. If React Native doesn't export a native API that your JS app needs you should be able to export it yourself!


## Native Module Setup
There are different ways to write a native module for your React Native application:

- Creating a local library that can be imported in your React Native application. ReadCreating local librariesguide to learn more.
- Directly within your React Native application's iOS/Android projects
- As an NPM package that can be installed as a dependency by your/other React Native applications.
This guide will first walk you through implementing a native module directly within a React Native application. However the native module you build in the following guide can be distributed as an NPM package. Check out theSetting Up a Native Module as an NPM Packageguide if you are interested in doing so.


## Getting Started
In the following sections we will walk you through guides on how to build a native module directly within a React Native application. As a prerequisite, you will need a React Native application to work within. You can follow the stepshereto setup a React Native application if you do not already have one.

Imagine that you want to access the iOS/Android native calendar APIs from JavaScript within a React Native application in order to create calendar events. React Native does not expose a JavaScript API to communicate with the native calendar libraries. However, through native modules, you can write native code that communicates with native calendar APIs. Then you can invoke that native code through JavaScript in your React Native application.

In the following sections you will create such a Calendar native module for bothAndroidandiOS.


================================================================================


# iOS Native Modules
Source: https://reactnative.dev/docs/legacy/native-modules-ios

Native Module and Native Components are our stable technologies used by the legacy architecture.
They will be deprecated in the future when the New Architecture will be stable. The New Architecture usesTurbo Native ModuleandFabric Native Componentsto achieve similar results.

Welcome to Native Modules for iOS. Please start by reading theNative Modules Introfor an intro to what native modules are.


## Create a Calendar Native Module
In the following guide you will create a native module,CalendarModule, that will allow you to access Apple's calendar APIs from JavaScript. By the end you will be able to callCalendarModule.createCalendarEvent('Dinner Party', 'My House');from JavaScript, invoking a native method that creates a calendar event.


### Setup
To get started, open up the iOS project within your React Native application in Xcode. You can find your iOS project here within a React Native app:

We recommend using Xcode to write your native code. Xcode is built for iOS development, and using it will help you to quickly resolve smaller errors like code syntax.


### Create Custom Native Module Files
The first step is to create our main custom native module header and implementation files. Create a new file calledRCTCalendarModule.h

and add the following to it:

```
//  RCTCalendarModule.h#import <React/RCTBridgeModule.h>@interface RCTCalendarModule : NSObject <RCTBridgeModule>@end
```

You can use any name that fits the native module you are building. Name the classRCTCalendarModulesince you are creating a calendar native module. Since ObjC does not have language-level support for namespaces like Java or C++, convention is to prepend the class name with a substring. This could be an abbreviation of your application name or your infra name. RCT, in this example, refers to React.

As you can see below, the CalendarModule class implements theRCTBridgeModuleprotocol. A native module is an Objective-C class that implements theRCTBridgeModuleprotocol.

Next up, let’s start implementing the native module. Create the corresponding implementation file using cocoa touch class in xcode,RCTCalendarModule.m, in the same folder and include the following content:

```
// RCTCalendarModule.m#import "RCTCalendarModule.h"@implementation RCTCalendarModule// To export a module named RCTCalendarModuleRCT_EXPORT_MODULE();@end
```


### Module Name
For now, yourRCTCalendarModule.mnative module only includes aRCT_EXPORT_MODULEmacro, which exports and registers the native module class with React Native. TheRCT_EXPORT_MODULEmacro also takes an optional argument that specifies the name that the module will be accessible as in your JavaScript code.

This argument is not a string literal. In the example belowRCT_EXPORT_MODULE(CalendarModuleFoo)is passed, notRCT_EXPORT_MODULE("CalendarModuleFoo").

```
// To export a module named CalendarModuleFooRCT_EXPORT_MODULE(CalendarModuleFoo);
```

The native module can then be accessed in JS like this:

```
const {CalendarModuleFoo} = ReactNative.NativeModules;
```

If you do not specify a name, the JavaScript module name will match the Objective-C class name, with any "RCT" or "RK" prefixes removed.

Let's follow the example below and callRCT_EXPORT_MODULEwithout any arguments. As a result, the module will be exposed to React Native using the nameCalendarModule, since that is the Objective-C class name, with RCT removed.

```
// Without passing in a name this will export the native module name as the Objective-C class name with “RCT” removedRCT_EXPORT_MODULE();
```

The native module can then be accessed in JS like this:

```
const {CalendarModule} = ReactNative.NativeModules;
```


### Export a Native Method to JavaScript
React Native will not expose any methods in a native module to JavaScript unless explicitly told to. This can be done using theRCT_EXPORT_METHODmacro. Methods written in theRCT_EXPORT_METHODmacro are asynchronous and the return type is therefore always void. In order to pass a result from aRCT_EXPORT_METHODmethod to JavaScript you can use callbacks or emit events (covered below). Let’s go ahead and set up a native method for ourCalendarModulenative module using theRCT_EXPORT_METHODmacro. Call itcreateCalendarEvent()and for now have it take in name and location arguments as strings. Argument type options will be covered shortly.

```
RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location){}
```

Please note that theRCT_EXPORT_METHODmacro will not be necessary with TurboModules unless your method relies on RCT argument conversion (see argument types below). Ultimately, React Native will removeRCT_EXPORT_MACRO,so we discourage people from usingRCTConvert. Instead, you can do the argument conversion within the method body.

Before you build out thecreateCalendarEvent()method’s functionality, add a console log in the method so you can confirm it has been invoked from JavaScript in your React Native application. Use theRCTLogAPIs from React. Let’s import that header at the top of your file and then add the log call.

```
#import <React/RCTLog.h>RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location){ RCTLogInfo(@"Pretending to create an event %@ at %@", name, location);}
```


### Synchronous Methods
You can use theRCT_EXPORT_BLOCKING_SYNCHRONOUS_METHODto create a synchronous native method.

```
RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(getName){return [[UIDevice currentDevice] name];}
```

The return type of this method must be of object type (id) and should be serializable to JSON. This means that the hook can only return nil or JSON values (e.g. NSNumber, NSString, NSArray, NSDictionary).

At the moment, we do not recommend using synchronous methods, since calling methods synchronously can have strong performance penalties and introduce threading-related bugs to your native modules. Additionally, please note that if you choose to useRCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD, your app can no longer use the Google Chrome debugger. This is because synchronous methods require the JS VM to share memory with the app. For the Google Chrome debugger, React Native runs inside the JS VM in Google Chrome, and communicates asynchronously with the mobile devices via WebSockets.


### Test What You Have Built
At this point you have set up the basic scaffolding for your native module in iOS. Test that out by accessing the native module and invoking it’s exported method in JavaScript.

Find a place in your application where you would like to add a call to the native module’screateCalendarEvent()method. Below is an example of a component,NewModuleButtonyou can add in your app. You can invoke the native module insideNewModuleButton'sonPress()function.

```
import React from 'react';import {Button} from 'react-native';const NewModuleButton = () => {  const onPress = () => {    console.log('We will invoke the native module here!');  };  return (    <Button      title="Click to invoke your native module!"      color="#841584"      onPress={onPress}    />  );};export default NewModuleButton;
```

In order to access your native module from JavaScript you need to first importNativeModulesfrom React Native:

```
import {NativeModules} from 'react-native';
```

You can then access theCalendarModulenative module off ofNativeModules.

```
const {CalendarModule} = NativeModules;
```

Now that you have the CalendarModule native module available, you can invoke your native methodcreateCalendarEvent(). Below it is added to theonPress()method inNewModuleButton:

```
const onPress = () => {  CalendarModule.createCalendarEvent('testName', 'testLocation');};
```

The final step is to rebuild the React Native app so that you can have the latest native code (with your new native module!) available. In your command line, where the react native application is located, run the following :

- npmYarn
- Yarn
```
npm run ios
```

```
yarn ios
```


### Building as You Iterate
As you work through these guides and iterate on your native module, you will need to do a native rebuild of your application to access your most recent changes from JavaScript. This is because the code that you are writing sits within the native part of your application. While React Native’s metro bundler can watch for changes in JavaScript and rebuild JS bundle on the fly for you, it will not do so for native code. So if you want to test your latest native changes you need to rebuild by using the above command.


### Recap✨
You should now be able to invoke yourcreateCalendarEvent()method on your native module in JavaScript. Since you are usingRCTLogin the function, you can confirm your native method is being invoked byenabling debug mode in your appand looking at the JS console in Chrome or the mobile app debugger Flipper. You should see yourRCTLogInfo(@"Pretending to create an event %@ at %@", name, location);message each time you invoke the native module method.

At this point you have created an iOS native module and invoked a method on it from JavaScript in your React Native application. You can read on to learn more about things like what argument types your native module method takes and how to setup callbacks and promises within your native module.


## Beyond a Calendar Native Module

### Better Native Module Export
Importing your native module by pulling it off ofNativeModuleslike above is a bit clunky.

To save consumers of your native module from needing to do that each time they want to access your native module, you can create a JavaScript wrapper for the module. Create a new JavaScript file named NativeCalendarModule.js with the following content:

```
/*** This exposes the native CalendarModule module as a JS module. This has a* function 'createCalendarEvent' which takes the following parameters:* 1. String name: A string representing the name of the event* 2. String location: A string representing the location of the event*/import {NativeModules} from 'react-native';const {CalendarModule} = NativeModules;export default CalendarModule;
```

This JavaScript file also becomes a good location for you to add any JavaScript side functionality. For example, if you use a type system like TypeScript you can add type annotations for your native module here. While React Native does not yet support Native to JS type safety, with these type annotations, all your JS code will be type safe. These annotations will also make it easier for you to switch to type-safe native modules down the line. Below is an example of adding type safety to the Calendar Module:

```
/** * This exposes the native CalendarModule module as a JS module. This has a * function 'createCalendarEvent' which takes the following parameters: * * 1. String name: A string representing the name of the event * 2. String location: A string representing the location of the event */import {NativeModules} from 'react-native';const {CalendarModule} = NativeModules;interface CalendarInterface {  createCalendarEvent(name: string, location: string): void;}export default CalendarModule as CalendarInterface;
```

In your other JavaScript files you can access the native module and invoke its method like this:

```
import NativeCalendarModule from './NativeCalendarModule';NativeCalendarModule.createCalendarEvent('foo', 'bar');
```

This assumes that the place you are importingCalendarModuleis in the same hierarchy asNativeCalendarModule.js. Please update the relative import as necessary.


### Argument Types
When a native module method is invoked in JavaScript, React Native converts the arguments from JS objects to their Objective-C/Swift object analogues. So for example, if your Objective-C Native Module method accepts a NSNumber, in JS you need to call the method with a number. React Native will handle the conversion for you. Below is a list of the argument types supported for native module methods and the JavaScript equivalents they map to.

The following types are currently supported but will not be supported in TurboModules. Please avoid using them.Function (failure) -> RCTResponseErrorBlockNumber -> NSIntegerNumber -> CGFloatNumber -> float

- Function (failure) -> RCTResponseErrorBlock
- Number -> NSInteger
- Number -> CGFloat
- Number -> float
For iOS, you can also write native module methods with any argument type that is supported by theRCTConvertclass (seeRCTConvertfor details about what is supported). The RCTConvert helper functions all accept a JSON value as input and map it to a native Objective-C type or class.


### Exporting Constants
A native module can export constants by overriding the native methodconstantsToExport(). BelowconstantsToExport()is overridden, and returns a Dictionary that contains a default event name property you can access in JavaScript like so:

```
- (NSDictionary *)constantsToExport{ return @{ @"DEFAULT_EVENT_NAME": @"New Event" };}
```

The constant can then be accessed by invokinggetConstants()on the native module in JS like so:

```
const {DEFAULT_EVENT_NAME} = CalendarModule.getConstants();console.log(DEFAULT_EVENT_NAME);
```

Technically, it is possible to access constants exported inconstantsToExport()directly off theNativeModuleobject. This will no longer be supported with TurboModules, so we encourage the community to switch to the above approach to avoid necessary migration down the line.

The constants are exported only at initialization time, so if you changeconstantsToExport()values at runtime it won't affect the JavaScript environment.

For iOS, if you overrideconstantsToExport()then you should also implement+ requiresMainQueueSetupto let React Native know if your module needs to be initialized on the main thread, before any JavaScript code executes. Otherwise you will see a warning that in the future your module may be initialized on a background thread unless you explicitly opt out with+ requiresMainQueueSetup:. If your module does not require access to UIKit, then you should respond to+ requiresMainQueueSetupwith NO.


### Callbacks
Native modules also support a unique kind of argument - a callback. Callbacks are used to pass data from Objective-C to JavaScript for asynchronous methods. They can also be used to asynchronously execute JS from the native side.

For iOS, callbacks are implemented using the typeRCTResponseSenderBlock. Below the callback parametermyCallBackis added to thecreateCalendarEventMethod():

```
RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title                location:(NSString *)location                myCallback:(RCTResponseSenderBlock)callback)
```

You can then invoke the callback in your native function, providing whatever result you want to pass to JavaScript in an array. Note thatRCTResponseSenderBlockaccepts only one argument - an array of parameters to pass to the JavaScript callback. Below you will pass back the ID of an event created in an earlier call.

It is important to highlight that the callback is not invoked immediately after the native function completes—remember the communication is asynchronous.

```
RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title location:(NSString *)location callback: (RCTResponseSenderBlock)callback){ NSInteger eventId = ... callback(@[@(eventId)]); RCTLogInfo(@"Pretending to create an event %@ at %@", title, location);}
```

This method could then be accessed in JavaScript using the following:

```
const onSubmit = () => {  CalendarModule.createCalendarEvent(    'Party',    '04-12-2020',    eventId => {      console.log(`Created a new event with id ${eventId}`);    },  );};
```

A native module is supposed to invoke its callback only once. It can, however, store the callback and invoke it later. This pattern is often used to wrap iOS APIs that require delegates— seeRCTAlertManagerfor an example. If the callback is never invoked, some memory is leaked.

There are two approaches to error handling with callbacks. The first is to follow Node’s convention and treat the first argument passed to the callback array as an error object.

```
RCT_EXPORT_METHOD(createCalendarEventCallback:(NSString *)title location:(NSString *)location callback: (RCTResponseSenderBlock)callback){  NSNumber *eventId = [NSNumber numberWithInt:123];  callback(@[[NSNull null], eventId]);}
```

In JavaScript, you can then check the first argument to see if an error was passed through:

```
const onPress = () => {  CalendarModule.createCalendarEventCallback(    'testName',    'testLocation',    (error, eventId) => {      if (error) {        console.error(`Error found! ${error}`);      }      console.log(`event id ${eventId} returned`);    },  );};
```

Another option is to use two separate callbacks: onFailure and onSuccess.

```
RCT_EXPORT_METHOD(createCalendarEventCallback:(NSString *)title                  location:(NSString *)location                  errorCallback: (RCTResponseSenderBlock)errorCallback                  successCallback: (RCTResponseSenderBlock)successCallback){  @try {    NSNumber *eventId = [NSNumber numberWithInt:123];    successCallback(@[eventId]);  }  @catch ( NSException *e ) {    errorCallback(@[e]);  }}
```

Then in JavaScript you can add a separate callback for error and success responses:

```
const onPress = () => {  CalendarModule.createCalendarEventCallback(    'testName',    'testLocation',    error => {      console.error(`Error found! ${error}`);    },    eventId => {      console.log(`event id ${eventId} returned`);    },  );};
```

If you want to pass error-like objects to JavaScript, useRCTMakeErrorfromRCTUtils.h.Right now this only passes an Error-shaped dictionary to JavaScript, but React Native aims to automatically generate real JavaScript Error objects in the future. You can also provide aRCTResponseErrorBlockargument, which is used for error callbacks and accepts anNSError \* object. Please note that this argument type will not be supported with TurboModules.


### Promises
Native modules can also fulfill a promise, which can simplify your JavaScript, especially when using ES2016'sasync/awaitsyntax. When the last parameter of a native module method is aRCTPromiseResolveBlockandRCTPromiseRejectBlock, its corresponding JS method will return a JS Promise object.

Refactoring the above code to use a promise instead of callbacks looks like this:

```
RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title                 location:(NSString *)location                 resolver:(RCTPromiseResolveBlock)resolve                 rejecter:(RCTPromiseRejectBlock)reject){ NSInteger eventId = createCalendarEvent(); if (eventId) {    resolve(@(eventId));  } else {    reject(@"event_failure", @"no event id returned", nil);  }}
```

The JavaScript counterpart of this method returns a Promise. This means you can use theawaitkeyword within an async function to call it and wait for its result:

```
const onSubmit = async () => {  try {    const eventId = await CalendarModule.createCalendarEvent(      'Party',      'my house',    );    console.log(`Created a new event with id ${eventId}`);  } catch (e) {    console.error(e);  }};
```


### Sending Events to JavaScript
Native modules can signal events to JavaScript without being invoked directly. For example, you might want to signal to JavaScript a reminder that a calendar event from the native iOS calendar app will occur soon. The preferred way to do this is to subclassRCTEventEmitter, implementsupportedEventsand call selfsendEventWithName:

Update your header class to importRCTEventEmitterand subclassRCTEventEmitter:

```
//  CalendarModule.h#import <React/RCTBridgeModule.h>#import <React/RCTEventEmitter.h>@interface CalendarModule : RCTEventEmitter <RCTBridgeModule>@end
```

JavaScript code can subscribe to these events by creating a newNativeEventEmitterinstance around your module.

You will receive a warning if you expend resources unnecessarily by emitting an event while there are no listeners. To avoid this, and to optimize your module's workload (e.g. by unsubscribing from upstream notifications or pausing background tasks), you can overridestartObservingandstopObservingin yourRCTEventEmittersubclass.

```
@implementation CalendarModule{  bool hasListeners;}// Will be called when this module's first listener is added.-(void)startObserving {    hasListeners = YES;    // Set up any upstream listeners or background tasks as necessary}// Will be called when this module's last listener is removed, or on dealloc.-(void)stopObserving {    hasListeners = NO;    // Remove upstream listeners, stop unnecessary background tasks}- (void)calendarEventReminderReceived:(NSNotification *)notification{  NSString *eventName = notification.userInfo[@"name"];  if (hasListeners) {// Only send events if anyone is listening    [self sendEventWithName:@"EventReminder" body:@{@"name": eventName}];  }}
```


### Threading
Unless the native module provides its own method queue, it shouldn't make any assumptions about what thread it's being called on. Currently, if a native module doesn't provide a method queue, React Native will create a separate GCD queue for it and invoke its methods there. Please note that this is an implementation detail and might change. If you want to explicitly provide a method queue for a native module, override the(dispatch_queue_t) methodQueuemethod in the native module. For example, if it needs to use a main-thread-only iOS API, it should specify this via:

```
- (dispatch_queue_t)methodQueue{  return dispatch_get_main_queue();}
```

Similarly, if an operation may take a long time to complete, the native module can specify its own queue to run operations on. Again, currently React Native will provide a separate method queue for your native module, but this is an implementation detail you should not rely on. If you don't provide your own method queue, in the future, your native module's long running operations may end up blocking async calls being executed on other unrelated native modules. TheRCTAsyncLocalStoragemodule here, for example, creates its own queue so the React queue isn't blocked waiting on potentially slow disk access.

```
- (dispatch_queue_t)methodQueue{ return dispatch_queue_create("com.facebook.React.AsyncLocalStorageQueue", DISPATCH_QUEUE_SERIAL);}
```

The specifiedmethodQueuewill be shared by all of the methods in your module. If only one of your methods is long-running (or needs to be run on a different queue than the others for some reason), you can usedispatch_asyncinside the method to perform that particular method's code on another queue, without affecting the others:

```
RCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback){ dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{   // Call long-running code on background thread   ...   // You can invoke callback from any thread/queue   callback(@[...]); });}
```

ThemethodQueuemethod will be called once when the module is initialized, and then retained by React Native, so there is no need to keep a reference to the queue yourself, unless you wish to make use of it within your module. However, if you wish to share the same queue between multiple modules then you will need to ensure that you retain and return the same queue instance for each of them.


### Dependency Injection
React Native will create and initialize any registered native modules automatically. However, you may wish to create and initialize your own module instances to, for example, inject dependencies.

You can do this by creating a class that implements theRCTBridgeDelegateProtocol, initializing anRCTBridgewith the delegate as an argument and initialising aRCTRootViewwith the initialized bridge.

```
id<RCTBridgeDelegate> moduleInitialiser = [[classThatImplementsRCTBridgeDelegate alloc] init];RCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:moduleInitialiser launchOptions:nil];RCTRootView *rootView = [[RCTRootView alloc]                        initWithBridge:bridge                            moduleName:kModuleName                     initialProperties:nil];
```


### Exporting Swift
Swift doesn't have support for macros, so exposing native modules and their methods to JavaScript inside React Native requires a bit more setup. However, it works relatively the same. Let's say you have the sameCalendarModulebut as a Swift class:

```
// CalendarModule.swift@objc(CalendarModule)class CalendarModule: NSObject { @objc(addEvent:location:date:) func addEvent(_ name: String, location: String, date: NSNumber) -> Void {   // Date is ready to use! } @objc func constantsToExport() -> [String: Any]! {   return ["someKey": "someValue"] }}
```

It is important to use the@objcmodifiers to ensure the class and functions are exported properly to the Objective-C runtime.

Then create a private implementation file that will register the required information with React Native:

```
// CalendarModuleBridge.m#import <React/RCTBridgeModule.h>@interface RCT_EXTERN_MODULE(CalendarModule, NSObject)RCT_EXTERN_METHOD(addEvent:(NSString *)name location:(NSString *)location date:(nonnull NSNumber *)date)@end
```

For those of you new to Swift and Objective-C, whenever youmix the two languages in an iOS project, you will also need an additional bridging file, known as a bridging header, to expose the Objective-C files to Swift. Xcode will offer to create this header file for you if you add your Swift file to your app through the XcodeFile>New Filemenu option. You will need to importRCTBridgeModule.hin this header file.

```
// CalendarModule-Bridging-Header.h#import <React/RCTBridgeModule.h>
```

You can also useRCT_EXTERN_REMAP_MODULEand_RCT_EXTERN_REMAP_METHODto alter the JavaScript name of the module or methods you are exporting. For more information seeRCTBridgeModule.

Important when making third party modules: Static libraries with Swift are only supported in Xcode 9 and later. In order for the Xcode project to build when you use Swift in the iOS static library you include in the module, your main app project must contain Swift code and a bridging header itself. If your app project does not contain any Swift code, a workaround can be a single empty .swift file and an empty bridging header.


### Reserved Method Names
Native modules can conform to theRCTInvalidatingprotocol on iOS by implementing theinvalidate()method. This methodcan be invokedwhen the native bridge is invalidated (i.e.: on devmode reload). Please use this mechanism as necessary to do the required cleanup for your native module.


================================================================================


# Native Modules NPM Package Setup
Source: https://reactnative.dev/docs/legacy/native-modules-setup

Native Module and Native Components are our stable technologies used by the legacy architecture.
They will be deprecated in the future when the New Architecture will be stable. The New Architecture usesTurbo Native ModuleandFabric Native Componentsto achieve similar results.

Native modules are usually distributed as npm packages, except that on top of the usual JavaScript they will include some native code per platform. To understand more about npm packages you may findthis guideuseful.

To get set up with the basic project structure for a native module we will use the community tool calledcreate-react-native-library. You can go ahead further and dive deep into how that library works, but for our needs we will only execute the basic script:

```
npx create-react-native-library@latest react-native-awesome-module
```

Wherereact-native-awesome-moduleis the name you would like for the new module. After doing this you will navigate intoreact-native-awesome-modulefolder and bootstrap the example project by running:

```
yarn
```

When the bootstrap is done, you will be able to start the example app by executing one of the following commands:

```
# Android appyarn example android# iOS appyarn example ios
```

When all steps above are done, you will be able to continue withAndroid Native ModulesoriOS Native Modulesguides to add in some code.


================================================================================


# Using Libraries
Source: https://reactnative.dev/docs/libraries

React Native provides a set of built-inCore Components and APIsready to use in your app. You're not limited to the components and APIs bundled with React Native. React Native has a community of thousands of developers. If the Core Components and APIs don't have what you are looking for, you may be able to find and install a library from the community to add the functionality to your app.


## Selecting a Package Manager
React Native libraries are typically installed from thenpm registryusing a Node.js package manager such asnpm CLIorYarn Classic.

If you have Node.js installed on your computer then you already have the npm CLI installed. Some developers prefer to use Yarn Classic for slightly faster install times and additional advanced features like Workspaces. Both tools work great with React Native. We will assume npm for the rest of this guide for simplicity of explanation.

The terms "library" and "package" are used interchangeably in the JavaScript community.


## Installing a Library
To install a library in your project, navigate to your project directory in your terminal and run the installation command. Let's try this withreact-native-webview:

- npmYarn
- Yarn
```
npm install react-native-webview
```

```
yarn add react-native-webview
```

The library that we installed includes native code, and we need to link to our app before we use it.


## Linking Native Code on iOS
React Native uses CocoaPods to manage iOS project dependencies and most React Native libraries follow this same convention. If a library you are using does not, then please refer to their README for additional instruction. In most cases, the following instructions will apply.

Runpod installin ouriosdirectory in order to link it to our native iOS project. A shortcut for doing this without switching to theiosdirectory is to runnpx pod-install.

```
npx pod-install
```

Once this is complete, re-build the app binary to start using your new library:

- npmYarn
- Yarn
```
npm run ios
```

```
yarn ios
```


## Linking Native Code on Android
React Native uses Gradle to manage Android project dependencies. After you install a library with native dependencies, you will need to re-build the app binary to use your new library:

- npmYarn
- Yarn
```
npm run android
```

```
yarn android
```


## Finding Libraries
React Native Directoryis a searchable database of libraries built specifically for React Native. This is the first place to look for a library for your React Native app.

Many of the libraries you will find on the directory are fromReact Native CommunityorExpo.

Libraries built by the React Native Community are driven by volunteers and individuals at companies that depend on React Native. They often support iOS, tvOS, Android, Windows, but this varies across projects. Many of the libraries in this organization were once React Native Core Components and APIs.

Libraries built by Expo are all written in TypeScript and support iOS, Android, andreact-native-webwherever possible.

After React Native Directory, thenpm registryis the next best place if you can't find a library specifically for React Native on the directory. The npm registry is the definitive source for JavaScript libraries, but the libraries that it lists may not all be compatible with React Native. React Native is one of many JavaScript programming environments, including Node.js, web browsers, Electron, and more, and npm includes libraries that work for all of these environments.


## Determining Library Compatibility

### Does it work with React Native?
Usually libraries builtspecifically for other platformswill not work with React Native. Examples includereact-selectwhich is built for the web and specifically targetsreact-dom, andrimrafwhich is built for Node.js and interacts with your computer file system. Other libraries likelodashuse only JavaScript language features and work in any environment. You will gain a sense for this over time, but until then the easiest way to find out is to try it yourself. You can remove packages usingnpm uninstallif it turns out that it does not work in React Native.


### Does it work for the platforms that my app supports?
React Native Directoryallows you to filter by platform compatibility, such as iOS, Android, Web, and Windows. If the library you would like to use is not currently listed there, refer to the README for the library to learn more.


### Does it work with my app version of React Native?
The latest version of a library is typically compatible with the latest version of React Native. If you are using an older version, you should refer to the README to know which version of the library you should install. You can install a particular version of the library by runningnpm install <library-name>@<version-number>, for example:npm install @react-native-community/netinfo@^2.0.0.


================================================================================


# Linking
Source: https://reactnative.dev/docs/linking

Linkinggives you a general interface to interact with both incoming and outgoing app links.

Every Link (URL) has a URL Scheme, some websites are prefixed withhttps://orhttp://and thehttpis the URL Scheme. Let's call it scheme for short.

In addition tohttps, you're likely also familiar with themailtoscheme. When you open a link with the mailto scheme, your operating system will open an installed mail application. Similarly, there are schemes for making phone calls and sending SMS. Read more aboutbuilt-in URLschemes below.

Like using the mailto scheme, it's possible to link to other applications by using custom url schemes. For example, when you get aMagic Linkemail from Slack, theLaunch Slackbutton is an anchor tag with an href that looks something like:slack://secret/magic-login/other-secret. Like with Slack, you can tell the operating system that you want to handle a custom scheme. When the Slack app opens, it receives the URL that was used to open it. This is often referred to as deep linking. Read more about how toget the deep linkinto your app.

A custom URL scheme isn't the only way to open your application on mobile. For example, if you want to email someone a link to be opened on mobile, using a custom URL scheme isn't ideal because the user might open the email on a desktop, where the link wouldn't work. Instead, you should use standardhttpslinks, such ashttps://www.myapp.io/records/1234546. On mobile, these links can be configured to open your app. On Android, this feature is calledDeep Links, while on iOS, it is known asUniversal Links.


### Built-in URL Schemes
As mentioned in the introduction, there are some URL schemes for core functionality that exist on every platform. The following is a non-exhaustive list, but covers the most commonly used schemes.


### Enabling Deep Links

### Projects with Native Code Only
The following section only applies to projects with native code exposed. If you are using the managed Expo workflow, see the guide onLinkingin the Expo documentation for the appropriate alternative.

If you want to enable deep links in your app, please read the below guide:

- AndroidiOS
- iOS
For instructions on how to add support for deep linking on Android, refer toEnabling Deep Links for App Content - Add Intent Filters for Your Deep Links.

If you wish to receive the intent in an existing instance of MainActivity, you may set thelaunchModeof MainActivity tosingleTaskinAndroidManifest.xml. See<activity>documentation for more information.xml<activityandroid:name=".MainActivity"android:launchMode="singleTask">

```
<activity  android:name=".MainActivity"  android:launchMode="singleTask">
```

On iOS, you'll need to add theLinkingIOSfolder into your header search paths as described in step 3here. If you also want to listen to incoming app links during your app's execution, you'll need to add the following lines to your*AppDelegate.m:ObjectiveCSwiftAppDelegate.mm// iOS 9.x or newer#import<React/RCTLinkingManager.h>-(BOOL)application:(UIApplication*)applicationopenURL:(NSURL*)urloptions:(NSDictionary<UIApplicationOpenURLOptionsKey,id>*)options{return[RCTLinkingManager application:application openURL:url options:options];}If your app is usingUniversal Links, you'll need to add the following code as well:AppDelegate.mm-(BOOL)application:(UIApplication*)application continueUserActivity:(nonnull NSUserActivity*)userActivityrestorationHandler:(nonnullvoid(^)(NSArray<id<UIUserActivityRestoring>>*_Nullable))restorationHandler{return[RCTLinkingManager application:applicationcontinueUserActivity:userActivityrestorationHandler:restorationHandler];}AppDelegate.swiftoverridefuncapplication(_app:UIApplication,openurl:URL,options:[UIApplication.OpenURLOptionsKey:Any]=[:])->Bool{returnRCTLinkingManager.application(app,open:url,options:options)}If your app is usingUniversal Links, you'll need to add the following code as well:AppDelegate.swiftoverridefuncapplication(_application:UIApplication,continueuserActivity:NSUserActivity,restorationHandler:@escaping([UIUserActivityRestoring]?)->Void)->Bool{returnRCTLinkingManager.application(application,continue:userActivity,restorationHandler:restorationHandler)}

- ObjectiveCSwift
- Swift
```
// iOS 9.x or newer#import <React/RCTLinkingManager.h>- (BOOL)application:(UIApplication *)application   openURL:(NSURL *)url   options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options{  return [RCTLinkingManager application:application openURL:url options:options];}
```

If your app is usingUniversal Links, you'll need to add the following code as well:AppDelegate.mm-(BOOL)application:(UIApplication*)application continueUserActivity:(nonnull NSUserActivity*)userActivityrestorationHandler:(nonnullvoid(^)(NSArray<id<UIUserActivityRestoring>>*_Nullable))restorationHandler{return[RCTLinkingManager application:applicationcontinueUserActivity:userActivityrestorationHandler:restorationHandler];}

```
- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler{ return [RCTLinkingManager application:application                  continueUserActivity:userActivity                    restorationHandler:restorationHandler];}
```

```
override func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {  return RCTLinkingManager.application(app, open: url, options: options)}
```

If your app is usingUniversal Links, you'll need to add the following code as well:AppDelegate.swiftoverridefuncapplication(_application:UIApplication,continueuserActivity:NSUserActivity,restorationHandler:@escaping([UIUserActivityRestoring]?)->Void)->Bool{returnRCTLinkingManager.application(application,continue:userActivity,restorationHandler:restorationHandler)}

```
override func application(  _ application: UIApplication,  continue userActivity: NSUserActivity,  restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool {    return RCTLinkingManager.application(      application,      continue: userActivity,      restorationHandler: restorationHandler    )  }
```


### Handling Deep Links
There are two ways to handle URLs that open your app.

You can handle these events withLinking.addEventListener('url', callback)- it callscallback({url})with the linked URL

You can handle these events withLinking.getInitialURL()- it returns a Promise that resolves to the URL, if there is one.


## Example

### Open Links and Deep Links (Universal Links)
- TypeScriptJavaScript
- JavaScript

### Open Custom Settings
- TypeScriptJavaScript
- JavaScript

### Get the Deep Link
- TypeScriptJavaScript
- JavaScript

### Send Intents (Android)
- TypeScriptJavaScript
- JavaScript

## Methods

### addEventListener()
```
static addEventListener(  type: 'url',  handler: (event: {url: string}) => void,): EmitterSubscription;
```

Add a handler to Linking changes by listening to theurlevent type and providing the handler.


### canOpenURL()
```
static canOpenURL(url: string): Promise<boolean>;
```

Determine whether or not an installed app can handle a given URL.

The method returns aPromiseobject. When it is determined whether or not the given URL can be handled, the promise is resolved and the first parameter is whether or not it can be opened.

ThePromisewill reject on Android if it was impossible to check if the URL can be opened or when targeting Android 11 (SDK 30) if you didn't specify the relevant intent queries inAndroidManifest.xml. Similarly on iOS, the promise will reject if you didn't add the specific scheme in theLSApplicationQueriesSchemeskey insideInfo.plist(see bellow).

Parameters:

For web URLs, the protocol ("http://","https://") must be set accordingly!

This method has limitations on iOS 9+. Fromthe official Apple documentation:If your app is linked against an earlier version of iOS but is running in iOS 9.0 or later, you can call this method up to 50 times. After reaching that limit, subsequent calls always resolve tofalse. If the user reinstalls or upgrades the app, iOS resets the limit.As of iOS 9, your app also needs to provide theLSApplicationQueriesSchemeskey insideInfo.plistorcanOpenURL()will always resolve tofalse.

- If your app is linked against an earlier version of iOS but is running in iOS 9.0 or later, you can call this method up to 50 times. After reaching that limit, subsequent calls always resolve tofalse. If the user reinstalls or upgrades the app, iOS resets the limit.
- As of iOS 9, your app also needs to provide theLSApplicationQueriesSchemeskey insideInfo.plistorcanOpenURL()will always resolve tofalse.
When targeting Android 11 (SDK 30) you must specify the intents for the schemes you want to handle inAndroidManifest.xml. A list of common intents can be foundhere.For example to handlehttpsschemes the following needs to be added to your manifest:<manifest...><queries><intent><actionandroid:name="android.intent.action.VIEW"/><dataandroid:scheme="https"/></intent></queries></manifest>

For example to handlehttpsschemes the following needs to be added to your manifest:<manifest...><queries><intent><actionandroid:name="android.intent.action.VIEW"/><dataandroid:scheme="https"/></intent></queries></manifest>

```
<manifest ...>  <queries>    <intent>      <action android:name="android.intent.action.VIEW" />      <data android:scheme="https"/>    </intent>  </queries></manifest>
```


### getInitialURL()
```
static getInitialURL(): Promise<string | null>;
```

If the app launch was triggered by an app link, it will give the link url, otherwise it will givenull.

To support deep linking on Android, referhttps://developer.android.com/training/app-indexing/deep-linking.html#handling-intents.

getInitialURLmay returnnullwhen Remote JS Debugging is active. Disable the debugger to ensure it gets passed.


### openSettings()
```
static openSettings(): Promise<void>;
```

Open the Settings app and displays the app’s custom settings, if it has any.


### openURL()
```
static openURL(url: string): Promise<any>;
```

Try to open the givenurlwith any of the installed apps.

You can use other URLs, like a location (e.g. "geo:37.484847,-122.148386" on Android or "https://maps.apple.com/?ll=37.484847,-122.148386" on iOS), a contact, or any other URL that can be opened with the installed apps.

The method returns aPromiseobject. If the user confirms the open dialog or the url automatically opens, the promise is resolved. If the user cancels the open dialog or there are no registered applications for the url, the promise is rejected.

Parameters:

This method will fail if the system doesn't know how to open the specified URL. If you're passing in a non-http(s) URL, it's best to checkcanOpenURL()first. For web URLs, the protocol ("http://","https://") must be set accordingly!

This method may behave differently in a simulator e.g."tel:"links are not able to be handled in the iOS simulator as there's no access to the dialer app.


### sendIntent()Android
```
static sendIntent(  action: string,  extras?: Array<{key: string; value: string | number | boolean}>,): Promise<void>;
```

Launch an Android intent with extras.

Parameters:


================================================================================


# Linking Libraries
Source: https://reactnative.dev/docs/linking-libraries-ios

Not every app uses all the native capabilities, and including the code to support all those features would impact the binary size... But we still want to support adding these features whenever you need them.

With that in mind we exposed many of these features as independent static libraries.

For most of the libs it will be as quick as dragging two files, sometimes a third step will be necessary, but no more than that.

All the libraries we ship with React Native live in theLibrariesfolder in the root of the repository. Some of them are pure JavaScript, and you only need torequireit.
Other libraries also rely on some native code, in that case you'll have to add these files to your app, otherwise the app will throw an error as soon as you try to use the library.


## Here are the few steps to link your libraries that contain native code

### Automatic linking
Install a library with native dependencies:

```
npm install <library-with-native-dependencies> --save
```

--saveor--save-devflag is very important for this step. React Native will link your libs based ondependenciesanddevDependenciesin yourpackage.jsonfile.

That's it! Next time you build your app the native code will be linked thanks to theautolinkingmechanism.


### Manual linking
If the library has native code, there must be an.xcodeprojfile inside its folder. Drag this file to your project on Xcode (usually under theLibrariesgroup on Xcode);

Click on your main project file (the one that represents the.xcodeproj) selectBuild Phasesand drag the static library from theProductsfolder inside the Library you are importing toLink Binary With Libraries

Not every library will need this step, what you need to consider is:

Do I need to know the contents of the library at compile time?

What that means is, are you using this library on the native side or only in JavaScript? If you are only using it in JavaScript, you are good to go!

If you do need to call it from native, then we need to know the library's headers. To achieve that you have to go to your project's file, selectBuild Settingsand search forHeader Search Paths. There you should include the path to your library. (This documentation used to recommend usingrecursive, but this is no longer recommended, as it can cause subtle build failures, especially with CocoaPods.)


================================================================================


# Metro
Source: https://reactnative.dev/docs/metro

React Native usesMetroto build your JavaScript code and assets.


## Configuring Metro
Configuration options for Metro can be customized in your project'smetro.config.jsfile. This can export either:

- An object (recommended)that will be merged on top of Metro's internal config defaults.
- A functionthat will be called with Metro's internal config defaults and should return a final config object.
Please seeConfiguring Metroon the Metro website for documentation on all available config options.

In React Native, your Metro config should extend either@react-native/metro-configor@expo/metro-config. These packages contain essential defaults necessary to build and run React Native apps.

Below is the defaultmetro.config.jsfile in a React Native template project:

```
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');/** * Metro configuration * https://metrobundler.dev/docs/configuration * * @type {import('metro-config').MetroConfig} */const config = {};module.exports = mergeConfig(getDefaultConfig(__dirname), config);
```

Metro options you wish to customize can be done so within theconfigobject.


### Advanced: Using a config function
Exporting a config function is an opt-in to managing the final config yourself —Metro will not apply any internal defaults. This pattern can be useful when needing to read the base default config object from Metro or to set options dynamically.

From@react-native/metro-config0.72.1, it is no longer necessary to use a config function to access the complete default config. See theTipsection below.

```
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');module.exports = function (baseConfig) {  const defaultConfig = mergeConfig(baseConfig, getDefaultConfig(__dirname));  const {resolver: {assetExts, sourceExts}} = defaultConfig;  return mergeConfig(    defaultConfig,    {      resolver: {        assetExts: assetExts.filter(ext => ext !== 'svg'),        sourceExts: [...sourceExts, 'svg'],      },    },  );};
```

Using a config function is for advanced use cases. A simpler method than the above, e.g. for customisingsourceExts, would be to read these defaults from@react-native/metro-config.AlternativejsconstdefaultConfig=getDefaultConfig(__dirname);constconfig={resolver:{sourceExts:[...defaultConfig.resolver.sourceExts,'svg'],},};module.exports=mergeConfig(defaultConfig,config);However!, we recommend copying and editing when overriding these config values — placing the source of truth in your config file.✅Recommendedjsconstconfig={resolver:{sourceExts:['js','ts','tsx','svg'],},};

AlternativejsconstdefaultConfig=getDefaultConfig(__dirname);constconfig={resolver:{sourceExts:[...defaultConfig.resolver.sourceExts,'svg'],},};module.exports=mergeConfig(defaultConfig,config);However!, we recommend copying and editing when overriding these config values — placing the source of truth in your config file.✅Recommendedjsconstconfig={resolver:{sourceExts:['js','ts','tsx','svg'],},};

```
const defaultConfig = getDefaultConfig(__dirname);const config = {  resolver: {    sourceExts: [...defaultConfig.resolver.sourceExts, 'svg'],  },};module.exports = mergeConfig(defaultConfig, config);
```

However!, we recommend copying and editing when overriding these config values — placing the source of truth in your config file.✅Recommendedjsconstconfig={resolver:{sourceExts:['js','ts','tsx','svg'],},};

✅Recommendedjsconstconfig={resolver:{sourceExts:['js','ts','tsx','svg'],},};

```
const config = {  resolver: {    sourceExts: ['js', 'ts', 'tsx', 'svg'],  },};
```


## Learn more about Metro
- Metro website
- Video: "Metro & React Native DevX" talk at App.js 2023

================================================================================


# Modal
Source: https://reactnative.dev/docs/modal

The Modal component is a basic way to present content above an enclosing view.


## Example

## Props

### View Props
InheritsView Props.


### 🗑️animated
Use theanimationTypeprop instead.


### animationType
TheanimationTypeprop controls how the modal animates.

Possible values:

- slideslides in from the bottom
- fadefades into view
- noneappears without an animation

### backdropColor
ThebackdropColorof the modal (or background color of the modal's container.) Defaults towhiteif not provided and transparent isfalse. Ignored iftransparentistrue.


### hardwareAcceleratedAndroid
ThehardwareAcceleratedprop controls whether to force hardware acceleration for the underlying window.


### navigationBarTranslucentAndroid
ThenavigationBarTranslucentprop determines whether your modal should go under the system navigation bar. However,statusBarTranslucentalso needs to be set totrueto make navigation bar translucent.


### onDismissiOS
TheonDismissprop allows passing a function that will be called once the modal has been dismissed.


### onOrientationChangeiOS
TheonOrientationChangecallback is called when the orientation changes while the modal is being displayed. The orientation provided is only 'portrait' or 'landscape'. This callback is also called on initial render, regardless of the current orientation.


### allowSwipeDismissaliOS
Controls whether the modal can be dismissed by swiping down on iOS.
This requires you to implement theonRequestCloseprop to handle the dismissal.


### ref
A ref setter that will be assigned anelement nodewhen mounted.


### onRequestClose
TheonRequestClosecallback is called when the user taps the hardware back button on Android or the menu button on Apple TV. Because of this required prop, be aware thatBackHandlerevents will not be emitted as long as the modal is open.
On iOS, this callback is called when a Modal is being dismissed using a drag gesture whenpresentationStyleispageSheet or formSheet. WhenallowSwipeDismissalis enabled this callback will be called after dismissing the modal.


### onShow
TheonShowprop allows passing a function that will be called once the modal has been shown.


### presentationStyleiOS
ThepresentationStyleprop controls how the modal appears (generally on larger devices such as iPad or plus-sized iPhones). Seehttps://developer.apple.com/reference/uikit/uimodalpresentationstylefor details.

Possible values:

- fullScreencovers the screen completely
- pageSheetcovers portrait-width view centered (only on larger devices)
- formSheetcovers narrow-width view centered (only on larger devices)
- overFullScreencovers the screen completely, but allows transparency

### statusBarTranslucentAndroid
ThestatusBarTranslucentprop determines whether your modal should go under the system statusbar.


### supportedOrientationsiOS
ThesupportedOrientationsprop allows the modal to be rotated to any of the specified orientations. On iOS, the modal is still restricted by what's specified in your app's Info.plist's UISupportedInterfaceOrientations field.

When usingpresentationStyleofpageSheetorformSheet, this property will be ignored on iOS.


### transparent
Thetransparentprop determines whether your modal will fill the entire view. Setting this totruewill render the modal over a transparent background.


### visible
Thevisibleprop determines whether your modal is visible.


================================================================================


# More Resources
Source: https://reactnative.dev/docs/more-resources

There’s always more to learn: developer workflows, shipping to app stores, internationalization, security and more.


## Where to go from here
- Set up your environment
- Set up your development workflow
- Design and layout your app
- Debug your app
- Make your app cross platform
- Get involved in the React Native community

## Dive deep
- React’s Documentation
- MDN’s JavaScript tutorials, reference, and guides
- AndroidandiOSplatform docs

## IDEs
We recommend using theVS Codecode editor and its handyReact Native tools.


## Platforms to try
Expois a framework of tools and services for React Native that focuses on helping you build, ship, and iterate on your app, to use preview deployment workflows that are popular with web development, and to automate your development workflows. Expo also makes it possible to build React Native apps without ever touching Xcode or Android Studio, and it doesn't get in the way if you want to use those tools.

Igniteis a starter kit CLI with several React Native boilerplates. The latest, Ignite Maverick, uses MobX-State-Tree for state management, React Navigation, and other common libraries. It has generators for screens, models, and more, and supports Expo out of the box. Ignite also comes with a component library that is tuned for custom designs, theming support, and testing. If you are looking for a preconfigured tech stack, Ignite could be perfect for you.


## Example Apps
Try out apps from theShowcaseto see what React Native is capable of! Looking for something more hands on? Check out thisset of example apps on GitHub. You can look at their source code—try running one on a simulator or device.


## Find, make, and share your own Native Components and TurboModules
React Native has a community of thousands of developers like you making content, tools, tutorials—and Native Components!

Can’t find what you’re looking for in the Core Components? VisitReact Native Directoryto find what the community has been creating.

This documentation references a legacy set of API and needs to be updated to reflect the New Architecture

Interested in making your own Native Component or Module? Making modules for your own use case and sharing them with others on NPM and GitHub helps grow the React Native ecosystem and community! Read the guides to making your own Native Modules (Android,iOS) and Native Components (Android,iOS).


================================================================================


# Native Platform
Source: https://reactnative.dev/docs/native-platform

Your application may need access to platform features that aren’t directly available from react-native or one of the hundreds ofthird-party librariesmaintained by the community. Maybe you want to reuse some existing Objective-C, Swift, Java, Kotlin or C++ code from the JavaScript runtime. Whatever your reason, React Native exposes a powerful set of API to connect your native code to your JavaScript application code.

This guide introduces:

- Native Modules:native libraries that have no User Interface (UI) for the user. Examples would be persistent storage, notifications, network events. These are accessible to your user as JavaScript functions and objects.
- Native Component:native platform views, widgets and controllers that are available to your application's JavaScript code through React Components.
You might have previously been familiar with:Legacy Native Modules;Legacy Native Components;These are our deprecated native module and component API. You can still use many of these legacy libraries with the New Architecture thanks to our interop layers. You should consider:using alternative libraries,upgrading to newer library versions that have first-class support for the New Architecture, orport these libraries yourself to Turbo Native Modules or Fabric Native Components.

- Legacy Native Modules;
- Legacy Native Components;
These are our deprecated native module and component API. You can still use many of these legacy libraries with the New Architecture thanks to our interop layers. You should consider:using alternative libraries,upgrading to newer library versions that have first-class support for the New Architecture, orport these libraries yourself to Turbo Native Modules or Fabric Native Components.

- using alternative libraries,
- upgrading to newer library versions that have first-class support for the New Architecture, or
- port these libraries yourself to Turbo Native Modules or Fabric Native Components.
- Native ModulesAndroid & iOSCross-Platform with C++Advanced: Custom C++ Types
- Android & iOS
- Cross-Platform with C++
- Advanced: Custom C++ Types
- Fabric Native ComponentsAndroid & iOS
- Android & iOS

================================================================================


# Navigating Between Screens
Source: https://reactnative.dev/docs/navigation

Mobile apps are rarely made up of a single screen. Managing the presentation of, and transition between, multiple screens is typically handled by what is known as a navigator.

This guide covers the various navigation components available in React Native. If you are getting started with navigation, you will probably want to useReact Navigation. React Navigation provides a straightforward navigation solution, with the ability to present common stack navigation and tabbed navigation patterns on both Android and iOS.

If you're integrating React Native into an app that already manages navigation natively, or looking for an alternative to React Navigation, the following library provides native navigation on both platforms:react-native-navigation.


## React Navigation
The community solution to navigation is a standalone library that allows developers to set up the screens of an app with a few lines of code.


### Starter template
If you're starting a new project, you can use the React Navigation template to quickly set up a new project withExpo:

```
npx create-expo-app@latest --template react-navigation/template
```

See the project'sREADME.mdfor more information on how to get started.


### Installation and setup
First, you need to install them in your project:

```
npm install @react-navigation/native @react-navigation/native-stack
```

Next, install the required peer dependencies. You need to run different commands depending on whether your project is an Expo managed project or a bare React Native project.

- If you have an Expo managed project, install the dependencies withexpo:shellnpx expoinstallreact-native-screens react-native-safe-area-context
If you have an Expo managed project, install the dependencies withexpo:

```
npx expo install react-native-screens react-native-safe-area-context
```

- If you have a bare React Native project, install the dependencies withnpm:shellnpminstallreact-native-screens react-native-safe-area-contextFor iOS with bare React Native project, make sure you haveCocoaPodsinstalled. Then install the pods to complete the installation:shellcdiospodinstallcd..
If you have a bare React Native project, install the dependencies withnpm:

```
npm install react-native-screens react-native-safe-area-context
```

For iOS with bare React Native project, make sure you haveCocoaPodsinstalled. Then install the pods to complete the installation:

```
cd iospod installcd ..
```

Once you've installed and configured the dependencies, you can move on to setting up your project to use React Navigation.

When using React Navigation, you configurenavigatorsin your app. Navigators handle the transition between screens in your app and provide UI such as header, tab bar etc.

Now you are ready to build and run your app on the device/simulator.


### Usage
Now you can create an app with a home screen and a profile screen:

```
import * as React from 'react';import {createStaticNavigation} from '@react-navigation/native';import {createNativeStackNavigator} from '@react-navigation/native-stack';const RootStack = createNativeStackNavigator({  screens: {    Home: {      screen: HomeScreen,      options: {title: 'Welcome'},    },    Profile: {      screen: ProfileScreen,    },  },});const Navigation = createStaticNavigation(RootStack);export default function App() {  return <Navigation />;}
```

In this example,RootStackis a navigator with 2 screens (HomeandProfile), defined in thescreensproperty increateNativeStackNavigator. Similarly, you can define as many screens as you like.

You can specify options such as the screen title for each screen in theoptionsproperty of each screen. Each screen definition also needs ascreenproperty that is a React component or another navigator.

Inside each screen component, you can use theuseNavigationhook to get thenavigationobject, which has various methods to link to other screens. For example, you can usenavigation.navigateto go to theProfilescreen:

```
import {useNavigation} from '@react-navigation/native';function HomeScreen() {  const navigation = useNavigation();  return (    <Button      title="Go to Jane's profile"      onPress={() =>        navigation.navigate('Profile', {name: 'Jane'})      }    />  );}function ProfileScreen({route}) {  return <Text>This is {route.params.name}'s profile</Text>;}
```

Thisnative-stacknavigator uses the native APIs:UINavigationControlleron iOS andFragmenton Android so that navigation built withcreateNativeStackNavigatorwill behave the same and have the similar performance characteristics as apps built natively on top of those APIs.

React Navigation also has packages for different kind of navigators such as tabs and drawer. You can use them to implement various patterns in your app.

For a complete intro to React Navigation, follow theReact Navigation Getting Started Guide.


================================================================================


# Networking
Source: https://reactnative.dev/docs/network

Many mobile apps need to load resources from a remote URL. You may want to make a POST request to a REST API, or you may need to fetch a chunk of static content from another server.


## Using Fetch
React Native provides theFetch APIfor your networking needs. Fetch will seem familiar if you have usedXMLHttpRequestor other networking APIs before. You may refer to MDN's guide onUsing Fetchfor additional information.


### Making requests
In order to fetch content from an arbitrary URL, you can pass the URL to fetch:

```
fetch('https://mywebsite.com/mydata.json');
```

Fetch also takes an optional second argument that allows you to customize the HTTP request. You may want to specify additional headers, or make a POST request:

```
fetch('https://mywebsite.com/endpoint/', {  method: 'POST',  headers: {    Accept: 'application/json',    'Content-Type': 'application/json',  },  body: JSON.stringify({    firstParam: 'yourValue',    secondParam: 'yourOtherValue',  }),});
```

Take a look at theFetch Request docsfor a full list of properties.


### Handling the response
The above examples show how you can make a request. In many cases, you will want to do something with the response.

Networking is an inherently asynchronous operation. Fetch method will return aPromisethat makes it straightforward to write code that works in an asynchronous manner:

```
const getMoviesFromApi = () => {  return fetch('https://reactnative.dev/movies.json')    .then(response => response.json())    .then(json => {      return json.movies;    })    .catch(error => {      console.error(error);    });};
```

You can also use theasync/awaitsyntax in a React Native app:

```
const getMoviesFromApiAsync = async () => {  try {    const response = await fetch(      'https://reactnative.dev/movies.json',    );    const json = await response.json();    return json.movies;  } catch (error) {    console.error(error);  }};
```

Don't forget to catch any errors that may be thrown byfetch, otherwise they will be dropped silently.

- TypeScriptJavaScript
- JavaScript
By default, iOS 9.0 or later enforce App Transport Security (ATS). ATS requires any HTTP connection to use HTTPS. If you need to fetch from a cleartext URL (one that begins withhttp) you will first need toadd an ATS exception. If you know ahead of time what domains you will need access to, it is more secure to add exceptions only for those domains; if the domains are not known until runtime you candisable ATS completely. Note however that from January 2017,Apple's App Store review will require reasonable justification for disabling ATS. SeeApple's documentationfor more information.

On Android, as of API Level 28, clear text traffic is also blocked by default. This behaviour can be overridden by settingandroid:usesCleartextTrafficin the app manifest file.


## Using Other Networking Libraries
TheXMLHttpRequest APIis built into React Native. This means that you can use third party libraries such asfrisbeeoraxiosthat depend on it, or you can use the XMLHttpRequest API directly if you prefer.

```
const request = new XMLHttpRequest();request.onreadystatechange = e => {  if (request.readyState !== 4) {    return;  }  if (request.status === 200) {    console.log('success', request.responseText);  } else {    console.warn('error');  }};request.open('GET', 'https://mywebsite.com/endpoint/');request.send();
```

The security model for XMLHttpRequest is different than on web as there is no concept ofCORSin native apps.


## WebSocket Support
React Native also supportsWebSockets, a protocol which provides full-duplex communication channels over a single TCP connection.

```
const ws = new WebSocket('ws://host.com/path');ws.onopen = () => {  // connection opened  ws.send('something'); // send a message};ws.onmessage = e => {  // a message was received  console.log(e.data);};ws.onerror = e => {  // an error occurred  console.log(e.message);};ws.onclose = e => {  // connection closed  console.log(e.code, e.reason);};
```


## Known Issues withfetchand cookie based authentication
The following options are currently not working withfetch

- redirect:manual
- credentials:omit
- Having same name headers on Android will result in only the latest one being present. A temporary solution can be found here:https://github.com/facebook/react-native/issues/18837#issuecomment-398779994.
- Cookie based authentication is currently unstable. You can view some of the issues raised here:https://github.com/facebook/react-native/issues/23185
- As a minimum on iOS, when redirected through a302, if aSet-Cookieheader is present, the cookie is not set properly. Since the redirect cannot be handled manually this might cause a scenario where infinite requests occur if the redirect is the result of an expired session.

## Configuring NSURLSession on iOS
For some applications it may be appropriate to provide a customNSURLSessionConfigurationfor the underlyingNSURLSessionthat is used for network requests in a React Native application running on iOS. For instance, one may need to set a custom user agent string for all network requests coming from the app or supplyNSURLSessionwith an ephemeralNSURLSessionConfiguration. The functionRCTSetCustomNSURLSessionConfigurationProviderallows for such customization. Remember to add the following import to the file in whichRCTSetCustomNSURLSessionConfigurationProviderwill be called:

```
#import <React/RCTHTTPRequestHandler.h>
```

RCTSetCustomNSURLSessionConfigurationProvidershould be called early in the application life cycle such that it is readily available when needed by React, for instance:

```
-(void)application:(__unused UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {  // set RCTSetCustomNSURLSessionConfigurationProvider  RCTSetCustomNSURLSessionConfigurationProvider(^NSURLSessionConfiguration *{     NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];     // configure the session     return configuration;  });  // set up React  _bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:launchOptions];}
```


================================================================================


# Nodes from refs
Source: https://reactnative.dev/docs/nodes

React Native apps render a native view tree that represents the UI, similar to how React DOM does on Web (the DOM tree). React Native provides imperative access to this tree viarefs, which are returned by all native components (including those rendered by built-in components likeView).

React Native provides 3 types of nodes:

- Elements: element nodes represent native components in the native view tree (similar toElementnodes on Web). They are provided by all native components via refs.
- Text: text nodes represent raw text content on the tree (similar toTextnodes on Web). They are not directly accessible viarefs, but can be accessed using methods likechildNodeson element refs.
- Documents: document nodes represent a complete native view tree (similar toDocumentnodes on Web). Like text nodes, they can only be accessed through other nodes, using properties likeownerDocument.
As on Web, these nodes can be used to traverse the rendered UI tree, access layout information or execute imperative operations likefocus.

Unlike on Web, these nodes do not allow mutation(e.g.:node.appendChild), as the tree contents are fully managed by the React renderer.


================================================================================


# Optimizing FlatList Configuration
Source: https://reactnative.dev/docs/optimizing-flatlist-configuration


## Terms
- VirtualizedList:The component behindFlatList(React Native's implementation of theVirtual Listconcept.)
VirtualizedList:The component behindFlatList(React Native's implementation of theVirtual Listconcept.)

- Memory consumption:How much information about your list is being stored in memory, which could lead to an app crash.
Memory consumption:How much information about your list is being stored in memory, which could lead to an app crash.

- Responsiveness:Application ability to respond to interactions. Low responsiveness, for instance, is when you touch on a component and it waits a bit to respond, instead of responding immediately as expected.
Responsiveness:Application ability to respond to interactions. Low responsiveness, for instance, is when you touch on a component and it waits a bit to respond, instead of responding immediately as expected.

- Blank areas:WhenVirtualizedListcan't render your items fast enough, you may enter a part of your list with non-rendered components that appear as blank space.
Blank areas:WhenVirtualizedListcan't render your items fast enough, you may enter a part of your list with non-rendered components that appear as blank space.

- Viewport:The visible area of content that is rendered to pixels.
Viewport:The visible area of content that is rendered to pixels.

- Window:The area in which items should be mounted, which is generally much larger than the viewport.
Window:The area in which items should be mounted, which is generally much larger than the viewport.


## Props
Here are a list of props that can help to improveFlatListperformance:


### removeClippedSubviews
Iftrue, views that are outside of the viewport are automatically detached from the native view hierarchy.

Pros:This reduces time spent on the main thread, and thus reduces the risk of dropped frames, by excluding views outside of the viewport from the native rendering and drawing traversals.

Cons:Be aware that this implementation can have bugs, such as missing content (mainly observed on iOS), especially if you are doing complex things with transforms and/or absolute positioning. Also note this does not save significant memory because the views are not deallocated, only detached.


### maxToRenderPerBatch
It is aVirtualizedListprop that can be passed throughFlatList. This controls the amount of items rendered per batch, which is the next chunk of items rendered on every scroll.

Pros:Setting a bigger number means less visual blank areas when scrolling (increases the fill rate).

Cons:More items per batch means longer periods of JavaScript execution potentially blocking other event processing, like presses, hurting responsiveness.


### updateCellsBatchingPeriod
WhilemaxToRenderPerBatchtells the amount of items rendered per batch, settingupdateCellsBatchingPeriodtells yourVirtualizedListthe delay in milliseconds between batch renders (how frequently your component will be rendering the windowed items).

Pros:Combining this prop withmaxToRenderPerBatchgives you the power to, for example, render more items in a less frequent batch, or less items in a more frequent batch.

Cons:Less frequent batches may cause blank areas, More frequent batches may cause responsiveness issues.


### initialNumToRender
The initial amount of items to render.

Pros:Define precise number of items that would cover the screen for every device. This can be a big performance boost for the initial render.

Cons:Setting a lowinitialNumToRendermay cause blank areas, especially if it's too small to cover the viewport on initial render.


### windowSize
The number passed here is a measurement unit where 1 is equivalent to your viewport height. The default value is 21 (10 viewports above, 10 below, and one in between).

Pros:BiggerwindowSizewill result in less chance of seeing blank space while scrolling. On the other hand, smallerwindowSizewill result in fewer items mounted simultaneously, saving memory.

Cons:For a biggerwindowSize, you will have more memory consumption. For a lowerwindowSize, you will have a bigger chance of seeing blank areas.


## List items
Below are some tips about list item components. They are the core of your list, so they need to be fast.


### Use basic components
The more complex your components are, the slower they will render. Try to avoid a lot of logic and nesting in your list items. If you are reusing this list item component a lot in your app, create a component only for your big lists and make them with as little logic and nesting as possible.


### Use light components
The heavier your components are, the slower they render. Avoid heavy images (use a cropped version or thumbnail for list items, as small as possible). Talk to your design team, use as little effects and interactions and information as possible in your list. Show them in your item's detail.


### Usememo()
React.memo()creates a memoized component that will be re-rendered only when the props passed to the component change. We can use this function to optimize the components in the FlatList.

```
import React, {memo} from 'react';import {View, Text} from 'react-native';const MyListItem = memo(  ({title}: {title: string}) => (    <View>      <Text>{title}</Text>    </View>  ),  (prevProps, nextProps) => {    return prevProps.title === nextProps.title;  },);export default MyListItem;
```

In this example, we have determined that MyListItem should be re-rendered only when the title changes. We passed the comparison function as the second argument to React.memo() so that the component is re-rendered only when the specified prop is changed. If the comparison function returns true, the component will not be re-rendered.


### Use cached optimized images
You can use the community packages (such as@d11/react-native-fast-imagefromDream11) for more performant images. Every image in your list is anew Image()instance. The faster it reaches theloadedhook, the faster your JavaScript thread will be free again.


### UsegetItemLayout
If all your list item components have the same height (or width, for a horizontal list), providing thegetItemLayoutprop removes the need for yourFlatListto manage async layout calculations. This is a very desirable optimization technique.

If your components have dynamic size and you really need performance, consider asking your design team if they may think of a redesign in order to perform better.


### UsekeyExtractororkey
You can set thekeyExtractorto yourFlatListcomponent. This prop is used for caching and as the Reactkeyto track item re-ordering.

You can also use akeyprop in your item component.


### Avoid anonymous function onrenderItem
For functional components, move therenderItemfunction outside of the returned JSX. Also, ensure that it is wrapped in auseCallbackhook to prevent it from being recreated each render.

For class components, move therenderItemfunction outside of the render function, so it won't recreate itself each time the render function is called.

```
const renderItem = useCallback(({item}) => (   <View key={item.key}>      <Text>{item.title}</Text>   </View> ), []);return (  // ...  <FlatList data={items} renderItem={renderItem} />;  // ...);
```


================================================================================


# Optimizing JavaScript loading
Source: https://reactnative.dev/docs/optimizing-javascript-loading

Parsing and running JavaScript code requires memory and time. Because of this, as your app grows, it's often useful to delay loading code until it's needed for the first time. React Native comes with some standard optimizations that are on by default, and there are techniques you can adopt in your own code to help React load your app more efficiently. There are also some advanced automatic optimizations (with their own tradeoffs) that are suitable for very large apps.


## Recommended: Use Hermes
Hermes is the default engine for new React Native apps, and is highly optimized for efficient code loading. In release builds, JavaScript code is fully compiled to bytecode ahead of time. Bytecode is loaded to memory on-demand and does not need to be parsed like plain JavaScript does.

Read more about using Hermes in React Nativehere.


## Recommended: Lazy-load large components
If a component with a lot of code/dependencies is not likely to be used when initially rendering your app, you can use React'slazyAPI to defer loading its code until it's rendered for the first time. Typically, you should consider lazy-loading screen-level components in your app, so that adding new screens to your app does not increase its startup time.

Read more aboutlazy-loading components with Suspense, including code examples, in React's documentation.


### Tip: Avoid module side effects
Lazy-loading components can change the behavior of your app if your component modules (or their dependencies) haveside effects, such as modifying global variables or subscribing to events outside of a component. Most modules in React apps should not have any side effects.

```
import Logger from './utils/Logger';//  🚩 🚩 🚩 Side effect! This must be executed before React can even begin to// render the SplashScreen component, and can unexpectedly break code elsewhere// in your app if you later decide to lazy-load SplashScreen.global.logger = new Logger();export function SplashScreen() {  // ...}
```


## Advanced: Callrequireinline
Sometimes you may want to defer loading some code until you use it for the first time, without usinglazyor an asynchronousimport(). You can do this by using therequire()function where you would otherwise use a staticimportat the top of the file.

```
import {Component} from 'react';import {Text} from 'react-native';// ... import some very expensive modulesexport default function VeryExpensive() {  // ... lots and lots of rendering logic  return <Text>Very Expensive Component</Text>;}
```

```
import {useCallback, useState} from 'react';import {TouchableOpacity, View, Text} from 'react-native';// Usually we would write a static import:// import VeryExpensive from './VeryExpensive';let VeryExpensive = null;export default function Optimize() {  const [needsExpensive, setNeedsExpensive] = useState(false);  const didPress = useCallback(() => {    if (VeryExpensive == null) {      VeryExpensive = require('./VeryExpensive').default;    }    setNeedsExpensive(true);  }, []);  return (    <View style={{marginTop: 20}}>      <TouchableOpacity onPress={didPress}>        <Text>Load</Text>      </TouchableOpacity>      {needsExpensive ? <VeryExpensive /> : null}    </View>  );}
```


## Advanced: Automatically inlinerequirecalls
If you use the React Native CLI to build your app,requirecalls (but notimports) will automatically be inlined for you, both in your code and inside any third-party packages (node_modules) you use.

```
import {useCallback, useState} from 'react';import {TouchableOpacity, View, Text} from 'react-native';// This top-level require call will be evaluated lazily as part of the component below.const VeryExpensive = require('./VeryExpensive').default;export default function Optimize() {  const [needsExpensive, setNeedsExpensive] = useState(false);  const didPress = useCallback(() => {    setNeedsExpensive(true);  }, []);  return (    <View style={{marginTop: 20}}>      <TouchableOpacity onPress={didPress}>        <Text>Load</Text>      </TouchableOpacity>      {needsExpensive ? <VeryExpensive /> : null}    </View>  );}
```

Some React Native frameworks disable this behavior. In particular, in Expo projects,requirecalls are not inlined by default. You can enable this optimization by editing your project's Metro config and settinginlineRequires: trueingetTransformOptions.


### Pitfalls of inlinerequires
Inliningrequirecalls changes the order in which modules are evaluated, and can even cause some modules toneverbe evaluated. This is usually safe to do automatically, because JavaScript modules are often written to be side-effect-free.

If one of your modules does have side effects - for example, if it initializes some logging mechanism, or patches a global API used by the rest of your code - then you might see unexpected behavior or even crashes. In those cases, you may want to exclude certain modules from this optimization, or disable it entirely.

Todisable all automatic inlining ofrequirecalls:

Update yourmetro.config.jsto set theinlineRequirestransformer option tofalse:

```
module.exports = {  transformer: {    async getTransformOptions() {      return {        transform: {          inlineRequires: false,        },      };    },  },};
```

To onlyexclude certain modules fromrequireinlining:

There are two relevant transformer options:inlineRequires.blockListandnonInlinedRequires. See the code snippet for examples of how to use each one.

```
module.exports = {  transformer: {    async getTransformOptions() {      return {        transform: {          inlineRequires: {            blockList: {              // require() calls in `DoNotInlineHere.js` will not be inlined.              [require.resolve('./src/DoNotInlineHere.js')]: true,              // require() calls anywhere else will be inlined, unless they              // match any entry nonInlinedRequires (see below).            },          },          nonInlinedRequires: [            // require('react') calls will not be inlined anywhere            'react',          ],        },      };    },  },};
```

See the documentation forgetTransformOptionsin Metrofor more details on setting up and fine-tuning your inlinerequires.


## Advanced: Use random access module bundles (non-Hermes)
Not supported whenusing Hermes.Hermes bytecode is not compatible with the RAM bundle format, and provides the same (or better) performance in all use cases.

Random access module bundles (also known as RAM bundles) work in conjunction with the techniques mentioned above to limit the amount of JavaScript code that needs to be parsed and loaded into memory. Each module is stored as a separate string (or file) which is only parsed when the module needs to be executed.

RAM bundles may be physically split into separate files, or they may use theindexedformat, consisting of a lookup table of multiple modules in a single file.

- AndroidiOS
- iOS
On Android enable the RAM format by editing yourandroid/app/build.gradlefile. Before the lineapply from: "../../node_modules/react-native/react.gradle"add or amend theproject.ext.reactblock:project.ext.react=[bundleCommand:"ram-bundle",]Use the following lines on Android if you want to use a single indexed file:project.ext.react=[bundleCommand:"ram-bundle",extraPackagerArgs:["--indexed-ram-bundle"]]

```
project.ext.react = [  bundleCommand: "ram-bundle",]
```

Use the following lines on Android if you want to use a single indexed file:project.ext.react=[bundleCommand:"ram-bundle",extraPackagerArgs:["--indexed-ram-bundle"]]

```
project.ext.react = [  bundleCommand: "ram-bundle",  extraPackagerArgs: ["--indexed-ram-bundle"]]
```

On iOS, RAM bundles are always indexed ( = single file).Enable the RAM format in Xcode by editing the build phase "Bundle React Native code and images". Before../node_modules/react-native/scripts/react-native-xcode.shaddexport BUNDLE_COMMAND="ram-bundle":exportBUNDLE_COMMAND="ram-bundle"exportNODE_BINARY=node../node_modules/react-native/scripts/react-native-xcode.sh

Enable the RAM format in Xcode by editing the build phase "Bundle React Native code and images". Before../node_modules/react-native/scripts/react-native-xcode.shaddexport BUNDLE_COMMAND="ram-bundle":exportBUNDLE_COMMAND="ram-bundle"exportNODE_BINARY=node../node_modules/react-native/scripts/react-native-xcode.sh

```
export BUNDLE_COMMAND="ram-bundle"export NODE_BINARY=node../node_modules/react-native/scripts/react-native-xcode.sh
```

See the documentation forgetTransformOptionsin Metrofor more details on setting up and fine-tuning your RAM bundle build.


================================================================================


# Other Debugging Methods
Source: https://reactnative.dev/docs/other-debugging-methods

This page covers how to use legacy JavaScript debugging methods. If you are getting started with a new React Native or Expo app, we recommend usingReact Native DevTools.


## Safari Developer Tools (direct JSC debugging)
You can use Safari to debug the iOS version of your app when usingJavaScriptCore(JSC) as your app's runtime.

- Physical devices only: Open the Settings app, and navigate to Safari > Advanced, and make sure "Web Inspector" is turned on.
- On your Mac, open Safari and enable the Develop menu. This can be found under Safari > Settings..., then the Advanced tab, then selecting "Show features for web developers".
- Find your device under the Develop menu, and select the "JSContext" item from the submenu. This will open Safari's Web Inspector, which includes Console and Sources panels similar to Chrome DevTools.
While source maps may not be enabled by default, you can followthis guideorvideoto enable them and set break points at the right places in the source code.

Every time the app is reloaded, a new JSContext is created. Choosing "Automatically Show Web Inspectors for JSContexts" saves you from having to select the latest JSContext manually.


## Remote JavaScript Debugging (removed)
Remote JavaScript Debugging has been removed as of React Native 0.79. See the originaldeprecation announcement.If you are on an older version of React Native, please go to the docsfor your version.

If you are on an older version of React Native, please go to the docsfor your version.


================================================================================


# Out-of-Tree Platforms
Source: https://reactnative.dev/docs/out-of-tree-platforms

React Native is not only for Android and iOS devices - our partners and the community maintain projects that bring React Native to other platforms, such as:

From Partners

- React Native macOS- React Native for macOS and Cocoa.
- React Native Windows- React Native for Microsoft's Universal Windows Platform (UWP).
- React Native visionOS- React Native for Apple's visionOS.
From Community

- React Native tvOS- React Native for Apple TV and Android TV devices.
- React Native Web- React Native on the web using React DOM.
- React Native Skia- React Native usingSkiaas a renderer. Currently supports Linux and macOS.

## Creating your own React Native platform
Right now the process of creating a React Native platform from scratch is not very well documented - one of the goals of the upcoming re-architecture (Fabric) is to make maintaining a platform easier.


### Bundling
As of React Native 0.57 you can now register your React Native platform with React Native's JavaScript bundler,Metro. This means you can pass--platform exampletonpx react-native bundle, and it will look for JavaScript files with the.example.jssuffix.

To register your platform with RNPM, your module's name must match one of these patterns:

- react-native-example- It will search all top-level modules that start withreact-native-
- @org/react-native-example- It will search for modules that start withreact-native-under any scope
- @react-native-example/module- It will search in all modules under scopes with names starting with@react-native-
You must also have an entry in yourpackage.jsonlike this:

```
{  "rnpm": {    "haste": {      "providesModuleNodeModules": ["react-native-example"],      "platforms": ["example"]    }  }}
```

"providesModuleNodeModules"is an array of modules that will get added to the Haste module search path, and"platforms"is an array of platform suffixes that will be added as valid platforms.


================================================================================


# PanResponder
Source: https://reactnative.dev/docs/panresponder

PanResponderreconciles several touches into a single gesture. It makes single-touch gestures resilient to extra touches, and can be used to recognize basic multi-touch gestures.

By default,PanResponderholds anInteractionManagerhandle to block long-running JS events from interrupting active gestures.

It provides a predictable wrapper of the responder handlers provided by thegesture responder system. For each handler, it provides a newgestureStateobject alongside the native event object:

```
onPanResponderMove: (event, gestureState) => {}
```

A native event is a synthetic touch event with form ofPressEvent.

AgestureStateobject has the following:

- stateID- ID of the gestureState- persisted as long as there's at least one touch on screen
- moveX- the latest screen coordinates of the recently-moved touch
- moveY- the latest screen coordinates of the recently-moved touch
- x0- the screen coordinates of the responder grant
- y0- the screen coordinates of the responder grant
- dx- accumulated distance of the gesture since the touch started
- dy- accumulated distance of the gesture since the touch started
- vx- current velocity of the gesture
- vy- current velocity of the gesture
- numberActiveTouches- Number of touches currently on screen

## Usage Pattern
```
const ExampleComponent = () => {  const panResponder = React.useRef(    PanResponder.create({      // Ask to be the responder:      onStartShouldSetPanResponder: (evt, gestureState) => true,      onStartShouldSetPanResponderCapture: (evt, gestureState) =>        true,      onMoveShouldSetPanResponder: (evt, gestureState) => true,      onMoveShouldSetPanResponderCapture: (evt, gestureState) =>        true,      onPanResponderGrant: (evt, gestureState) => {        // The gesture has started. Show visual feedback so the user knows        // what is happening!        // gestureState.d{x,y} will be set to zero now      },      onPanResponderMove: (evt, gestureState) => {        // The most recent move distance is gestureState.move{X,Y}        // The accumulated gesture distance since becoming responder is        // gestureState.d{x,y}      },      onPanResponderTerminationRequest: (evt, gestureState) =>        true,      onPanResponderRelease: (evt, gestureState) => {        // The user has released all touches while this view is the        // responder. This typically means a gesture has succeeded      },      onPanResponderTerminate: (evt, gestureState) => {        // Another component has become the responder, so this gesture        // should be cancelled      },      onShouldBlockNativeResponder: (evt, gestureState) => {        // Returns whether this component should block native components from becoming the JS        // responder. Returns true by default. Is currently only supported on android.        return true;      },    }),  ).current;  return <View {...panResponder.panHandlers} />;};
```


## Example
PanResponderworks withAnimatedAPI to help build complex gestures in the UI. The following example contains an animatedViewcomponent which can be dragged freely across the screen

Try thePanResponder example in RNTester.


## Methods

### create()
```
static create(config: PanResponderCallbacks): PanResponderInstance;
```

Parameters:

Theconfigobject provides enhanced versions of all of the responder callbacks that provide not only thePressEvent, but also thePanRespondergesture state, by replacing the wordResponderwithPanResponderin each of the typicalonResponder*callbacks. For example, theconfigobject would look like:

- onMoveShouldSetPanResponder: (e, gestureState) => {...}
- onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}
- onStartShouldSetPanResponder: (e, gestureState) => {...}
- onStartShouldSetPanResponderCapture: (e, gestureState) => {...}
- onPanResponderReject: (e, gestureState) => {...}
- onPanResponderGrant: (e, gestureState) => {...}
- onPanResponderStart: (e, gestureState) => {...}
- onPanResponderEnd: (e, gestureState) => {...}
- onPanResponderRelease: (e, gestureState) => {...}
- onPanResponderMove: (e, gestureState) => {...}
- onPanResponderTerminate: (e, gestureState) => {...}
- onPanResponderTerminationRequest: (e, gestureState) => {...}
- onShouldBlockNativeResponder: (e, gestureState) => {...}
In general, for events that have capture equivalents, we update the gestureState once in the capture phase and can use it in the bubble phase as well.

Be careful withonStartShould*callbacks. They only reflect updatedgestureStatefor start/end events that bubble/capture to the Node. Once the node is the responder, you can rely on every start/end event being processed by the gesture andgestureStatebeing updated accordingly. (numberActiveTouches) may not be totally accurate unless you are the responder.


================================================================================


# Performance Overview
Source: https://reactnative.dev/docs/performance

A compelling reason to use React Native instead of WebView-based tools is to achieve at least 60 frames per second and provide a native look and feel to your apps. Whenever feasible, we aim for React Native to handle optimizations automatically, allowing you to focus on your app without worrying about performance. However, there are certain areas where we haven't quite reached that level yet, and others where React Native (similar to writing native code directly) cannot determine the best optimization approach for you. In such cases, manual intervention becomes necessary. We strive to deliver buttery-smooth UI performance by default, but there may be instances where that isn't possible.

This guide is intended to teach you some basics to help you totroubleshoot performance issues, as well as discusscommon sources of problems and their suggested solutions.


## What you need to know about frames
Your grandparents' generation called movies"moving pictures"for a reason: realistic motion in video is an illusion created by quickly changing static images at a consistent speed. We refer to each of these images as frames. The number of frames that is displayed each second has a direct impact on how smooth and ultimately life-like a video (or user interface) seems to be. iOS and Android devices display at least 60 frames per second, which gives you and the UI system at most 16.67ms to do all of the work needed to generate the static image (frame) that the user will see on the screen for that interval. If you are unable to do the work necessary to generate that frame within the allotted time slot, then you will "drop a frame" and the UI will appear unresponsive.

Now to confuse the matter a little bit, open up theDev Menuin your app and toggleShow Perf Monitor. You will notice that there are two different frame rates.


### JS frame rate (JavaScript thread)
For most React Native applications, your business logic will run on the JavaScript thread. This is where your React application lives, API calls are made, touch events are processed, and more. Updates to native-backed views are batched and sent over to the native side at the end of each iteration of the event loop, before the frame deadline (if all goes well). If the JavaScript thread is unresponsive for a frame, it will be considered a dropped frame. For example, if you were to set a new state on the root component of a complex application and it resulted in re-rendering computationally expensive component subtrees, it's conceivable that this might take 200ms and result in 12 frames being dropped. Any animations controlled by JavaScript would appear to freeze during that time. If enough frames are dropped, the user will feel it.

An example is responding to touches: if you are doing work across multiple frames on the JavaScript thread, you might notice a delay in responding toTouchableOpacity, for example. This is because the JavaScript thread is busy and cannot process the raw touch events sent over from the main thread. As a result,TouchableOpacitycannot react to the touch events and command the native view to adjust its opacity.


### UI frame rate (main thread)
You may have noticed that performance of native stack navigators (such as the@react-navigation/native-stackprovided by React Navigation) is better out of the box than JavaScript-based stack navigators. This is because the transition animations are executed on the native main UI thread, so they are not interrupted by frame drops on the JavaScript thread.

Similarly, you can happily scroll up and down through aScrollViewwhen the JavaScript thread is locked up because theScrollViewlives on the main thread. The scroll events are dispatched to the JS thread, but their receipt is not necessary for the scroll to occur.


## Common sources of performance problems

### Running in development mode (dev=true)
JavaScript thread performance suffers greatly when running in dev mode. This is unavoidable: a lot more work needs to be done at runtime to provide you with good warnings and error messages. Always make sure to test performance inrelease builds.


### Usingconsole.logstatements
When running a bundled app, these statements can cause a big bottleneck in the JavaScript thread. This includes calls from debugging libraries such asredux-logger, so make sure to remove them before bundling. You can also use thisbabel pluginthat removes all theconsole.*calls. You need to install it first withnpm i babel-plugin-transform-remove-console --save-dev, and then edit the.babelrcfile under your project directory like this:

```
{  "env": {    "production": {      "plugins": ["transform-remove-console"]    }  }}
```

This will automatically remove allconsole.*calls in the release (production) versions of your project.

It is recommended to use the plugin even if noconsole.*calls are made in your project. A third party library could also call them.


### FlatListrendering is too slow or scroll performance is bad for large lists
If yourFlatListis rendering slowly, be sure that you've implementedgetItemLayoutto optimize rendering speed by skipping measurement of the rendered items.

There are also other third-party list libraries that are optimized for performance, includingFlashListandLegend List.


### Dropping JS thread FPS because of doing a lot of work on the JavaScript thread at the same time
"Slow Navigator transitions" is the most common manifestation of this, but there are other times this can happen. UsingInteractionManagercan be a good approach, but if the user experience cost is too high to delay work during an animation, then you might want to considerLayoutAnimation.

TheAnimated APIcurrently calculates each keyframe on-demand on the JavaScript thread unless yousetuseNativeDriver: true, whileLayoutAnimationleverages Core Animation and is unaffected by JS thread and main thread frame drops.

One case for using this is animating in a modal (sliding down from top and fading in a translucent overlay) while initializing and perhaps receiving responses for several network requests, rendering the contents of the modal, and updating the view where the modal was opened from. See theAnimations guidefor more information about how to useLayoutAnimation.

Caveats:

- LayoutAnimationonly works for fire-and-forget animations ("static" animations) -- if it must be interruptible, you will need to useAnimated.

### Moving a view on the screen (scrolling, translating, rotating) drops UI thread FPS
This is especially true on Android when you have text with a transparent background positioned on top of an image, or any other situation where alpha compositing would be required to re-draw the view on each frame. You will find that enablingrenderToHardwareTextureAndroidcan help with this significantly. For iOS,shouldRasterizeIOSis already enabled by default.

Be careful not to overuse this or your memory usage could go through the roof. Profile your performance and memory usage when using these props. If you don't plan to move a view anymore, turn this property off.


### Animating the size of an image drops UI thread FPS
On iOS, each time you adjust the width or height of anImagecomponentit is re-cropped and scaled from the original image. This can be very expensive, especially for large images. Instead, use thetransform: [{scale}]style property to animate the size. An example of when you might do this is when you tap an image and zoom it in to full screen.


### My TouchableX view isn't very responsive
Sometimes, if we do an action in the same frame that we are adjusting the opacity or highlight of a component that is responding to a touch, we won't see that effect until after theonPressfunction has returned. This may occur ifonPresssets a state that results in a heavy re-render and a few frames are dropped as a result. A solution to this is to wrap any action inside of youronPresshandler inrequestAnimationFrame:

```
function handleOnPress() {  requestAnimationFrame(() => {    this.doExpensiveAction();  });}
```


================================================================================


# PermissionsAndroid
Source: https://reactnative.dev/docs/permissionsandroid


### Project with Native Code Required
The following section only applies to projects with native code exposed. If you are using the managed Expo workflow, see the guide onPermissionsin the Expo documentation for the appropriate alternative.

PermissionsAndroidprovides access to Android M's new permissions model. The so-called "normal" permissions are granted by default when the application is installed as long as they appear inAndroidManifest.xml. However, "dangerous" permissions require a dialog prompt. You should use this module for those permissions.

On devices before SDK version 23, the permissions are automatically granted if they appear in the manifest, socheckshould always result totrueandrequestshould always resolve toPermissionsAndroid.RESULTS.GRANTED.

If a user has previously turned off a permission that you prompt for, the OS will advise your app to show a rationale for needing the permission. The optionalrationaleargument will show a dialog prompt only if necessary - otherwise the normal permission prompt will appear.


### Example

### Permissions that require prompting the user
Available as constants underPermissionsAndroid.PERMISSIONS:

- READ_CALENDAR: 'android.permission.READ_CALENDAR'
- WRITE_CALENDAR: 'android.permission.WRITE_CALENDAR'
- CAMERA: 'android.permission.CAMERA'
- READ_CONTACTS: 'android.permission.READ_CONTACTS'
- WRITE_CONTACTS: 'android.permission.WRITE_CONTACTS'
- GET_ACCOUNTS: 'android.permission.GET_ACCOUNTS'
- ACCESS_FINE_LOCATION: 'android.permission.ACCESS_FINE_LOCATION'
- ACCESS_COARSE_LOCATION: 'android.permission.ACCESS_COARSE_LOCATION'
- ACCESS_BACKGROUND_LOCATION: 'android.permission.ACCESS_BACKGROUND_LOCATION'
- RECORD_AUDIO: 'android.permission.RECORD_AUDIO'
- READ_PHONE_STATE: 'android.permission.READ_PHONE_STATE'
- CALL_PHONE: 'android.permission.CALL_PHONE'
- READ_CALL_LOG: 'android.permission.READ_CALL_LOG'
- WRITE_CALL_LOG: 'android.permission.WRITE_CALL_LOG'
- ADD_VOICEMAIL: 'com.android.voicemail.permission.ADD_VOICEMAIL'
- USE_SIP: 'android.permission.USE_SIP'
- PROCESS_OUTGOING_CALLS: 'android.permission.PROCESS_OUTGOING_CALLS'
- BODY_SENSORS: 'android.permission.BODY_SENSORS'
- SEND_SMS: 'android.permission.SEND_SMS'
- RECEIVE_SMS: 'android.permission.RECEIVE_SMS'
- READ_SMS: 'android.permission.READ_SMS'
- RECEIVE_WAP_PUSH: 'android.permission.RECEIVE_WAP_PUSH'
- RECEIVE_MMS: 'android.permission.RECEIVE_MMS'
- READ_EXTERNAL_STORAGE: 'android.permission.READ_EXTERNAL_STORAGE'
- WRITE_EXTERNAL_STORAGE: 'android.permission.WRITE_EXTERNAL_STORAGE'
- BLUETOOTH_CONNECT: 'android.permission.BLUETOOTH_CONNECT'
- BLUETOOTH_SCAN: 'android.permission.BLUETOOTH_SCAN'
- BLUETOOTH_ADVERTISE: 'android.permission.BLUETOOTH_ADVERTISE'
- ACCESS_MEDIA_LOCATION: 'android.permission.ACCESS_MEDIA_LOCATION'
- ACCEPT_HANDOVER: 'android.permission.ACCEPT_HANDOVER'
- ACTIVITY_RECOGNITION: 'android.permission.ACTIVITY_RECOGNITION'
- ANSWER_PHONE_CALLS: 'android.permission.ANSWER_PHONE_CALLS'
- READ_PHONE_NUMBERS: 'android.permission.READ_PHONE_NUMBERS'
- UWB_RANGING: 'android.permission.UWB_RANGING'
- BODY_SENSORS_BACKGROUND: 'android.permission.BODY_SENSORS_BACKGROUND'
- READ_MEDIA_IMAGES: 'android.permission.READ_MEDIA_IMAGES'
- READ_MEDIA_VIDEO: 'android.permission.READ_MEDIA_VIDEO'
- READ_MEDIA_AUDIO: 'android.permission.READ_MEDIA_AUDIO'
- POST_NOTIFICATIONS: 'android.permission.POST_NOTIFICATIONS'
- NEARBY_WIFI_DEVICES: 'android.permission.NEARBY_WIFI_DEVICES'
- READ_VOICEMAIL: 'com.android.voicemail.permission.READ_VOICEMAIL',
- WRITE_VOICEMAIL: 'com.android.voicemail.permission.WRITE_VOICEMAIL',

### Result strings for requesting permissions
Available as constants underPermissionsAndroid.RESULTS:

- GRANTED: 'granted'
- DENIED: 'denied'
- NEVER_ASK_AGAIN: 'never_ask_again'

## Methods

### check()
```
static check(permission: Permission): Promise<boolean>;
```

Returns a promise resolving to a boolean value as to whether the specified permissions has been granted.

Parameters:


### request()
```
static request(  permission: Permission,  rationale?: Rationale,): Promise<PermissionStatus>;
```

Prompts the user to enable a permission and returns a promise resolving to a string value (see result strings above) indicating whether the user allowed or denied the request or does not want to be asked again.

Ifrationaleis provided, this function checks with the OS whether it is necessary to show a dialog explaining why the permission is needed (https://developer.android.com/training/permissions/requesting.html#explain) and then shows the system permission dialog.

Parameters:

Rationale:


### requestMultiple()
```
static requestMultiple(  permissions: Permission[],): Promise<{[key in Permission]: PermissionStatus}>;
```

Prompts the user to enable multiple permissions in the same dialog and returns an object with the permissions as keys and strings as values (see result strings above) indicating whether the user allowed or denied the request or does not want to be asked again.

Parameters:


================================================================================


# PixelRatio
Source: https://reactnative.dev/docs/pixelratio

PixelRatiogives you access to the device's pixel density and font scale.


## Fetching a correctly sized image
You should get a higher resolution image if you are on a high pixel density device. A good rule of thumb is to multiply the size of the image you display by the pixel ratio.

```
const image = getImage({  width: PixelRatio.getPixelSizeForLayoutSize(200),  height: PixelRatio.getPixelSizeForLayoutSize(100),});<Image source={image} style={{width: 200, height: 100}} />;
```


## Pixel grid snapping
In iOS, you can specify positions and dimensions for elements with arbitrary precision, for example 29.674825. But, ultimately the physical display only have a fixed number of pixels, for example 640×1136 for iPhone SE (1st generation) or 828×1792 for iPhone 11. iOS tries to be as faithful as possible to the user value by spreading one original pixel into multiple ones to trick the eye. The downside of this technique is that it makes the resulting element look blurry.

In practice, we found out that developers do not want this feature and they have to work around it by doing manual rounding in order to avoid having blurry elements. In React Native, we are rounding all the pixels automatically.

We have to be careful when to do this rounding. You never want to work with rounded and unrounded values at the same time as you're going to accumulate rounding errors. Having even one rounding error is deadly because a one pixel border may vanish or be twice as big.

In React Native, everything in JavaScript and within the layout engine works with arbitrary precision numbers. It's only when we set the position and dimensions of the native element on the main thread that we round. Also, rounding is done relative to the root rather than the parent, again to avoid accumulating rounding errors.


## Example

## Methods

### get()
```
static get(): number;
```

Returns the device pixel density. Some examples:

- PixelRatio.get() === 1mdpi Android devices
- mdpi Android devices
- PixelRatio.get() === 1.5hdpi Android devices
- hdpi Android devices
- PixelRatio.get() === 2iPhone SE, 6S, 7, 8iPhone XRiPhone 11xhdpi Android devices
- iPhone SE, 6S, 7, 8
- iPhone XR
- iPhone 11
- xhdpi Android devices
- PixelRatio.get() === 3iPhone 6S Plus, 7 Plus, 8 PlusiPhone X, XS, XS MaxiPhone 11 Pro, 11 Pro MaxPixel, Pixel 2xxhdpi Android devices
- iPhone 6S Plus, 7 Plus, 8 Plus
- iPhone X, XS, XS Max
- iPhone 11 Pro, 11 Pro Max
- Pixel, Pixel 2
- xxhdpi Android devices
- PixelRatio.get() === 3.5Nexus 6Pixel XL, Pixel 2 XLxxxhdpi Android devices
- Nexus 6
- Pixel XL, Pixel 2 XL
- xxxhdpi Android devices

### getFontScale()
```
static getFontScale(): number;
```

Returns the scaling factor for font sizes. This is the ratio that is used to calculate the absolute font size, so any elements that heavily depend on that should use this to do calculations.

- on Android value reflects the user preference set inSettings > Display > Font size
- on iOS value reflects the user preference set inSettings > Display & Brightness > Text Size, value can also be updated inSettings > Accessibility > Display & Text Size > Larger Text
If a font scale is not set, this returns the device pixel ratio.


### getPixelSizeForLayoutSize()
```
static getPixelSizeForLayoutSize(layoutSize: number): number;
```

Converts a layout size (dp) to pixel size (px).

Guaranteed to return an integer number.


### roundToNearestPixel()
```
static roundToNearestPixel(layoutSize: number): number;
```

Rounds a layout size (dp) to the nearest layout size that corresponds to an integer number of pixels. For example, on a device with a PixelRatio of 3,PixelRatio.roundToNearestPixel(8.4) = 8.33, which corresponds to exactly (8.33 * 3) = 25 pixels.


================================================================================


# Platform
Source: https://reactnative.dev/docs/platform


## Example

## Properties

### constants
```
static constants: PlatformConstants;
```

Returns an object which contains all available common and specific constants related to the platform.

Properties:


### isPadiOS
```
static isPad: boolean;
```

Returns a boolean which defines if device is an iPad.


### isTV
```
static isTV: boolean;
```

Returns a boolean which defines if device is a TV.


### isVision
```
static isVision: boolean;
```

Returns a boolean which defines if device is an Apple Vision.If you are usingApple Vision Pro (Designed for iPad)isVisionwill befalsebutisPadwill betrue


### isTesting
```
static isTesting: boolean;
```

Returns a boolean which defines if application is running in Developer Mode with testing flag set.


### OS
```
static OS: 'android' | 'ios';
```

Returns string value representing the current OS.


### Version
```
static Version: 'number' | 'string';
```

Returns the version of the OS.


## Methods

### select()
```
static select(config: Record<string, T>): T;
```

Returns the most fitting value for the platform you are currently running on.

Select method returns the most fitting value for the platform you are currently running on. That is, if you're running on a phone,androidandioskeys will take preference. If those are not specified,nativekey will be used and then thedefaultkey.

Theconfigparameter is an object with the following keys:

- android(any)
- ios(any)
- native(any)
- default(any)
Example usage:

```
import {Platform, StyleSheet} from 'react-native';const styles = StyleSheet.create({  container: {    flex: 1,    ...Platform.select({      android: {        backgroundColor: 'green',      },      ios: {        backgroundColor: 'red',      },      default: {        // other platforms, web for example        backgroundColor: 'blue',      },    }),  },});
```

This will result in a container havingflex: 1on all platforms, a green background color on Android, a red background color on iOS, and a blue background color on other platforms.

Since the value of the corresponding platform key can be of typeany,selectmethod can also be used to return platform-specific components, like below:

```
const Component = Platform.select({  ios: () => require('ComponentIOS'),  android: () => require('ComponentAndroid'),})();<Component />;
```

```
const Component = Platform.select({  native: () => require('ComponentForNative'),  default: () => require('ComponentForWeb'),})();<Component />;
```


================================================================================


# Platform-Specific Code
Source: https://reactnative.dev/docs/platform-specific-code

When building a cross-platform app, you'll want to re-use as much code as possible. Scenarios may arise where it makes sense for the code to be different, for example you may want to implement separate visual components for Android and iOS.

React Native provides two ways to organize your code and separate it by platform:

- Using thePlatformmodule.
- Usingplatform-specific file extensions.
Certain components may have properties that work on one platform only. All of these props are annotated with@platformand have a small badge next to them on the website.


## Platform module
React Native provides a module that detects the platform in which the app is running. You can use the detection logic to implement platform-specific code. Use this option when only small parts of a component are platform-specific.

```
import {Platform, StyleSheet} from 'react-native';const styles = StyleSheet.create({  height: Platform.OS === 'ios' ? 200 : 100,});
```

Platform.OSwill beioswhen running on iOS andandroidwhen running on Android.

There is also aPlatform.selectmethod available that, given an object where keys can be one of'ios' | 'android' | 'native' | 'default', returns the most fitting value for the platform you are currently running on. That is, if you're running on a phone,iosandandroidkeys will take preference. If those are not specified,nativekey will be used and then thedefaultkey.

```
import {Platform, StyleSheet} from 'react-native';const styles = StyleSheet.create({  container: {    flex: 1,    ...Platform.select({      ios: {        backgroundColor: 'red',      },      android: {        backgroundColor: 'green',      },      default: {        // other platforms, web for example        backgroundColor: 'blue',      },    }),  },});
```

This will result in a container havingflex: 1on all platforms, a red background color on iOS, a green background color on Android, and a blue background color on other platforms.

Since it acceptsanyvalue, you can also use it to return platform-specific components, like below:

```
const Component = Platform.select({  ios: () => require('ComponentIOS'),  android: () => require('ComponentAndroid'),})();<Component />;
```

```
const Component = Platform.select({  native: () => require('ComponentForNative'),  default: () => require('ComponentForWeb'),})();<Component />;
```


### Detecting the Android versionAndroid
On Android, thePlatformmodule can also be used to detect the version of the Android Platform in which the app is running:

```
import {Platform} from 'react-native';if (Platform.Version === 25) {  console.log('Running on Nougat!');}
```

Note:Versionis set to the Android API version not the Android OS version. To find a mapping please refer toAndroid Version History.


### Detecting the iOS versioniOS
On iOS, theVersionis a result of-[UIDevice systemVersion], which is a string with the current version of the operating system. An example of the system version is "10.3". For example, to detect the major version number on iOS:

```
import {Platform} from 'react-native';const majorVersionIOS = parseInt(Platform.Version, 10);if (majorVersionIOS <= 9) {  console.log('Work around a change in behavior');}
```


## Platform-specific extensions
When your platform-specific code is more complex, you should consider splitting the code out into separate files. React Native will detect when a file has a.ios.or.android.extension and load the relevant platform file when required from other components.

For example, say you have the following files in your project:

```
BigButton.ios.jsBigButton.android.js
```

You can then import the component as follows:

```
import BigButton from './BigButton';
```

React Native will automatically pick up the right file based on the running platform.


## Native-specific extensions (i.e. sharing code with NodeJS and Web)
You can also use the.native.jsextension when a module needs to be shared between NodeJS/Web and React Native but it has no Android/iOS differences. This is especially useful for projects that have common code shared among React Native and ReactJS.

For example, say you have the following files in your project:

```
Container.js # picked up by webpack, Rollup or any other Web bundlerContainer.native.js # picked up by the React Native bundler for both Android and iOS (Metro)
```

You can still import it without the.nativeextension, as follows:

```
import Container from './Container';
```

Pro tip:Configure your Web bundler to ignore.native.jsextensions in order to avoid having unused code in your production bundle, thus reducing the final bundle size.


================================================================================


# PlatformColor
Source: https://reactnative.dev/docs/platformcolor

```
PlatformColor(color1, [color2, ...colorN]);
```

You can use thePlatformColorfunction to access native colors on the target platform by supplying the native color’s corresponding string value. You pass a string to thePlatformColorfunction and, provided it exists on that platform, it will return the corresponding native color, which you can apply in any part of your application.

If you pass more than one string value to thePlatformColorfunction, it will treat the first value as the default and the rest as fallback.

```
PlatformColor('bogusName', 'linkColor');
```

Since native colors can be sensitive to themes and/or high contrast, this platform specific logic also translates inside your components.


### Supported colors
For a full list of the types of system colors supported, see:

- Android:R.attr-?attrprefixR.color-@android:colorprefix
- R.attr-?attrprefix
- R.color-@android:colorprefix
- iOS (Objective-C and Swift notations):UIColor Standard ColorsUIColor UI Element Colors
- UIColor Standard Colors
- UIColor UI Element Colors
- Web
If you’re familiar with design systems, another way of thinking about this is thatPlatformColorlets you tap into the local design system's color tokens so your app can blend right in!


## Example
The string value provided to thePlatformColorfunction must match the string as it exists on the native platform where the app is running. In order to avoid runtime errors, the function should be wrapped in a platform check, either through aPlatform.OS === 'platform'or aPlatform.select(), as shown on the example above.

You can find a complete example that demonstrates proper, intended use ofPlatformColorinPlatformColorExample.js.


================================================================================


# Pressable
Source: https://reactnative.dev/docs/pressable

Pressable is a Core Component wrapper that can detect various stages of press interactions on any of its defined children.

```
<Pressable onPress={onPressFunction}>  <Text>I'm pressable!</Text></Pressable>
```


## How it works
On an element wrapped byPressable:

- onPressInis called when a press is activated.
- onPressOutis called when the press gesture is deactivated.
After pressingonPressIn, one of two things will happen:

- The person will remove their finger, triggeringonPressOutfollowed byonPress.
- If the person leaves their finger longer than 500 milliseconds before removing it,onLongPressis triggered. (onPressOutwill still fire when they remove their finger.)
Fingers are not the most precise instruments, and it is common for users to accidentally activate the wrong element or miss the activation area. To help,Pressablehas an optionalHitRectyou can use to define how far a touch can register away from the wrapped element. Presses can start anywhere within aHitRect.

PressRectallows presses to move beyond the element and itsHitRectwhile maintaining activation and being eligible for a "press"—think of sliding your finger slowly away from a button you're pressing down on.

The touch area never extends past the parent view bounds and the Z-index of sibling views always takes precedence if a touch hits two overlapping views.

You can setHitRectwithhitSlopand setPressRectwithpressRetentionOffset.

Pressableuses React Native'sPressabilityAPI. For more information around the state machine flow of Pressability and how it works, check out the implementation forPressability.


## Example

## Props

### android_disableSoundAndroid
If true, doesn't play Android system sound on press.


### android_rippleAndroid
Enables the Android ripple effect and configures its properties.


### children
Either children or a function that receives a boolean reflecting whether the component is currently pressed.


### unstable_pressDelay
Duration (in milliseconds) to wait after press down before callingonPressIn.


### delayLongPress
Duration (in milliseconds) fromonPressInbeforeonLongPressis called.


### disabled
Whether the press behavior is disabled.


### hitSlop
Sets additional distance outside of element in which a press can be detected.


### onHoverIn
Called when the hover is activated to provide visual feedback.


### onHoverOut
Called when the hover is deactivated to undo visual feedback.


### onLongPress
Called if the time afteronPressInlasts longer than 500 milliseconds. This time period can be customized withdelayLongPress.


### onPress
Called afteronPressOut.


### onPressIn
Called immediately when a touch is engaged, beforeonPressOutandonPress.


### onPressMove
Called when the press location moves.


### onPressOut
Called when a touch is released.


### pressRetentionOffset
Additional distance outside of this view in which a touch is considered a press beforeonPressOutis triggered.


### style
Either view styles or a function that receives a boolean reflecting whether the component is currently pressed and returns view styles.


### testOnly_pressed
Used only for documentation or testing (e.g. snapshot testing).


## Type Definitions

### RippleConfig
Ripple effect configuration for theandroid_rippleproperty.

Properties:


================================================================================


# PressEvent Object Type
Source: https://reactnative.dev/docs/pressevent

PressEventobject is returned in the callback as a result of user press interaction, for exampleonPressinButtoncomponent.


## Example
```
{    changedTouches: [PressEvent],    identifier: 1,    locationX: 8,    locationY: 4.5,    pageX: 24,    pageY: 49.5,    target: 1127,    timestamp: 85131876.58868201,    touches: []}
```


## Keys and values

### changedTouches
Array of all PressEvents that have changed since the last event.


### forceiOS
Amount of force used during the 3D Touch press. Returns the float value in range from0.0to1.0.


### identifier
Unique numeric identifier assigned to the event.


### locationX
Touch origin X coordinate inside touchable area (relative to the element).


### locationY
Touch origin Y coordinate inside touchable area (relative to the element).


### pageX
Touch origin X coordinate on the screen (relative to the root view).


### pageY
Touch origin Y coordinate on the screen (relative to the root view).


### target
The node id of the element receiving the PressEvent.


### timestamp
Timestamp value when a PressEvent occurred. Value is represented in milliseconds.


### touches
Array of all current PressEvents on the screen.


## Used by
- Button
- PanResponder
- Pressable
- ScrollView
- Text
- TextInput
- TouchableHighlight
- TouchableOpacity
- TouchableNativeFeedback
- TouchableWithoutFeedback
- View

================================================================================


# Profiling
Source: https://reactnative.dev/docs/profiling

Profiling is the process of analyzing an app's performance, resource usage, and behavior to identify potential bottlenecks or inefficiencies. It's worth making use of profiling tools to ensure your app works smoothly across different devices and conditions.

For iOS, Instruments is an invaluable tool, and on Android you should learn to use theAndroid Studio Profiler.

But first,make sure that Development Mode is OFF!.


## Profiling Android UI Performance with System Tracing
Android supports 10k+ different phones and is generalized to support software rendering: the framework architecture and need to generalize across many hardware targets unfortunately means you get less for free relative to iOS. But sometimes, there are things you can improve -- and many times it's not native code's fault at all!

The first step for debugging this jank is to answer the fundamental question of where your time is being spent during each 16ms frame. For that, we'll be using thebuilt-in System Tracing profiler in the Android Studio.

The standalonesystracetool has been removed from Android platform-tools. Use the Android Studio Profiler instead, which provides the same functionality with a better user interface.


### 1. Collecting a trace
First, connect a device that exhibits the stuttering you want to investigate to your computer via USB. Open your project'sandroidfolder in Android Studio, select your device in the top right pane, andrun your project as profileable.

When your app is built as profileable and is running on the device, get your app to the point right before the navigation/animation you want to profile and start the"Capture System Activities" taskin the Android Studio Profiler pane.

Once the trace starts collecting, perform the animation or interaction you care about. Then press "Stop recording". You can nowinspect the trace directly in the Android Studio. Alternatively, you can select it in the "Past Recordings" pane, press "Export recording", and open it in a tool likePerfetto.


### 2. Reading the trace
After opening the trace in Android Studio or Perfetto, you should see something like this:

Use the WASD keys to strafe and zoom.

The exact UI might be different but the instructions below will apply regardless of the tool you're using.

Check this checkbox at the top right of the screen to highlight the 16ms frame boundaries:You should see zebra stripes as in the screenshot above. If you don't, try profiling on a different device: Samsung has been known to have issues displaying vsyncs while the Nexus series is generally pretty reliable.

You should see zebra stripes as in the screenshot above. If you don't, try profiling on a different device: Samsung has been known to have issues displaying vsyncs while the Nexus series is generally pretty reliable.

You should see zebra stripes as in the screenshot above. If you don't, try profiling on a different device: Samsung has been known to have issues displaying vsyncs while the Nexus series is generally pretty reliable.


### 3. Find your process
Scroll until you see (part of) the name of your package. In this case, I was profilingcom.facebook.adsmanager, which shows up asbook.adsmanagerbecause of silly thread name limits in the kernel.

On the left side, you'll see a set of threads which correspond to the timeline rows on the right. There are a few threads we care about for our purposes: the UI thread (which has your package name or the name UI Thread),mqt_js, andmqt_native_modules. If you're running on Android 5+, we also care about the Render Thread.

- UI Thread.This is where standard android measure/layout/draw happens. The thread name on the right will be your package name (in my case book.adsmanager) or UI Thread. The events that you see on this thread should look something like this and have to do withChoreographer,traversals, andDispatchUI:
UI Thread.This is where standard android measure/layout/draw happens. The thread name on the right will be your package name (in my case book.adsmanager) or UI Thread. The events that you see on this thread should look something like this and have to do withChoreographer,traversals, andDispatchUI:

- JS Thread.This is where JavaScript is executed. The thread name will be eithermqt_jsor<...>depending on how cooperative the kernel on your device is being. To identify it if it doesn't have a name, look for things likeJSCall,Bridge.executeJSCall, etc:
JS Thread.This is where JavaScript is executed. The thread name will be eithermqt_jsor<...>depending on how cooperative the kernel on your device is being. To identify it if it doesn't have a name, look for things likeJSCall,Bridge.executeJSCall, etc:

- Native Modules Thread.This is where native module calls (e.g. theUIManager) are executed. The thread name will be eithermqt_native_modulesor<...>. To identify it in the latter case, look for things likeNativeCall,callJavaModuleMethod, andonBatchComplete:
Native Modules Thread.This is where native module calls (e.g. theUIManager) are executed. The thread name will be eithermqt_native_modulesor<...>. To identify it in the latter case, look for things likeNativeCall,callJavaModuleMethod, andonBatchComplete:

- Bonus: Render Thread.If you're using Android L (5.0) and up, you will also have a render thread in your application. This thread generates the actual OpenGL commands used to draw your UI. The thread name will be eitherRenderThreador<...>. To identify it in the latter case, look for things likeDrawFrameandqueueBuffer:
Bonus: Render Thread.If you're using Android L (5.0) and up, you will also have a render thread in your application. This thread generates the actual OpenGL commands used to draw your UI. The thread name will be eitherRenderThreador<...>. To identify it in the latter case, look for things likeDrawFrameandqueueBuffer:


## Identifying a culprit
A smooth animation should look something like the following:

Each change in color is a frame -- remember that in order to display a frame, all our UI work needs to be done by the end of that 16ms period. Notice that no thread is working close to the frame boundary. An application rendering like this is rendering at 60 FPS.

If you noticed chop, however, you might see something like this:

Notice that the JS thread is executing almost all the time, and across frame boundaries! This app is not rendering at 60 FPS. In this case,the problem lies in JS.

You might also see something like this:

In this case, the UI and render threads are the ones that have work crossing frame boundaries. The UI that we're trying to render on each frame is requiring too much work to be done. In this case,the problem lies in the native views being rendered.

At this point, you'll have some very helpful information to inform your next steps.


## Resolving JavaScript issues
If you identified a JS problem, look for clues in the specific JS that you're executing. In the scenario above, we seeRCTEventEmitterbeing called multiple times per frame. Here's a zoom-in of the JS thread from the trace above:

This doesn't seem right. Why is it being called so often? Are they actually different events? The answers to these questions will probably depend on your product code. And many times, you'll want to look intoshouldComponentUpdate.


## Resolving native UI Issues
If you identified a native UI problem, there are usually two scenarios:

- the UI you're trying to draw each frame involves too much work on the GPU, or
- You're constructing new UI during the animation/interaction (e.g. loading in new content during a scroll).

### Too much GPU work
In the first scenario, you'll see a trace that has the UI thread and/or Render Thread looking like this:

Notice the long amount of time spent inDrawFramethat crosses frame boundaries. This is time spent waiting for the GPU to drain its command buffer from the previous frame.

To mitigate this, you should:

- investigate usingrenderToHardwareTextureAndroidfor complex, static content that is being animated/transformed (e.g. theNavigatorslide/alpha animations)
- make sure that you arenotusingneedsOffscreenAlphaCompositing, which is disabled by default, as it greatly increases the per-frame load on the GPU in most cases.

### Creating new views on the UI thread
In the second scenario, you'll see something more like this:

Notice that first the JS thread thinks for a bit, then you see some work done on the native modules thread, followed by an expensive traversal on the UI thread.

There isn't a quick way to mitigate this unless you're able to postpone creating new UI until after the interaction, or you are able to simplify the UI you're creating. The react native team is working on an infrastructure level solution for this that will allow new UI to be created and configured off the main thread, allowing the interaction to continue smoothly.


### Finding native CPU hotspots
If the problem seems to be on the native side, you can use theCPU hotspot profilerto get more details on what's happening. Open the Android Studio Profiler panel and select "Find CPU Hotspots (Java/Kotlin Method Recording)".

Make sure you select "Find CPU Hotspots(Java/Kotlin Recording)" rather than "Find CPU Hotspots (Callstack Sample)". They have similar icons but do different things.

Perform the interactions and press "Stop recording". Recording is resource-intensive, so keep the interaction short. You can then either inspect the resulting trace in the Android Studio or export it and open it in an online tool likeFirefox Profiler.

Unlike System Trace, CPU hotspot profiling is slow so it won't give you accurate measurements. However, it should give you an idea of what native methods are being called, and where the time is being spent proportionally during each frame.


================================================================================


# 🗑️ ProgressBarAndroid
Source: https://reactnative.dev/docs/progressbarandroid

Use one of thecommunity packagesinstead.

Android-only React component used to indicate that the app is loading or there is some activity in the app.


### Example

## Props
InheritsView Props.


### animating
Whether to show the ProgressBar (true, the default) or hide it (false).


### color
Color of the progress bar.


### indeterminate
If the progress bar will show indeterminate progress. Note that this can only be false if styleAttr is Horizontal, and requires aprogressvalue.


### progress
The progress value (between 0 and 1).


### styleAttr
Style of the ProgressBar. One of:

- Horizontal
- Normal (default)
- Small
- Large
- Inverse
- SmallInverse
- LargeInverse

### testID
Used to locate this view in end-to-end tests.


================================================================================


# Props
Source: https://reactnative.dev/docs/props

Most components can be customized when they are created, with different parameters. These created parameters are calledprops, short for properties.

For example, one basic React Native component is theImage. When you create an image, you can use a prop namedsourceto control what image it shows.

Notice the braces surrounding{pic}- these embed the variablepicinto JSX. You can put any JavaScript expression inside braces in JSX.

Your own components can also useprops. This lets you make a single component that is used in many different places in your app, with slightly different properties in each place by referring topropsin yourrenderfunction. Here's an example:

- TypeScriptJavaScript
- JavaScript
Usingnameas a prop lets us customize theGreetingcomponent, so we can reuse that component for each of our greetings. This example also uses theGreetingcomponent in JSX, similar to theCore Components. The power to do this is what makes React so cool - if you find yourself wishing that you had a different set of UI primitives to work with, you can invent new ones.

The other new thing going on here is theViewcomponent. AViewis useful as a container for other components, to help control style and layout.

Withpropsand the basicText,Image, andViewcomponents, you can build a wide variety of static screens. To learn how to make your app change over time, you need tolearn about State.


================================================================================


# Publishing to Apple App Store
Source: https://reactnative.dev/docs/publishing-to-app-store

The publishing process is the same as any other native iOS app, with some additional considerations to take into account.

If you are using Expo, read the Expo guide forDeploying to App Storesto build and submit your app for the Apple App Store. This guide works with any React Native app to automate the deployment process.


### 1. Configure release scheme
Building an app for distribution in the App Store requires using theReleasescheme in Xcode. Apps built forReleasewill automatically disable the in-app Dev Menu, which will prevent your users from inadvertently accessing the menu in production. It will also bundle the JavaScript locally, so you can put the app on a device and test whilst not connected to the computer.

To configure your app to be built using theReleasescheme, go toProduct→Scheme→Edit Scheme. Select theRuntab in the sidebar, then set the Build Configuration dropdown toRelease.

The static bundle is built every time you target a physical device, even in Debug. If you want to save time, turn off bundle generation in Debug by adding the following to your shell script in the Xcode Build PhaseBundle React Native code and images:

```
 if [ "${CONFIGURATION}" == "Debug" ]; then  export SKIP_BUNDLING=true fi
```


### 2. Build app for release
You can now build your app for release by tappingCmd ⌘+Bor selectingProduct→Buildfrom the menu bar. Once built for release, you'll be able to distribute the app to beta testers and submit the app to the App Store.

You can also use theReact Native CLIto perform this operation using the option--modewith the valueRelease(e.g. from the root of your project:npm run ios -- --mode="Release"oryarn ios --mode Release).

Once you are done with the testing and ready to publish to App Store, follow along with this guide.

- Launch your terminal, and navigate into the iOS folder of your app and typeopen ..
- Double click on YOUR_APP_NAME.xcworkspace. It should launch Xcode.
- Click onProduct→Archive. Make sure to set the device to "Any iOS Device (arm64)".
Check your Bundle Identifier and make sure it is exactly same as the one you have created in the Identifiers in Apple Developer Dashboard.

- After the archive is completed, in the archive window, click onDistribute App.
- Click onApp Store Connectnow (if you want to publish in App Store).
- ClickUpload→ Make sure all the checkboxes are selected, hitNext.
- Choose betweenAutomatically manage signingandManually manage signingbased on your needs.
- Click onUpload.
- Now you can find it in the App Store Connect under TestFlight.
Now fill up the necessary information and in the Build Section, select the build of the app and click onSave→Submit For Review.


### 3. Screenshots
The Apple Store requires you have screenshots for the latest devices. The reference for such devices would be foundhere. Note that screenshots for some display sizes are not required if they are provided for other sizes.


================================================================================


# 🗑️ PushNotificationIOS
Source: https://reactnative.dev/docs/pushnotificationios

Use one of thecommunity packagesinstead.


### Projects with Native Code Only
The following section only applies to projects with native code exposed. If you are using the managed Expo workflow, see the guide onNotificationsin the Expo documentation for the appropriate alternative.

Handle notifications for your app, including scheduling and permissions.


## Getting Started
To enable push notifications,configure your notifications with Appleand your server-side system.

Then,enable remote notificationsin your project. This will automatically enable the required settings.


### Enable support forregisterevents
In yourAppDelegate.m, add:

```
#import <React/RCTPushNotificationManager.h>
```

Then implement the following in order to handle remote notification registration events:

```
- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{ // This will trigger 'register' events on PushNotificationIOS [RCTPushNotificationManager didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];}- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error{ // This will trigger 'registrationError' events on PushNotificationIOS [RCTPushNotificationManager didFailToRegisterForRemoteNotificationsWithError:error];}
```


### Handle notifications
You'll need to implementUNUserNotificationCenterDelegatein yourAppDelegate:

```
#import <UserNotifications/UserNotifications.h>@interface YourAppDelegate () <UNUserNotificationCenterDelegate>@end
```

Set the delegate on app launch:

```
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{  ...  UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];  center.delegate = self;  return YES;}
```

ImplementuserNotificationCenter:willPresentNotification:withCompletionHandler:to handle notifications that arrive when the app is in the foreground. Use the completionHandler to determine if the notification will be shown to the user and notifyRCTPushNotificationManageraccordingly:

```
// Called when a notification is delivered to a foreground app.- (void)userNotificationCenter:(UNUserNotificationCenter *)center       willPresentNotification:(UNNotification *)notification         withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler{  // This will trigger 'notification' and 'localNotification' events on PushNotificationIOS  [RCTPushNotificationManager didReceiveNotification:notification];  // Decide if and how the notification will be shown to the user  completionHandler(UNNotificationPresentationOptionNone);}
```

ImplementuserNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:to handle when a notification is tapped, typically called for background notifications which the user taps to open the app. However, if you had set foreground notifications to be shown inuserNotificationCenter:willPresentNotification:withCompletionHandler:, this method will also be invoked on foreground notifications when tapped. In this case, you should only notifyRCTPushNotificationManagerin one of these callbacks.

If the tapped notification resulted in app launch, callsetInitialNotification:. If the notification was not previously handled byuserNotificationCenter:willPresentNotification:withCompletionHandler:, calldidReceiveNotification:as well:

```
- (void)  userNotificationCenter:(UNUserNotificationCenter *)center  didReceiveNotificationResponse:(UNNotificationResponse *)response           withCompletionHandler:(void (^)(void))completionHandler{  // This condition passes if the notification was tapped to launch the app  if ([response.actionIdentifier isEqualToString:UNNotificationDefaultActionIdentifier]) {    // Allow the notification to be retrieved on the JS side using getInitialNotification()    [RCTPushNotificationManager setInitialNotification:response.notification];  }  // This will trigger 'notification' and 'localNotification' events on PushNotificationIOS  [RCTPushNotificationManager didReceiveNotification:response.notification];  completionHandler();}
```


## Methods

### presentLocalNotification()
```
static presentLocalNotification(details: PresentLocalNotificationDetails);
```

Schedules a local notification for immediate presentation.

Parameters:

detailsis an object containing:

- alertTitle: The text displayed as the title of the notification alert.
- alertBody: The message displayed in the notification alert.
- userInfo: An object containing additional notification data (optional).
- category: The category of this notification, required for actionable notifications (optional). e.g. notifications with additional actions such as Reply or Like.
- applicationIconBadgeNumberThe number to display as the app's icon badge. The default value of this property is 0, which means that no badge is displayed (optional).
- isSilent: If true, the notification will appear without sound (optional).
- soundName: The sound played when the notification is fired (optional).
- alertAction: DEPRECATED. This was used for iOS's legacy UILocalNotification.

### scheduleLocalNotification()
```
static scheduleLocalNotification(details: ScheduleLocalNotificationDetails);
```

Schedules a local notification for future presentation.

Parameters:

detailsis an object containing:

- alertTitle: The text displayed as the title of the notification alert.
- alertBody: The message displayed in the notification alert.
- fireDate: When the notification will be fired. Schedule notifications using eitherfireDateorfireIntervalSeconds, withfireDatetaking precedence.
- fireIntervalSeconds: Seconds from now to display the notification.
- userInfo: An object containing additional notification data (optional).
- category: The category of this notification, required for actionable notifications (optional). e.g. notifications with additional actions such as Reply or Like.
- applicationIconBadgeNumberThe number to display as the app's icon badge. The default value of this property is 0, which means that no badge is displayed (optional).
- isSilent: If true, the notification will appear without sound (optional).
- soundName: The sound played when the notification is fired (optional).
- alertAction: DEPRECATED. This was used for iOS's legacy UILocalNotification.
- repeatInterval: DEPRECATED. UsefireDateorfireIntervalSecondsinstead.

### cancelAllLocalNotifications()
```
static cancelAllLocalNotifications();
```

Cancels all scheduled local notifications.


### removeAllDeliveredNotifications()
```
static removeAllDeliveredNotifications();
```

Removes all delivered notifications from Notification Center.


### getDeliveredNotifications()
```
static getDeliveredNotifications(callback: (notifications: Object[]) => void);
```

Provides a list of the app’s notifications that are currently displayed in Notification Center.

Parameters:

A delivered notification is an object containing:

- identifier: The identifier of this notification.
- title: The title of this notification.
- body: The body of this notification.
- category: The category of this notification (optional).
- userInfo: An object containing additional notification data (optional).
- thread-id: The thread identifier of this notification, if it has one.

### removeDeliveredNotifications()
```
static removeDeliveredNotifications(identifiers: string[]);
```

Removes the specified notifications from Notification Center.

Parameters:


### setApplicationIconBadgeNumber()
```
static setApplicationIconBadgeNumber(num: number);
```

Sets the badge number for the app icon on the Home Screen.

Parameters:


### getApplicationIconBadgeNumber()
```
static getApplicationIconBadgeNumber(callback: (num: number) => void);
```

Gets the current badge number for the app icon on the Home Screen.

Parameters:


### cancelLocalNotifications()
```
static cancelLocalNotifications(userInfo: Object);
```

Cancels any scheduled local notifications which match the fields in the provideduserInfo.

Parameters:


### getScheduledLocalNotifications()
```
static getScheduledLocalNotifications(  callback: (notifications: ScheduleLocalNotificationDetails[]) => void,);
```

Gets the list of local notifications that are currently scheduled.

Parameters:


### addEventListener()
```
static addEventListener(  type: PushNotificationEventName,  handler:    | ((notification: PushNotification) => void)    | ((deviceToken: string) => void)    | ((error: {message: string; code: number; details: any}) => void),);
```

Attaches a listener to notification events including local notifications, remote notifications, and notification registration results.

Parameters:

Valid events types include:

- notification: Fired when a remote notification is received. The handler will be invoked with an instance ofPushNotificationIOS. This will handle notifications that arrive in the foreground or were tapped to open the app from the background.
- localNotification: Fired when a local notification is received. The handler will be invoked with an instance ofPushNotificationIOS. This will handle notifications that arrive in the foreground or were tapped to open the app from the background.
- register: Fired when the user registers successfully for remote notifications. The handler will be invoked with a hex string representing the deviceToken.
- registrationError: Fired when the user fails to register for remote notifications. Typically occurs due to APNS issues or if the device is a simulator. The handler will be invoked with{message: string, code: number, details: any}.

### removeEventListener()
```
static removeEventListener(  type: PushNotificationEventName,);
```

Removes the event listener. Do this incomponentWillUnmountto prevent memory leaks.

Parameters:


### requestPermissions()
```
static requestPermissions(permissions?: PushNotificationPermissions[]);
```

Requests notification permissions from iOS, prompting the user with a dialog box. By default, this will request all notification permissions, but you can optionally specify which permissions to request. The following permissions are supported:

- alert
- badge
- sound
If a map is provided to the method, only the permissions with truthy values will be requested.

This method returns a promise that will resolve when the user accepts or rejects the request, or if the permissions were previously rejected. The promise resolves to the state of the permissions after the request has been completed.

Parameters:


### abandonPermissions()
```
static abandonPermissions();
```

Unregister for all remote notifications received via Apple Push Notification service.

You should call this method in rare circumstances only, such as when a new version of the app removes support for all types of remote notifications. Users can temporarily prevent apps from receiving remote notifications through the Settings app. Apps unregistered through this method can always re-register.


### checkPermissions()
```
static checkPermissions(  callback: (permissions: PushNotificationPermissions) => void,);
```

Check which push permissions are currently enabled.

Parameters:

callbackwill be invoked with apermissionsobject:

- alert: boolean
- badge: boolean
- sound: boolean

### getInitialNotification()
```
static getInitialNotification(): Promise<PushNotification | null>;
```

This method returns a promise. If the app was launched by a push notification, this promise resolves to an object of typePushNotificationIOSfor the notification that was tapped. Otherwise, it resolves tonull.


### getAuthorizationStatus()
```
static getAuthorizationStatus(): Promise<number>;
```

This method returns a promise that resolves to the current notification authorization status. SeeUNAuthorizationStatusfor possible values.


### finish()
```
finish(result: string);
```

This method is available for remote notifications that have been received viaapplication:didReceiveRemoteNotification:fetchCompletionHandler:. However, this is superseded byUNUserNotificationCenterDelegateand will no longer be invoked if bothapplication:didReceiveRemoteNotification:fetchCompletionHandler:and the newer handlers fromUNUserNotificationCenterDelegateare implemented.

If for some reason you're still relying onapplication:didReceiveRemoteNotification:fetchCompletionHandler:, you'll need to set up event handling on the iOS side:

```
- (void)           application:(UIApplication *)application  didReceiveRemoteNotification:(NSDictionary *)userInfo        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))handler{  [RCTPushNotificationManager didReceiveRemoteNotification:userInfo fetchCompletionHandler:handler];}
```

Callfinish()to execute the native completion handlers once you're done handling the notification on the JS side. When calling this block, pass in the fetch result value that best describes the results of your operation. For a list of possible values, seePushNotificationIOS.FetchResult.

If you're usingapplication:didReceiveRemoteNotification:fetchCompletionHandler:, youmustcall this handler and should do so as soon as possible. See theofficial documentationfor more details.


### getMessage()
```
getMessage(): string | Object;
```

An alias forgetAlertto get the notification's main message string.


### getSound()
```
getSound(): string;
```

Gets the sound string from theapsobject. This will benullfor local notifications.


### getCategory()
```
getCategory(): string;
```

Gets the category string from theapsobject.


### getAlert()
```
getAlert(): string | Object;
```

Gets the notification's main message from theapsobject. Also see the alias:getMessage().


### getContentAvailable()
```
getContentAvailable(): number;
```

Gets the content-available number from theapsobject.


### getBadgeCount()
```
getBadgeCount(): number;
```

Gets the badge count number from theapsobject.


### getData()
```
getData(): Object;
```

Gets the data object on the notification.


### getThreadID()
```
getThreadID();
```

Gets the thread ID on the notification.


================================================================================


# React Native DevTools
Source: https://reactnative.dev/docs/react-native-devtools

React Native DevTools is our modern debugging experience for React Native. Purpose-built from the ground up, it aims to be fundamentally more integrated, correct, and reliable than previous debugging methods.

React Native DevTools is designed for debugging React app concerns, and not to replace native tools. If you want to inspect React Native’s underlying platform layers (for example, while developing a Native Module), please use the debugging tools available in Android Studio and Xcode (seeDebugging Native Code).

React Native DevTools supports all React Native apps running Hermes. It replaces the previous Flipper, Experimental Debugger, and Hermes debugger (Chrome) frontends.It is not possible to set up React Native DevTools with any older versions of React Native.Chrome Browser DevTools — unsupportedConnecting to React Native viachrome://inspectis no longer supported. Features may not work correctly, as the latest versions of Chrome DevTools (which are built to match the latest browser capabilities and APIs) have not been tested, and this frontend lacks our customisations. Instead, we ship a supported version with React Native DevTools.Visual Studio Code — unsupported(pre-existing)Third party extensions such asExpo ToolsandRadon IDEmay have improved compatibility, but are not directly supported by the React team.

It is not possible to set up React Native DevTools with any older versions of React Native.Chrome Browser DevTools — unsupportedConnecting to React Native viachrome://inspectis no longer supported. Features may not work correctly, as the latest versions of Chrome DevTools (which are built to match the latest browser capabilities and APIs) have not been tested, and this frontend lacks our customisations. Instead, we ship a supported version with React Native DevTools.Visual Studio Code — unsupported(pre-existing)Third party extensions such asExpo ToolsandRadon IDEmay have improved compatibility, but are not directly supported by the React team.

- Chrome Browser DevTools — unsupportedConnecting to React Native viachrome://inspectis no longer supported. Features may not work correctly, as the latest versions of Chrome DevTools (which are built to match the latest browser capabilities and APIs) have not been tested, and this frontend lacks our customisations. Instead, we ship a supported version with React Native DevTools.
- Connecting to React Native viachrome://inspectis no longer supported. Features may not work correctly, as the latest versions of Chrome DevTools (which are built to match the latest browser capabilities and APIs) have not been tested, and this frontend lacks our customisations. Instead, we ship a supported version with React Native DevTools.
- Visual Studio Code — unsupported(pre-existing)Third party extensions such asExpo ToolsandRadon IDEmay have improved compatibility, but are not directly supported by the React team.
- Third party extensions such asExpo ToolsandRadon IDEmay have improved compatibility, but are not directly supported by the React team.
We want the tooling you use to debug React across all platforms to be reliable, familiar, simple, and cohesive. All the features described on this page are built with these principles in mind, and we also want to offer more capabilities in future.We are actively iterating on the future of React Native DevTools, and have created a centralizedGitHub discussionto keep track of issues, frequently asked questions, and feedback.

We are actively iterating on the future of React Native DevTools, and have created a centralizedGitHub discussionto keep track of issues, frequently asked questions, and feedback.


## Core features
React Native DevTools is based on the Chrome DevTools frontend. If you have a web development background, its features should be familiar. As a starting point, we recommend browsing theChrome DevTools docswhich contain full guides as well as video resources.


### Console
The Console panel allows you to view and filter messages, evaluate JavaScript, inspect object properties, and more.

Console features reference | Chrome DevTools

- If your app has a lot of logs, use the filter box or change the log levels that are shown.
- Watch values over time withLive Expressions.
- Persist messages across reloads withPreserve Logs.
- UseCtrl+Lto clear the console view.

### Sources & breakpoints
The Sources panel allows you to view the source files in your app and register breakpoints. Use a breakpoint to define a line of code where your app should pause — allowing you to inspect the live state of the program and incrementally step through code.

Pause your code with breakpoints | Chrome DevTools

Breakpoints are a fundamental tool in your debugging toolkit!Navigate to a source file using the sidebar orCmd ⌘+P/Ctrl+P.Click in the line number column next to a line of code to add a breakpoint.Use the navigation controls at the top right tostep through codewhen paused.

- Navigate to a source file using the sidebar orCmd ⌘+P/Ctrl+P.
- Click in the line number column next to a line of code to add a breakpoint.
- Use the navigation controls at the top right tostep through codewhen paused.
- A "Paused in Debugger" overlay appears when your app is paused. Tap it to resume.
- Pay attention to the right-hand panels when on a breakpoint, which allow you to inspect the current scope and call stack, and set watch expressions.
- Use adebugger;statement to quickly set a breakpoint from your text editor. This will reach the device immediately via Fast Refresh.
- There are multiple kinds of breakpoints! For example,Conditional Breakpoints and Logpoints.

### NetworkSince 0.83
The Network panel allows you to view and inspect the network requests made by your app. Logged requests provide detailed metadata such as timings and headers sent/received, as well as response previews.

Network requests are recorded automatically when DevTools is open. We support most features from Chrome, with some exceptions. See more below.

Which network events are captured?Today, we record all network calls throughfetch(),XMLHttpRequest, and<Image>— with support for custom networking libraries, such as Expo Fetch, coming later.Expo Network differencesBecause of this, apps using Expo will continue to see the "Expo Network" panel — a separate implementation by the Expo framework which will log these additional request sources but has slightly reduced features.Coverage for Expo-specific network events.No request initiator support.No Performance panel integration.We're working with Expo to integrate Expo Fetch and third party networking libraries with our new Network inspection pipeline in future releases.Unimplemented featuresAt launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

Today, we record all network calls throughfetch(),XMLHttpRequest, and<Image>— with support for custom networking libraries, such as Expo Fetch, coming later.Expo Network differencesBecause of this, apps using Expo will continue to see the "Expo Network" panel — a separate implementation by the Expo framework which will log these additional request sources but has slightly reduced features.Coverage for Expo-specific network events.No request initiator support.No Performance panel integration.We're working with Expo to integrate Expo Fetch and third party networking libraries with our new Network inspection pipeline in future releases.Unimplemented featuresAt launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

Expo Network differencesBecause of this, apps using Expo will continue to see the "Expo Network" panel — a separate implementation by the Expo framework which will log these additional request sources but has slightly reduced features.Coverage for Expo-specific network events.No request initiator support.No Performance panel integration.We're working with Expo to integrate Expo Fetch and third party networking libraries with our new Network inspection pipeline in future releases.Unimplemented featuresAt launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

Because of this, apps using Expo will continue to see the "Expo Network" panel — a separate implementation by the Expo framework which will log these additional request sources but has slightly reduced features.Coverage for Expo-specific network events.No request initiator support.No Performance panel integration.We're working with Expo to integrate Expo Fetch and third party networking libraries with our new Network inspection pipeline in future releases.Unimplemented featuresAt launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

- Coverage for Expo-specific network events.
- No request initiator support.
- No Performance panel integration.
We're working with Expo to integrate Expo Fetch and third party networking libraries with our new Network inspection pipeline in future releases.Unimplemented featuresAt launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

Unimplemented featuresAt launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

At launch, these are the features we don't yet support in React Native:WebSocket eventsNetwork response mockingSimulated network throttling

- WebSocket events
- Network response mocking
- Simulated network throttling
If you are inspecting a large volume of response data, please note that response previews are cached in an on-device buffer with a maximum size of 100MB. This means we may evict response previews (but not metadata) if the cache becomes too large, oldest request first.

- Use the Initiator tab to see the call stack of where a network request was initiated in your app.
- Network events will also be shown in the Network track in the Performance panel.

### PerformanceSince 0.83
Performance tracing allows you to record a performance session within your app to understand how your JavaScript code is running and what operations took the most time. In React Native, we show JavaScript execution, React Performance tracks, Network events, and customUser Timings, rendered in a single performance timeline.

- UseAnnotationsto label and mark up a performance trace — useful beforedownloading and sharingwith a teammate.
- Use thePerformanceObserverAPIin your app to observe performance events at runtime — useful if you want to capture performance telemetry.
- React Performance tracks
- Performance APIs > User Timings | MDN
- "Debug Like a Senior — React Native Performance Panel" | Software Mansion

### Memory
The Memory panel allows you to take a heap snapshot and view the memory usage of your JavaScript code over time.

Record heap snapshots | Chrome DevTools

- UseCmd ⌘+F/Ctrl+Fto filter for specific objects in the heap.
- Taking anallocation timeline reportcan be useful to see memory usage over time as a graph, to identify possible memory leaks.

## React DevTools features
In the integrated Components and Profiler panels, you'll find all the features of theReact DevToolsbrowser extension. These work seamlessly in React Native DevTools.


### React Components
The React Components panel allows you to inspect and update the rendered React component tree.

- Hover or select an element in DevTools to highlight it on the device.
- To locate an element in DevTools, click the top-left "Select element" button, then tap any element in the app.
- Props and state on a component can be viewed and modified at runtime using the right hand panel.
- Components optimized withReact Compilerwill be annotated with a "Memo ✨" badge.
Re-renders can be a significant contributor to performance issues in React apps. DevTools can highlight component re-renders as they happen.To enable, click the View Settings (⚙︎) icon and check "Highlight updates when components render".

- To enable, click the View Settings (⚙︎) icon and check "Highlight updates when components render".

### React Profiler
The React Profiler panel allows you to record performance profiles to understand the timing of component renders and React commits.

For more info, see theoriginal 2018 guide(note that parts of this may be outdated).


## Reconnecting DevTools
Occasionally, DevTools might disconnect from the target device. This can happen if:

- The app is closed.
- The app is rebuilt (a new native build is installed).
- The app crashes on the native side.
- The dev server (Metro) is quit.
- A physical device is disconnected.
On disconnect, a dialog will be shown with the message "Debugging connection was closed".

From here, you can either:

- Dismiss: Select the close (×) icon or click outside the dialog to return to the DevTools UI in the last state before disconnection.
- Reconnect: Select "Reconnect DevTools", having addressed the reason for disconnection.

================================================================================


# React Native Gradle Plugin
Source: https://reactnative.dev/docs/react-native-gradle-plugin

This guide describes how to configure theReact Native Gradle Plugin(often referred as RNGP), when building your React Native application for Android.


## Using the plugin
The React Native Gradle Plugin is distributed as a separate NPM package which is installed automatically withreact-native.

The plugin isalready configuredfor new projects created usingnpx react-native init. You don't need to do any extra steps to install it if you created your app with this command.

If you're integrating React Native into an existing project, please refer tothe corresponding page: it contains specific instructions on how to install the plugin.


## Configuring the plugin
By default, the plugin will workout of the boxwith sensible defaults. You should refer to this guide and customize the behavior only if you need it.

To configure the plugin you can modify thereactblock, inside yourandroid/app/build.gradle:

```
apply plugin: "com.facebook.react"/** * This is the configuration block to customize your React Native Android app. * By default you don't need to apply any configuration, just uncomment the lines you need. */react {  // Custom configuration goes here.}
```

Each configuration key is described below:


### root
This is the root folder of your React Native project, i.e. where thepackage.jsonfile lives. Default is... You can customize it as follows:

```
root = file("../")
```


### reactNativeDir
This is the folder where thereact-nativepackage lives. Default is../node_modules/react-native.
If you're in a monorepo or using a different package manager, you can use adjustreactNativeDirto your setup.

You can customize it as follows:

```
reactNativeDir = file("../node_modules/react-native")
```


### codegenDir
This is the folder where thereact-native-codegenpackage lives. Default is../node_modules/react-native-codegen.
If you're in a monorepo or using a different package manager, you can adjustcodegenDirto your setup.

You can customize it as follows:

```
codegenDir = file("../node_modules/@react-native/codegen")
```


### cliFile
This is the entrypoint file for the React Native CLI. Default is../node_modules/react-native/cli.js.
The entrypoint file is needed as the plugin needs to invoke the CLI for bundling and creating your app.

If you're in a monorepo or using a different package manager, you can adjustcliFileto your setup.
You can customize it as follows:

```
cliFile = file("../node_modules/react-native/cli.js")
```


### debuggableVariants
This is the list of variants that are debuggable (seeusing variantsfor more context on variants).

By default the plugin is considering asdebuggableVariantsonlydebug, whilereleaseis not. If you have other
variants (likestaging,lite, etc.) you'll need to adjust this accordingly.

Variants that are listed asdebuggableVariantswill not come with a shipped bundle, so you'll need Metro to run them.

You can customize it as follows:

```
debuggableVariants = ["liteDebug", "prodDebug"]
```


### nodeExecutableAndArgs
This is the list of node command and arguments that should be invoked for all the scripts. By default is[node]but can be customized to add extra flags as follows:

```
nodeExecutableAndArgs = ["node"]
```


### bundleCommand
This is the name of thebundlecommand to be invoked when creating the bundle for your app. That's useful if you're usingRAM Bundles. By default isbundlebut can be customized to add extra flags as follows:

```
bundleCommand = "ram-bundle"
```


### bundleConfig
This is the path to a configuration file that will be passed tobundle --config <file>if provided. Default is empty (no config file will be probided). More information on bundling config files can be foundon the CLI documentation. Can be customized as follow:

```
bundleConfig = file(../rn-cli.config.js)
```


### bundleAssetName
This is the name of the bundle file that should be generated. Default isindex.android.bundle. Can be customized as follow:

```
bundleAssetName = "MyApplication.android.bundle"
```


### entryFile
The entry file used for bundle generation. The default is to search forindex.android.jsorindex.js. Can be customized as follow:

```
entryFile = file("../js/MyApplication.android.js")
```


### extraPackagerArgs
A list of extra flags that will be passed to thebundlecommand. The list of available flags is inthe CLI documentation. Default is empty. Can be customized as follows:

```
extraPackagerArgs = []
```


### hermesCommand
The path to thehermesccommand (the Hermes Compiler). React Native comes with a version of the Hermes compiler bundled with it, so you generally won't be needing to customize this. The plugin will use the correct compiler for your system by default.


### hermesFlags
The list of flags to pass tohermesc. By default is["-O", "-output-source-map"]. You can customize it as follows

```
hermesFlags = ["-O", "-output-source-map"]
```


### enableBundleCompression
Whether the Bundle Asset should be compressed when packaged into a.apk, or not.

Disabling compression for the.bundleallows it to be directly memory-mapped to RAM, hence improving startup time - at the cost of a larger resulting app size on disk. Please note that the.apkdownload size will be mostly unaffected as the.apkfiles are compressed before downloading

By default this is disabled, and you should not turn it on, unless you're really concerned about disk space for your application.


## Using Flavors & Build Variants
When building Android apps, you might want to usecustom flavorsto have different versions of your app starting from the same project.

Please refer to theofficial Android guideto configure custom build types (likestaging) or custom flavors (likefull,lite, etc.).
By default new apps are created with two build types (debugandrelease) and no custom flavors.

The combination of all the build types and all the flavors generates a set ofbuild variants. For instance fordebug/staging/releasebuild types andfull/liteyou will have 6 build variants:fullDebug,fullStaging,fullReleaseand so on.

If you're using custom variants beyonddebugandrelease, you need to instruct the React Native Gradle Plugin specifying which of your variants aredebuggableusing thedebuggableVariantsconfiguration as follows:

```
apply plugin: "com.facebook.react"react {+ debuggableVariants = ["fullStaging", "fullDebug"]}
```

This is necessary because the plugin will skip the JS bundling for all thedebuggableVariants: you'll need Metro to run them. For example, if you listfullStagingin thedebuggableVariants, you won't be able to publish it to a store as it will be missing the bundle.


## What is the plugin doing under the hood?
The React Native Gradle Plugin is responsible for configuring your Application build to ship React Native applications to production.
The plugin is also used inside 3rd party libraries, to run theCodegenused for the New Architecture.

Here is a summary of the plugin responsibilities:

- Add acreateBundle<Variant>JsAndAssetstask for every non debuggable variant, that is responsible of invoking thebundle,hermescandcompose-source-mapcommands.
- Setting up the proper version of thecom.facebook.react:react-androidandcom.facebook.react:hermes-androiddependency, reading the React Native version from thepackage.jsonofreact-native.
- Setting up the proper Maven repositories (Maven Central, Google Maven Repo, JSC local Maven repo, etc.) needed to consume all the necessary Maven Dependencies.
- Setting up the NDK to let you build apps that are using the New Architecture.
- Setting up thebuildConfigFieldsso that you can know at runtime if Hermes or the New Architecture are enabled.
- Setting up the Metro DevServer Port as an Android resource so the app knows on which port to connect.
- Invoking theReact Native Codegenif a library or app is using the Codegen for the New Architecture.

================================================================================


# React Node Object Type
Source: https://reactnative.dev/docs/react-node

A React Node is one of the following types:

- Boolean (which is ignored)
- nullorundefined(which is ignored)
- Number
- String
- A React element (result of JSX)
- An array of any of the above, possibly a nested one

================================================================================


# Rect Object Type
Source: https://reactnative.dev/docs/rect

Rectaccepts numeric pixel values to describe how far to extend a rectangular area. These values are added to the original area's size to expand it.


## Example
```
{    bottom: 20,    left: null,    right: undefined,    top: 50}
```


## Keys and values

### bottom

### left

### right

### top

## Used by
- Image
- Pressable
- Text
- TouchableWithoutFeedback

================================================================================


# RefreshControl
Source: https://reactnative.dev/docs/refreshcontrol

This component is used inside a ScrollView or ListView to add pull to refresh functionality. When the ScrollView is atscrollY: 0, swiping down triggers anonRefreshevent.


## Example
refreshingis a controlled prop, this is why it needs to be set totruein theonRefreshfunction otherwise the refresh indicator will stop immediately.


## Props

### View Props
InheritsView Props.


### Requiredrefreshing
Whether the view should be indicating an active refresh.


### colorsAndroid
The colors (at least one) that will be used to draw the refresh indicator.


### enabledAndroid
Whether the pull to refresh functionality is enabled.


### onRefresh
Called when the view starts refreshing.


### progressBackgroundColorAndroid
The background color of the refresh indicator.


### progressViewOffset
Progress view top offset.


### sizeAndroid
Size of the refresh indicator.


### tintColoriOS
The color of the refresh indicator.


### titleiOS
The title displayed under the refresh indicator.


### titleColoriOS
The color of the refresh indicator title.


================================================================================


# Releases Overview
Source: https://reactnative.dev/docs/releases

New React Native releases are shippedevery two months, usually resulting in six (6) new minors per year.

Below is the schedule and current status of recent and upcoming React Native releases:

The different support level presented in the table are defined as such:

- FutureAfter a new version branch gets cut, creating new Release Candidates to allow the community to test the upcoming version is very important. New RC releases are done at a high pace, as soon as viable.
- After a new version branch gets cut, creating new Release Candidates to allow the community to test the upcoming version is very important. New RC releases are done at a high pace, as soon as viable.
- ActiveStable releases in active support receive frequent updates. Latest stable has the highest priority, and at the start of its stable cycle (right after .0 is released) multiple patches will be done as soon as possible to stabilize the version and ensure a good upgrade experience to the community.
- Stable releases in active support receive frequent updates. Latest stable has the highest priority, and at the start of its stable cycle (right after .0 is released) multiple patches will be done as soon as possible to stabilize the version and ensure a good upgrade experience to the community.
- End of CycleA version in this support bracket will receive less patches, unless some important regressions need to be addressed. Once a next version becomes the new latest stable, before the version in EoC moves over into Unsupported one last patch released will be produced with the latest receive pick requests.
- A version in this support bracket will receive less patches, unless some important regressions need to be addressed. Once a next version becomes the new latest stable, before the version in EoC moves over into Unsupported one last patch released will be produced with the latest receive pick requests.
- UnsupportedWhen a version is in the unsupported stage, no new released are to be expected. Only very important regressions might create exceptions to this rule; it is recommended that codebases using an unsupported version upgrade as soon as possible.
- When a version is in the unsupported stage, no new released are to be expected. Only very important regressions might create exceptions to this rule; it is recommended that codebases using an unsupported version upgrade as soon as possible.

## Commitment to Stability
In order to support users upgrading React Native versions, we’re committed to maintain thelatest 3 minor series(e.g. 0.78.x, 0.77.x and 0.76.x when 0.78 is the latest release).

For those releases we’ll be publishing regular updates and bug fixes.

You can read more about our support policy onthe react-native-releases working group.

More information on our versioning, and what we consider a breaking change is available in ourversioning policypage.


================================================================================


# Release Levels
Source: https://reactnative.dev/docs/releases/release-levels

React Native provides the community with the ability to adopt individual new features as soon as their design and implementation are nearly complete, even before they are included in a stable release. This approach is known asrelease levels.

You can configure the release level of React Native so that your React Native instance will initialize with Feature Flags set to eitherEXPERIMENTAL,CANARY, orSTABLEmodes.

This approach is similar toCanary and Experimental releases in React, but with a key difference: regardless of the release level, the same version of React JS and React Native code is used.React Native is also not using@canaryor@experimentalNPM tags, as release levels are available for both stable and nightly releases of React Native.

Moreover, setting the release level toEXPERIMENTALorCANARYwillnotresult in consumingreact@nightlyorreact@canarydue to how react-native is consuming the React version (you can read more about it here).


## When to Use Each Release Level
- STABLE:Use for all production apps and libraries that do not need early access to unreleased features.This is the default level for stable and nightly releases.
- Use for all production apps and libraries that do not need early access to unreleased features.
- This is the default level for stable and nightly releases.
- CANARY:Use if you are a framework author, advanced app developer, or need to test or adopt new features before they are released in stable.Not recommended for production or user-facing applications.
- Use if you are a framework author, advanced app developer, or need to test or adopt new features before they are released in stable.
- Not recommended for production or user-facing applications.
- EXPERIMENTAL:Use only for testing and providing feedback for new features in the early stages of developmentNot recommended for production or user-facing applications.
- Use only for testing and providing feedback for new features in the early stages of development
- Not recommended for production or user-facing applications.

## How to initialize React Native using Canary & Experimental

### Android
TheDefaultNewArchitectureEntryPointclass now has areleaseLevelproperty (default:STABLE).The feature flag system uses this property to select the appropriate set of feature flags for the chosen release level.

```
DefaultNewArchitectureEntryPoint.releaseLevel = ReleaseLevel.CANARYDefaultNewArchitectureEntryPoint.load()
```

The build system generates different feature flag override classes for each release level, ensuring the correct features are enabled for each stage.


### iOS
TheRCTReactNativeFactoryclass now has an initializer that accepts areleaseLevelparameter. The feature flag setup uses this parameter to select the correct feature flag overrides.

```
[[RCTReactNativeFactory alloc] initWithDelegate:delegate releaseLevel:Canary];
```

The system ensures that only one release level is active per app instance, and will crash if multiple factories are created with different release levels.


================================================================================


# Versioning Policy
Source: https://reactnative.dev/docs/releases/versioning-policy

This page describes the versioning policy we follow for thereact-nativepackage.

We test each version of React Native thoroughly, both with manual and automated tests, to ensure the quality doesn't regress.

Thestablechannel of React Native follows the 0.x.y release policy described below.

React Native also offers anightlyrelease channel to encourage early feedback on experimental features.

This page describes our approach to version numbers forreact-nativeand for packages under the@react-nativescope.


## Stable Release Versions
React Native releases stable versions at a regular cadence.

We follow the 0.x.y versioning schema:

- Breaking changes will be shipped in a new minor version, i.e. we increment the x number (e.g.: 0.78.0 to 0.79.0).
- New features and APIs will also be shipped in a new minor version, i.e. we increment the x number (e.g.: 0.78.0 to 0.79.0).
- Critical bug fixes will be shipped in a new patch version, i.e. we increment the y number (e.g.: 0.78.1 to 0.78.2).
Stable releases are shipped regularly, with the latest tagged aslateston NPM.

A series of releases under the same minor number is called aminor series(e.g. 0.76.x is the minor series for 0.76.0, 0.76.1, 0.76.2, etc.).

You can read more about ourcommitment to stabilityinthe releases page.


### Breaking changes
Breaking changes are inconvenient for everyone, and we’re trying to minimize them to the bare minimum. All the breaking changes we ship in each stable release will be highlighted in:

- TheBreakingand theRemovedsection ofthe React Native Changelog
- Each release blogpost in theBreaking Changessection
For each breaking change we’re committed to explaining the reasoning behind it, provide a replacement API if possible, and minimize the impact on final users.


### What is a breaking change?
We consider a breaking change for React Native:

- An incompatible API change (i.e. an API that is changed or removed so that your code won’t compile/run anymore due to that change). Examples:Changes of any JS/Java/Kotlin/Obj-c/C++ APIs that would require your code to be changed in order to compile.Changes inside@react-native/codegenthat are not backward compatible.
- Changes of any JS/Java/Kotlin/Obj-c/C++ APIs that would require your code to be changed in order to compile.
- Changes inside@react-native/codegenthat are not backward compatible.
- A significant behavior/runtime change. Example:The layout logic of a prop is changed drastically.
- The layout logic of a prop is changed drastically.
- A significant change in the development experience. Example:A debugging feature is entirely removed.
- A debugging feature is entirely removed.
- A major bump of any of our transitive dependencies. Examples:Bumping React from 18.x to 19.xBumping the Target SDK on Android from 34 to 35).
- Bumping React from 18.x to 19.x
- Bumping the Target SDK on Android from 34 to 35).
- A reduction of any of our supported platform versions. Examples:Bumping min SDK on Android from 21 to 23Bumping the min iOS version to 15.1.
- Bumping min SDK on Android from 21 to 23
- Bumping the min iOS version to 15.1.
We don’t consider those changes to be breaking:

- Modifying APIs starting withunstable_prefix: These APIs expose experimental features, and we are not confident on their final shape. By releasing these with anunstable_prefix, we can iterate faster and get to a stable API sooner.
- Changes to private or internal APIs: These APIs are often prefixed with eitherinternal_,private_or living inside ainternal/orprivate/folder/package. While some of those APIs might have public visibility due to tooling constraints, we don’t consider them part of our public API, so we’ll be changing them without previous notice.Similarly, If you access internal property names like__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIREDor__reactInternalInstance$uk43rzhitjg, there are no guarantees. You are on your own.Classes annotated with@FrameworkAPIare also considered internal
- Similarly, If you access internal property names like__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIREDor__reactInternalInstance$uk43rzhitjg, there are no guarantees. You are on your own.
- Classes annotated with@FrameworkAPIare also considered internal
- Changes to tooling/development APIs: Some public APIs of React Native are reserved for integration with frameworks and other tools. For example, some of the Metro APIs or React Native DevTools APIs are supposed to be used only by other frameworks or tools. Changes to those APIs are discussed directly with the affected tools and are not considered breaking changes (we won’t be communicating them broadly in the release blogposts).
- Development warnings: Since warnings don’t affect runtime behavior, we may add new warnings or modify existing warnings in between any versions.
If we expect a change to cause broad problems in the community, we will still do our best to provide a gradual migration path for the ecosystem.


### Deprecation Cycles
As we keep on developing and evolving React Native, we write new APIs and sometimes we need to deprecate existing ones. Those APIs will go through a deprecation cycle.

Once an API is deprecated, it will remain availablealsofor thefollowingstable releases.

For example: if an API is deprecated in React Native 0.76.x, it will still be available in 0.77.x and won’t be removed sooner than React Native 0.78.x.

Sometimes we decide to keep a deprecated API for a longer time, if we feel that the ecosystem needs more time to migrate away from it. For those APIs we generally provide warnings to help users migrate away from them.


## Release channels
React Native relies on a thriving open source community to file bug reports, open pull requests, and submit RFCs. To encourage feedback we do support several release channels.

This section will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React Native primarily to build user-facing applications should not need to worry about release channels other than latest.


### latest
latestis for stable, semver React Native releases. It’s what you get when you install React Native from npm. This is the channel you’re already using today. User-facing applications that consume React Native directly use this channel.

We publish a newer minor series of React Native regularly, and we update thelatesttag to reflect the latest stable version.


### next
Before we declare a new React Native release stable, we publish a series ofrelease candidate, starting from RC0. Those versions are pre-release versions (following the versioning schema0.79.0-rc.0) and are tagged asnexton NPM.

When a new branch cut happens, and RCs start to get published on NPM and GitHub, it’s a good idea to test your library/framework against anextversion of React Native.

That will ensure that your project will keep on working well with the upcoming versions of React Native.

However, do not use prereleases/RCs in user-facing applications directly as they’re not considered production ready.


### nightly
We also publish anightlyrelease channel. Nightlies are published every day starting from themainbranch offacebook/react-native. Nightlies are considered unstable versions of React Native and are not recommended for production use.

Nightlies follow the versioning schema as0.80.0-nightly-<DATE>-<SHA>where<DATE>is the date of the nightly and<SHA>is the SHA of the commit that was used to publish this nightly.

The nightly releases are provided for testing purposes only, and we provide no guarantees that behavior won’t change between nightlies. They do not follow the semver protocol that we use for releases from latest/next.

It is a good idea to set up a CI workflow to test your library against a react-native@nightly version every day, to make sure your library will keep on working with future releases.


================================================================================


# RootTag
Source: https://reactnative.dev/docs/roottag

RootTagis an opaque identifier assigned to the native root view of your React Native surface — i.e. theReactRootVieworRCTRootViewinstance for Android or iOS respectively. In short, it is a surface identifier.


## When to use a RootTag?
For most React Native developers, you likely won’t need to deal withRootTags.

RootTags are useful for when an app rendersmultiple React Native root viewsand you need to handle native API calls differently depending on the surface. An example of this is when an app is using native navigation and each screen is a separate React Native root view.

In native navigation, every React Native root view is rendered in a platform’s navigation view (e.g.,Activityfor Android,UINavigationViewControllerfor iOS). By this, you are able to leverage the navigation paradigms of the platform such as native look and feel and navigation transitions. The functionality to interact with the native navigation APIs can be exposed to React Native via anative module.

For example, to update the title bar of a screen, you would call the navigation module’s APIsetTitle("Updated Title"), but it would need to know which screen in the stack to update. ARootTagis necessary here to identify the root view and its hosting container.

Another use case forRootTagis when your app needs to attribute a certain JavaScript call to native based on its originating root view. ARootTagis necessary to differentiate the source of the call from different surfaces.


## How to access the RootTag... if you need it
In versions 0.65 and below, RootTag is accessed via alegacy context. To prepare React Native for Concurrent features coming in React 18 and beyond, we are migrating to the latestContext APIviaRootTagContextin 0.66. Version 0.65 supports both the legacy context and the recommendedRootTagContextto allow developers time to migrate their call-sites. See the breaking changes summary.

How to accessRootTagvia theRootTagContext.

```
import {RootTagContext} from 'react-native';import NativeAnalytics from 'native-analytics';import NativeNavigation from 'native-navigation';function ScreenA() {  const rootTag = useContext(RootTagContext);  const updateTitle = title => {    NativeNavigation.setTitle(rootTag, title);  };  const handleOneEvent = () => {    NativeAnalytics.logEvent(rootTag, 'one_event');  };  // ...}class ScreenB extends React.Component {  static contextType: typeof RootTagContext = RootTagContext;  updateTitle(title) {    NativeNavigation.setTitle(this.context, title);  }  handleOneEvent() {    NativeAnalytics.logEvent(this.context, 'one_event');  }  // ...}
```

Learn more about the Context API forclassesandhooksfrom the React docs.


### Breaking Change in 0.65
RootTagContextwas formerly namedunstable_RootTagContextand changed toRootTagContextin 0.65. Please update any usages ofunstable_RootTagContextin your codebase.


### Breaking Change in 0.66
The legacy context access toRootTagwill be removed and replaced byRootTagContext. Beginning in 0.65, we encourage developers to proactively migrateRootTagaccesses toRootTagContext.


## Future Plans
With the new React Native architecture progressing, there will be future iterations toRootTag, with the intention to keep theRootTagtype opaque and prevent thrash in React Native codebases. Please do not rely on the fact that RootTag currently aliases to a number! If your app relies on RootTags, keep an eye on our version change logs, which you can findhere.


================================================================================


# Running On Device
Source: https://reactnative.dev/docs/running-on-device

It's always a good idea to test your app on an actual device before releasing it to your users. This document will guide you through the necessary steps to run your React Native app on a device and to get it ready for production.

If you usedcreate-expo-appto set up your project, you can run your app on a device in Expo Go by scanning the QR code that is displayed when you runnpm start. Refer to the Expo guide forrunning your project on your devicefor more information.

- AndroidiOS
- iOS

## Running your app on Android devices
- macOSWindowsLinux
- WindowsLinux
- Linux

### 1. Enable Debugging over USB
Most Android devices can only install and run apps downloaded from Google Play, by default. You will need to enable USB Debugging on your device in order to install your app during development.To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going toSettings→About phone→Software informationand then tapping theBuild numberrow at the bottom seven times. You can then go back toSettings→Developer optionsto enable "USB debugging".2. Plug in your device via USBLet's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.noteIf you seeunauthorizedin the list you will need to runadb reverse tcp:8081 tcp:8081and press allow USB debugging on the device.3. Run your appFrom the root of your project; type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going toSettings→About phone→Software informationand then tapping theBuild numberrow at the bottom seven times. You can then go back toSettings→Developer optionsto enable "USB debugging".2. Plug in your device via USBLet's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.noteIf you seeunauthorizedin the list you will need to runadb reverse tcp:8081 tcp:8081and press allow USB debugging on the device.3. Run your appFrom the root of your project; type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 2. Plug in your device via USB
Let's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.noteIf you seeunauthorizedin the list you will need to runadb reverse tcp:8081 tcp:8081and press allow USB debugging on the device.3. Run your appFrom the root of your project; type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.noteIf you seeunauthorizedin the list you will need to runadb reverse tcp:8081 tcp:8081and press allow USB debugging on the device.3. Run your appFrom the root of your project; type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb devicesList of devices attachedemulator-5554 offline   # Google emulator14ed2fcc device         # Physical device
```

Seeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.noteIf you seeunauthorizedin the list you will need to runadb reverse tcp:8081 tcp:8081and press allow USB debugging on the device.3. Run your appFrom the root of your project; type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

If you seeunauthorizedin the list you will need to runadb reverse tcp:8081 tcp:8081and press allow USB debugging on the device.


### 3. Run your app
From the root of your project; type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

- npmYarn
- Yarn
```
npm run android
```

```
yarn android
```

If you get a "bridge configuration isn't available" error, seeUsing adb reverse.

You can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).


## Connecting to the development server
You can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### Method 1: Using adb reverse (recommended)
You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb -s <device name> reverse tcp:8081 tcp:8081
```

To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb devices
```

You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### Method 2: Connect via Wi-Fi
You can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

You can find the IP address inSystem Settings (or System Preferences)→Network.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

- Make sure your laptop and your phone are on thesameWi-Fi network.
- Open your React Native app on your device.
- You'll see ared screen with an error. This is OK. The following steps will fix that.
- Open the in-appDev Menu.
- Go toDev Settings→Debug server host & port for device.
- Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).
- Go back to theDev Menuand selectReload JS.
You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


## Building your app for production
You have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 1. Enable Debugging over USB
Most Android devices can only install and run apps downloaded from Google Play, by default. You will need to enable USB Debugging on your device in order to install your app during development.To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going toSettings→About phone→Software informationand then tapping theBuild numberrow at the bottom seven times. You can then go back toSettings→Developer optionsto enable "USB debugging".2. Plug in your device via USBLet's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, run the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidtipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going toSettings→About phone→Software informationand then tapping theBuild numberrow at the bottom seven times. You can then go back toSettings→Developer optionsto enable "USB debugging".2. Plug in your device via USBLet's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, run the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidtipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 2. Plug in your device via USB
Let's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, run the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidtipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, run the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidtipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb devicesList of devices attachedemulator-5554 offline   # Google emulator14ed2fcc device         # Physical device
```

Seeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, run the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidtipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 3. Run your app
From the root of your project, run the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidtipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

- npmYarn
- Yarn
```
npm run android
```

```
yarn android
```

You can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).


## Connecting to the development server
You can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### Method 1: Using adb reverse (recommended)
You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb -s <device name> reverse tcp:8081 tcp:8081
```

To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb devices
```

You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### Method 2: Connect via Wi-Fi
You can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Open the command prompt and typeipconfigto find your machine's IP address (more info).Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

- Make sure your laptop and your phone are on thesameWi-Fi network.
- Open your React Native app on your device.
- You'll see ared screen with an error. This is OK. The following steps will fix that.
- Open the in-appDev Menu.
- Go toDev Settings→Debug server host & port for device.
- Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).
- Go back to theDev Menuand selectReload JS.
You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


## Building your app for production
You have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 1. Enable Debugging over USB
Most Android devices can only install and run apps downloaded from Google Play, by default. You will need to enable USB Debugging on your device in order to install your app during development.To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going toSettings→About phone→Software informationand then tapping theBuild numberrow at the bottom seven times. You can then go back toSettings→Developer optionsto enable "USB debugging".2. Plug in your device via USBLet's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Next, check the manufacturer code by usinglsusb(on mac, you must firstinstall lsusb).lsusbshould output something like this:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 003: ID 22b8:2e76 Motorola PCSBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubThese lines represent the USB devices currently connected to your machine.You want the line that represents your phone. If you're in doubt, try unplugging your phone and running the command again:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubYou'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

To enable USB debugging on your device, you will first need to enable the "Developer options" menu by going toSettings→About phone→Software informationand then tapping theBuild numberrow at the bottom seven times. You can then go back toSettings→Developer optionsto enable "USB debugging".2. Plug in your device via USBLet's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Next, check the manufacturer code by usinglsusb(on mac, you must firstinstall lsusb).lsusbshould output something like this:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 003: ID 22b8:2e76 Motorola PCSBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubThese lines represent the USB devices currently connected to your machine.You want the line that represents your phone. If you're in doubt, try unplugging your phone and running the command again:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubYou'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 2. Plug in your device via USB
Let's now set up an Android device to run our React Native projects. Go ahead and plug in your device via USB to your development machine.Next, check the manufacturer code by usinglsusb(on mac, you must firstinstall lsusb).lsusbshould output something like this:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 003: ID 22b8:2e76 Motorola PCSBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubThese lines represent the USB devices currently connected to your machine.You want the line that represents your phone. If you're in doubt, try unplugging your phone and running the command again:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubYou'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Next, check the manufacturer code by usinglsusb(on mac, you must firstinstall lsusb).lsusbshould output something like this:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 003: ID 22b8:2e76 Motorola PCSBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubThese lines represent the USB devices currently connected to your machine.You want the line that represents your phone. If you're in doubt, try unplugging your phone and running the command again:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubYou'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ lsusbBus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 003: ID 22b8:2e76 Motorola PCSBus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

These lines represent the USB devices currently connected to your machine.You want the line that represents your phone. If you're in doubt, try unplugging your phone and running the command again:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubYou'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

You want the line that represents your phone. If you're in doubt, try unplugging your phone and running the command again:bash$ lsusbBus 002 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 001 Device 002: ID8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation3.0root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation2.0root hubYou'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ lsusbBus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching HubBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
```

You'll see that after removing the phone, the line which has the phone model ("Motorola PCS" in this case) disappeared from the list. This is the line that we care about.Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Bus 001 Device 003: ID 22b8:2e76 Motorola PCSFrom the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

From the above line, you want to grab the first four digits from the device ID:22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

22b8:2e76In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

In this case, it's22b8. That's the identifier for Motorola.You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

You'll need to input this into your udev rules in order to get up and running:shellecho'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"'|sudotee/etc/udev/rules.d/51-android-usb.rulesMake sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
echo 'SUBSYSTEM=="usb", ATTR{idVendor}=="22b8", MODE="0666", GROUP="plugdev"' | sudo tee /etc/udev/rules.d/51-android-usb.rules
```

Make sure that you replace22b8with the identifier you get in the above command.Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Now check that your device is properly connecting to ADB, the Android Debug Bridge, by runningadb devices.shell$ adb devicesList of devices attachedemulator-5554 offline# Google emulator14ed2fcc device# Physical deviceSeeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb devicesList of devices attachedemulator-5554 offline   # Google emulator14ed2fcc device         # Physical device
```

Seeingdevicein the right column means the device is connected. You must haveonly one device connectedat a time.3. Run your appFrom the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### 3. Run your app
From the root of your project, type the following in your command prompt to install and launch your app on the device:npmYarnshellnpmrun androidshellyarnandroidnoteIf you get a "bridge configuration isn't available" error, seeUsing adb reverse.tipYou can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).Connecting to the development serverYou can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

- npmYarn
- Yarn
```
npm run android
```

```
yarn android
```

If you get a "bridge configuration isn't available" error, seeUsing adb reverse.

You can also use theReact Native CLIto generate and run areleasebuild (e.g. from the root of your project:yarn android --mode release).


## Connecting to the development server
You can also iterate quickly on a device by connecting to the development server running on your development machine. There are several ways of accomplishing this, depending on whether you have access to a USB cable or a Wi-Fi network.Method 1: Using adb reverse (recommended)You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### Method 1: Using adb reverse (recommended)
You can use this method if your device is running Android 5.0 (Lollipop) or newer, it has USB debugging enabled, and it is connected via USB to your development machine.Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Run the following in a command prompt:shell$ adb-s<device name>reverse tcp:8081 tcp:8081To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb -s <device name> reverse tcp:8081 tcp:8081
```

To find the device name, run the following adb command:shell$ adb devicesYou can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

```
$ adb devices
```

You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Method 2: Connect via Wi-FiYou can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


### Method 2: Connect via Wi-Fi
You can also connect to the development server over Wi-Fi. You'll first need to install the app on your device using a USB cable, but once that has been done you can debug wirelessly by following these instructions. You'll need your development machine's current IP address before proceeding.Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

Open a terminal and type/sbin/ifconfigto find your machine's IP address.Make sure your laptop and your phone are on thesameWi-Fi network.Open your React Native app on your device.You'll see ared screen with an error. This is OK. The following steps will fix that.Open the in-appDev Menu.Go toDev Settings→Debug server host & port for device.Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).Go back to theDev Menuand selectReload JS.You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.

- Make sure your laptop and your phone are on thesameWi-Fi network.
- Open your React Native app on your device.
- You'll see ared screen with an error. This is OK. The following steps will fix that.
- Open the in-appDev Menu.
- Go toDev Settings→Debug server host & port for device.
- Type in your machine's IP address and the port of the local dev server (e.g.10.0.1.1:8081).
- Go back to theDev Menuand selectReload JS.
You can now enable Fast Refresh from theDev Menu. Your app will reload whenever your JavaScript code has changed.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


## Building your app for production
You have built a great app using React Native, and you are now itching to release it in the Play Store. The process is the same as any other native Android app, with some additional considerations to take into account. Follow the guide forgenerating a signed APKto learn more.


## Running your app on iOS devices
- macOSWindowsLinux
- WindowsLinux
- Linux

### 1. Plug in your device via USB
Connect your iOS device to your Mac using a USB to Lightning or USB-C cable. Navigate to theiosfolder in your project, then open the.xcodeprojfile, or if you are using CocoaPods open.xcworkspace, within it using Xcode.If this is your first time running an app on your iOS device, you may need to register your device for development. Open theProductmenu from Xcode's menubar, then go toDestination. Look for and select your device from the list. Xcode will then register your device for development.2. Configure code signingRegister for anApple Developer accountif you don't have one yet.Select your project in the Xcode Project Navigator, then select your main target (it should share the same name as your project). Look for the "General" tab. Go to "Signing" and make sure your Apple Developer account or team is selected under the Team dropdown. Do the same for the tests target (it ends with Tests, and is below your main target).Repeatthis step for theTeststarget in your project.3. Build and Run your appIf everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

If this is your first time running an app on your iOS device, you may need to register your device for development. Open theProductmenu from Xcode's menubar, then go toDestination. Look for and select your device from the list. Xcode will then register your device for development.2. Configure code signingRegister for anApple Developer accountif you don't have one yet.Select your project in the Xcode Project Navigator, then select your main target (it should share the same name as your project). Look for the "General" tab. Go to "Signing" and make sure your Apple Developer account or team is selected under the Team dropdown. Do the same for the tests target (it ends with Tests, and is below your main target).Repeatthis step for theTeststarget in your project.3. Build and Run your appIf everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.


### 2. Configure code signing
Register for anApple Developer accountif you don't have one yet.Select your project in the Xcode Project Navigator, then select your main target (it should share the same name as your project). Look for the "General" tab. Go to "Signing" and make sure your Apple Developer account or team is selected under the Team dropdown. Do the same for the tests target (it ends with Tests, and is below your main target).Repeatthis step for theTeststarget in your project.3. Build and Run your appIf everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Select your project in the Xcode Project Navigator, then select your main target (it should share the same name as your project). Look for the "General" tab. Go to "Signing" and make sure your Apple Developer account or team is selected under the Team dropdown. Do the same for the tests target (it ends with Tests, and is below your main target).Repeatthis step for theTeststarget in your project.3. Build and Run your appIf everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Repeatthis step for theTeststarget in your project.3. Build and Run your appIf everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

3. Build and Run your appIf everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.


### 3. Build and Run your app
If everything is set up correctly, your device will be listed as the build target in the Xcode toolbar, and it will also appear in the Devices pane (Shift ⇧+Cmd ⌘+2). You can now press theBuild and runbutton (Cmd ⌘+R) or selectRunfrom theProductmenu. Your app will launch on your device shortly.noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

noteIf you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.Connecting to the development serverYou can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

If you run into any issues, please take a look at Apple'sLaunching Your App on a Devicedocs.


## Connecting to the development server
You can also iterate quickly on a device using the development server. You only have to be on the same Wi-Fi network as your computer. Shake your device to open theDev Menu, then enable Fast Refresh. Your app will reload whenever your JavaScript code has changed.TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

TroubleshootingtipIf you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.


### Troubleshooting
If you have any issues, ensure that your Mac and device are on the same network and can reach each other. Many open wireless networks with captive portals are configured to prevent devices from reaching other devices on the network. You may use your device's Personal Hotspot feature in this case. You may also share your internet (Wi-Fi/Ethernet) connection from your Mac to your device via USB and connect to the bundler through this tunnel for very high transfer speeds.

When trying to connect to the development server you might get ared screen with an errorsaying:noteConnection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Connection tohttp://localhost:8081/debugger-proxy?role=clienttimed out. Are you running node proxy? If you are running on the device, check if you have the right IP address inRCTWebSocketExecutor.m.

To solve this issue check the following points.1. Wi-Fi network.Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Make sure your laptop and your phone are on thesameWi-Fi network.2. IP addressMake sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Make sure that the build script detected the IP address of your machine correctly (e.g.10.0.1.123).Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

Open theReport navigatortab, select the lastBuildand search forIP=followed by an IP address. The IP address which gets embedded in the app should match your machines IP address.Building your app for productionYou have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.


## Building your app for production
You have built a great app using React Native, and you are now itching to release it in the App Store. The process is the same as any other native iOS app, with some additional considerations to take into account. Follow the guide forpublishing to the Apple App Storeto learn more.

A Mac is required in order to build your app for iOS devices. Alternatively, you can refer to ourenvironment setup guideto learn how to build your app using Expo CLI, which will allow you to run your app using the Expo client app.

A Mac is required in order to build your app for iOS devices. Alternatively, you can refer to ourenvironment setup guideto learn how to build your app using Expo CLI, which will allow you to run your app using the Expo client app.


================================================================================


# Running On Simulator
Source: https://reactnative.dev/docs/running-on-simulator-ios


## Starting the simulator
Once you have your React Native project initialized, you can run the following command inside the newly created project directory.

- npmYarn
- Yarn
```
npm run ios
```

```
yarn ios
```

If everything is set up correctly, you should see your new app running in the iOS Simulator shortly.


## Specifying a device
You can specify the device the simulator should run with the--simulatorflag, followed by the device name as a string. The default is"iPhone 14". If you wish to run your app on an iPhone SE (3rd generation), run the following command:

- npmYarn
- Yarn
```
npm run ios -- --simulator="iPhone SE (3rd generation)"
```

```
yarn ios --simulator "iPhone SE (3rd generation)"
```

The device names correspond to the list of devices available in Xcode. You can check your available devices by runningxcrun simctl list devicesfrom the console.


### Specifying a version of device
If you have multiple iOS versions installed, you also need to specify its appropriate version. E.g. To run your app on an iPhone 14 Pro (16.0) run the following command:

- npmYarn
- Yarn
```
npm run ios -- --simulator="iPhone 14 Pro (16.0)"
```

```
yarn ios --simulator "iPhone 14 Pro (16.0)"
```


## Specifying an UDID
You can specify the device UDID returned fromxcrun simctl list devicescommand. E.g. To run your app with UDIDAAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAArun the following command:

- npmYarn
- Yarn
```
npm run ios -- --udid="AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"
```

```
yarn ios --udid "AAAAAAAA-AAAA-AAAA-AAAA-AAAAAAAAAAAA"
```


================================================================================


# 🗑️ SafeAreaView
Source: https://reactnative.dev/docs/safeareaview

Usereact-native-safe-area-contextinstead.

The purpose ofSafeAreaViewis to render content within the safe area boundaries of a device. It is currently only applicable to iOS devices with iOS version 11 or later.

SafeAreaViewrenders nested content and automatically applies padding to reflect the portion of the view that is not covered by navigation bars, tab bars, toolbars, and other ancestor views. Moreover, and most importantly, Safe Area's paddings reflect the physical limitation of the screen, such as rounded corners or camera notches (i.e. the sensor housing area on iPhone 13).


## Example
To use, wrap your top level view with aSafeAreaViewwith aflex: 1style applied to it. You may also want to use a background color that matches your application's design.


## Props

### View Props
InheritsView Props.

As padding is used to implement the behavior of the component, padding rules in styles applied to aSafeAreaViewwill be ignored and can cause different results depending on the platform. See#22211for details.


================================================================================


# ScrollView
Source: https://reactnative.dev/docs/scrollview

Component that wraps platform ScrollView while providing integration with touch locking "responder" system.

Keep in mind that ScrollViews must have a bounded height in order to work, since they contain unbounded-height children into a bounded container (via a scroll interaction). In order to bound the height of a ScrollView, either set the height of the view directly (discouraged) or make sure all parent views have bounded height. Forgetting to transfer{flex: 1}down the view stack can lead to errors here, which the element inspector makes quick to debug.

Doesn't yet support other contained responders from blocking this scroll view from becoming the responder.

<ScrollView>vs<FlatList>- which one to use?

ScrollViewrenders all its react child components at once, but this has a performance downside.

Imagine you have a very long list of items you want to display, maybe several screens worth of content. Creating JS components and native views for everything all at once, much of which may not even be shown, will contribute to slow rendering and increased memory usage.

This is whereFlatListcomes into play.FlatListrenders items lazily, when they are about to appear, and removes items that scroll way off screen to save memory and processing time.

FlatListis also handy if you want to render separators between your items, multiple columns, infinite scroll loading, or any number of other features it supports out of the box.


## Example

## Props

### View Props
InheritsView Props.


### StickyHeaderComponent
A React Component that will be used to render sticky headers, should be used together withstickyHeaderIndices. You may need to set this component if your sticky header uses custom transforms, for example, when you want your list to have an animated and hidable header. If a component has not been provided, the defaultScrollViewStickyHeadercomponent will be used.


### alwaysBounceHorizontaliOS
When true, the scroll view bounces horizontally when it reaches the end even if the content is smaller than the scroll view itself.


### alwaysBounceVerticaliOS
When true, the scroll view bounces vertically when it reaches the end even if the content is smaller than the scroll view itself.


### automaticallyAdjustContentInsetsiOS
Controls whether iOS should automatically adjust the content inset for scroll views that are placed behind a navigation bar or tab bar/toolbar.


### automaticallyAdjustKeyboardInsetsiOS
Controls whether the ScrollView should automatically adjust itscontentInsetandscrollViewInsetswhen the Keyboard changes its size.


### automaticallyAdjustsScrollIndicatorInsetsiOS
Controls whether iOS should automatically adjust the scroll indicator insets. See Apple'sdocumentation on the property.


### bouncesiOS
When true, the scroll view bounces when it reaches the end of the content if the content is larger than the scroll view along the axis of the scroll direction. Whenfalse, it disables all bouncing even if thealwaysBounce*props aretrue.


### bouncesZoomiOS
Whentrue, gestures can drive zoom past min/max and the zoom will animate to the min/max value at gesture end, otherwise the zoom will not exceed the limits.


### canCancelContentTouchesiOS
Whenfalse, once tracking starts, won't try to drag if the touch moves.


### centerContentiOS
Whentrue, the scroll view automatically centers the content when the content is smaller than the scroll view bounds; when the content is larger than the scroll view, this property has no effect.


### contentContainerStyle
These styles will be applied to the scroll view content container which wraps all of the child views. Example:

```
return (  <ScrollView contentContainerStyle={styles.contentContainer}>  </ScrollView>);...const styles = StyleSheet.create({  contentContainer: {    paddingVertical: 20  }});
```


### contentInsetiOS
The amount by which the scroll view content is inset from the edges of the scroll view.


### contentInsetAdjustmentBehavioriOS
This property specifies how the safe area insets are used to modify the content area of the scroll view. Available on iOS 11 and later.


### contentOffset
Used to manually set the starting scroll offset.


### decelerationRate
A floating-point number that determines how quickly the scroll view decelerates after the user lifts their finger. You may also use string shortcuts"normal"and"fast"which match the underlying iOS settings forUIScrollViewDecelerationRateNormalandUIScrollViewDecelerationRateFastrespectively.

- 'normal'0.998 on iOS, 0.985 on Android.
- 'fast', 0.99 on iOS, 0.9 on Android.

### directionalLockEnablediOS
When true, the ScrollView will try to lock to only vertical or horizontal scrolling while dragging.


### disableIntervalMomentum
When true, the scroll view stops on the next index (in relation to scroll position at release) regardless of how fast the gesture is. This can be used for pagination when the page is less than the width of the horizontal ScrollView or the height of the vertical ScrollView.


### disableScrollViewPanResponder
When true, the default JS pan responder on the ScrollView is disabled, and full control over touches inside the ScrollView is left to its child components. This is particularly useful ifsnapToIntervalis enabled, since it does not follow typical touch patterns. Do not use this on regular ScrollView use cases withoutsnapToIntervalas it may cause unexpected touches to occur while scrolling.


### endFillColorAndroid
Sometimes a scrollview takes up more space than its content fills. When this is the case, this prop will fill the rest of the scrollview with a color to avoid setting a background and creating unnecessary overdraw. This is an advanced optimization that is not needed in the general case.


### fadingEdgeLengthAndroid
Fades out the edges of the scroll content.

If the value is greater than0, the fading edges will be set accordingly to the current scroll direction and position, indicating if there is more content to show.


### horizontal
Whentrue, the scroll view's children are arranged horizontally in a row instead of vertically in a column.


### indicatorStyleiOS
The style of the scroll indicators.

- 'default'same asblack.
- 'black', scroll indicator isblack. This style is good against a light background.
- 'white', scroll indicator iswhite. This style is good against a dark background.

### invertStickyHeaders
If sticky headers should stick at the bottom instead of the top of the ScrollView. This is usually used with inverted ScrollViews.


### keyboardDismissMode
Determines whether the keyboard gets dismissed in response to a drag.

- 'none', drags do not dismiss the keyboard.
- 'on-drag', the keyboard is dismissed when a drag begins.
iOS Only

- 'interactive', the keyboard is dismissed interactively with the drag and moves in synchrony with the touch, dragging upwards cancels the dismissal. On Android this is not supported and it will have the same behavior as'none'.

### keyboardShouldPersistTaps
Determines when the keyboard should stay visible after a tap.

- 'never'tapping outside of the focused text input when the keyboard is up dismisses the keyboard. When this happens, children won't receive the tap.
- 'always', the keyboard will not dismiss automatically, and the scroll view will not catch taps, but children of the scroll view can catch taps.
- 'handled', the keyboard will not dismiss automatically when the tap was handled by children of the scroll view (or captured by an ancestor).
- false,deprecated, use'never'instead
- true,deprecated, use'always'instead

### maintainVisibleContentPosition
When set, the scroll view will adjust the scroll position so that the first child that is currently visible and at or beyondminIndexForVisiblewill not change position. This is useful for lists that are loading content in both directions, e.g. a chat thread, where new messages coming in might otherwise cause the scroll position to jump. A value of 0 is common, but other values such as 1 can be used to skip loading spinners or other content that should not maintain position.

The optionalautoscrollToTopThresholdcan be used to make the content automatically scroll to the top after making the adjustment if the user was within the threshold of the top before the adjustment was made. This is also useful for chat-like applications where you want to see new messages scroll into place, but not if the user has scrolled up a ways and it would be disruptive to scroll a bunch.

Caveat 1: Reordering elements in the scrollview with this enabled will probably cause jumpiness and jank. It can be fixed, but there are currently no plans to do so. For now, don't re-order the content of any ScrollViews or Lists that use this feature.

Caveat 2: This usescontentOffsetandframe.originin native code to compute visibility. Occlusion, transforms, and other complexity won't be taken into account as to whether content is "visible" or not.


### maximumZoomScaleiOS
The maximum allowed zoom scale.


### minimumZoomScaleiOS
The minimum allowed zoom scale.


### nestedScrollEnabledAndroid
Enables nested scrolling for Android API level 21+.


### onContentSizeChange
Called when scrollable content view of the ScrollView changes.

The handler function will receive two parameters: the content width and content height(contentWidth, contentHeight).

It's implemented using onLayout handler attached to the content container which this ScrollView renders.


### onMomentumScrollBegin
Called when the momentum scroll starts (scroll which occurs as the ScrollView starts gliding).


### onMomentumScrollEnd
Called when the momentum scroll ends (scroll which occurs as the ScrollView glides to a stop).


### onScroll
Fires at most once per frame during scrolling. The event has the following shape (all values with unspecified type are numbers):

```
{  nativeEvent: {    contentInset: {bottom, left, right, top},    contentOffset: {x, y},    contentSize: {height, width},    layoutMeasurement: {height, width},    velocity: {x, y},    responderIgnoreScroll: boolean,    zoomScale,    // iOS only    targetContentOffset: {x, y}  }}
```


### onScrollBeginDrag
Called when the user begins to drag the scroll view.


### onScrollEndDrag
Called when the user stops dragging the scroll view and it either stops or begins to glide.


### onScrollToTopiOS
Fires when the scroll view scrolls to top after the status bar has been tapped.


### overScrollModeAndroid
Used to override default value of overScroll mode.

Possible values:

- 'auto'- Allow a user to over-scroll this view only if the content is large enough to meaningfully scroll.
- 'always'- Always allow a user to over-scroll this view.
- 'never'- Never allow a user to over-scroll this view.

### pagingEnabled
When true, the scroll view stops on multiples of the scroll view's size when scrolling. This can be used for horizontal pagination.


### persistentScrollbarAndroid
Causes the scrollbars not to turn transparent when they are not in use.


### pinchGestureEnablediOS
When true, ScrollView allows use of pinch gestures to zoom in and out.


### refreshControl
A RefreshControl component, used to provide pull-to-refresh functionality for the ScrollView. Only works for vertical ScrollViews (horizontalprop must befalse).

SeeRefreshControl.


### removeClippedSubviews
Using this property may lead to bugs (missing content) in some circumstances - use at your own risk.

Whentrue, offscreen child views are removed from their native backing superview when offscreen. This may improve scroll performance for large lists. On Android the default value istrue.


### scrollEnabled
When false, the view cannot be scrolled via touch interaction.

Note that the view can always be scrolled by callingscrollTo.


### scrollEventThrottle
Limits how often scroll events will be fired while scrolling, specified as a time interval in ms. This may be useful when expensive work is performed in response to scrolling. Values ≤16will disable throttling, regardless of the refresh rate of the device.


### scrollIndicatorInsetsiOS
The amount by which the scroll view indicators are inset from the edges of the scroll view. This should normally be set to the same value as thecontentInset.


### scrollPerfTagAndroid
Tag used to log scroll performance on this scroll view. Will force momentum events to be turned on (see sendMomentumEvents). This doesn't do anything out of the box and you need to implement a custom native FpsListener for it to be useful.


### scrollToOverflowEnablediOS
Whentrue, the scroll view can be programmatically scrolled beyond its content size.


### scrollsToTopiOS
Whentrue, the scroll view scrolls to top when the status bar is tapped.


### showsHorizontalScrollIndicator
Whentrue, shows a horizontal scroll indicator.


### showsVerticalScrollIndicator
Whentrue, shows a vertical scroll indicator.


### snapToAlignment
WhensnapToIntervalis set,snapToAlignmentwill define the relationship of the snapping to the scroll view.

Possible values:

- 'start'will align the snap at the left (horizontal) or top (vertical).
- 'center'will align the snap in the center.
- 'end'will align the snap at the right (horizontal) or bottom (vertical).

### snapToEnd
Use in conjunction withsnapToOffsets. By default, the end of the list counts as a snap offset. SetsnapToEndto false to disable this behavior and allow the list to scroll freely between its end and the lastsnapToOffsetsoffset.


### snapToInterval
When set, causes the scroll view to stop at multiples of the value ofsnapToInterval. This can be used for paginating through children that have lengths smaller than the scroll view. Typically used in combination withsnapToAlignmentanddecelerationRate="fast". Overrides less configurablepagingEnabledprop.


### snapToOffsets
When set, causes the scroll view to stop at the defined offsets. This can be used for paginating through variously sized children that have lengths smaller than the scroll view. Typically used in combination withdecelerationRate="fast". Overrides less configurablepagingEnabledandsnapToIntervalprops.


### snapToStart
Use in conjunction withsnapToOffsets. By default, the beginning of the list counts as a snap offset. SetsnapToStarttofalseto disable this behavior and allow the list to scroll freely between its start and the firstsnapToOffsetsoffset.


### stickyHeaderHiddenOnScroll
When set totrue, sticky header will be hidden when scrolling down the list, and it will dock at the top of the list when scrolling up.


### stickyHeaderIndices
An array of child indices determining which children get docked to the top of the screen when scrolling. For example, passingstickyHeaderIndices={[0]}will cause the first child to be fixed to the top of the scroll view. You can also use like [x,y,z] to make multiple items sticky when they are at the top. This property is not supported in conjunction withhorizontal={true}.


### zoomScaleiOS
The current scale of the scroll view content.


## Methods

### flashScrollIndicators()
```
flashScrollIndicators();
```

Displays the scroll indicators momentarily.


### scrollTo()
```
scrollTo(  options?: {x?: number, y?: number, animated?: boolean} | number,  deprecatedX?: number,  deprecatedAnimated?: boolean,);
```

Scrolls to a given x, y offset, either immediately, with a smooth animation.

Example:

scrollTo({x: 0, y: 0, animated: true})

The weird function signature is due to the fact that, for historical reasons, the function also accepts separate arguments as an alternative to the options object. This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.


### scrollToEnd()
```
scrollToEnd(options?: {animated?: boolean});
```

If this is a vertical ScrollView scrolls to the bottom. If this is a horizontal ScrollView scrolls to the right.

UsescrollToEnd({animated: true})for smooth animated scrolling,scrollToEnd({animated: false})for immediate scrolling. If no options are passed,animateddefaults totrue.


================================================================================


# SectionList
Source: https://reactnative.dev/docs/sectionlist

A performant interface for rendering sectioned lists, supporting the most handy features:

- Fully cross-platform.
- Configurable viewability callbacks.
- List header support.
- List footer support.
- Item separator support.
- Section header support.
- Section separator support.
- Heterogeneous data and item rendering support.
- Pull to Refresh.
- Scroll loading.
If you don't need section support and want a simpler interface, use<FlatList>.


## Example
This is a convenience wrapper around<VirtualizedList>, and thus inherits its props (as well as those of<ScrollView>) that aren't explicitly listed here, along with the following caveats:

- Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.
- This is aPureComponentwhich means that it will not re-render ifpropsremain shallow-equal. Make sure that everything yourrenderItemfunction depends on is passed as a prop (e.g.extraData) that is not===after updates, otherwise your UI may not update on changes. This includes thedataprop and parent component state.
- In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate and momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.
- By default, the list looks for akeyprop on each item and uses that for the React key. Alternatively, you can provide a customkeyExtractorprop.

## Props

### VirtualizedList Props
InheritsVirtualizedList Props.


### RequiredrenderItem
Default renderer for every item in every section. Can be over-ridden on a per-section basis. Should return a React element.

The render function will be passed an object with the following keys:

- 'item' (object) - the item object as specified in this section'sdatakey
- 'index' (number) - Item's index within the section.
- 'section' (object) - The full section object as specified insections.
- 'separators' (object) - An object with the following keys:'highlight' (function) -() => void'unhighlight' (function) -() => void'updateProps' (function) -(select, newProps) => void'select' (enum) - possible values are 'leading', 'trailing''newProps' (object)
- 'highlight' (function) -() => void
- 'unhighlight' (function) -() => void
- 'updateProps' (function) -(select, newProps) => void'select' (enum) - possible values are 'leading', 'trailing''newProps' (object)
- 'select' (enum) - possible values are 'leading', 'trailing'
- 'newProps' (object)

### Requiredsections
The actual data to render, akin to thedataprop inFlatList.


### extraData
A marker property for telling the list to re-render (since it implementsPureComponent). If any of yourrenderItem, Header, Footer, etc. functions depend on anything outside of thedataprop, stick it here and treat it immutably.


### initialNumToRender
How many items to render in the initial batch. This should be enough to fill the screen but not much more. Note these items will never be unmounted as part of the windowed rendering in order to improve perceived performance of scroll-to-top actions.


### inverted
Reverses the direction of scroll. Uses scale transforms of -1.


### ItemSeparatorComponent
Rendered in between each item, but not at the top or bottom. By default,highlighted,section, and[leading/trailing][Item/Section]props are provided.renderItemprovidesseparators.highlight/unhighlightwhich will update thehighlightedprop, but you can also add custom props withseparators.updateProps. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### keyExtractor
Used to extract a unique key for a given item at the specified index. Key is used for caching and as the React key to track item re-ordering. The default extractor checksitem.key, thenitem.id, and then falls back to using the index, like React does. Note that this sets keys for each item, but each overall section still needs its own key.


### ListEmptyComponent
Rendered when the list is empty. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListFooterComponent
Rendered at the very end of the list. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListHeaderComponent
Rendered at the very beginning of the list. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### onRefresh
If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality. Make sure to also set therefreshingprop correctly. To offset the RefreshControl from the top (e.g. by 100 pts), useprogressViewOffset={100}.


### onViewableItemsChanged
Called when the viewability of rows changes, as defined by theviewabilityConfigprop.


### refreshing
Set this true while waiting for new data from a refresh.


### removeClippedSubviews
Using this property may lead to bugs (missing content) in some circumstances - use at your own risk.

Whentrue, offscreen child views are removed from their native backing superview when offscreen. This may improve scroll performance for large lists. On Android the default value istrue.


### renderSectionFooter
Rendered at the bottom of each section.


### renderSectionHeader
Rendered at the top of each section. These stick to the top of theScrollViewby default on iOS. SeestickySectionHeadersEnabled.


### SectionSeparatorComponent
Rendered at the top and bottom of each section (note this is different fromItemSeparatorComponentwhich is only rendered between items). These are intended to separate sections from the headers above and below and typically have the same highlight response asItemSeparatorComponent. Also receiveshighlighted,[leading/trailing][Item/Section], and any custom props fromseparators.updateProps.


### stickySectionHeadersEnabled
Makes section headers stick to the top of the screen until the next one pushes it off. Only enabled by default on iOS because that is the platform standard there.


## Methods

### flashScrollIndicators()iOS
```
flashScrollIndicators();
```

Displays the scroll indicators momentarily.


### recordInteraction()
```
recordInteraction();
```

Tells the list an interaction has occurred, which should trigger viewability calculations, e.g. ifwaitForInteractionsis true and the user has not scrolled. This is typically called by taps on items or by navigation actions.


### scrollToLocation()
```
scrollToLocation(params: SectionListScrollParams);
```

Scrolls to the item at the specifiedsectionIndexanditemIndex(within the section) positioned in the viewable area such thatviewPositionset to0places it at the top (and may be covered by a sticky header),1at the bottom, and0.5centered in the middle.

You cannot scroll to locations outside the render window without specifying thegetItemLayoutoronScrollToIndexFailedprop.

Parameters:

Validparamskeys are:

- 'animated' (boolean) - Whether the list should do an animation while scrolling. Defaults totrue.
- 'itemIndex' (number) - Index within section for the item to scroll to. Required.
- 'sectionIndex' (number) - Index for section that contains the item to scroll to. Required.
- 'viewOffset' (number) - A fixed number of pixels to offset the final target position, e.g. to compensate for sticky headers.
- 'viewPosition' (number) - A value of0places the item specified by index at the top,1at the bottom, and0.5centered in the middle.

## Type Definitions

### Section
An object that identifies the data to be rendered for a given section.

Properties:


================================================================================


# Security
Source: https://reactnative.dev/docs/security

Security is often overlooked when building apps. It is true that it is impossible to build software that is completely impenetrable—we’ve yet to invent a completely impenetrable lock (bank vaults do, after all, still get broken into). However, the probability of falling victim to a malicious attack or being exposed for a security vulnerability is inversely proportional to the effort you’re willing to put in to protecting your application against any such eventuality. Although an ordinary padlock is pickable, it is still much harder to get past than a cabinet hook!

In this guide, you will learn about best practices for storing sensitive information, authentication, network security, and tools that will help you secure your app. This is not a preflight checklist—it is a catalogue of options, each of which will help further protect your app and users.


## Storing Sensitive Info
Never store sensitive API keys in your app code. Anything included in your code could be accessed in plain text by anyone inspecting the app bundle. Tools likereact-native-dotenvandreact-native-configare great for adding environment-specific variables like API endpoints, but they should not be confused with server-side environment variables, which can often contain secrets and API keys.

If you must have an API key or a secret to access some resource from your app, the most secure way to handle this would be to build an orchestration layer between your app and the resource. This could be a serverless function (e.g. using AWS Lambda or Google Cloud Functions) which can forward the request with the required API key or secret. Secrets in server side code cannot be accessed by the API consumers the same way secrets in your app code can.

For persisted user data, choose the right type of storage based on its sensitivity.As your app is used, you’ll often find the need to save data on the device, whether to support your app being used offline, cut down on network requests or save your user’s access token between sessions so they wouldn’t have to re-authenticate each time they use the app.

Persisted vs unpersisted— persisted data is written to the device’s disk, which lets the data be read by your app across application launches without having to do another network request to fetch it or asking the user to re-enter it. But this also can make that data more vulnerable to being accessed by attackers. Unpersisted data is never written to disk—so there's no data to access!


### Async Storage
Async Storageis a community-maintained module for React Native that provides an asynchronous, unencrypted, key-value store. Async Storage is not shared between apps: every app has its own sandbox environment and has no access to data from other apps.

- Web
Async Storage is the React Native equivalent of Local Storage from the web


### Secure Storage
React Native does not come bundled with any way of storing sensitive data. However, there are pre-existing solutions for Android and iOS platforms.

Keychain Servicesallows you to securely store small chunks of sensitive info for the user. This is an ideal place to store certificates, tokens, passwords, and any other sensitive information that doesn’t belong in Async Storage.

Shared Preferencesis the Android equivalent for a persistent key-value data store.Data in Shared Preferences is not encrypted by default, butEncrypted Shared Preferenceswraps the Shared Preferences class for Android, and automatically encrypts keys and values.

TheAndroid Keystoresystem lets you store cryptographic keys in a container to make it more difficult to extract from the device.

In order to use iOS Keychain services or Android Secure Shared Preferences, you can either write a bridge yourself or use a library which wraps them for you and provides a unified API at your own risk. Some libraries to consider:

- expo-secure-store
- react-native-keychain
Be mindful of unintentionally storing or exposing sensitive info.This could happen accidentally, for example saving sensitive form data in redux state and persisting the whole state tree in Async Storage. Or sending user tokens and personal info to an application monitoring service such as Sentry or Crashlytics.


## Authentication and Deep Linking
Mobile apps have a unique vulnerability that is non-existent in the web:deep linking. Deep linking is a way of sending data directly to a native application from an outside source. A deep link looks likeapp://whereappis your app scheme and anything following the // could be used internally to handle the request.

For example, if you were building an ecommerce app, you could useapp://products/1to deep link to your app and open the product detail page for a product with id 1. You can think of these kind of like URLs on the web, but with one crucial distinction:

Deep links are not secure and you should never send any sensitive information in them.

The reason deep links are not secure is because there is no centralized method of registering URL schemes. As an application developer, you can use almost any url scheme you choose byconfiguring it in Xcodefor iOS oradding an intent on Android.

There is nothing stopping a malicious application from hijacking your deep link by also registering to the same scheme and then obtaining access to the data your link contains. Sending something likeapp://products/1is not harmful, but sending tokens is a security concern.

When the operating system has two or more applications to choose from when opening a link, Android will show the user aDisambiguation dialogand ask them to choose which application to use to open the link. On iOS however, the operating system will make the choice for you, so the user will be blissfully unaware. Apple has made steps to address this issue in later iOS versions (iOS 11) where they instituted a first-come-first-served principle, although this vulnerability could still be exploited in different ways which you can read more abouthere. Usinguniversal linkswill allow linking to content within your app securely in iOS.


### OAuth2 and Redirects
The OAuth2 authentication protocol is incredibly popular nowadays, prided as the most complete and secure protocol around. The OpenID Connect protocol is also based on this. In OAuth2, the user is asked to authenticate via a third party. On successful completion, this third party redirects back to the requesting application with a verification code which can be exchanged for a JWT — aJSON Web Token. JWT is an open standard for securely transmitting information between parties on the web.

On the web, this redirect step is secure, because URLs on the web are guaranteed to be unique. This is not true for apps because, as mentioned earlier, there is no centralized method of registering URL schemes! In order to address this security concern, an additional check must be added in the form of PKCE.

PKCE, pronounced “Pixy” stands for Proof of Key Code Exchange, and is an extension to the OAuth 2 spec. This involves adding an additional layer of security which verifies that the authentication and token exchange requests come from the same client. PKCE uses theSHA 256Cryptographic Hash Algorithm. SHA 256 creates a unique “signature” for a text or file of any size, but it is:

- Always the same length regardless of the input file
- Guaranteed to always produce the same result for the same input
- One way (that is, you can’t reverse engineer it to reveal the original input)
Now you have two values:

- code_verifier- a large random string generated by the client
- code_challenge- the SHA 256 of the code_verifier
During the initial/authorizerequest, the client also sends thecode_challengefor thecode_verifierit keeps in memory. After the authorize request has returned correctly, the client also sends thecode_verifierthat was used to generate thecode_challenge. The IDP will then calculate thecode_challenge, see if it matches what was set on the very first/authorizerequest, and only send the access token if the values match.

This guarantees that only the application that triggered the initial authorization flow would be able to successfully exchange the verification code for a JWT. So even if a malicious application gets access to the verification code, it will be useless on its own. To see this in action, check outthis example.

A library to consider for native OAuth isreact-native-app-auth. React-native-app-auth is an SDK for communicating with OAuth2 providers. It wraps the nativeAppAuth-iOSandAppAuth-Androidlibraries and can support PKCE.

react-native-app-authcan support PKCE only if your Identity Provider supports it.


## Network Security
Your APIs should always useSSL encryption. SSL encryption protects against the requested data being read in plain text between when it leaves the server and before it reaches the client. You’ll know the endpoint is secure, because it starts withhttps://instead ofhttp://.


### SSL Pinning
Using https endpoints could still leave your data vulnerable to interception. With https, the client will only trust the server if it can provide a valid certificate that is signed by a trusted Certificate Authority that is pre-installed on the client. An attacker could take advantage of this by installing a malicious root CA certificate to the user’s device, so the client would trust all certificates that are signed by the attacker. Thus, relying on certificates alone could still leave you vulnerable to aman-in-the-middle attack.

SSL pinningis a technique that can be used on the client side to avoid this attack. It works by embedding (or pinning) a list of trusted certificates to the client during development, so that only the requests signed with one of the trusted certificates will be accepted, and any self-signed certificates will not be.

When using SSL pinning, you should be mindful of certificate expiry. Certificates expire every 1-2 years and when one does, it’ll need to be updated in the app as well as on the server. As soon as the certificate on the server has been updated, any apps with the old certificate embedded in them will cease to work.


## Summary
There is no bulletproof way to handle security, but with conscious effort and diligence, it is possible to significantly reduce the likelihood of a security breach in your application. Invest in security proportional to the sensitivity of the data stored in your application, the number of users, and the damage a hacker could do when gaining access to their account. And remember: it’s significantly harder to access information that was never requested in the first place.


================================================================================


# ❌ SegmentedControlIOS
Source: https://reactnative.dev/docs/segmentedcontrolios

Use one of thecommunity packagesinstead.


================================================================================


# Set Up Your Environment
Source: https://reactnative.dev/docs/set-up-your-environment

In this guide, you'll learn how to set up your environment, so that you can run your project with Android Studio and Xcode. This will allow you to develop with Android emulators and iOS simulators, build your app locally, and more.

This guide requires Android Studio or Xcode. If you already have one of these programs installed, you should be able to get up and running within a few minutes. If they are not installed, you should expect to spend about an hour installing and configuring them.Is setting up my environment required?Setting up your environment is not required if you're using aFramework. With a React Native Framework, you don't need to set up Android Studio or Xcode as it will take care of building the native app for youIf you have constraints that prevent you from using a Framework, or you'd like to write your own Framework, then setting up your local environment is a requirement. After your environment is set up, learn how toget started without a framework.

Setting up your environment is not required if you're using aFramework. With a React Native Framework, you don't need to set up Android Studio or Xcode as it will take care of building the native app for youIf you have constraints that prevent you from using a Framework, or you'd like to write your own Framework, then setting up your local environment is a requirement. After your environment is set up, learn how toget started without a framework.

If you have constraints that prevent you from using a Framework, or you'd like to write your own Framework, then setting up your local environment is a requirement. After your environment is set up, learn how toget started without a framework.

- macOSWindowsLinux
- WindowsLinux
- Linux
- AndroidiOS
- iOS

## Installing dependencies
You will need Node, Watchman, the React Native command line interface, a JDK, and Android Studio.

While you can use any editor of your choice to develop your app, you will need to install Android Studio in order to set up the necessary tooling to build your React Native app for Android.


### Node & Watchman
We recommend installing Node and Watchman usingHomebrew. Run the following commands in a Terminal after installing Homebrew:

```
brew install nodebrew install watchman
```

If you have already installed Node on your system, make sure it is Node 20.19.4 or newer.

Watchmanis a tool by Facebook for watching changes in the filesystem. It is highly recommended you install it for better performance.


### Java Development Kit
We recommend installing the OpenJDK distribution called AzulZuluusingHomebrew. Run the following commands in a Terminal after installing Homebrew:

```
brew install --cask zulu@17# Get path to where cask was installed to find the JDK installerbrew info --cask zulu@17# ==> zulu@17: <version number># https://www.azul.com/downloads/# Installed# /opt/homebrew/Caskroom/zulu@17/<version number> (185.8MB) (note that the path is /usr/local/Caskroom on non-Apple Silicon Macs)# Installed using the formulae.brew.sh API on 2024-06-06 at 10:00:00# Navigate to the folderopen /opt/homebrew/Caskroom/zulu@17/<version number> # or /usr/local/Caskroom/zulu@17/<version number>
```

After opening Finder, double click theDouble-Click to Install Azul Zulu JDK 17.pkgpackage to install the JDK.

After the JDK installation, add or update yourJAVA_HOMEenvironment variable in~/.zshrc(or in~/.bash_profile).

If you used above steps, JDK will likely be located at/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home:

```
export JAVA_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home
```

The Zulu OpenJDK distribution offers JDKs forboth Intel and M1 Macs. This will make sure your builds are faster on M1 Macs compared to using an Intel-based JDK.

If you have already installed JDK on your system, we recommend JDK 17. You may encounter problems using higher JDK versions.


### Android development environment
Setting up your development environment can be somewhat tedious if you're new to Android development. If you're already familiar with Android development, there are a few things you may need to configure. In either case, please make sure to carefully follow the next few steps.

Download and install Android Studio. While on Android Studio installation wizard, make sure the boxes next to all of the following items are checked:

- Android SDK
- Android SDK Platform
- Android Virtual Device
Then, click "Next" to install all of these components.

If the checkboxes are grayed out, you will have a chance to install these components later on.

Once setup has finalized and you're presented with the Welcome screen, proceed to the next step.

Android Studio installs the latest Android SDK by default. Building a React Native app with native code, however, requires theAndroid 15 (VanillaIceCream)SDK in particular. Additional Android SDKs can be installed through the SDK Manager in Android Studio.

To do that, open Android Studio, click on "More Actions" button and select "SDK Manager".

The SDK Manager can also be found within the Android Studio "Settings" dialog, underLanguages & Frameworks→Android SDK.

Select the "SDK Platforms" tab from within the SDK Manager, then check the box next to "Show Package Details" in the bottom right corner. Look for and expand theAndroid 15 (VanillaIceCream)entry, then make sure the following items are checked:

- Android SDK Platform 35
- Intel x86 Atom_64 System ImageorGoogle APIs Intel x86 Atom System Imageor (for Apple M1 Silicon)Google APIs ARM 64 v8a System Image
Next, select the "SDK Tools" tab and check the box next to "Show Package Details" here as well. Look for and expand the "Android SDK Build-Tools" entry, then make sure that36.0.0andAndroid SDK Command-line Tools (latest)are selected.

Finally, click "Apply" to download and install the Android SDK and related build tools.

The React Native tools require some environment variables to be set up in order to build apps with native code.

Add the following lines to your~/.zprofileor~/.zshrc(if you are usingbash, then~/.bash_profileor~/.bashrc) config file:

```
export ANDROID_HOME=$HOME/Library/Android/sdkexport PATH=$PATH:$ANDROID_HOME/emulatorexport PATH=$PATH:$ANDROID_HOME/platform-tools
```

Runsource ~/.zprofile(orsource ~/.bash_profileforbash) to load the config into your current shell. Verify that ANDROID_HOME has been set by runningecho $ANDROID_HOMEand the appropriate directories have been added to your path by runningecho $PATH.

Please make sure you use the correct Android SDK path. You can find the actual location of the SDK in the Android Studio "Settings" dialog, underLanguages & Frameworks→Android SDK.


## Preparing the Android device
You will need an Android device to run your React Native Android app. This can be either a physical Android device, or more commonly, you can use an Android Virtual Device which allows you to emulate an Android device on your computer.

Either way, you will need to prepare the device to run Android apps for development.


### Using a physical device
If you have a physical Android device, you can use it for development in place of an AVD by plugging it in to your computer using a USB cable and following the instructionshere.


### Using a virtual device
If you use Android Studio to open./AwesomeProject/android, you can see the list of available Android Virtual Devices (AVDs) by opening the "AVD Manager" from within Android Studio. Look for an icon that looks like this:

If you have recently installed Android Studio, you will likely need tocreate a new AVD. Select "Create Virtual Device...", then pick any Phone from the list and click "Next", then select theVanillaIceCreamAPI Level 35 image.

Click "Next" then "Finish" to create your AVD. At this point you should be able to click on the green triangle button next to your AVD to launch it.


### That's it!
Congratulations! You successfully set up your development environment.


## Now what?
- If you want to add this new React Native code to an existing application, check out theIntegration guide.
- If you're curious to learn more about React Native, check out theIntroduction to React Native.

## Installing dependencies
You will need Node, Watchman, the React Native command line interface, Xcode and CocoaPods.

While you can use any editor of your choice to develop your app, you will need to install Xcode in order to set up the necessary tooling to build your React Native app for iOS.


### Node & Watchman
We recommend installing Node and Watchman usingHomebrew. Run the following commands in a Terminal after installing Homebrew:

```
brew install nodebrew install watchman
```

If you have already installed Node on your system, make sure it is Node 20.19.4 or newer.

Watchmanis a tool by Facebook for watching changes in the filesystem. It is highly recommended you install it for better performance.


### Xcode
Please use thelatest versionof Xcode.

The easiest way to install Xcode is via theMac App Store. Installing Xcode will also install the iOS Simulator and all the necessary tools to build your iOS app.

You will also need to install the Xcode Command Line Tools. Open Xcode, then chooseSettings... (or Preferences...)from the Xcode menu. Go to the Locations panel and install the tools by selecting the most recent version in the Command Line Tools dropdown.

To install a simulator, openXcode > Settings... (or Preferences...)and select thePlatforms (or Components)tab. Select a simulator with the corresponding version of iOS you wish to use.

If you are using Xcode version 14.0 or greater to install a simulator, openXcode > Settings > Platformstab, then click "+" icon and selectiOS…option.

CocoaPodsis one of the dependency management system available for iOS. CocoaPods is a Rubygem. You can install CocoaPods using the version of Ruby that ships with the latest version of macOS.

For more information, please visitCocoaPods Getting Started guide.


### [Optional] Configuring your environment
Starting from React Native version 0.69, it is possible to configure the Xcode environment using the.xcode.envfile provided by the template.

The.xcode.envfile contains an environment variable to export the path to thenodeexecutable in theNODE_BINARYvariable.
This is thesuggested approachto decouple the build infrastructure from the system version ofnode. You should customize this variable with your own path or your ownnodeversion manager, if it differs from the default.

On top of this, it's possible to add any other environment variable and to source the.xcode.envfile in your build script phases. If you need to run script that requires some specific environment, this is thesuggested approach: it allows to decouple the build phases from a specific environment.

If you are already usingNVM(a command which helps you install and switch between versions of Node.js) andzsh, you might want to move the code that initialize NVM from your~/.zshrcinto a~/.zshenvfile to help Xcode find your Node executable:zshexport NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvmYou might also want to ensure that all "shell script build phase" of your Xcode project, is using/bin/zshas its shell.

```
export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
```

You might also want to ensure that all "shell script build phase" of your Xcode project, is using/bin/zshas its shell.


### That's it!
Congratulations! You successfully set up your development environment.


## Now what?
- If you want to add this new React Native code to an existing application, check out theIntegration guide.
- If you're curious to learn more about React Native, check out theIntroduction to React Native.
- AndroidiOS
- iOS

## Installing dependencies
You will need Node, the React Native command line interface, a JDK, and Android Studio.

While you can use any editor of your choice to develop your app, you will need to install Android Studio in order to set up the necessary tooling to build your React Native app for Android.


### Node, JDK
We recommend installing Node viaChocolatey, a popular package manager for Windows.

It is recommended to use an LTS version of Node. If you want to be able to switch between different versions, you might want to install Node vianvm-windows, a Node version manager for Windows.

React Native also requiresJava SE Development Kit (JDK), which can be installed using Chocolatey as well.

Open an Administrator Command Prompt (right click Command Prompt and select "Run as Administrator"), then run the following command:

```
choco install -y nodejs-lts microsoft-openjdk17
```

If you have already installed Node on your system, make sure it is Node 20.19.4 or newer. If you already have a JDK on your system, we recommend JDK17. You may encounter problems using higher JDK versions.

You can find additional installation options onNode's Downloads page.

If you're using the latest version of Java Development Kit, you'll need to change the Gradle version of your project so it can recognize the JDK. You can do that by going to{project root folder}\android\gradle\wrapper\gradle-wrapper.propertiesand changing thedistributionUrlvalue to upgrade the Gradle version. You can check outhere the latest releases of Gradle.


### Android development environment
Setting up your development environment can be somewhat tedious if you're new to Android development. If you're already familiar with Android development, there are a few things you may need to configure. In either case, please make sure to carefully follow the next few steps.

Download and install Android Studio. While on Android Studio installation wizard, make sure the boxes next to all of the following items are checked:

- Android SDK
- Android SDK Platform
- Android Virtual Device
- If you are not already using Hyper-V:Performance (Intel ® HAXM)(See here for AMD or Hyper-V)
Then, click "Next" to install all of these components.

If the checkboxes are grayed out, you will have a chance to install these components later on.

Once setup has finalized and you're presented with the Welcome screen, proceed to the next step.

Android Studio installs the latest Android SDK by default. Building a React Native app with native code, however, requires theAndroid 15 (VanillaIceCream)SDK in particular. Additional Android SDKs can be installed through the SDK Manager in Android Studio.

To do that, open Android Studio, click on "More Actions" button and select "SDK Manager".

The SDK Manager can also be found within the Android Studio "Settings" dialog, underLanguages & Frameworks→Android SDK.

Select the "SDK Platforms" tab from within the SDK Manager, then check the box next to "Show Package Details" in the bottom right corner. Look for and expand theAndroid 15 (VanillaIceCream)entry, then make sure the following items are checked:

- Android SDK Platform 35
- Intel x86 Atom_64 System ImageorGoogle APIs Intel x86 Atom System Image
Next, select the "SDK Tools" tab and check the box next to "Show Package Details" here as well. Look for and expand theAndroid SDK Build-Toolsentry, then make sure that36.0.0andAndroid SDK Command-line Tools (latest)are selected.

Finally, click "Apply" to download and install the Android SDK and related build tools.

The React Native tools require some environment variables to be set up in order to build apps with native code.

- Open theWindows Control Panel.
- Click onUser Accounts,then clickUser Accountsagain
- Click onChange my environment variables
- Click onNew...to create a newANDROID_HOMEuser variable that points to the path to your Android SDK:
The SDK is installed, by default, at the following location:

```
%LOCALAPPDATA%\Android\Sdk
```

You can find the actual location of the SDK in the Android Studio "Settings" dialog, underLanguages & Frameworks→Android SDK.

Open a new Command Prompt window to ensure the new environment variable is loaded before proceeding to the next step.

- Open powershell
- Copy and pasteGet-ChildItem -Path Env:\into powershell
- VerifyANDROID_HOMEhas been added
- Open theWindows Control Panel.
- Click onUser Accounts,then clickUser Accountsagain
- Click onChange my environment variables
- Select thePathvariable.
- ClickEdit.
- ClickNewand add the path to platform-tools to the list.
The default location for this folder is:

```
%LOCALAPPDATA%\Android\Sdk\platform-tools
```


## Preparing the Android device
You will need an Android device to run your React Native Android app. This can be either a physical Android device, or more commonly, you can use an Android Virtual Device which allows you to emulate an Android device on your computer.

Either way, you will need to prepare the device to run Android apps for development.


### Using a physical device
If you have a physical Android device, you can use it for development in place of an AVD by plugging it in to your computer using a USB cable and following the instructionshere.


### Using a virtual device
If you use Android Studio to open./AwesomeProject/android, you can see the list of available Android Virtual Devices (AVDs) by opening the "AVD Manager" from within Android Studio. Look for an icon that looks like this:

If you have recently installed Android Studio, you will likely need tocreate a new AVD. Select "Create Virtual Device...", then pick any Phone from the list and click "Next", then select theVanillaIceCreamAPI Level 35 image.

If you don't have HAXM installed, click on "Install HAXM" or followthese instructionsto set it up, then go back to the AVD Manager.

Click "Next" then "Finish" to create your AVD. At this point you should be able to click on the green triangle button next to your AVD to launch it.


### That's it!
Congratulations! You successfully set up your development environment.


## Now what?
- If you want to add this new React Native code to an existing application, check out theIntegration guide.
- If you're curious to learn more about React Native, check out theIntroduction to React Native.

## Unsupported
A Mac is required to build projects with native code for iOS. You can useExpo GofromExpoto develop your app on your iOS device.

- AndroidiOS
- iOS

## Installing dependencies
You will need Node, the React Native command line interface, a JDK, and Android Studio.

While you can use any editor of your choice to develop your app, you will need to install Android Studio in order to set up the necessary tooling to build your React Native app for Android.


### Node
Follow theinstallation instructions for your Linux distributionto install Node 20.19.4 or newer.


### Java Development Kit
React Native currently recommends version 17 of the Java SE Development Kit (JDK). You may encounter problems using higher JDK versions. You may download and installOpenJDKfromAdoptOpenJDKor your system packager.


### Android development environment
Setting up your development environment can be somewhat tedious if you're new to Android development. If you're already familiar with Android development, there are a few things you may need to configure. In either case, please make sure to carefully follow the next few steps.

Download and install Android Studio. While on Android Studio installation wizard, make sure the boxes next to all of the following items are checked:

- Android SDK
- Android SDK Platform
- Android Virtual Device
Then, click "Next" to install all of these components.

If the checkboxes are grayed out, you will have a chance to install these components later on.

Once setup has finalized and you're presented with the Welcome screen, proceed to the next step.

Android Studio installs the latest Android SDK by default. Building a React Native app with native code, however, requires theAndroid 15 (VanillaIceCream)SDK in particular. Additional Android SDKs can be installed through the SDK Manager in Android Studio.

To do that, open Android Studio, click on "Configure" button and select "SDK Manager".

The SDK Manager can also be found within the Android Studio "Settings" dialog, underLanguages & Frameworks→Android SDK.

Select the "SDK Platforms" tab from within the SDK Manager, then check the box next to "Show Package Details" in the bottom right corner. Look for and expand theAndroid 15 (VanillaIceCream)entry, then make sure the following items are checked:

- Android SDK Platform 35
- Intel x86 Atom_64 System ImageorGoogle APIs Intel x86 Atom System Image
Next, select the "SDK Tools" tab and check the box next to "Show Package Details" here as well. Look for and expand the "Android SDK Build-Tools" entry, then make sure that36.0.0andAndroid SDK Command-line Tools (latest)are selected.

Finally, click "Apply" to download and install the Android SDK and related build tools.

The React Native tools require some environment variables to be set up in order to build apps with native code.

Add the following lines to your$HOME/.bash_profileor$HOME/.bashrc(if you are usingzshthen~/.zprofileor~/.zshrc) config file:

```
export ANDROID_HOME=$HOME/Android/Sdkexport PATH=$PATH:$ANDROID_HOME/emulatorexport PATH=$PATH:$ANDROID_HOME/platform-tools
```

.bash_profileis specific tobash. If you're using another shell, you will need to edit the appropriate shell-specific config file.

Typesource $HOME/.bash_profileforbashorsource $HOME/.zprofileto load the config into your current shell. Verify that ANDROID_HOME has been set by runningecho $ANDROID_HOMEand the appropriate directories have been added to your path by runningecho $PATH.

Please make sure you use the correct Android SDK path. You can find the actual location of the SDK in the Android Studio "Settings" dialog, underLanguages & Frameworks→Android SDK.


### Watchman
Follow theWatchman installation guideto compile and install Watchman from source.

Watchmanis a tool by Facebook for watching changes in the filesystem. It is highly recommended you install it for better performance and increased compatibility in certain edge cases (translation: you may be able to get by without installing this, but your mileage may vary; installing this now may save you from a headache later).


## Preparing the Android device
You will need an Android device to run your React Native Android app. This can be either a physical Android device, or more commonly, you can use an Android Virtual Device which allows you to emulate an Android device on your computer.

Either way, you will need to prepare the device to run Android apps for development.


### Using a physical device
If you have a physical Android device, you can use it for development in place of an AVD by plugging it in to your computer using a USB cable and following the instructionshere.


### Using a virtual device
If you use Android Studio to open./AwesomeProject/android, you can see the list of available Android Virtual Devices (AVDs) by opening the "AVD Manager" from within Android Studio. Look for an icon that looks like this:

If you have recently installed Android Studio, you will likely need tocreate a new AVD. Select "Create Virtual Device...", then pick any Phone from the list and click "Next", then select theVanillaIceCreamAPI Level 35 image.

We recommend configuringVM accelerationon your system to improve performance. Once you've followed those instructions, go back to the AVD Manager.

Click "Next" then "Finish" to create your AVD. At this point you should be able to click on the green triangle button next to your AVD to launch it.


### That's it!
Congratulations! You successfully set up your development environment.


## Now what?
- If you want to add this new React Native code to an existing application, check out theIntegration guide.
- If you're curious to learn more about React Native, check out theIntroduction to React Native.

## Unsupported
A Mac is required to build projects with native code for iOS. You can useExpo GofromExpoto develop your app on your iOS device.


================================================================================


# Settings
Source: https://reactnative.dev/docs/settings

Settingsserves as a wrapper forNSUserDefaults, a persistent key-value store available only on iOS.


## Example

## Methods

### clearWatch()
```
static clearWatch(watchId: number);
```

watchIdis the number returned bywatchKeys()when the subscription was originally configured.


### get()
```
static get(key: string): any;
```

Get the current value for a givenkeyinNSUserDefaults.


### set()
```
static set(settings: Record<string, any>);
```

Set one or more values inNSUserDefaults.


### watchKeys()
```
static watchKeys(keys: string | array<string>, callback: () => void): number;
```

Subscribe to be notified when the value for any of the keys specified by thekeysparameter has been changed inNSUserDefaults. Returns awatchIdnumber that may be used withclearWatch()to unsubscribe.

watchKeys()by design ignores internalset()calls and fires callback only on changes preformed outside of React Native code.


================================================================================


# Shadow Props
Source: https://reactnative.dev/docs/shadow-props

- TypeScriptJavaScript
- JavaScript
There are 3 sets of shadow APIs in React Native:

- boxShadow: A View style prop and a spec-compliant implementation of theweb style prop of the same name.
- dropShadow: A specific filter function available as part of thefilterView style prop.
- Variousshadowprops (shadowColor,shadowOffset,shadowOpacity,shadowRadius): These map directly to their native counterparts exposed by the platform-level APIs.
The difference betweendropShadowandboxShadoware as follows:

- dropShadowexists as part offilter, whereasboxShadowis a standalone style prop.
- dropShadowis an alpha mask, so only pixels with a positive alpha value will "cast" a shadow.boxShadowwill cast around the border box of the element no matter it's contents (unless it is inset).
- dropShadowis only available on Android,boxShadowis available on iOS and Android.
- dropShadowcannot be inset likeboxShadow.
- dropShadowdoes not have thespreadDistanceargument likeboxShadow.
BothboxShadowanddropShadoware generally more capable than theshadowprops. Theshadowprops, however, map to native platform-level APIs, so if you only need a straightforward shadow these props are recommended. Note that onlyshadowColorworks on both Android and iOS, all othershadowprops only work on iOS.


## Props

### boxShadow
SeeView Style Propsfor documentation.


### dropShadowAndroid
SeeView Style Propsfor documentation.


### shadowColor
Sets the drop shadow color.

This property will only work on Android API 28 and above. For similar functionality on lower Android APIs, use theelevationproperty.


### shadowOffsetiOS
Sets the drop shadow offset.


### shadowOpacityiOS
Sets the drop shadow opacity (multiplied by the color's alpha component).


### shadowRadiusiOS
Sets the drop shadow blur radius.


================================================================================


# Share
Source: https://reactnative.dev/docs/share


## Example
- TypeScriptJavaScript
- JavaScript

## Methods

### share()
```
static share(content: ShareContent, options?: ShareOptions);
```

Open a dialog to share text content.

In iOS, returns a Promise which will be invoked with an object containingactionandactivityType. If the user dismissed the dialog, the Promise will still be resolved with action beingShare.dismissedActionand all the other keys being undefined. Note that some share options will not appear or work on the iOS simulator.

In Android, returns a Promise which will always be resolved with action beingShare.sharedAction.

Properties:


## Properties

### sharedAction
```
static sharedAction: 'sharedAction';
```

The content was successfully shared.


### dismissedActioniOS
```
static dismissedAction: 'dismissedAction';
```

The dialog has been dismissed.


================================================================================


# Publishing to Google Play Store
Source: https://reactnative.dev/docs/signed-apk-android

Android requires that all apps be digitally signed with a certificate before they can be installed. In order to distribute your Android application viaGoogle Play storeit needs to be signed with a release key that then needs to be used for all future updates. Since 2017 it is possible for Google Play to manage signing releases automatically thanks toApp Signing by Google Playfunctionality. However, before your application binary is uploaded to Google Play it needs to be signed with an upload key. TheSigning Your Applicationspage on Android Developers documentation describes the topic in detail. This guide covers the process in brief, as well as lists the steps required to package the JavaScript bundle.

If you are using Expo, read the Expo guide forDeploying to App Storesto build and submit your app for the Google Play Store. This guide works with any React Native app to automate the deployment process.


## Generating an upload key
You can generate a private signing key usingkeytool.


### Windows
On Windowskeytoolmust be run fromC:\Program Files\Java\jdkx.x.x_x\bin, as administrator.

```
keytool -genkeypair -v -storetype PKCS12 -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
```

This command prompts you for passwords for the keystore and key and for the Distinguished Name fields for your key. It then generates the keystore as a file calledmy-upload-key.keystore.

The keystore contains a single key, valid for 10000 days. The alias is a name that you will use later when signing your app, so remember to take note of the alias.


### macOS
On macOS, if you're not sure where your JDK bin folder is, then perform the following command to find it:

```
/usr/libexec/java_home
```

It will output the directory of the JDK, which will look something like this:

```
/Library/Java/JavaVirtualMachines/jdkX.X.X_XXX.jdk/Contents/Home
```

Navigate to that directory by using the commandcd /your/jdk/pathand use the keytool command with sudo permission as shown below.

```
sudo keytool -genkey -v -keystore my-upload-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
```

Remember to keep the keystore file private. In case you've lost upload key or it's been compromised you shouldfollow these instructions.


## Setting up Gradle variables
- Place themy-upload-key.keystorefile under theandroid/appdirectory in your project folder.
- Edit the file~/.gradle/gradle.propertiesorandroid/gradle.properties, and add the following (replace*****with the correct keystore password, alias and key password),
```
MYAPP_UPLOAD_STORE_FILE=my-upload-key.keystoreMYAPP_UPLOAD_KEY_ALIAS=my-key-aliasMYAPP_UPLOAD_STORE_PASSWORD=*****MYAPP_UPLOAD_KEY_PASSWORD=*****
```

These are going to be global Gradle variables, which we can later use in our Gradle config to sign our app.

Saving the above Gradle variables in~/.gradle/gradle.propertiesinstead ofandroid/gradle.propertiesprevents them from being checked in to git. You may have to create the~/.gradle/gradle.propertiesfile in your user's home directory before you can add the variables.

If you are not keen on storing your passwords in plaintext, and you are running macOS, you can alsostore your credentials in the Keychain Access app. Then you can skip the two last rows in~/.gradle/gradle.properties.


## Adding signing config to your app's Gradle config
The last configuration step that needs to be done is to setup release builds to be signed using upload key. Edit the fileandroid/app/build.gradlein your project folder, and add the signing config,

```
...android {    ...    defaultConfig { ... }    signingConfigs {        release {            if (project.hasProperty('MYAPP_UPLOAD_STORE_FILE')) {                storeFile file(MYAPP_UPLOAD_STORE_FILE)                storePassword MYAPP_UPLOAD_STORE_PASSWORD                keyAlias MYAPP_UPLOAD_KEY_ALIAS                keyPassword MYAPP_UPLOAD_KEY_PASSWORD            }        }    }    buildTypes {        release {            ...            signingConfig signingConfigs.release        }    }}...
```


## Generating the release AAB
Run the following command in a terminal:

```
npx react-native build-android --mode=release
```

This command uses Gradle'sbundleReleaseunder the hood that bundles all the JavaScript needed to run your app into the AAB (Android App Bundle). If you need to change the way the JavaScript bundle and/or drawable resources are bundled (e.g. if you changed the default file/folder names or the general structure of the project), have a look atandroid/app/build.gradleto see how you can update it to reflect these changes.

Make suregradle.propertiesdoes not includeorg.gradle.configureondemand=trueas that will make the release build skip bundling JS and assets into the app binary.

The generated AAB can be found underandroid/app/build/outputs/bundle/release/app-release.aab, and is ready to be uploaded to Google Play.

In order for Google Play to accept AAB format the App Signing by Google Play needs to be configured for your application on the Google Play Console. If you are updating an existing app that doesn't use App Signing by Google Play, please check ourmigration sectionto learn how to perform that configuration change.


## Testing the release build of your app
Before uploading the release build to the Play Store, make sure you test it thoroughly. First uninstall any previous version of the app you already have installed. Install it on the device using the following command in the project root:

- npmYarn
- Yarn
```
npm run android -- --mode="release"
```

```
yarn android --mode release
```

Note that--mode releaseis only available if you've set up signing as described above.

You can terminate any running bundler instances, since all your framework and JavaScript code is bundled in the APK's assets.


## Publishing to other stores
By default, the generated APK has the native code for bothx86,x86_64,ARMv7aandARM64-v8aCPU architectures. This makes it easier to share APKs that run on almost all Android devices. However, this has the downside that there will be some unused native code on any device, leading to unnecessarily bigger APKs.

You can create an APK for each CPU by adding the following line in yourandroid/app/build.gradlefile:

```
android {    splits {        abi {            reset()            enable true            universalApk false            include "armeabi-v7a", "arm64-v8a", "x86", "x86_64"        }    }}
```

Upload these files to markets which support device targeting, such asAmazon AppStoreorF-Droid, and the users will automatically get the appropriate APK. If you want to upload to other markets, such asAPKFiles, which do not support multiple APKs for a single app, change theuniversalApk falseline totrueto create the default universal APK with binaries for both CPUs.

Please note that you will also have to configure distinct version codes, assuggested in this pagefrom the official Android documentation.


## Enabling Proguard to reduce the size of the APK (optional)
Proguard is a tool that can slightly reduce the size of the APK. It does this by stripping parts of the React Native Java bytecode (and its dependencies) that your app is not using.

Make sure to thoroughly test your app if you've enabled Proguard. Proguard often requires configuration specific to each native library you're using. Seeapp/proguard-rules.pro.

To enable Proguard, editandroid/app/build.gradle:

```
/** * Run Proguard to shrink the Java bytecode in release builds. */def enableProguardInReleaseBuilds = true
```


## Migrating old Android React Native apps to use App Signing by Google Play
If you are migrating from previous version of React Native chances are your app does not use App Signing by Google Play feature. We recommend you enable that in order to take advantage from things like automatic app splitting. In order to migrate from the old way of signing you need to start bygenerating new upload keyand then replacing release signing config inandroid/app/build.gradleto use the upload key instead of the release one (see section aboutadding signing config to gradle). Once that's done you should follow theinstructions from Google Play Help websitein order to send your original release key to Google Play.


## Default Permissions
By default,INTERNETpermission is added to your Android app as pretty much all apps use it.SYSTEM_ALERT_WINDOWpermission is added to your Android APK in debug mode but it will be removed in production.


================================================================================


# State
Source: https://reactnative.dev/docs/state

There are two types of data that control a component:propsandstate.propsare set by the parent and they are fixed throughout the lifetime of a component. For data that is going to change, we have to usestate.

In general, you should initializestatein the constructor, and then callsetStatewhen you want to change it.

For example, let's say we want to make text that blinks all the time. The text itself gets set once when the blinking component gets created, so the text itself is aprop. The "whether the text is currently on or off" changes over time, so that should be kept instate.

- TypeScriptJavaScript
- JavaScript
In a real application, you probably won't be setting state with a timer. You might set state when you have new data from the server, or from user input. You can also use a state container likeReduxorMobXto control your data flow. In that case you would use Redux or MobX to modify your state rather than callingsetStatedirectly.

When setState is called, BlinkApp will re-render its Component. By calling setState within the Timer, the component will re-render every time the Timer ticks.

State works the same way as it does in React, so for more details on handling state, you can look at theReact.Component API. At this point, you may have noticed that most of our examples use the default text color. To customize the text color, you will have tolearn about Style.


================================================================================


# StatusBar
Source: https://reactnative.dev/docs/statusbar

Component to control the app's status bar. The status bar is the zone, typically at the top of the screen, that displays the current time, Wi-Fi and cellular network information, battery level and/or other status icons.


### Usage with Navigator
It is possible to have multipleStatusBarcomponents mounted at the same time. The props will be merged in the order theStatusBarcomponents were mounted.

- TypeScriptJavaScript
- JavaScript

### Imperative API
For cases where using a component is not ideal, there is also an imperative API exposed as static functions on the component. It is however not recommended to use the static API and the component for the same prop because any value set by the static API will get overridden by the one set by the component in the next render.


## Constants

### currentHeightAndroid
The height of the status bar, which includes the notch height, if present.


## Props

### animated
If the transition between status bar property changes should be animated. Supported forbackgroundColor,barStyleandhiddenproperties.


### backgroundColorAndroid
The background color of the status bar.

Due to edge-to-edge enforcement introduced in Android 15, setting background color of the status bar is deprecated in API level 35 and setting it will have no effect. You can read more about ouredge-to-edge recommendations here.


### barStyle
Sets the color of the status bar text.

On Android, this will only have an impact on API versions 23 and above.


### hidden
If the status bar is hidden.


### networkActivityIndicatorVisibleiOS
If the network activity indicator should be visible.


### showHideTransitioniOS
The transition effect when showing and hiding the status bar using thehiddenprop.


### translucentAndroid
If the status bar is translucent. When translucent is set totrue, the app will draw under the status bar. This is useful when using a semi transparent status bar color.

Due to edge-to-edge enforcement introduced in Android 15, setting the status bar as translucent is deprecated in API level 35 and setting it will have no effect. You can read more about ouredge-to-edge recommendations here.


## Methods

### popStackEntry()
```
static popStackEntry(entry: StatusBarProps);
```

Get and remove the last StatusBar entry from the stack.

Parameters:


### pushStackEntry()
```
static pushStackEntry(props: StatusBarProps): StatusBarProps;
```

Push a StatusBar entry onto the stack. The return value should be passed topopStackEntrywhen complete.

Parameters:


### replaceStackEntry()
```
static replaceStackEntry(  entry: StatusBarProps,  props: StatusBarProps): StatusBarProps;
```

Replace an existing StatusBar stack entry with new props.

Parameters:


### setBackgroundColor()Android
```
static setBackgroundColor(color: ColorValue, animated?: boolean);
```

Set the background color for the status bar.

Due to edge-to-edge enforcement introduced in Android 15, setting background color of the status bar is deprecated in API level 35 and setting it will have no effect. You can read more about ouredge-to-edge recommendations here.

Parameters:


### setBarStyle()
```
static setBarStyle(style: StatusBarStyle, animated?: boolean);
```

Set the status bar style.

Parameters:


### setHidden()
```
static setHidden(hidden: boolean, animation?: StatusBarAnimation);
```

Show or hide the status bar.

Parameters:


### 🗑️setNetworkActivityIndicatorVisible()iOS
The status bar network activity indicator is not supported in iOS 13 and later. This will be removed in a future release.

```
static setNetworkActivityIndicatorVisible(visible: boolean);
```

Control the visibility of the network activity indicator.

Parameters:


### setTranslucent()Android
```
static setTranslucent(translucent: boolean);
```

Control the translucency of the status bar.

Due to edge-to-edge enforcement introduced in Android 15, setting the status bar as translucent is deprecated in API level 35 and setting it will have no effect. You can read more about ouredge-to-edge recommendations here.

Parameters:


## Type Definitions

### StatusBarAnimation
Status bar animation type for transitions on the iOS.

Constants:


### StatusBarStyle
Status bar style type.

Constants:


================================================================================


# ❌ StatusBarIOS
Source: https://reactnative.dev/docs/statusbarios

UseStatusBarfor mutating the status bar.


================================================================================


# Strict TypeScript API (opt in)
Source: https://reactnative.dev/docs/strict-typescript-api

The Strict TypeScript API is a preview of our future, stable JavaScript API for React Native.

Specifically, this is a new set of TypeScript types for thereact-nativenpm package, available from 0.80 onwards. These provide stronger and more futureproof type accuracy, and will allow us to confidently evolve React Native's API into a stable shape. Opting in to the Strict TypeScript API brings some structural type differences, and is therefore a one-time breaking change.

The new types are:

- Generated directly from our source code— improving coverage and correctness, so you can expect stronger compatibility guarantees.
- Restricted toreact-native's index file— more tightly defining our public API, and meaning we won't break the API when making internal file changes.
When the community is ready, the Strict TypeScript API will become our default API in future — synchronized with deep imports removal.


## Opting in
We're shipping these new types alongside our existing types, meaning you can choose to migrate when ready. We encourage early adopters and newly created apps to opt in via yourtsconfig.jsonfile.

Opting in is abreaking change, since some of our new types have updated names and shapes, although many apps won't be affected. You can learn about each breaking change in the next section.

```
{  "extends": "@react-native/typescript-config",  "compilerOptions": {    ...    "customConditions": ["react-native-strict-api"]  }}
```

This will instruct TypeScript to resolvereact-nativetypes from our newtypes_generated/dir, instead of the previoustypes/dir (manually maintained). No restart of TypeScript or your editor is required.

The Strict TypeScript API follows ourRFCto remove deep imports from React Native. Therefore, some APIs are no longer exported at root. This is intentional, in order to reduce the overall surface area of React Native's API.

Sending feedback: We will be working with the community to finalize which APIs we export over (at least) the next two React Native releases. Please share your feedback in ourfeedback thread.See also ourannouncement blog postfor more info on our motivation and timelines.

See also ourannouncement blog postfor more info on our motivation and timelines.


## Migration guide

### Codegen types should now be imported from thereact-nativepackage
Types used for codegen, likeInt32,Double,WithDefaultetc. are now available under a singleCodegenTypesnamespace. Similarly,codegenNativeComponentandcodegenNativeCommandsare now available to import from the react-native package instead of using the deep import.

NamespacedCodegenTypesas well ascodegenNativeCommandsandcodegenNativeComponentare also available fromreact-nativepackage when the Strict API is not enabled to make the adoption easier for third-party libraries.

Before

```
import codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';import type {  Int32,  WithDefault,} from 'react-native/Libraries/Types/CodegenTypes';interface NativeProps extends ViewProps {  enabled?: WithDefault<boolean, true>;  size?: Int32;}export default codegenNativeComponent<NativeProps>(  'RNCustomComponent',);
```

After

```
import {CodegenTypes, codegenNativeComponent} from 'react-native';interface NativeProps extends ViewProps {  enabled?: CodegenTypes.WithDefault<boolean, true>;  size?: CodegenTypes.Int32;}export default codegenNativeComponent<NativeProps>(  'RNCustomComponent',);
```


### Removal of*Statictypes
Before

```
import {Linking, LinkingStatic} from 'react-native';function foo(linking: LinkingStatic) {}foo(Linking);
```

After

```
import {Linking} from 'react-native';function foo(linking: Linking) {}foo(Linking);
```

The following APIs were previously named as*Staticplus a variable declaration of said type. In most cases there was an alias so that value and the type were exported under the same identifier, but some were missing.

(For example there was anAlertStatictype,Alertvariable of typeAlertStaticand typeAlertwhich was an alias forAlertStatic. But in the case ofPixelRatiothere was aPixelRatioStatictype and aPixelRatiovariable of that type without additional type aliases.)

Affected APIs

- AlertStatic
- ActionSheetIOSStatic
- ToastAndroidStatic
- InteractionManagerStatic(In this case there was no relevantInteractionManagertype alias)
- UIManagerStatic
- PlatformStatic
- SectionListStatic
- PixelRatioStatic(In this case there was no relevantPixelRatiotype alias)
- AppStateStatic
- AccessibilityInfoStatic
- ImageResizeModeStatic
- BackHandlerStatic
- DevMenuStatic(In this case there was no relevantDevMenutype alias)
- ClipboardStatic
- PermissionsAndroidStatic
- ShareStatic
- DeviceEventEmitterStatic
- LayoutAnimationStatic
- KeyboardStatic(In this case there was no relevantKeyboardtype alias)
- DevSettingsStatic(In this case there was no relevantDevSettingstype alias)
- I18nManagerStatic
- EasingStatic
- PanResponderStatic
- NativeModulesStatic(In this case there was no relevantNativeModulestype alias)
- LogBoxStatic
- PushNotificationIOSStatic
- SettingsStatic
- VibrationStatic

### Some core components are now function components instead of class components
- View
- Image
- TextInput
- Modal
- Text
- TouchableWithoutFeedback
- Switch
- ActivityIndicator
- ProgressBarAndroid
- InputAccessoryView
- Button
- SafeAreaView
Due to this change, accessing ref types of these views requires usingReact.ComponentRef<typeof View>pattern which works as expected for both class and function components, e.g.:

```
const ref = useRef<React.ComponentRef<typeof View>>(null);
```


## Other breaking changes

### Changes to Animated types
Animated nodes were previously generic types based on their interpolation output. Now, they are non-generic types with a genericinterpolatemethod.

Animated.LegacyRefis no longer available.


### Unified types for optional props
In the new types, every optional prop will be typed astype | undefined.


### Removal of some deprecated types
All types listed inDeprecatedPropertiesAlias.d.tsare inaccessible under the Strict API.


### Removal of leftover component props
Some properties that were defined in type definitions but were not used by the component or were lacking a definition were removed (for example:lineBreakModeonText,scrollWithoutAnimationToonScrollView, transform styles defined outside of transform array).


### Previously accessible private type helpers may now be removed
Due to the configuration of the previous type definitions, every defined type was accessible from thereact-nativepackage. This included types that were not explicitly exported and helper types that were only supposed to be used internally.

Notable examples of this are types related to StyleSheet (likeRecursiveArray,RegisteredStyleandFalsy) and Animated (likeWithAnimatedArrayandWithAnimatedObject).


================================================================================


# Style
Source: https://reactnative.dev/docs/style

With React Native, you style your application using JavaScript. All of the core components accept a prop namedstyle. The style names andvaluesusually match how CSS works on the web, except names are written using camel casing, e.g.backgroundColorrather thanbackground-color.

Thestyleprop can be a plain old JavaScript object. That's what we usually use for example code. You can also pass an array of styles - the last style in the array has precedence, so you can use this to inherit styles.

As a component grows in complexity, it is often cleaner to useStyleSheet.createto define several styles in one place. Here's an example:

One common pattern is to make your component accept astyleprop which in turn is used to style subcomponents. You can use this to make styles "cascade" the way they do in CSS.

There are a lot more ways to customize the text style. Check out theText component referencefor a complete list.

Now you can make your text beautiful. The next step in becoming a style expert is tolearn how to control component size.


## Known issues
- react-native#29308: In some cases React Native does not match how CSS works on the web, for example the touch area never extends past the parent view bounds and on Android negative margin is not supported.

================================================================================


# StyleSheet
Source: https://reactnative.dev/docs/stylesheet

A StyleSheet is an abstraction similar to CSS StyleSheets.

Code quality tips:

- By moving styles away from the render function, you're making the code easier to understand.
- Naming the styles is a good way to add meaning to the low level components in the render function, and encourage reuse.
- In most IDEs, usingStyleSheet.create()will offer static type checking and suggestions to help you write valid styles.

## Methods

### compose()
```
static compose(style1: Object, style2: Object): Object | Object[];
```

Combines two styles such thatstyle2will override any styles instyle1. If either style is falsy, the other one is returned without allocating an array, saving allocations and maintaining reference equality for PureComponent checks.


### create()
```
static create(styles: Object extends Record<string, ViewStyle | ImageStyle | TextStyle>): Object;
```

An identity function for creating styles. The main practical benefit of creating styles insideStyleSheet.create()is static type checking against native style properties.


### flatten()
```
static flatten(style: Array<Object extends Record<string, ViewStyle | ImageStyle | TextStyle>>): Object;
```

Flattens an array of style objects, into one aggregated style object.


### setStyleAttributePreprocessor()
Breaking changes will probably happen a lot and will not be reliably announced. The whole thing might be deleted, who knows? Use at your own risk.

```
static setStyleAttributePreprocessor(  property: string,  process: (propValue: any) => any,);
```

Sets a function to use to pre-process a style property value. This is used internally to process color and transform values. You should not use this unless you really know what you are doing and have exhausted other options.


## Properties

### absoluteFill
A very common pattern is to create overlays with position absolute and zero positioning (position: 'absolute', left: 0, right: 0, top: 0, bottom: 0), soabsoluteFillcan be used for convenience and to reduce duplication of these repeated styles. If you want, absoluteFill can be used to create a customized entry in a StyleSheet, e.g.:


### absoluteFillObject
Sometimes you may wantabsoluteFillbut with a couple tweaks -absoluteFillObjectcan be used to create a customized entry in aStyleSheet, e.g.:


### hairlineWidth
This is defined as the width of a thin line on the platform. It can be used as the thickness of a border or division between two elements. Example:

This constant will always be a round number of pixels (so a line defined by it can look crisp) and will try to match the standard width of a thin line on the underlying platform. However, you should not rely on it being a constant size, because on different platforms and screen densities its value may be calculated differently.

A line with hairline width may not be visible if your simulator is downscaled.


================================================================================


# Switch
Source: https://reactnative.dev/docs/switch

Renders a boolean input.

This is a controlled component that requires anonValueChangecallback that updates thevalueprop in order for the component to reflect user actions. If thevalueprop is not updated, the component will continue to render the suppliedvalueprop instead of the expected result of any user actions.


## Example

## Props

### View Props
InheritsView Props.


### disabled
If true the user won't be able to toggle the switch.


### ios_backgroundColoriOS
On iOS, custom color for the background. This background color can be seen either when the switch value isfalseor when the switch is disabled (and the switch is translucent).


### onChange
Invoked when the user tries to change the value of the switch. Receives the change event as an argument. If you want to only receive the new value, useonValueChangeinstead.


### onValueChange
Invoked when the user tries to change the value of the switch. Receives the new value as an argument. If you want to instead receive an event, useonChange.


### ref
A ref setter that will be assigned anelement nodewhen mounted.


### thumbColor
Color of the foreground switch grip. If this is set on iOS, the switch grip will lose its drop shadow.


### trackColor
Custom colors for the switch track.

iOS: When the switch value isfalse, the track shrinks into the border. If you want to change the color of the background exposed by the shrunken track, useios_backgroundColor.


### value
The value of the switch. If true the switch will be turned on. Default value is false.


================================================================================


# Systrace
Source: https://reactnative.dev/docs/systrace

Systraceis a standard Android marker-based profiling tool (and is installed when you install the Android platform-tools package). Profiled code blocks are surrounded by start/end markers which are then visualized in a colorful chart format. Both the Android SDK and React Native framework provide standard markers that you can visualize.


## Example
Systraceallows you to mark JavaScript (JS) events with a tag and an integer value. Capture the non-Timed JS events in EasyProfiler.


## Methods

### isEnabled()
```
static isEnabled(): boolean;
```


### beginEvent()
```
static beginEvent(eventName: string | (() => string), args?: EventArgs);
```

beginEvent/endEvent for starting and then ending a profile within the same call stack frame.


### endEvent()
```
static endEvent(args?: EventArgs);
```


### beginAsyncEvent()
```
static beginAsyncEvent(  eventName: string | (() => string),  args?: EventArgs,): number;
```

beginAsyncEvent/endAsyncEvent for starting and then ending a profile where the end can either occur on another thread or out of the current stack frame, eg await the returned cookie variable should be used as input into the endAsyncEvent call to end the profile.


### endAsyncEvent()
```
static endAsyncEvent(  eventName: EventName,  cookie: number,  args?: EventArgs,);
```


### counterEvent()
```
static counterEvent(eventName: string | (() => string), value: number);
```

Register the value to the profileName on the systrace timeline.


================================================================================


# TargetEvent Object Type
Source: https://reactnative.dev/docs/targetevent

TargetEventobject is returned in the callback as a result of focus change, for exampleonFocusoronBlurin theTextInputcomponent.


## Example
```
{    target: 1127}
```


## Keys and values

### target
The node id of the element receiving the TargetEvent.


## Used by
- TextInput
- TouchableWithoutFeedback

================================================================================


# Testing
Source: https://reactnative.dev/docs/testing-overview

As your codebase expands, small errors and edge cases you don’t expect can cascade into larger failures. Bugs lead to bad user experience and ultimately, business losses. One way to prevent fragile programming is to test your code before releasing it into the wild.

In this guide, we will cover different, automated ways to ensure your app works as expected, ranging from static analysis to end-to-end tests.


## Why Test
We're humans, and humans make mistakes. Testing is important because it helps you uncover these mistakes and verifies that your code is working. Perhaps even more importantly, testing ensures that your code continues to work in the future as you add new features, refactor the existing ones, or upgrade major dependencies of your project.

There is more value in testing than you might realize. One of the best ways to fix a bug in your code is to write a failing test that exposes it. Then when you fix the bug and re-run the test, if it passes it means the bug is fixed, never reintroduced into the code base.

Tests can also serve as documentation for new people joining your team. For people who have never seen a codebase before, reading tests can help them understand how the existing code works.

Last but not least, more automated testing means less time spent with manualQA, freeing up valuable time.


## Static Analysis
The first step to improve your code quality is to start using static analysis tools. Static analysis checks your code for errors as you write it, but without running any of that code.

- Lintersanalyze code to catch common errors such as unused code and to help avoid pitfalls, to flag style guide no-nos like using tabs instead of spaces (or vice versa, depending on your configuration).
- Type checkingensures that the construct you’re passing to a function matches what the function was designed to accept, preventing passing a string to a counting function that expects a number, for instance.
React Native comes with two such tools configured out of the box:ESLintfor linting andTypeScriptfor type checking.


## Writing Testable Code
To start with tests, you first need to write code that is testable. Consider an aircraft manufacturing process - before any model first takes off to show that all of its complex systems work well together, individual parts are tested to guarantee they are safe and function correctly. For example, wings are tested by bending them under extreme load; engine parts are tested for their durability; the windshield is tested against simulated bird impact.

Software is similar. Instead of writing your entire program in one huge file with many lines of code, you write your code in multiple small modules that you can test more thoroughly than if you tested the assembled whole. In this way, writing testable code is intertwined with writing clean, modular code.

To make your app more testable, start by separating the view part of your app—your React components—from your business logic and app state (regardless of whether you use Redux, MobX or other solutions). This way, you can keep your business logic testing—which shouldn’t rely on your React components—independent of the components themselves, whose job is primarily rendering your app’s UI!

Theoretically, you could go so far as to move all logic and data fetching out of your components. This way your components would be solely dedicated to rendering. Your state would be entirely independent of your components. Your app’s logic would work without any React components at all!

We encourage you to further explore the topic of testable code in other learning resources.


## Writing Tests
After writing testable code, it’s time to write some actual tests! The default template of React Native ships withJesttesting framework. It includes a preset that's tailored to this environment so you can get productive without tweaking the configuration and mocks straight away—more on mocksshortly. You can use Jest to write all types of tests featured in this guide.

If you do test-driven development, you actually write tests first! That way, testability of your code is given.


### Structuring Tests
Your tests should be short and ideally test only one thing. Let's start with an example unit test written with Jest:

```
it('given a date in the past, colorForDueDate() returns red', () => {  expect(colorForDueDate('2000-10-20')).toBe('red');});
```

The test is described by the string passed to theitfunction. Take good care writing the description so that it’s clear what is being tested. Do your best to cover the following:

- Given- some precondition
- When- some action executed by the function that you’re testing
- Then- the expected outcome
This is also known as AAA (Arrange, Act, Assert).

Jest offersdescribefunction to help structure your tests. Usedescribeto group together all tests that belong to one functionality. Describes can be nested, if you need that. Other functions you'll commonly use arebeforeEachorbeforeAllthat you can use for setting up the objects you're testing. Read more in theJest api reference.

If your test has many steps or many expectations, you probably want to split it into multiple smaller ones. Also, ensure that your tests are completely independent of one another. Each test in your suite must be executable on its own without first running some other test. Conversely, if you run all your tests together, the first test must not influence the output of the second one.

Lastly, as developers we like when our code works great and doesn't crash. With tests, this is often the opposite. Think of a failed test as of agood thing!When a test fails, it often means something is not right. This gives you an opportunity to fix the problem before it impacts the users.


## Unit Tests
Unit tests cover the smallest parts of code, like individual functions or classes.

When the object being tested has any dependencies, you’ll often need to mock them out, as described in the next paragraph.

The great thing about unit tests is that they are quick to write and run. Therefore, as you work, you get fast feedback about whether your tests are passing. Jest even has an option to continuously run tests that are related to code you’re editing:Watch mode.


### Mocking
Sometimes, when your tested objects have external dependencies, you’ll want to “mock them out.” “Mocking” is when you replace some dependency of your code with your own implementation.

Generally, using real objects in your tests is better than using mocks but there are situations where this is not possible. For example: when your JS unit test relies on a native module written in Java or Objective-C.

Imagine you’re writing an app that shows the current weather in your city and you’re using some external service or other dependency that provides you with the weather information. If the service tells you that it’s raining, you want to show an image with a rainy cloud. You don’t want to call that service in your tests, because:

- It could make the tests slow and unstable (because of the network requests involved)
- The service may return different data every time you run the test
- Third party services can go offline when you really need to run tests!
Therefore, you can provide a mock implementation of the service, effectively replacing thousands of lines of code and some internet-connected thermometers!

Jest comes withsupport for mockingfrom function level all the way to module level mocking.


## Integration Tests
When writing larger software systems, individual pieces of it need to interact with each other. In unit testing, if your unit depends on another one, you’ll sometimes end up mocking the dependency, replacing it with a fake one.

In integration testing, real individual units are combined (same as in your app) and tested together to ensure that their cooperation works as expected. This is not to say that mocking does not happen here: you’ll still need mocks (for example, to mock communication with a weather service), but you'll need them much less than in unit testing.

Please note that the terminology around what integration testing means is not always consistent. Also, the line between what is a unit test and what is an integration test may not always be clear. For this guide, your test falls into "integration testing" if it:Combines several modules of your app as described aboveUses an external systemMakes a network call to other application (such as the weather service API)Does any kind of file or databaseI/O

- Combines several modules of your app as described above
- Uses an external system
- Makes a network call to other application (such as the weather service API)
- Does any kind of file or databaseI/O

## Component Tests
React components are responsible for rendering your app, and users will directly interact with their output. Even if your app's business logic has high testing coverage and is correct, without component tests you may still deliver a broken UI to your users. Component tests could fall into both unit and integration testing, but because they are such a core part of React Native, we'll cover them separately.

For testing React components, there are two things you may want to test:

- Interaction: to ensure the component behaves correctly when interacted with by a user (eg. when user presses a button)
- Rendering: to ensure the component render output used by React is correct (eg. the button's appearance and placement in the UI)
For example, if you have a button that has anonPresslistener, you want to test that the button both appears correctly and that tapping the button is correctly handled by the component.

There are several libraries that can help you testing these:

- React Native Testing Librarybuilds on top of React’s test renderer and addsfireEventandqueryAPIs described in the next paragraph.
- [Deprecated] React’sTest Renderer, developed alongside its core, provides a React renderer that can be used to render React components to pure JavaScript objects, without depending on the DOM or a native mobile environment.
Component tests are only JavaScript tests running in Node.js environment. They donottake into account any iOS, Android, or other platform code which is backing the React Native components. It follows that they cannot give you a 100% confidence that everything works for the user. If there is a bug in the iOS or Android code, they will not find it.


### Testing User Interactions
Aside from rendering some UI, your components handle events likeonChangeTextforTextInputoronPressforButton. They may also contain other functions and event callbacks. Consider the following example:

```
function GroceryShoppingList() {  const [groceryItem, setGroceryItem] = useState('');  const [items, setItems] = useState<string[]>([]);  const addNewItemToShoppingList = useCallback(() => {    setItems([groceryItem, ...items]);    setGroceryItem('');  }, [groceryItem, items]);  return (    <>      <TextInput        value={groceryItem}        placeholder="Enter grocery item"        onChangeText={text => setGroceryItem(text)}      />      <Button        title="Add the item to list"        onPress={addNewItemToShoppingList}      />      {items.map(item => (        <Text key={item}>{item}</Text>      ))}    </>  );}
```

When testing user interactions, test the component from the user perspective—what's on the page? What changes when interacted with?

As a rule of thumb, prefer using things users can see or hear:

- make assertions using rendered text oraccessibility helpers
Conversely, you should avoid:

- making assertions on component props or state
- testID queries
Avoid testing implementation details like props or state—while such tests work, they are not oriented toward how users will interact with the component and tend to break by refactoring (for example when you'd like to rename some things or rewrite class component using hooks).

React class components are especially prone to testing their implementation details such as internal state, props or event handlers. To avoid testing implementation details, prefer using function components with Hooks, which make relying on component internalsharder.

Component testing libraries such asReact Native Testing Libraryfacilitate writing user-centric tests by careful choice of provided APIs. The following example usesfireEventmethodschangeTextandpressthat simulate a user interacting with the component and a query functiongetAllByTextthat finds matchingTextnodes in the rendered output.

```
test('given empty GroceryShoppingList, user can add an item to it', () => {  const {getByPlaceholderText, getByText, getAllByText} = render(    <GroceryShoppingList />,  );  fireEvent.changeText(    getByPlaceholderText('Enter grocery item'),    'banana',  );  fireEvent.press(getByText('Add the item to list'));  const bananaElements = getAllByText('banana');  expect(bananaElements).toHaveLength(1); // expect 'banana' to be on the list});
```

This example is not testing how some state changes when you call a function. It tests what happens when a user changes text in theTextInputand presses theButton!


### Testing Rendered Output
Snapshot testingis an advanced kind of testing enabled by Jest. It is a very powerful and low-level tool, so extra attention is advised when using it.

A "component snapshot" is a JSX-like string created by a custom React serializer built into Jest. This serializer lets Jest translate React component trees to string that's human-readable. Put another way: a component snapshot is a textual representation of your component’s render outputgeneratedduring a test run. It may look like this:

```
<Text  style={    Object {      "fontSize": 20,      "textAlign": "center",    }  }>  Welcome to React Native!</Text>
```

With snapshot testing, you typically first implement your component and then run the snapshot test. The snapshot test then creates a snapshot and saves it to a file in your repo as a reference snapshot.The file is then committed and checked during code review. Any future changes to the component render output will change its snapshot, which will cause the test to fail. You then need to update the stored reference snapshot for the test to pass. That change again needs to be committed and reviewed.

Snapshots have several weak points:

- For you as a developer or reviewer, it can be hard to tell whether a change in snapshot is intended or whether it's evidence of a bug. Especially large snapshots can quickly become hard to understand and their added value becomes low.
- When snapshot is created, at that point it is considered to be correct-even in the case when the rendered output is actually wrong.
- When a snapshot fails, it's tempting to update it using the--updateSnapshotjest option without taking proper care to investigate whether the change is expected. Certain developer discipline is thus needed.
Snapshots themselves do not ensure that your component render logic is correct, they are merely good at guarding against unexpected changes and for checking that the components in the React tree under test receive the expected props (styles and etc.).

We recommend that you only use small snapshots (seeno-large-snapshotsrule). If you want to test achangebetween two React component states, usesnapshot-diff. When in doubt, prefer explicit expectations as described in the previous paragraph.


## End-to-End Tests
In end-to-end (E2E) tests, you verify your app is working as expected on a device (or a simulator / emulator) from the user perspective.

This is done by building your app in the release configuration and running the tests against it. In E2E tests, you no longer think about React components, React Native APIs, Redux stores or any business logic. That is not the purpose of E2E tests and those are not even accessible to you during E2E testing.

Instead, E2E testing libraries allow you to find and control elements in the screen of your app: for example, you canactuallytap buttons or insert text intoTextInputsthe same way a real user would. Then you can make assertions about whether or not a certain element exists in the app’s screen, whether or not it’s visible, what text it contains, and so on.

E2E tests give you the highest possible confidence that part of your app is working. The tradeoffs include:

- writing them is more time consuming compared to the other types of tests
- they are slower to run
- they are more prone to flakiness (a "flaky" test is a test which randomly passes and fails without any change to code)
Try to cover the vital parts of your app with E2E tests: authentication flow, core functionalities, payments, etc. Use faster JS tests for the non-vital parts of your app. The more tests you add, the higher your confidence, but also, the more time you'll spend maintaining and running them. Consider the tradeoffs and decide what's best for you.

There are several E2E testing tools available: in the React Native community,Detoxis a popular framework because it’s tailored for React Native apps. Another popular library in the space of iOS and Android apps isAppiumorMaestro.


## Summary
We hope you enjoyed reading and learned something from this guide. There are many ways you can test your apps. It may be hard to decide what to use at first. However, we believe it all will make sense once you start adding tests to your awesome React Native app. So what are you waiting for? Get your coverage up!


### Links
- React testing overview
- React Native Testing Library
- Jest docs
- Detox
- Appium
- Maestro
This guide originally authored and contributed in full byVojtech Novak.


================================================================================


# Text
Source: https://reactnative.dev/docs/text

A React component for displaying text.

Textsupports nesting, styling, and touch handling.

In the following example, the nested title and body text will inherit thefontFamilyfromstyles.baseText, but the title provides its own additional styles. The title and body will stack on top of each other on account of the literal newlines:


## Nested text
Both Android and iOS allow you to display formatted text by annotating ranges of a string with specific formatting like bold or colored text (NSAttributedStringon iOS,SpannableStringon Android). In practice, this is very tedious. For React Native, we decided to use the web paradigm for this, where you can nest text to achieve the same effect.

Behind the scenes, React Native converts this to a flatNSAttributedStringorSpannableStringthat contains the following information:

```
"I am bold and red"0-9: bold9-17: bold, red
```


## Containers
The<Text>element is unique relative to layout: everything inside is no longer using the Flexbox layout but using text layout. This means that elements inside of a<Text>are no longer rectangles, but wrap when they see the end of the line.

```
<Text>  <Text>First part and </Text>  <Text>second part</Text></Text>// Text container: the text will be inline, if the space allows it// |First part and second part|// otherwise, the text will flow as if it was one// |First part |// |and second |// |part       |<View>  <Text>First part and </Text>  <Text>second part</Text></View>// View container: each text is its own block// |First part and|// |second part   |// otherwise, the text will flow in its own block// |First part |// |and        |// |second part|
```


## Limited Style Inheritance
On the web, the usual way to set a font family and size for the entire document is to take advantage of inherited CSS properties like so:

```
html {  font-family:    'lucida grande', tahoma, verdana, arial, sans-serif;  font-size: 11px;  color: #141823;}
```

All elements in the document will inherit this font unless they or one of their parents specifies a new rule.

In React Native, we are more strict about it:you must wrap all the text nodes inside of a<Text>component. You cannot have a text node directly under a<View>.

```
// BAD: will raise exception, can't have a text node as child of a <View><View>  Some text</View>// GOOD<View>  <Text>    Some text  </Text></View>
```

You also lose the ability to set up a default font for an entire subtree. Meanwhile,fontFamilyonly accepts a single font name, which is different fromfont-familyin CSS. The recommended way to use consistent fonts and sizes across your application is to create a componentMyAppTextthat includes them and use this component across your app. You can also use this component to make more specific components likeMyAppHeaderTextfor other kinds of text.

```
<View>  <MyAppText>    Text styled with the default font for the entire application  </MyAppText>  <MyAppHeaderText>Text styled as a header</MyAppHeaderText></View>
```

Assuming thatMyAppTextis a component that only renders out its children into aTextcomponent with styling, thenMyAppHeaderTextcan be defined as follows:

```
const MyAppHeaderText = ({children}) => {  return (    <MyAppText>      <Text style={{fontSize: 20}}>{children}</Text>    </MyAppText>  );};
```

ComposingMyAppTextin this way ensures that we get the styles from a top-level component, but leaves us the ability to add/override them in specific use cases.

React Native still has the concept of style inheritance, but limited to text subtrees. In this case, the second part will be both bold and red.

```
<Text style={{fontWeight: 'bold'}}>  I am bold  <Text style={{color: 'red'}}>and red</Text></Text>
```

We believe that this more constrained way to style text will yield better apps:

- (Developer) React components are designed with strong isolation in mind: You should be able to drop a component anywhere in your application, trusting that as long as the props are the same, it will look and behave the same way. Text properties that could inherit from outside of the props would break this isolation.
(Developer) React components are designed with strong isolation in mind: You should be able to drop a component anywhere in your application, trusting that as long as the props are the same, it will look and behave the same way. Text properties that could inherit from outside of the props would break this isolation.

- (Implementor) The implementation of React Native is also simplified. We do not need to have afontFamilyfield on every single element, and we do not need to potentially traverse the tree up to the root every time we display a text node. The style inheritance is only encoded inside of the native Text component and doesn't leak to other components or the system itself.
(Implementor) The implementation of React Native is also simplified. We do not need to have afontFamilyfield on every single element, and we do not need to potentially traverse the tree up to the root every time we display a text node. The style inheritance is only encoded inside of the native Text component and doesn't leak to other components or the system itself.


## Props

### accessibilityHint
An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not clear from the accessibility label.


### accessibilityLanguageiOS
A value indicating which language should be used by the screen reader when the user interacts with the element. It should follow theBCP 47 specification.

See theiOSaccessibilityLanguagedocfor more information.


### accessibilityLabel
Overrides the text that's read by the screen reader when the user interacts with the element. By default, the label is constructed by traversing all the children and accumulating all theTextnodes separated by space.


### accessibilityRole
Tells the screen reader to treat the currently focused on element as having a specific role.

On iOS, these roles map to corresponding Accessibility Traits. Image button has the same functionality as if the trait was set to both 'image' and 'button'. See theAccessibility guidefor more information.

On Android, these roles have similar functionality on TalkBack as adding Accessibility Traits does on Voiceover in iOS


### accessibilityState
Tells the screen reader to treat the currently focused on element as being in a specific state.

You can provide one state, no state, or multiple states. The states must be passed in through an object, e.g.{selected: true, disabled: true}.


### accessibilityActions
Accessibility actions allow an assistive technology to programmatically invoke the actions of a component. TheaccessibilityActionsproperty should contain a list of action objects. Each action object should contain the field name and label.

See theAccessibility guidefor more information.


### onAccessibilityAction
Invoked when the user performs the accessibility actions. The only argument to this function is an event containing the name of the action to perform.

See theAccessibility guidefor more information.


### accessible
When set totrue, indicates that the view is an accessibility element.

See theAccessibility guidefor more information.


### adjustsFontSizeToFit
Specifies whether fonts should be scaled down automatically to fit given style constraints.


### allowFontScaling
Specifies whether fonts should scale to respect Text Size accessibility settings.


### android_hyphenationFrequencyAndroid
Sets the frequency of automatic hyphenation to use when determining word breaks on Android API Level 23+.


### aria-busy
Indicates an element is being modified and that assistive technologies may want to wait until the changes are complete before informing the user about the update.


### aria-checked
Indicates the state of a checkable element. This field can either take a boolean or the "mixed" string to represent mixed checkboxes.


### aria-disabled
Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.


### aria-expanded
Indicates whether an expandable element is currently expanded or collapsed.


### aria-label
Defines a string value that labels an interactive element.


### aria-selected
Indicates whether a selectable element is currently selected or not.


### dataDetectorTypeAndroid
Determines the types of data converted to clickable URLs in the text element. By default, no data types are detected.

You can provide only one type.


### disabledAndroid
Specifies the disabled state of the text view for testing purposes.


### dynamicTypeRampiOS
TheDynamic Typeramp to apply to this element on iOS.


### ellipsizeMode
WhennumberOfLinesis set, this prop defines how the text will be truncated.numberOfLinesmust be set in conjunction with this prop.

This can be one of the following values:

- head- The line is displayed so that the end fits in the container and the missing text at the beginning of the line is indicated by an ellipsis glyph. e.g., "...wxyz"
- middle- The line is displayed so that the beginning and end fit in the container and the missing text in the middle is indicated by an ellipsis glyph. "ab...yz"
- tail- The line is displayed so that the beginning fits in the container and the missing text at the end of the line is indicated by an ellipsis glyph. e.g., "abcd..."
- clip- Lines are not drawn past the edge of the text container.
On Android, whennumberOfLinesis set to a value higher than1, onlytailvalue will work correctly.


### id
Used to locate this view from native code. Has precedence overnativeIDprop.


### maxFontSizeMultiplier
Specifies the largest possible scale a font can reach whenallowFontScalingis enabled. Possible values:

- null/undefined: inherit from the parent node or the global default (0)
- 0: no max, ignore parent/global default
- >= 1: sets themaxFontSizeMultiplierof this node to this value

### minimumFontScale
Specifies the smallest possible scale a font can reach whenadjustsFontSizeToFitis enabled. (values 0.01-1.0).


### nativeID
Used to locate this view from native code.


### numberOfLines
Used to truncate the text with an ellipsis after computing the text layout, including line wrapping, such that the total number of lines does not exceed this number. Setting this property to0will result in unsetting this value, which means that no lines restriction will be applied.

This prop is commonly used withellipsizeMode.


### onLayout
Invoked on mount and on layout changes.


### onLongPress
This function is called on long press.


### onMoveShouldSetResponder
Does this view want to "claim" touch responsiveness? This is called for every touch move on theViewwhen it is not the responder.


### onPress
Function called on user press, triggered afteronPressOut.


### onPressIn
Called immediately when a touch is engaged, beforeonPressOutandonPress.


### onPressOut
Called when a touch is released.


### onResponderGrant
The View is now responding to touch events. This is the time to highlight and show the user what is happening.

On Android, return true from this callback to prevent any other native components from becoming responder until this responder terminates.


### onResponderMove
The user is moving their finger.


### onResponderRelease
Fired at the end of the touch.


### onResponderTerminate
The responder has been taken from theView. Might be taken by other views after a call toonResponderTerminationRequest, or might be taken by the OS without asking (e.g., happens with control center/ notification center on iOS)


### onResponderTerminationRequest
Some otherViewwants to become a responder and is asking thisViewto release its responder. Returningtrueallows its release.


### onStartShouldSetResponderCapture
If a parentViewwants to prevent a childViewfrom becoming a responder on a touch start, it should have this handler which returnstrue.


### onTextLayout
Invoked on Text layout change.


### pressRetentionOffset
When the scroll view is disabled, this defines how far your touch may move off of the button, before deactivating the button. Once deactivated, try moving it back and you'll see that the button is once again reactivated! Move it back and forth several times while the scroll view is disabled. Ensure you pass in a constant to reduce memory allocations.


### ref
A ref setter that will be assigned anelement nodewhen mounted.

Note thatTextcomponents don't provide text nodes, the same way that paragraph elements (<p>) on Web are element nodes instead of text nodes. Text nodes can be found as their child nodes instead.


### role
rolecommunicates the purpose of a component to the user of an assistive technology. Has precedence over theaccessibilityRoleprop.


### selectable
Lets the user select text, to use the native copy and paste functionality.


### selectionColorAndroid
The highlight color of the text.


### style

### suppressHighlightingiOS
Whentrue, no visual change is made when text is pressed down. By default, a gray oval highlights the text on press down.


### testID
Used to locate this view in end-to-end tests.


### textBreakStrategyAndroid
Set text break strategy on Android API Level 23+, possible values aresimple,highQuality,balanced.


### lineBreakStrategyIOSiOS
Set line break strategy on iOS 14+. Possible values arenone,standard,hangul-wordandpush-out.


## Type Definitions

### TextLayout
TextLayoutobject is a part ofTextLayoutEventcallback and contains the measurement data forTextline.

```
{    capHeight: 10.496,    ascender: 14.624,    descender: 4,    width: 28.224,    height: 18.624,    xHeight: 6.048,    x: 0,    y: 0}
```


### TextLayoutEvent
TextLayoutEventobject is returned in the callback as a result of a component layout change. It contains a key calledlineswith a value which is an array containingTextLayoutobject corresponded to every rendered text line.

```
{  lines: [    TextLayout,    TextLayout,    // ...  ];  target: 1127;}
```


================================================================================


# Text nodes
Source: https://reactnative.dev/docs/text-nodes

Text nodes represent raw text content on the tree (similar toTextnodes on Web). They are not directly accessible viarefs, but can be accessed using methods likechildNodeson element refs.


## Reference

### Web-compatible API
FromCharacterData:

- PropertiesdatalengthnextElementSiblingpreviousElementSibling
- data
- length
- nextElementSibling
- previousElementSibling
- MethodssubstringData()
- substringData()
FromNode:

- PropertieschildNodesfirstChildisConnectedlastChildnextSiblingnodeNamenodeTypenodeValueownerDocumentℹ️ Will return thedocument instancewhere this component was rendered.parentElementparentNodepreviousSiblingtextContent
- childNodes
- firstChild
- isConnected
- lastChild
- nextSibling
- nodeName
- nodeType
- nodeValue
- ownerDocumentℹ️ Will return thedocument instancewhere this component was rendered.
- ℹ️ Will return thedocument instancewhere this component was rendered.
- parentElement
- parentNode
- previousSibling
- textContent
- MethodscompareDocumentPosition()contains()getRootNode()ℹ️ Will return a reference to itself if the component is not mounted.hasChildNodes()
- compareDocumentPosition()
- contains()
- getRootNode()ℹ️ Will return a reference to itself if the component is not mounted.
- ℹ️ Will return a reference to itself if the component is not mounted.
- hasChildNodes()

================================================================================


# Text Style Props
Source: https://reactnative.dev/docs/text-style-props


### Example
- TypeScriptJavaScript
- JavaScript

## Props

### color

### fontFamily
The generic font familiessystem-ui,ui-sans-serif,ui-serif,ui-monospace, andui-roundedare supported on iOS.


### fontSize

### fontStyle

### fontWeight
Specifies font weight. The values'normal'and'bold'are supported for most fonts. Not all fonts have a variant for each of the numeric values, in that case the closest one is chosen.


### includeFontPaddingAndroid
Set tofalseto remove extra font padding intended to make space for certain ascenders / descenders. With some fonts, this padding can make text look slightly misaligned when centered vertically. For best results also settextAlignVerticaltocenter.


### fontVariant
Allows you to set all the font variants for a font. Can be set by using an array of enums or a space-separated string e.g.'small-caps common-ligatures'.


### letterSpacing
Increase or decrease the spacing between characters. By default there is no extra letter spacing.


### lineHeight
Numeric value that controls the vertical spacing between lines of text within a text element. It specifies the distance between the baselines of consecutive lines of text.


### textAlign
Specifies text alignment. On Android, the value 'justify' is only supported on Oreo (8.0) or above (API level >= 26). The value will fallback tolefton lower Android versions.


### textAlignVerticalAndroid

### textDecorationColoriOS

### textDecorationLine

### textDecorationStyleiOS

### textShadowColor

### textShadowOffset

### textShadowRadius

### textTransform

### verticalAlignAndroid

### writingDirectioniOS

### userSelect
It allows the user to select text and to use the native copy and paste functionality. Has precedence over theselectableprop.


================================================================================


# TextInput
Source: https://reactnative.dev/docs/textinput

A foundational component for inputting text into the app via a keyboard. Props provide configurability for several features, such as auto-correction, auto-capitalization, placeholder text, and different keyboard types, such as a numeric keypad.

The most basic use case is to plop down aTextInputand subscribe to theonChangeTextevents to read the user input. There are also other events, such asonSubmitEditingandonFocusthat can be subscribed to. A minimal example:

Two methods exposed via the native element are.focus()and.blur()that will focus or blur the TextInput programmatically.

Note that some props are only available withmultiline={true/false}. Additionally, border styles that apply to only one side of the element (e.g.,borderBottomColor,borderLeftWidth, etc.) will not be applied ifmultiline=true. To achieve the same effect, you can wrap yourTextInputin aView:

TextInputhas a border at the bottom of its view by default. This border has its padding set by the background image provided by the system, and it cannot be changed. Solutions to avoid this are to either not set height explicitly, in which case the system will take care of displaying the border in the correct position, or to not display the border by settingunderlineColorAndroidto transparent.

Note that on Android performing text selection in an input can change the app's activitywindowSoftInputModeparam toadjustResize. This may cause issues with components that have position: 'absolute' while the keyboard is active. To avoid this behavior either specifywindowSoftInputModein AndroidManifest.xml (https://developer.android.com/guide/topics/manifest/activity-element.html) or control this param programmatically with native code.


## Props

### View Props
InheritsView Props.


### allowFontScaling
Specifies whether fonts should scale to respect Text Size accessibility settings. The default istrue.


### autoCapitalize
TellsTextInputto automatically capitalize certain characters. This property is not supported by some keyboard types such asname-phone-pad.

- characters: all characters.
- words: first letter of each word.
- sentences: first letter of each sentence (default).
- none: don't auto capitalize anything.

### autoComplete
Specifies autocomplete hints for the system, so it can provide autofill. On Android, the system will always attempt to offer autofill by using heuristics to identify the type of content. To disable autocomplete, setautoCompletetooff.

The following values work across platforms:

- additional-name
- address-line1
- address-line2
- birthdate-day(iOS 17+)
- birthdate-full(iOS 17+)
- birthdate-month(iOS 17+)
- birthdate-year(iOS 17+)
- cc-csc(iOS 17+)
- cc-exp(iOS 17+)
- cc-exp-day(iOS 17+)
- cc-exp-month(iOS 17+)
- cc-exp-year(iOS 17+)
- cc-number
- country
- current-password
- email
- family-name
- given-name
- honorific-prefix
- honorific-suffix
- name
- new-password
- off
- one-time-code
- postal-code
- street-address
- tel
- username
The following values work on iOS only:

- cc-family-name(iOS 17+)
- cc-given-name(iOS 17+)
- cc-middle-name(iOS 17+)
- cc-name(iOS 17+)
- cc-type(iOS 17+)
- nickname
- organization
- organization-title
- url
The following values work on Android only:

- gender
- name-family
- name-given
- name-middle
- name-middle-initial
- name-prefix
- name-suffix
- password
- password-new
- postal-address
- postal-address-country
- postal-address-extended
- postal-address-extended-postal-code
- postal-address-locality
- postal-address-region
- sms-otp
- tel-country-code
- tel-device
- tel-national
- username-new

### autoCorrect
Iffalse, disables auto-correct. The default value istrue.


### autoFocus
Iftrue, focuses the input. The default value isfalse.


### 🗑️blurOnSubmit
Note thatsubmitBehaviornow takes the place ofblurOnSubmitand will override any behavior defined byblurOnSubmit. SeesubmitBehavior.

Iftrue, the text field will blur when submitted. The default value is true for single-line fields and false for multiline fields. Note that for multiline fields, settingblurOnSubmittotruemeans that pressing return will blur the field and trigger theonSubmitEditingevent instead of inserting a newline into the field.


### caretHidden
Iftrue, caret is hidden. The default value isfalse.


### clearButtonModeiOS
When the clear button should appear on the right side of the text view. This property is supported only for single-line TextInput component. The default value isnever.


### clearTextOnFocusiOS
Iftrue, clears the text field automatically when editing begins.


### contextMenuHidden
Iftrue, context menu is hidden. The default value isfalse.


### dataDetectorTypesiOS
Determines the types of data converted to clickable URLs in the text input. Only valid ifmultiline={true}andeditable={false}. By default no data types are detected.

You can provide one type or an array of many types.

Possible values fordataDetectorTypesare:

- 'phoneNumber'
- 'link'
- 'address'
- 'calendarEvent'
- 'none'
- 'all'

### defaultValue
Provides an initial value that will change when the user starts typing. Useful for use-cases where you do not want to deal with listening to events and updating the value prop to keep the controlled state in sync.


### disableKeyboardShortcutsiOS
Iftrue, the keyboard shortcuts (undo/redo and copy buttons) are disabled.


### cursorColorAndroid
When provided it will set the color of the cursor (or "caret") in the component. Unlike the behavior ofselectionColorthe cursor color will be set independently from the color of the text selection box.


### disableFullscreenUIAndroid
Whenfalse, if there is a small amount of space available around a text input (e.g. landscape orientation on a phone), the OS may choose to have the user edit the text inside of a full screen text input mode. Whentrue, this feature is disabled and users will always edit the text directly inside of the text input. Defaults tofalse.


### editable
Iffalse, text is not editable. The default value istrue.


### enablesReturnKeyAutomaticallyiOS
Iftrue, the keyboard disables the return key when there is no text and automatically enables it when there is text. The default value isfalse.


### enterKeyHint
Determines what text should be shown to the return key. Has precedence over thereturnKeyTypeprop.

The following values work across platforms:

- done
- next
- search
- send
- go
Android Only

The following values work on Android only:

- previous
iOS Only

The following values work on iOS only:

- enter

### importantForAutofillAndroid
Tells the operating system whether the individual fields in your app should be included in a view structure for autofill purposes on Android API Level 26+. Possible values areauto,no,noExcludeDescendants,yes, andyesExcludeDescendants. The default value isauto.

- auto: Let the Android System use its heuristics to determine if the view is important for autofill.
- no: This view isn't important for autofill.
- noExcludeDescendants: This view and its children aren't important for autofill.
- yes: This view is important for autofill.
- yesExcludeDescendants: This view is important for autofill, but its children aren't important for autofill.

### inlineImageLeftAndroid
If defined, the provided image resource will be rendered on the left. The image resource must be inside/android/app/src/main/res/drawableand referenced like

```
<TextInput inlineImageLeft='search_icon'/>
```


### inlineImagePaddingAndroid
Padding between the inline image, if any, and the text input itself.


### inputAccessoryViewIDiOS
An optional identifier which links a customInputAccessoryViewto this text input. The InputAccessoryView is rendered above the keyboard when this text input is focused.


### inputAccessoryViewButtonLabeliOS
An optional label that overrides the defaultInputAccessoryViewbutton label.

By default, the default button label is not localized. Use this property to provide a localized version.


### inputMode
Works like theinputmodeattribute in HTML, it determines which keyboard to open, e.g.numericand has precedence overkeyboardType.

Support the following values:

- none
- text
- decimal
- numeric
- tel
- search
- email
- url

### keyboardAppearanceiOS
Determines the color of the keyboard.


### keyboardType
Determines which keyboard to open, e.g.numeric.

See screenshots of all the typeshere.

The following values work across platforms:

- default
- number-pad
- decimal-pad
- numeric
- email-address
- phone-pad
- url
iOS Only

The following values work on iOS only:

- ascii-capable
- numbers-and-punctuation
- name-phone-pad
- twitter
- web-search
Android Only

The following values work on Android only:

- visible-password

### lineBreakStrategyIOSiOS
Set line break strategy on iOS 14+. Possible values arenone,standard,hangul-wordandpush-out.


### lineBreakModeIOSiOS
Set line break mode on iOS. Possible values arewordWrapping,char,clip,head,middleandtail.


### maxFontSizeMultiplier
Specifies largest possible scale a font can reach whenallowFontScalingis enabled. Possible values:

- null/undefined(default): inherit from the parent node or the global default (0)
- 0: no max, ignore parent/global default
- >= 1: sets themaxFontSizeMultiplierof this node to this value

### maxLength
Limits the maximum number of characters that can be entered. Use this instead of implementing the logic in JS to avoid flicker.


### multiline
Iftrue, the text input can be multiple lines. The default value isfalse.

It is important to note that this aligns the text to the top on iOS, and centers it on Android. Use withtextAlignVerticalset totopfor the same behavior in both platforms.


### numberOfLines
numberOfLineson iOS is only available on theNew Architecture

Sets the maximum number of lines for aTextInput. Use it with multiline set totrueto be able to fill the lines.


### onBlur
Callback that is called when the text input is blurred.

If you are attempting to access thetextvalue fromnativeEventkeep in mind that the resulting value you get can beundefinedwhich can cause unintended errors. If you are trying to find the last value of TextInput, you can use theonEndEditingevent, which is fired upon completion of editing.


### onChange
Callback that is called when the text input's text changes.


### onChangeText
Callback that is called when the text input's text changes. Changed text is passed as a single string argument to the callback handler.


### onContentSizeChange
Callback that is called when the text input's content size changes.

Only called for multiline text inputs.


### onEndEditing
Callback that is called when text input ends.


### onPressIn
Callback that is called when a touch is engaged.


### onPressOut
Callback that is called when a touch is released.


### onFocus
Callback that is called when the text input is focused.


### onKeyPress
Callback that is called when a key is pressed. This will be called with object wherekeyValueis'Enter'or'Backspace'for respective keys and the typed-in character otherwise including' 'for space. Fires beforeonChangecallbacks. Note: on Android only the inputs from soft keyboard are handled, not the hardware keyboard inputs.


### onLayout
Invoked on mount and on layout changes.


### onScroll
Invoked on content scroll. May also contain other properties fromScrollEventbut on AndroidcontentSizeis not provided for performance reasons.


### onSelectionChange
Callback that is called when the text input selection is changed.


### onSubmitEditing
Callback that is called when the text input's submit button is pressed.

Note that on iOS this method isn't called when usingkeyboardType="phone-pad".


### placeholder
The string that will be rendered before text input has been entered.


### placeholderTextColor
The text color of the placeholder string.


### readOnly
Iftrue, text is not editable. The default value isfalse.


### returnKeyLabelAndroid
Sets the return key to the label. Use it instead ofreturnKeyType.


### returnKeyType
Determines how the return key should look. On Android you can also usereturnKeyLabel.

Cross platform

The following values work across platforms:

- done
- go
- next
- search
- send
Android Only

The following values work on Android only:

- none
- previous
iOS Only

The following values work on iOS only:

- default
- emergency-call
- google
- join
- route
- yahoo

### rejectResponderTerminationiOS
Iftrue, allows TextInput to pass touch events to the parent component. This allows components such as SwipeableListView to be swipeable from the TextInput on iOS, as is the case on Android by default. Iffalse, TextInput always asks to handle the input (except when disabled). The default value istrue.


### rowsAndroid
Sets the number of lines for aTextInput. Use it with multiline set totrueto be able to fill the lines.


### scrollEnablediOS
Iffalse, scrolling of the text view will be disabled. The default value istrue. Only works withmultiline={true}.


### secureTextEntry
Iftrue, the text input obscures the text entered so that sensitive text like passwords stay secure. The default value isfalse. Does not work withmultiline={true}.


### selection
The start and end of the text input's selection. Set start and end to the same value to position the cursor.


### selectionColor
The highlight, selection handle and cursor color of the text input.


### selectionHandleColorAndroid
Sets the color of the selection handle. UnlikeselectionColor, it allows the selection handle color to be customized independently of the selection's color.


### selectTextOnFocus
Iftrue, all text will automatically be selected on focus.


### showSoftInputOnFocus
Whenfalse, it will prevent the soft keyboard from showing when the field is focused. The default value istrue.


### smartInsertDeleteiOS
Iffalse, the iOS system will not insert an extra space after a paste operation neither delete one or two spaces after a cut or delete operation.


### spellCheckiOS
Iffalse, disables spell-check style (i.e. red underlines). The default value is inherited fromautoCorrect.


### submitBehavior
When the return key is pressed,

For single line inputs:

- 'newline'defaults to'blurAndSubmit'
- undefineddefaults to'blurAndSubmit'
For multiline inputs:

- 'newline'adds a newline
- undefineddefaults to'newline'
For both single line and multiline inputs:

- 'submit'will only send a submit event and not blur the input
- 'blurAndSubmit' will both blur the input and send a submit event

### textAlign
Align the input text to the left, center, or right sides of the input field.

Possible values fortextAlignare:

- left
- center
- right

### textContentTypeiOS
Give the keyboard and the system information about the expected semantic meaning for the content that users enter.

autoComplete, provides the same functionality and is available for all platforms. You can usePlatform.selectfor differing platform behaviors.Avoid using bothtextContentTypeandautoComplete. For backwards compatibility,textContentTypetakes precedence when both properties are set.

Avoid using bothtextContentTypeandautoComplete. For backwards compatibility,textContentTypetakes precedence when both properties are set.

You can settextContentTypetousernameorpasswordto enable autofill of login details from the device keychain.

newPasswordcan be used to indicate a new password input the user may want to save in the keychain, andoneTimeCodecan be used to indicate that a field can be autofilled by a code arriving in an SMS.

To disable autofill, settextContentTypetonone.

Possible values fortextContentTypeare:

- none
- addressCity
- addressCityAndState
- addressState
- birthdate(iOS 17+)
- birthdateDay(iOS 17+)
- birthdateMonth(iOS 17+)
- birthdateYear(iOS 17+)
- countryName
- creditCardExpiration(iOS 17+)
- creditCardExpirationMonth(iOS 17+)
- creditCardExpirationYear(iOS 17+)
- creditCardFamilyName(iOS 17+)
- creditCardGivenName(iOS 17+)
- creditCardMiddleName(iOS 17+)
- creditCardName(iOS 17+)
- creditCardNumber
- creditCardSecurityCode(iOS 17+)
- creditCardType(iOS 17+)
- emailAddress
- familyName
- fullStreetAddress
- givenName
- jobTitle
- location
- middleName
- name
- namePrefix
- nameSuffix
- newPassword
- nickname
- oneTimeCode
- organizationName
- password
- postalCode
- streetAddressLine1
- streetAddressLine2
- sublocality
- telephoneNumber
- URL
- username

### passwordRulesiOS
When usingtextContentTypeasnewPasswordon iOS we can let the OS know the minimum requirements of the password so that it can generate one that will satisfy them. In order to create a valid string forPasswordRulestake a look to theApple Docs.

If passwords generation dialog doesn't appear please make sure that:AutoFill is enabled:Settings→Passwords & Accounts→ toggle "On" theAutoFill Passwords,iCloud Keychain is used:Settings→Apple ID→iCloud→Keychain→ toggle "On" theiCloud Keychain.

- AutoFill is enabled:Settings→Passwords & Accounts→ toggle "On" theAutoFill Passwords,
- iCloud Keychain is used:Settings→Apple ID→iCloud→Keychain→ toggle "On" theiCloud Keychain.

### style
Note that not all Text styles are supported, an incomplete list of what is not supported includes:

- borderLeftWidth
- borderTopWidth
- borderRightWidth
- borderBottomWidth
- borderTopLeftRadius
- borderTopRightRadius
- borderBottomRightRadius
- borderBottomLeftRadius
Styles


### textBreakStrategyAndroid
Set text break strategy on Android API Level 23+, possible values aresimple,highQuality,balancedThe default value ishighQuality.


### underlineColorAndroidAndroid
The color of theTextInputunderline.


### value
The value to show for the text input.TextInputis a controlled component, which means the native value will be forced to match this value prop if provided. For most uses, this works great, but in some cases this may cause flickering - one common cause is preventing edits by keeping value the same. In addition to setting the same value, either seteditable={false}, or set/updatemaxLengthto prevent unwanted edits without flicker.


## Methods

### .focus()
```
focus();
```

Makes the native input request focus.


### .blur()
```
blur();
```

Makes the native input lose focus.


### clear()
```
clear();
```

Removes all text from theTextInput.


### isFocused()
```
isFocused(): boolean;
```

Returnstrueif the input is currently focused;falseotherwise.

- react-native#19096: Doesn't support Android'sonKeyPreIme.
- react-native#19366: Calling .focus() after closing Android's keyboard via back button doesn't bring keyboard up again.
- react-native#26799: Doesn't support Android'ssecureTextEntrywhenkeyboardType="email-address"orkeyboardType="phone-pad".

================================================================================


# Advanced Topics on Native Modules Development
Source: https://reactnative.dev/docs/the-new-architecture/advanced-topics-components

This document contains a set of advanced topics to implement more complex functionalities of Native Components. It is recommended to first read theCodegensection and the guides onNative Components.

This guide will cover the following topics:

- Direct Manipulation
- Measuring the Layout
- Invoking native functions on your native component

================================================================================


# Advanced Topics on Native Modules Development
Source: https://reactnative.dev/docs/the-new-architecture/advanced-topics-modules

This document contains a set of advanced topics to implement more complex functionalities of Native Modules. It is recommended to first read theCodegensection and the guides onNative Modules.

This guide will cover the following topics:

- Add custom C++ types to your C++ modules
- Use Swift in your Module
- Emit custom events from your Native Modules
- Native Modules Lifecycle

================================================================================


# The Codegen CLI
Source: https://reactnative.dev/docs/the-new-architecture/codegen-cli

Calling Gradle or manually calling a script might be hard to remember and it requires a lot of ceremony.

To simplify it, we created a CLI tool that can help you running those tasks: theCodegencli. This command runs@react-native/codegenfor your project. The following options are available:

```
npx @react-native-community/cli codegen --helpUsage: rnc-cli codegen [options]Options:  --verbose            Increase logging verbosity  --path <path>        Path to the React Native project root. (default: "/Users/MyUsername/projects/my-app")  --platform <string>  Target platform. Supported values: "android", "ios", "all". (default: "all")  --outputPath <path>  Path where generated artifacts will be output to.  -h, --help           display help for command
```


## Examples
- Readpackage.jsonfrom the current working directory, generate code based on its codegenConfig.
```
npx @react-native-community/cli codegen
```

- Readpackage.jsonfrom the current working directory, generate iOS code in the location defined in the codegenConfig.
```
npx @react-native-community/cli codegen --platform ios
```

- Readpackage.jsonfromthird-party/some-library, generate Android code inthird-party/some-library/android/generated.
```
npx @react-native-community/cli codegen \    --path third-party/some-library \    --platform android \    --outputPath third-party/some-library/android/generated
```


## Including Generated Code into Libraries
The Codegen CLI is a great tool for library developers. It can be used to take a sneak-peek at the generated code to see which interfaces you need to implement.

Normally the generated code is not included in the library, and the app that uses the library is responsible for running the Codegen at build time.
This is a good setup for most cases, but Codegen also offers a mechanism to include the generated code in the library itself via theincludesGeneratedCodeproperty.

It's important to understand what are the implications of usingincludesGeneratedCode = true. Including the generated code comes with several benefits such as:

- No need to rely on the app to runCodegenfor you, the generated code is always there.
- The implementation files are always consistent with the generated interfaces (this makes your library code more resilient against API changes in codegen).
- No need to include two sets of files to support both architectures on Android. You can only keep the New Architecture one, and it is guaranteed to be backwards compatible.
- Since all native code is there, it is possible to ship the native part of the library as a prebuild.
On the other hand, you also need to be aware of one drawback:

- The generated code will use the React Native version defined inside your library. So if your library is shipping with React Native 0.76, the generated code will be based on that version. This could mean that the generated code is not compatible with apps usingpreviousReact Native version used by the app (e.g. an App running on React Native 0.75).

## EnablingincludesGeneratedCode
To enable this setup:

- Add theincludesGeneratedCodeproperty into your library'scodegenConfigfield in thepackage.jsonfile. Set its value totrue.
- RunCodegenlocally with the codegen CLI.
- Update yourpackage.jsonto include the generated code.
- Update yourpodspecto include the generated code.
- Update yourbuild.Gradlefile to include the generated code.
- UpdatecmakeListsPathinreact-native.config.jsso that Gradle doesn't look for CMakeLists file in the build directory but instead in your outputDir.

================================================================================


# Create a Library for Your Module
Source: https://reactnative.dev/docs/the-new-architecture/create-module-library

React Native has a rich ecosystem of libraries to solve common problems. We collect React Native libraries in thereactnative.directorywebsite, and this is a great resource to bookmark for every React Native developer.

Sometimes, you might be working on a module that is worth extracting in a separate library for code reuse. This can be a library that you want to reuse in all your apps, a library that you want to distribute to the ecosystem as an open source component, or even a library you'd like to sell.

In this guide, you'll learn:

- how to extract a module into a library
- how to distribute the library using NPM

## Extract the Module into a Library
You can use thecreate-react-native-librarytool to create a new library. This tool sets up a new library with all the boilerplate code that is needed: all the configuration files and all files required by the various platforms. It also comes with a nice interactive menu to guide you through the creation of the library.

To extract a module into a separate library, you can follow these steps:

- Create the new library
- Move the code from the App to the Library
- Update the code to reflect the new structure
- Publish it.

### 1. Create a Library
- Start the creation process by running the command:
```
npx create-react-native-library@latest <Name of Your Library>
```

- Add a name for your module. It must be a valid npm name, so it should be all lowercase. You can use-to separate words.
- Add a description for the package.
- Continue filling the form until you reach the question"What type of library do you want to develop?"
- For the sake of this guide, select theTurbo moduleoption. Notice that you can create libraries for both New Architecture and Legacy Architecture.
- Then, you can choose whether you want a library that access the platform (Kotlin & Objective-C) or a shared C++ library (C++ for Android and iOS).
- Finally, select theTest Appas last option. This option creates the library with a separate app already configured within the library folder.
Once the interactive prompt is done, the tool creates a folder whose structure looks like this in Visual Studio Code:

Feel free to explore the code that has been created for you. However, the most important parts:

- Theandroidfolder: this is where the Android code lives
- Thecppfolder: this is where the c++ code lives
- Theiosfolder: this is where the iOS code lives
- Thesrcfolder: this is where the JS code lives.
Thepackage.jsonis already configured with all the information that we provided to thecreate-react-native-librarytool, including the name and the description of the package. Notice that thepackage.jsonis also already configured to run Codegen.

```
  "codegenConfig": {    "name": "RN<your module name>Spec",    "type": "all",    "jsSrcsDir": "src",    "outputDir": {      "ios": "ios/generated",      "android": "android/generated"    },    "android": {      "javaPackageName": "com.<name-of-the-module>"    }  },
```

Finally, the library contains already all the infrastructure to let the library be linked with iOS and Android.


### 2. Copy the Code over from Your App
The rest of the guide assumes that you have a local Turbo Native Module in your app, created following the guidelines shown in the other guides in the website: platform specific Turbo Native Modules, orcross-platform Turbo Native Modules. But it works also for Components and legacy architecture modules and components. You'll have to adapt the files you need to copy and update.

- [Not required for legacy architecture modules and components]Move the code you have in thespecsfolder in your app into thesrcfolder created by thecreate-react-native-libraryfolder.
- Update theindex.tsfile to properly export the Turbo Native Module spec so that it is accessible from the library. For example:
```
import NativeSampleModule from './NativeSampleModule';export default NativeSampleModule;
```

- Copy the native module over:Replace the code in theandroid/src/main/java/com/<name-of-the-module>with the code you wrote in the app for your native module, if any.Replace the code in theiosfolder with the code you wrote in your app for your native module, if any.Replace the code in thecppfolder with the code you wrote in your app for your native module, if any.
Copy the native module over:

- Replace the code in theandroid/src/main/java/com/<name-of-the-module>with the code you wrote in the app for your native module, if any.
- Replace the code in theiosfolder with the code you wrote in your app for your native module, if any.
- Replace the code in thecppfolder with the code you wrote in your app for your native module, if any.
- [Not required for legacy architecture modules and components]Update all the references from the previous spec name to the new spec name, the one that is defined in thecodegenConfigfield of the library'spackage.json. For example, if in the apppackage.jsonyou setAppSpecsascodegenConfig.nameand in the library it is calledRNNativeSampleModuleSpec, you have to replace every occurrence ofAppSpecswithRNNativeSampleModuleSpec.
[Not required for legacy architecture modules and components]Update all the references from the previous spec name to the new spec name, the one that is defined in thecodegenConfigfield of the library'spackage.json. For example, if in the apppackage.jsonyou setAppSpecsascodegenConfig.nameand in the library it is calledRNNativeSampleModuleSpec, you have to replace every occurrence ofAppSpecswithRNNativeSampleModuleSpec.

That's it! You have moved all the required code out of your app and in a separate library.


## Testing your Library
Thecreate-react-native-librarycomes with a useful example application that is already configured to work properly with the library. This is a great way to test it!

If you look at theexamplefolder, you can find the same structure of a new React Native application that you can create from thereact-native-community/template.

To test your library:

- Navigate to theexamplefolder.
- Runyarn installto install all the dependencies.
- For iOS only, you need to install CocoaPods:cd ios && pod install.
- Build and run Android withyarn androidfrom theexamplefolder.
- Build and run iOS withyarn iosfrom theexamplefolder.

## Use your library as a Local Module
There are some scenario where you might want to reuse your library as a local module for your applications, without publishing it to NPM.

In this case, you might end up in a scenario where you have your library sitting as a sibling of your apps.

```
Development├── App└── Library
```

You can use the library created withcreate-react-native-libraryalso in this case.

- add you library to your app by navigating into theAppfolder and runningyarn add ../Library.
- For iOS only, navigate in theApp/iosfolder and runbundle exec pod installto install your dependencies.
- Update theApp.tsxcode to import the code in your library. For example:
```
import NativeSampleModule from '../Library/src/index';
```

If you run your app right now, Metro would not find the JS files that it needs to serve to the app. That's because metro will be running starting from theAppfolder and it would not have access to the JS files located in theLibraryfolder. To fix this, let's update themetro.config.jsfile as it follows

```
const {getDefaultConfig, mergeConfig} = require('@react-native/metro-config');/** * Metro configuration * https://reactnative.dev/docs/metro * * @type {import('metro-config').MetroConfig} */+ const path = require('path');- const config = {}+ const config = {+  // Make Metro able to resolve required external dependencies+  watchFolders: [+    path.resolve(__dirname, '../Library'),+  ],+  resolver: {+    extraNodeModules: {+      'react-native': path.resolve(__dirname, 'node_modules/react-native'),+    },+  },+};module.exports = mergeConfig(getDefaultConfig(__dirname), config);
```

ThewatchFoldersconfigs tells Metro to watch for files and changes in some additional paths, in this case to the../Librarypath, which contains thesrc/indexfile you need.
Theresolverproperty is required to feed to the library the React Native code used by the app. The library might refer and import code from React Native: without the additional resolver, the imports in the library will fail.

At this point, you can build and run your app as usual:

- Build and run Android withyarn androidfrom theexamplefolder.
- Build and run iOS withyarn iosfrom theexamplefolder.

## Publish the Library on NPM
The setup to publish everything on NPM is already in place, thanks tocreate-react-native-library.

- Install the dependencies in your moduleyarn install.
- Build the library runningyarn prepare.
- Release it withyarn release.
After a while, you'll find your library on NPM. To verify that, run:

```
npm view <package.name>
```

wherepackage.nameis thenameyou set up in thepackage.jsonfile during the initialization of the library.

Now, you can install the library in your application by running:

```
yarn add <package.name>
```

For iOS only, whenever you install a new module with some native code, you have to reinstall CocoaPods, by runningbundle exec pod install(recommended) orpod installif you are not using Ruby's Bundler (not recommended).

Congratulations! You published your first React Native library.


================================================================================


# Advanced: Custom C++ Types
Source: https://reactnative.dev/docs/the-new-architecture/custom-cxx-types

This guide assumes that you are familiar with thePure C++ Turbo Native Modulesguide. This will build on top of that guide.

C++ Turbo Native Modules supportbridging functionalityfor moststd::standard types. You can use most of those types in your modules without any additional code required.

If you want to add support for new and custom types in your app or library, you need to provide the necessarybridgingheader file.


## Adding a New Custom: Int64
C++ Turbo Native Modules don't supportint64_tnumbers yet - because JavaScript doesn't support numbers greater 2^53. To represent numbers greater than 2^53, we can use astringtype in JS and automatically convert it toint64_tin C++.


### 1. Create the Bridging Header file
The first step to support a new custom type is to define the bridging header that takes care of converting the typefromthe JS representation to the C++ representation, and from the C++ representationtothe JS one.

- In thesharedfolder, add a new file calledInt64.h
- Add the following code to that file:
```
#pragma once#include <react/bridging/Bridging.h>namespace facebook::react {template <>struct Bridging<int64_t> {  // Converts from the JS representation to the C++ representation  static int64_t fromJs(jsi::Runtime &rt, const jsi::String &value) {    try {      size_t pos;      auto str = value.utf8(rt);      auto num = std::stoll(str, &pos);      if (pos != str.size()) {        throw std::invalid_argument("Invalid number"); // don't support alphanumeric strings      }      return num;    } catch (const std::logic_error &e) {      throw jsi::JSError(rt, e.what());    }  }  // Converts from the C++ representation to the JS representation  static jsi::String toJs(jsi::Runtime &rt, int64_t value) {    return bridging::toJs(rt, std::to_string(value));  }};}
```

The key components for your custom bridging header are:

- Explicit specialization of theBridgingstruct for your custom type. In this case, the template specify theint64_ttype.
- AfromJsfunction to convert from the JS representation to the C++ representation
- AtoJsfunction to convert from the C++ representation to the JS representation
On iOS, remember to add theInt64.hfile to the Xcode project.


### 2. Modify the JS Spec
Now, we can modify the JS spec to add a method that uses the new type. As usual, we can use either Flow or TypeScript for our specs.

- Open thespecs/NativeSampleTurbomodule
- Modify the spec as follows:
- TypeScriptFlow
- Flow
```
import {TurboModule, TurboModuleRegistry} from 'react-native';export interface Spec extends TurboModule {  readonly reverseString: (input: string) => string;+  readonly cubicRoot: (input: string) => number;}export default TurboModuleRegistry.getEnforcing<Spec>(  'NativeSampleModule',);
```

```
// @flowimport type {TurboModule} from 'react-native';import { TurboModuleRegistry } from "react-native";export interface Spec extends TurboModule {  +reverseString: (input: string) => string;+  +cubicRoot: (input: string) => number;}export default (TurboModuleRegistry.getEnforcing<Spec>(  "NativeSampleModule"): Spec);
```

In this files, we are defining the function that needs to be implemented in C++.


### 3. Implement the Native Code
Now, we need to implement the function that we declared in the JS specification.

- Open thespecs/NativeSampleModule.hfile and apply the following changes:
```
#pragma once#include <AppSpecsJSI.h>#include <memory>#include <string>+ #include "Int64.h"namespace facebook::react {class NativeSampleModule : public NativeSampleModuleCxxSpec<NativeSampleModule> {public:  NativeSampleModule(std::shared_ptr<CallInvoker> jsInvoker);  std::string reverseString(jsi::Runtime& rt, std::string input);+ int32_t cubicRoot(jsi::Runtime& rt, int64_t input);};} // namespace facebook::react
```

- Open thespecs/NativeSampleModule.cppfile and apply the implement the new function:
```
#include "NativeSampleModule.h"+ #include <cmath>namespace facebook::react {NativeSampleModule::NativeSampleModule(std::shared_ptr<CallInvoker> jsInvoker)    : NativeSampleModuleCxxSpec(std::move(jsInvoker)) {}std::string NativeSampleModule::reverseString(jsi::Runtime& rt, std::string input) {  return std::string(input.rbegin(), input.rend());}+int32_t NativeSampleModule::cubicRoot(jsi::Runtime& rt, int64_t input) {+    return std::cbrt(input);+}} // namespace facebook::react
```

The implementation imports the<cmath>C++ library to perform mathematical operations, then it implements thecubicRootfunction using thecbrtprimitive from the<cmath>module.


### 4. Test your code in Your App
Now, we can test the code in our app.

First, we need to update theApp.tsxfile to use the new method from the TurboModule. Then, we can build our apps in Android and iOS.

- Open theApp.tsxcode apply the following changes:
```
// ...+ const [cubicSource, setCubicSource] = React.useState('')+ const [cubicRoot, setCubicRoot] = React.useState(0)  return (    <SafeAreaView style={styles.container}>      <View>        <Text style={styles.title}>          Welcome to C++ Turbo Native Module Example        </Text>        <Text>Write down here the text you want to revert</Text>        <TextInput          style={styles.textInput}          placeholder="Write your text here"          onChangeText={setValue}          value={value}        />        <Button title="Reverse" onPress={onPress} />        <Text>Reversed text: {reversedValue}</Text>+        <Text>For which number do you want to compute the Cubic Root?</Text>+        <TextInput+          style={styles.textInput}+          placeholder="Write your text here"+          onChangeText={setCubicSource}+          value={cubicSource}+        />+        <Button title="Get Cubic Root" onPress={() => setCubicRoot(SampleTurboModule.cubicRoot(cubicSource))} />+        <Text>The cubic root is: {cubicRoot}</Text>      </View>    </SafeAreaView>  );}//...
```

- To test the app on Android, runyarn androidfrom the root folder of your project.
- To test the app on iOS, runyarn iosfrom the root folder of your project.

## Adding a New Structured Custom Type: Address
The approach above can be generalized to any kind of type. For structured types, React Native provides some helper functions that make it easier to bridge them from JS to C++ and vice versa.

Let's assume that we want to bridge a customAddresstype with the following properties:

```
interface Address {  street: string;  num: number;  isInUS: boolean;}
```


### 1. Define the type in the specs
For the first step, let's define the new custom type in the JS specs, so that Codegen can output all the supporting code. In this way, we don't have to manually write the code.

- Open thespecs/NativeSampleModulefile and add the following changes.
- TypeScriptFlow
- Flow
```
import {TurboModule, TurboModuleRegistry} from 'react-native';+export type Address = {+  street: string,+  num: number,+  isInUS: boolean,+};export interface Spec extends TurboModule {  readonly reverseString: (input: string) => string;+ readonly validateAddress: (input: Address) => boolean;}export default TurboModuleRegistry.getEnforcing<Spec>(  'NativeSampleModule',);
```

```
// @flowimport type {TurboModule} from 'react-native';import { TurboModuleRegistry } from "react-native";+export type Address = {+  street: string,+  num: number,+  isInUS: boolean,+};export interface Spec extends TurboModule {  +reverseString: (input: string) => string;+ +validateAddress: (input: Address) => boolean;}export default (TurboModuleRegistry.getEnforcing<Spec>(  "NativeSampleModule"): Spec);
```

This code defines the newAddresstype and defines a newvalidateAddressfunction for the Turbo Native Module. Notice that thevalidateFunctionrequires anAddressobject as parameter.

It is also possible to have functions that return custom types.


### 2. Define the bridging code
From theAddresstype defined in the specs, Codegen will generate two helper types:NativeSampleModuleAddressandNativeSampleModuleAddressBridging.

The first type is the definition of theAddress. The second type contains all the infrastructure to bridge the custom type from JS to C++ and vice versa. The only extra step we need to add is to define theBridgingstructure that extends theNativeSampleModuleAddressBridgingtype.

- Open theshared/NativeSampleModule.hfile
- Add the following code in the file:
```
#include "Int64.h"#include <memory>#include <string>namespace facebook::react {+  using Address = NativeSampleModuleAddress<std::string, int32_t, bool>;+  template <>+  struct Bridging<Address>+      : NativeSampleModuleAddressBridging<Address> {};  // ...}
```

This code defines anAddresstypealias for the generic typeNativeSampleModuleAddress.The order of the generics matters: the first template argument refers to the first data type of the struct, the second refers to the second, and so forth.

Then, the code adds theBridgingspecialization for the newAddresstype, by extendingNativeSampleModuleAddressBridgingthat is generated by Codegen.

There is a convention that is followed to generate this types:The first part of the name is always the type of the module.NativeSampleModule, in this example.The second part of the name is always the name of the JS type defined in the specs.Address, in this example.

- The first part of the name is always the type of the module.NativeSampleModule, in this example.
- The second part of the name is always the name of the JS type defined in the specs.Address, in this example.

### 3. Implement the Native Code
Now, we need to implement thevalidateAddressfunction in C++. First, we need to add the function declaration into the.hfile, and then we can implement it in the.cppfile.

- Open theshared/NativeSampleModule.hfile and add the function definition
```
  std::string reverseString(jsi::Runtime& rt, std::string input);+  bool validateAddress(jsi::Runtime &rt, jsi::Object input);};} // namespace facebook::react
```

- Open theshared/NativeSampleModule.cppfile and add the function implementation
```
bool NativeSampleModule::validateAddress(jsi::Runtime &rt, jsi::Object input) {  std::string street = input.getProperty(rt, "street").asString(rt).utf8(rt);  int32_t number = input.getProperty(rt, "num").asNumber();  return !street.empty() && number > 0;}
```

In the implementation, the object that represents theAddressis ajsi::Object. To extract the values from this object, we need to use the accessors provided byJSI:

- getProperty()retrieves the property from and object by name.
- asString()converts the property tojsi::String.
- utf8()converts thejsi::Stringto astd::string.
- asNumber()converts the property to adouble.
Once we manually parsed the object, we can implement the logic that we need.

If you want to learn more aboutJSIand how it works, have a look at thisgreat talkfrom App.JS 2024


### 4. Testing the code in the app
To test the code in the app, we have to modify theApp.tsxfile.

- Open theApp.tsxfile. Remove the content of theApp()function.
- Replace the body of theApp()function with the following code:
```
const [street, setStreet] = React.useState('');const [num, setNum] = React.useState('');const [isValidAddress, setIsValidAddress] = React.useState<  boolean | null>(null);const onPress = () => {  let houseNum = parseInt(num, 10);  if (isNaN(houseNum)) {    houseNum = -1;  }  const address = {    street,    num: houseNum,    isInUS: false,  };  const result = SampleTurboModule.validateAddress(address);  setIsValidAddress(result);};return (  <SafeAreaView style={styles.container}>    <View>      <Text style={styles.title}>        Welcome to C Turbo Native Module Example      </Text>      <Text>Address:</Text>      <TextInput        style={styles.textInput}        placeholder="Write your address here"        onChangeText={setStreet}        value={street}      />      <Text>Number:</Text>      <TextInput        style={styles.textInput}        placeholder="Write your address here"        onChangeText={setNum}        value={num}      />      <Button title="Validate" onPress={onPress} />      {isValidAddress != null && (        <Text>          Your address is {isValidAddress ? 'valid' : 'not valid'}        </Text>      )}    </View>  </SafeAreaView>);
```

Congratulation! 🎉

You bridged your first types from JS to C++.


================================================================================


# Direct Manipulation
Source: https://reactnative.dev/docs/the-new-architecture/direct-manipulation-new-architecture

It is sometimes necessary to make changes directly to a component without using state/props to trigger a re-render of the entire subtree. When using React in the browser for example, you sometimes need to directly modify a DOM node, and the same is true for views in mobile apps.setNativePropsis the React Native equivalent to setting properties directly on a DOM node.

UsesetNativePropswhen frequent re-rendering creates a performance bottleneck!Direct manipulation will not be a tool that you reach for frequently. You will typically only be using it for creating continuous animations to avoid the overhead of rendering the component hierarchy and reconciling many views.setNativePropsis imperative and stores state in the native layer (DOM, UIView, etc.) and not within your React components, which makes your code more difficult to reason about.Before you use it, try to solve your problem withsetStateandshouldComponentUpdate.

Direct manipulation will not be a tool that you reach for frequently. You will typically only be using it for creating continuous animations to avoid the overhead of rendering the component hierarchy and reconciling many views.setNativePropsis imperative and stores state in the native layer (DOM, UIView, etc.) and not within your React components, which makes your code more difficult to reason about.Before you use it, try to solve your problem withsetStateandshouldComponentUpdate.

Before you use it, try to solve your problem withsetStateandshouldComponentUpdate.


## setNativeProps to edit TextInput value
Another very common use case ofsetNativePropsis to edit the value of the TextInput. Thecontrolledprop of TextInput can sometimes drop characters when thebufferDelayis low and the user types very quickly. Some developers prefer to skip this prop entirely and instead usesetNativePropsto directly manipulate the TextInput value when necessary.

For example, the following code demonstrates editing the input when you tap a button:

- TypeScriptJavaScript
- JavaScript
You can use theclearmethod to clear theTextInputwhich clears the current input text using the same approach.


## Avoiding conflicts with the render function
If you update a property that is also managed by the render function, you might end up with some unpredictable and confusing bugs because anytime the component re-renders and that property changes, whatever value was previously set fromsetNativePropswill be completely ignored and overridden.


================================================================================


# Invoking native functions on your native component
Source: https://reactnative.dev/docs/the-new-architecture/fabric-component-native-commands

In thebase guideto write a new Native Component, you have explored how to create a new component, how to pass properties from the JS side to the native side, and how to emit events from native side to JS.

Custom components can also call some of the functions implemented in the native code imperatively, to achieve some more advanced functionalities, such as programmatically reload a web page.

In this guide you'll learn how to achieve this, by using a new concept: Native Commands.

This guide starts from theNative Componentsguide and assumes that you are familiar with it and that you are familiar withCodegen.


## 1. Update your component specs
The first step is to update the component spec to declare theNativeCommand.

- TypeScriptFlow
- Flow
Update theWebViewNativeComponent.tsas it follows:Demo/specs/WebViewNativeComponent.tsimport type {HostComponent, ViewProps} from 'react-native';import type {BubblingEventHandler} from 'react-native/Libraries/Types/CodegenTypes';import codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';+import codegenNativeCommands from 'react-native/Libraries/Utilities/codegenNativeCommands';type WebViewScriptLoadedEvent = {result: 'success' | 'error';};export interface NativeProps extends ViewProps {sourceURL?: string;onScriptLoaded?: BubblingEventHandler<WebViewScriptLoadedEvent> | null;}+interface NativeCommands {+reload: (viewRef: React.ElementRef<HostComponent<NativeProps>>) => void;+}+export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({+supportedCommands: ['reload'],+});export default codegenNativeComponent<NativeProps>('CustomWebView',) as HostComponent<NativeProps>;

```
import type {HostComponent, ViewProps} from 'react-native';import type {BubblingEventHandler} from 'react-native/Libraries/Types/CodegenTypes';import codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';+import codegenNativeCommands from 'react-native/Libraries/Utilities/codegenNativeCommands';type WebViewScriptLoadedEvent = {  result: 'success' | 'error';};export interface NativeProps extends ViewProps {  sourceURL?: string;  onScriptLoaded?: BubblingEventHandler<WebViewScriptLoadedEvent> | null;}+interface NativeCommands {+    reload: (viewRef: React.ElementRef<HostComponent<NativeProps>>) => void;+}+export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({+    supportedCommands: ['reload'],+});export default codegenNativeComponent<NativeProps>(  'CustomWebView',) as HostComponent<NativeProps>;
```

Update theWebViewNativeComponent.jsas it follows:Demo/specs/WebViewNativeComponent.js// @flow strict-localimport type {HostComponent, ViewProps} from 'react-native';import type {BubblingEventHandler} from 'react-native/Libraries/Types/CodegenTypes';import codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';+import codegenNativeCommands from 'react-native/Libraries/Utilities/codegenNativeCommands';type WebViewScriptLoadedEvent = $ReadOnly<{|result: "success" | "error",|}>;type NativeProps = $ReadOnly<{|...ViewProps,sourceURL?: string;onScriptLoaded?: BubblingEventHandler<WebViewScriptLoadedEvent>?;|}>;+interface NativeCommands {+reload: (viewRef: React.ElementRef<HostComponent<NativeProps>>) => void;+}+export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({+supportedCommands: ['reload'],+});export default (codegenNativeComponent<NativeProps>('CustomWebView',): HostComponent<NativeProps>);

```
// @flow strict-localimport type {HostComponent, ViewProps} from 'react-native';import type {BubblingEventHandler} from 'react-native/Libraries/Types/CodegenTypes';import codegenNativeComponent from 'react-native/Libraries/Utilities/codegenNativeComponent';+import codegenNativeCommands from 'react-native/Libraries/Utilities/codegenNativeCommands';type WebViewScriptLoadedEvent = $ReadOnly<{|  result: "success" | "error",|}>;type NativeProps = $ReadOnly<{|  ...ViewProps,  sourceURL?: string;  onScriptLoaded?: BubblingEventHandler<WebViewScriptLoadedEvent>?;|}>;+interface NativeCommands {+    reload: (viewRef: React.ElementRef<HostComponent<NativeProps>>) => void;+}+export const Commands: NativeCommands = codegenNativeCommands<NativeCommands>({+    supportedCommands: ['reload'],+});export default (codegenNativeComponent<NativeProps>(  'CustomWebView',): HostComponent<NativeProps>);
```

These changes requires you to:

- Import thecodegenNativeCommandsfunction fromreact-native. This instruct codegen that it has to generate the code forNativeCommands
- Define an interface that contains the methods we want to invoke in native. All the Native Commands must have a first parameter of typeReact.ElementRef.
- Export theCommandsvariable that is the result of the invocation ofcodegenNativeCommands, passing a list of the supported commands.
In TypeScript, theReact.ElementRefis deprecated. The correct type to use is actuallyReact.ComponentRef. However, due to a bug in Codegen, usingComponentRefwill crash the app. We have the fix already, but we need to release a new version of React Native to apply it.


## 2. Update the App code to use the new command
Now you can use the command in the the app.

- TypeScriptFlow
- Flow
Open theApp.tsxfile and modify it as it follows:App.tsximport React from 'react';-import {Alert, StyleSheet, View} from 'react-native';-import WebView from '../specs/WebViewNativeComponent';+import {Alert, StyleSheet, Pressable, Text, View} from 'react-native';+import WebView, {Commands} from '../specs/WebViewNativeComponent';function App(): React.JSX.Element {+const webViewRef = React.useRef<React.ElementRef<typeof View> | null>(null);++const refresh = () => {+if (webViewRef.current) {+Commands.reload(webViewRef.current);+}+};return (<View style={styles.container}><WebView+ref={webViewRef}sourceURL="https://react.dev/"style={styles.webview}onScriptLoaded={() => {Alert.alert('Page Loaded');}}/>+<View style={styles.tabbar}>+<Pressable onPress={refresh} style={styles.button}>+{({pressed}) => (+!pressed ? <Text style={styles.buttonText}>Refresh</Text> : <Text style={styles.buttonTextPressed}>Refresh</Text>) }+</Pressable>+</View></View>);}const styles = StyleSheet.create({container: {flex: 1,alignItems: 'center',alignContent: 'center',},webview: {width: '100%',-height: '100%',+height: '90%',},+tabbar: {+flex: 1,+backgroundColor: 'gray',+width: '100%',+alignItems: 'center',+alignContent: 'center',+},+button: {+margin: 10,+},+buttonText: {+fontSize: 20,+fontWeight: 'bold',+color: '#00D6FF',+width: '100%',+},+buttonTextPressed: {+fontSize: 20,+fontWeight: 'bold',+color: '#00D6FF77',+width: '100%',+},});export default App;

```
import React from 'react';-import {Alert, StyleSheet, View} from 'react-native';-import WebView from '../specs/WebViewNativeComponent';+import {Alert, StyleSheet, Pressable, Text, View} from 'react-native';+import WebView, {Commands} from '../specs/WebViewNativeComponent';function App(): React.JSX.Element {+    const webViewRef = React.useRef<React.ElementRef<typeof View> | null>(null);++    const refresh = () => {+        if (webViewRef.current) {+            Commands.reload(webViewRef.current);+        }+    };  return (    <View style={styles.container}>      <WebView+       ref={webViewRef}        sourceURL="https://react.dev/"        style={styles.webview}        onScriptLoaded={() => {          Alert.alert('Page Loaded');        }}      />+      <View style={styles.tabbar}>+        <Pressable onPress={refresh} style={styles.button}>+            {({pressed}) => (+                !pressed ? <Text style={styles.buttonText}>Refresh</Text> : <Text style={styles.buttonTextPressed}>Refresh</Text>) }+        </Pressable>+      </View>    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    alignItems: 'center',    alignContent: 'center',  },  webview: {    width: '100%',-    height: '100%',+    height: '90%',  },+  tabbar: {+    flex: 1,+    backgroundColor: 'gray',+    width: '100%',+    alignItems: 'center',+    alignContent: 'center',+  },+  button: {+    margin: 10,+  },+  buttonText: {+    fontSize: 20,+    fontWeight: 'bold',+    color: '#00D6FF',+    width: '100%',+  },+  buttonTextPressed: {+    fontSize: 20,+    fontWeight: 'bold',+    color: '#00D6FF77',+    width: '100%',+  },});export default App;
```

Open theApp.tsxfile and modify it as it follows:App.jsximport React from 'react';-import {Alert, StyleSheet, View} from 'react-native';-import WebView from '../specs/WebViewNativeComponent';+import {Alert, StyleSheet, Pressable, Text, View} from 'react-native';+import WebView, {Commands} from '../specs/WebViewNativeComponent';function App(): React.JSX.Element {+const webViewRef = React.useRef<React.ElementRef<typeof View> | null>(null);++const refresh = () => {+if (webViewRef.current) {+Commands.reload(webViewRef.current);+}+};return (<View style={styles.container}><WebView+ref={webViewRef}sourceURL="https://react.dev/"style={styles.webview}onScriptLoaded={() => {Alert.alert('Page Loaded');}}/>+<View style={styles.tabbar}>+<Pressable onPress={refresh} style={styles.button}>+{({pressed}) => (+!pressed ? <Text style={styles.buttonText}>Refresh</Text> : <Text style={styles.buttonTextPressed}>Refresh</Text>) }+</Pressable>+</View></View>);}const styles = StyleSheet.create({container: {flex: 1,alignItems: 'center',alignContent: 'center',},webview: {width: '100%',-height: '100%',+height: '90%',},+tabbar: {+flex: 1,+backgroundColor: 'gray',+width: '100%',+alignItems: 'center',+alignContent: 'center',+},+button: {+margin: 10,+},+buttonText: {+fontSize: 20,+fontWeight: 'bold',+color: '#00D6FF',+width: '100%',+},+buttonTextPressed: {+fontSize: 20,+fontWeight: 'bold',+color: '#00D6FF77',+width: '100%',+},});export default App;

```
import React from 'react';-import {Alert, StyleSheet, View} from 'react-native';-import WebView from '../specs/WebViewNativeComponent';+import {Alert, StyleSheet, Pressable, Text, View} from 'react-native';+import WebView, {Commands} from '../specs/WebViewNativeComponent';function App(): React.JSX.Element {+    const webViewRef = React.useRef<React.ElementRef<typeof View> | null>(null);++    const refresh = () => {+        if (webViewRef.current) {+            Commands.reload(webViewRef.current);+        }+    };  return (    <View style={styles.container}>      <WebView+       ref={webViewRef}        sourceURL="https://react.dev/"        style={styles.webview}        onScriptLoaded={() => {          Alert.alert('Page Loaded');        }}      />+      <View style={styles.tabbar}>+        <Pressable onPress={refresh} style={styles.button}>+            {({pressed}) => (+                !pressed ? <Text style={styles.buttonText}>Refresh</Text> : <Text style={styles.buttonTextPressed}>Refresh</Text>) }+        </Pressable>+      </View>    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    alignItems: 'center',    alignContent: 'center',  },  webview: {    width: '100%',-    height: '100%',+    height: '90%',  },+  tabbar: {+    flex: 1,+    backgroundColor: 'gray',+    width: '100%',+    alignItems: 'center',+    alignContent: 'center',+  },+  button: {+    margin: 10,+  },+  buttonText: {+    fontSize: 20,+    fontWeight: 'bold',+    color: '#00D6FF',+    width: '100%',+  },+  buttonTextPressed: {+    fontSize: 20,+    fontWeight: 'bold',+    color: '#00D6FF77',+    width: '100%',+  },});export default App;
```

The relevant changes here are the following:

- Import theCommandsconst from the spec file. The Command is an object that let us call the methods we have in native.
- Declare a ref to theWebViewcustom native component usinguseRef. You need to pass this ref to the native command.
- Implement therefreshfunction. This function checks that the WebView's ref is not null and if not, it calls the command.
- Add a pressable to call the command when the user taps on the button.
The remaining changes are regular React changes to add aPressableand to style the view so it looks nicer.


## 3. Rerun Codegen
Now that the specs are updated and the code is ready to use the command, it is time to implement the Native code. However, before diving into writing native code, you have to rerun codegen, to let it generate the new types that are needed by the Native code.

- AndroidiOS
- iOS
Codegen is executed through thegenerateCodegenArtifactsFromSchemaGradle task:bashcdandroid./gradlew generateCodegenArtifactsFromSchemaBUILD SUCCESSFULin837ms14actionable tasks:3executed,11up-to-dateThis is automatically run when you build your Android application.

```
cd android./gradlew generateCodegenArtifactsFromSchemaBUILD SUCCESSFUL in 837ms14 actionable tasks: 3 executed, 11 up-to-date
```

This is automatically run when you build your Android application.

Codegen is run as part of the script phases that's automatically added to the project generated by CocoaPods.bashcdiosbundleinstallbundleexecpodinstallThe output will look like this:shell...Framework buildtypeis static library[Codegen]Adding script_phases to ReactCodegen.[Codegen]Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen]Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen]Searchingforcodegen-enabled librariesinthe app.[Codegen]Found TurboModuleExample[Codegen]Searchingforcodegen-enabled librariesinthe project dependencies.[Codegen]Found react-native...

```
cd iosbundle installbundle exec pod install
```

The output will look like this:shell...Framework buildtypeis static library[Codegen]Adding script_phases to ReactCodegen.[Codegen]Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen]Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen]Searchingforcodegen-enabled librariesinthe app.[Codegen]Found TurboModuleExample[Codegen]Searchingforcodegen-enabled librariesinthe project dependencies.[Codegen]Found react-native...

```
...Framework build type is static library[Codegen] Adding script_phases to ReactCodegen.[Codegen] Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen] Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen] Searching for codegen-enabled libraries in the app.[Codegen] Found TurboModuleExample[Codegen] Searching for codegen-enabled libraries in the project dependencies.[Codegen] Found react-native...
```


## 4. Implement the Native Code
Now it's time to implement the native changes that will enable your JS to directly invoke methods on your native view.

- AndroidiOS
- iOS
To let your view respond to the Native Command, you only have to modify the ReactWebViewManager.If you try to build right now, the build will fail, because the currentReactWebViewManagerdoes not implement the newreloadmethod.
To fix the build error, let's modify theReactWebViewManagerto implement it.JavaKotlinReactWebViewManager.java//...@ReactProp(name = "sourceUrl")@Overridepublic void setSourceURL(ReactWebView view, String sourceURL) {if (sourceURL == null) {view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error);return;}view.loadUrl(sourceURL, new HashMap<>());}+@Override+public void reload(ReactWebView view) {+view.reload();+}public static final String REACT_CLASS = "CustomWebView";//...ReactWebViewManager.kt@ReactProp(name = "sourceUrl")override fun setSourceURL(view: ReactWebView, sourceURL: String?) {if (sourceURL == null) {view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error)return;}view.loadUrl(sourceURL, emptyMap())}+override fun reload(view: ReactWebView) {+view.reload()+}companion object {const val REACT_CLASS = "CustomWebView"}In this case, it's enough to call directly theview.reload()method because our ReactWebView inherits from the Android'sWebViewand it has a reload method directly available. If you are implementing a custom function, that is not available in your custom view, you might also have to implement the required method in the Android's View that is managed by the React Native'sViewManager.

If you try to build right now, the build will fail, because the currentReactWebViewManagerdoes not implement the newreloadmethod.
To fix the build error, let's modify theReactWebViewManagerto implement it.JavaKotlinReactWebViewManager.java//...@ReactProp(name = "sourceUrl")@Overridepublic void setSourceURL(ReactWebView view, String sourceURL) {if (sourceURL == null) {view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error);return;}view.loadUrl(sourceURL, new HashMap<>());}+@Override+public void reload(ReactWebView view) {+view.reload();+}public static final String REACT_CLASS = "CustomWebView";//...ReactWebViewManager.kt@ReactProp(name = "sourceUrl")override fun setSourceURL(view: ReactWebView, sourceURL: String?) {if (sourceURL == null) {view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error)return;}view.loadUrl(sourceURL, emptyMap())}+override fun reload(view: ReactWebView) {+view.reload()+}companion object {const val REACT_CLASS = "CustomWebView"}In this case, it's enough to call directly theview.reload()method because our ReactWebView inherits from the Android'sWebViewand it has a reload method directly available. If you are implementing a custom function, that is not available in your custom view, you might also have to implement the required method in the Android's View that is managed by the React Native'sViewManager.

- JavaKotlin
- Kotlin
```
//...  @ReactProp(name = "sourceUrl")  @Override  public void setSourceURL(ReactWebView view, String sourceURL) {    if (sourceURL == null) {      view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error);      return;    }    view.loadUrl(sourceURL, new HashMap<>());  }+  @Override+  public void reload(ReactWebView view) {+    view.reload();+  }  public static final String REACT_CLASS = "CustomWebView";//...
```

```
  @ReactProp(name = "sourceUrl")  override fun setSourceURL(view: ReactWebView, sourceURL: String?) {    if (sourceURL == null) {      view.emitOnScriptLoaded(ReactWebView.OnScriptLoadedEventResult.error)      return;    }    view.loadUrl(sourceURL, emptyMap())  }+  override fun reload(view: ReactWebView) {+    view.reload()+  }  companion object {    const val REACT_CLASS = "CustomWebView"  }
```

In this case, it's enough to call directly theview.reload()method because our ReactWebView inherits from the Android'sWebViewand it has a reload method directly available. If you are implementing a custom function, that is not available in your custom view, you might also have to implement the required method in the Android's View that is managed by the React Native'sViewManager.

To let your view respond to the Native Command, we need to implement a couple of methods on iOS.Let's open theRCTWebView.mmfile and let's modify it as it follows:RCTWebView.mm// Event emitter convenience method- (const CustomWebViewEventEmitter &)eventEmitter{return static_cast<const CustomWebViewEventEmitter &>(*_eventEmitter);}+- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args+{+RCTCustomWebViewHandleCommand(self, commandName, args);+}++- (void)reload+{+[_webView reloadFromOrigin];+}+ (ComponentDescriptorProvider)componentDescriptorProvider{return concreteComponentDescriptorProvider<CustomWebViewComponentDescriptor>();}To make your view respond to the Native Commands, you need to apply the following changes:Add ahandleCommand:argsfunction. This function is invoked by the components infrastructure to handle the commands. The function implementation is similar for every component: you need to call anRCT<componentNameInJS>HandleCommandfunction that is generated by Codegen for you. TheRCT<componentNameInJS>HandleCommandperform a bunch of validation, verifying that the command that we need to invoke is among the supported ones and that the parameters passed matches the one expected. If all the checks pass, theRCT<componentNameInJS>HandleCommandwill then invoke the proper native method.Implement thereloadmethod. In this example, thereloadmethod calls thereloadFromOriginfunction of the WebKit's WebView.

Let's open theRCTWebView.mmfile and let's modify it as it follows:RCTWebView.mm// Event emitter convenience method- (const CustomWebViewEventEmitter &)eventEmitter{return static_cast<const CustomWebViewEventEmitter &>(*_eventEmitter);}+- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args+{+RCTCustomWebViewHandleCommand(self, commandName, args);+}++- (void)reload+{+[_webView reloadFromOrigin];+}+ (ComponentDescriptorProvider)componentDescriptorProvider{return concreteComponentDescriptorProvider<CustomWebViewComponentDescriptor>();}To make your view respond to the Native Commands, you need to apply the following changes:Add ahandleCommand:argsfunction. This function is invoked by the components infrastructure to handle the commands. The function implementation is similar for every component: you need to call anRCT<componentNameInJS>HandleCommandfunction that is generated by Codegen for you. TheRCT<componentNameInJS>HandleCommandperform a bunch of validation, verifying that the command that we need to invoke is among the supported ones and that the parameters passed matches the one expected. If all the checks pass, theRCT<componentNameInJS>HandleCommandwill then invoke the proper native method.Implement thereloadmethod. In this example, thereloadmethod calls thereloadFromOriginfunction of the WebKit's WebView.

```
  // Event emitter convenience method  - (const CustomWebViewEventEmitter &)eventEmitter  {  return static_cast<const CustomWebViewEventEmitter &>(*_eventEmitter);  }+  - (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args+  {+  RCTCustomWebViewHandleCommand(self, commandName, args);+  }++  - (void)reload+  {+  [_webView reloadFromOrigin];+  }  + (ComponentDescriptorProvider)componentDescriptorProvider  {  return concreteComponentDescriptorProvider<CustomWebViewComponentDescriptor>();  }
```

To make your view respond to the Native Commands, you need to apply the following changes:Add ahandleCommand:argsfunction. This function is invoked by the components infrastructure to handle the commands. The function implementation is similar for every component: you need to call anRCT<componentNameInJS>HandleCommandfunction that is generated by Codegen for you. TheRCT<componentNameInJS>HandleCommandperform a bunch of validation, verifying that the command that we need to invoke is among the supported ones and that the parameters passed matches the one expected. If all the checks pass, theRCT<componentNameInJS>HandleCommandwill then invoke the proper native method.Implement thereloadmethod. In this example, thereloadmethod calls thereloadFromOriginfunction of the WebKit's WebView.

- Add ahandleCommand:argsfunction. This function is invoked by the components infrastructure to handle the commands. The function implementation is similar for every component: you need to call anRCT<componentNameInJS>HandleCommandfunction that is generated by Codegen for you. TheRCT<componentNameInJS>HandleCommandperform a bunch of validation, verifying that the command that we need to invoke is among the supported ones and that the parameters passed matches the one expected. If all the checks pass, theRCT<componentNameInJS>HandleCommandwill then invoke the proper native method.
- Implement thereloadmethod. In this example, thereloadmethod calls thereloadFromOriginfunction of the WebKit's WebView.

## 5. Run your app
Finally, you can run your app with the usual commands. Once the app is running, you can tap on the refresh button to see the page getting reloaded.


================================================================================


# Measuring the Layout
Source: https://reactnative.dev/docs/the-new-architecture/layout-measurements

Sometimes, you need to measure the current layout to apply some changes to the overall layout or to make decisions and call some specific logic.

React Native provides some native methods to know what are the measurements of the views.

The best way to invoke those methods is in auseLayoutEffecthook: this will give you the most recent values for those measurements and it will let you apply changes in the same frame when the measurements are computed.

Typical code will look like this:

```
function AComponent(children) {  const targetRef = React.useRef(null)  useLayoutEffect(() => {    targetRef.current?.measure((x, y, width, height, pageX, pageY) => {      //do something with the measurements    });  }, [ /* add dependencies here */]);  return (    <View ref={targetRef}>     {children}    <View />  );}
```

The methods described here are available on most of the default components provided by React Native. However, they arenotavailable on composite components that aren't directly backed by a native view. This will generally include most components that you define in your own app.


## measure(callback)
Determines the location on screen (xandy),width, andheightin the viewport of the given view. Returns the values via an async callback. If successful, the callback will be called with the following arguments:

- x: thexcoordinate of the origin (top-left corner) of the measured view in the viewport.
- y: theycoordinate of the origin (top-left corner) of the measured view in the viewport.
- width: thewidthof the view.
- height: theheightof the view.
- pageX: thexcoordinate of the view in the viewport (typically the whole screen).
- pageY: theycoordinate of the view in the viewport (typically the whole screen).
Also thewidthandheightreturned bymeasure()are thewidthandheightof the component in the viewport.


## measureInWindow(callback)
Determines the location (xandy) of the given view in the window and returns the values via an async callback. If the React root view is embedded in another native view, this will give you the absolute coordinates. If successful, the callback will be called with the following arguments:

- x: thexcoordinate of the view in the current window.
- y: theycoordinate of the view in the current window.
- width: thewidthof the view.
- height: theheightof the view.

================================================================================


# Emitting Events in Native Modules
Source: https://reactnative.dev/docs/the-new-architecture/native-modules-custom-events

In some circustamces, you may want to have a Native Module that listen to some events in the platform layer and then emit them to the JavaScript layer, to let you application react to such native events. In other cases, you might have long running operations that can emits events so that the UI can be updated when those happen.

Both are good use cases for emitting events from a Native Modules. In this guide, you'll learn how to do that.


## Emitting an Event when a new key added to the storage
In this example, you will learn how to emit an event when a new key is added to the storage. Changing the value of the key will not emit the event, but adding a new key will.

This guide starts from theNative Moduleguide.
Make sure to be familiar with that guide before diving into this one, potentially implementing the example in the guide.


## Step 1: Update the Specs of NativeLocalStorage
The first step would be to update the specs of theNativeLocalStoragespecs to let React Native aware that the module can emit events.

- TypeScriptFlow
- Flow
Open theNativeLocalStorage.tsfile and update it as it follows:NativeLocalStorage.ts+import type {TurboModule, CodegenTypes} from 'react-native';import {TurboModuleRegistry} from 'react-native';+export type KeyValuePair = {+key: string,+value: string,+}export interface Spec extends TurboModule {setItem(value: string, key: string): void;getItem(key: string): string | null;removeItem(key: string): void;clear(): void;+readonly onKeyAdded: CodegenTypes.EventEmitter<KeyValuePair>;}export default TurboModuleRegistry.getEnforcing<Spec>('NativeLocalStorage',);

```
+import type {TurboModule, CodegenTypes} from 'react-native';import {TurboModuleRegistry} from 'react-native';+export type KeyValuePair = {+  key: string,+  value: string,+}export interface Spec extends TurboModule {  setItem(value: string, key: string): void;  getItem(key: string): string | null;  removeItem(key: string): void;  clear(): void;+ readonly onKeyAdded: CodegenTypes.EventEmitter<KeyValuePair>;}export default TurboModuleRegistry.getEnforcing<Spec>(  'NativeLocalStorage',);
```

Open theNativeLocalStorage.jsfile and update it as it follows:NativeLocalStorage.js// @flow+import type {TurboModule, CodegenTypes} from 'react-native';import {TurboModule, TurboModuleRegistry} from 'react-native';+export type KeyValuePair = {+key: string,+value: string,+}export interface Spec extends TurboModule {setItem(value: string, key: string): void;getItem(key: string): ?string;removeItem(key: string): void;clear(): void;+onKeyAdded: CodegenTypes.EventEmitter<KeyValuePair>}export default (TurboModuleRegistry.get<Spec>('NativeLocalStorage'): ?Spec);

```
// @flow+import type {TurboModule, CodegenTypes} from 'react-native';import {TurboModule, TurboModuleRegistry} from 'react-native';+export type KeyValuePair = {+  key: string,+  value: string,+}export interface Spec extends TurboModule {  setItem(value: string, key: string): void;  getItem(key: string): ?string;  removeItem(key: string): void;  clear(): void;+ onKeyAdded: CodegenTypes.EventEmitter<KeyValuePair>}export default (TurboModuleRegistry.get<Spec>(  'NativeLocalStorage'): ?Spec);
```

With theimport typestatement, you are importing theCodegenTypesfromreact-native, which includes theEventEmittertype. This allows you to define theonKeyAddedproperty usingCodegenTypes.EventEmitter<KeyValuePair>, specifying that the event will emit a payload of typeKeyValuePair.

When the event is emitted, you expect for it to receive a parameter of typeKeyValuePair.


## Step 2: Generate Codegen
Given that you have updated the specs for your Native Module, you now have to rerun Codegen to generate the artifacts in the native code.

This is the same process presented in the Native Modules guide.

- AndroidiOS
- iOS
Codegen is executed through thegenerateCodegenArtifactsFromSchemaGradle task:bashcdandroid./gradlew generateCodegenArtifactsFromSchemaBUILD SUCCESSFULin837ms14actionable tasks:3executed,11up-to-dateThis is automatically run when you build your Android application.

```
cd android./gradlew generateCodegenArtifactsFromSchemaBUILD SUCCESSFUL in 837ms14 actionable tasks: 3 executed, 11 up-to-date
```

This is automatically run when you build your Android application.

Codegen is run as part of the script phases that's automatically added to the project generated by CocoaPods.bashcdiosbundleinstallbundleexecpodinstallThe output will look like this:shell...Framework buildtypeis static library[Codegen]Adding script_phases to ReactCodegen.[Codegen]Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen]Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen]SearchingforCodegen-enabled librariesinthe app.[Codegen]Found TurboModuleExample[Codegen]SearchingforCodegen-enabled librariesinthe project dependencies.[Codegen]Found react-native...

```
cd iosbundle installbundle exec pod install
```

The output will look like this:shell...Framework buildtypeis static library[Codegen]Adding script_phases to ReactCodegen.[Codegen]Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen]Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen]SearchingforCodegen-enabled librariesinthe app.[Codegen]Found TurboModuleExample[Codegen]SearchingforCodegen-enabled librariesinthe project dependencies.[Codegen]Found react-native...

```
...Framework build type is static library[Codegen] Adding script_phases to ReactCodegen.[Codegen] Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen] Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen] Searching for Codegen-enabled libraries in the app.[Codegen] Found TurboModuleExample[Codegen] Searching for Codegen-enabled libraries in the project dependencies.[Codegen] Found react-native...
```


## Step 3: Update the App code
Now, it's time to update the code of the App to handle the new event.

Open theApp.tsxfile and modify it as it follows:

```
import React from 'react';import {+ Alert,+ EventSubscription,  SafeAreaView,  StyleSheet,  Text,  TextInput,  Button,} from 'react-native';import NativeLocalStorage from './specs/NativeLocalStorage';const EMPTY = '<empty>';function App(): React.JSX.Element {  const [value, setValue] = React.useState<string | null>(null);+ const [key, setKey] = React.useState<string | null>(null);+ const listenerSubscription = React.useRef<null | EventSubscription>(null);+ React.useEffect(() => {+   listenerSubscription.current = NativeLocalStorage?.onKeyAdded((pair) => Alert.alert(`New key added: ${pair.key} with value: ${pair.value}`));+   return  () => {+     listenerSubscription.current?.remove();+     listenerSubscription.current = null;+   }+ }, [])  const [editingValue, setEditingValue] = React.useState<    string | null  >(null);- React.useEffect(() => {-   const storedValue = NativeLocalStorage?.getItem('myKey');-   setValue(storedValue ?? '');- }, []);  function saveValue() {+   if (key == null) {+     Alert.alert('Please enter a key');+     return;+   }    NativeLocalStorage?.setItem(editingValue ?? EMPTY, key);    setValue(editingValue);  }  function clearAll() {    NativeLocalStorage?.clear();    setValue('');  }  function deleteValue() {+   if (key == null) {+     Alert.alert('Please enter a key');+     return;+   }    NativeLocalStorage?.removeItem(key);    setValue('');  }+ function retrieveValue() {+   if (key == null) {+     Alert.alert('Please enter a key');+     return;+   }+   const val = NativeLocalStorage?.getItem(key);+   setValue(val);+ }  return (    <SafeAreaView style={{flex: 1}}>      <Text style={styles.text}>        Current stored value is: {value ?? 'No Value'}      </Text>+     <Text>Key:</Text>+      <TextInput+       placeholder="Enter the key you want to store"+       style={styles.textInput}+       onChangeText={setKey}+     />+     <Text>Value:</Text>      <TextInput        placeholder="Enter the text you want to store"        style={styles.textInput}        onChangeText={setEditingValue}      />      <Button title="Save" onPress={saveValue} />+     <Button title="Retrieve" onPress={retrieveValue} />      <Button title="Delete" onPress={deleteValue} />      <Button title="Clear" onPress={clearAll} />    </SafeAreaView>  );}const styles = StyleSheet.create({  text: {    margin: 10,    fontSize: 20,  },  textInput: {    margin: 10,    height: 40,    borderColor: 'black',    borderWidth: 1,    paddingLeft: 5,    paddingRight: 5,    borderRadius: 5,  },});export default App;
```

There are a few relevant changes to look at:

- You need to import theEventSubscriptiontype fromreact-nativeto handle theEventSubscription
- You need to use auseRefto keep track of theEventSubscriptionreference
- You register the listener using anuseEffecthook. TheonKeyAddedfunction takes a callback with an object of typeKeyValuePairas a function parameter.
- The callback added toonKeyAddedis executed every time the event is emitted from Native to JS.
- In theuseEffectcleanup function, youremovethe event subscription and you set the ref tonull.
The rest of the changes are regular React changes to improve the App for this new feature.


## Step 4: Write your Native Code
With everything prepared, let's start writing native platform code.

- AndroidiOS
- iOS
Assuming you followed the guide for Android described in theNative Modules guide, what's left to do is to plug the code that emit the events in your app.To do so, you have to:Open theNativeLocalStorage.ktfileModify it as it follows:NativeLocalStoragepackage com.nativelocalstorageimport android.content.Contextimport android.content.SharedPreferencesimport com.nativelocalstorage.NativeLocalStorageSpec+import com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.ReactApplicationContext+import com.facebook.react.bridge.WritableMapclass NativeLocalStorageModule(reactContext: ReactApplicationContext) : NativeLocalStorageSpec(reactContext) {override fun getName() = NAMEoverride fun setItem(value: String, key: String) {+var shouldEmit = false+if (getItem(key) != null) {+shouldEmit = true+}val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)val editor = sharedPref.edit()editor.putString(key, value)editor.apply()+if (shouldEmit == true) {+val eventData = Arguments.createMap().apply {+putString("key", key)+putString("value", value)+}+emitOnKeyAdded(eventData)+}}override fun getItem(key: String): String? {val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)val username = sharedPref.getString(key, null)return username.toString()}First, you need to import a couple of types that you need to use to create the eventData that needs to be sent from Native to JS. These imports are:import com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.WritableMapSecondly, you need to implement the logic that actually emits the event to JS. In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a function that expects aReadableMapas a parameter. You can create theReadableMapby using theArguments.createMap()factory method, and use theapplyfunction to populate the map. It's your responsibility to make sure that the the keys you are using in the map are the same properties that are defined in the spec type in JS.

To do so, you have to:Open theNativeLocalStorage.ktfileModify it as it follows:NativeLocalStoragepackage com.nativelocalstorageimport android.content.Contextimport android.content.SharedPreferencesimport com.nativelocalstorage.NativeLocalStorageSpec+import com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.ReactApplicationContext+import com.facebook.react.bridge.WritableMapclass NativeLocalStorageModule(reactContext: ReactApplicationContext) : NativeLocalStorageSpec(reactContext) {override fun getName() = NAMEoverride fun setItem(value: String, key: String) {+var shouldEmit = false+if (getItem(key) != null) {+shouldEmit = true+}val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)val editor = sharedPref.edit()editor.putString(key, value)editor.apply()+if (shouldEmit == true) {+val eventData = Arguments.createMap().apply {+putString("key", key)+putString("value", value)+}+emitOnKeyAdded(eventData)+}}override fun getItem(key: String): String? {val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)val username = sharedPref.getString(key, null)return username.toString()}First, you need to import a couple of types that you need to use to create the eventData that needs to be sent from Native to JS. These imports are:import com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.WritableMapSecondly, you need to implement the logic that actually emits the event to JS. In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a function that expects aReadableMapas a parameter. You can create theReadableMapby using theArguments.createMap()factory method, and use theapplyfunction to populate the map. It's your responsibility to make sure that the the keys you are using in the map are the same properties that are defined in the spec type in JS.

- Open theNativeLocalStorage.ktfile
- Modify it as it follows:
```
package com.nativelocalstorageimport android.content.Contextimport android.content.SharedPreferencesimport com.nativelocalstorage.NativeLocalStorageSpec+import com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.ReactApplicationContext+import com.facebook.react.bridge.WritableMapclass NativeLocalStorageModule(reactContext: ReactApplicationContext) : NativeLocalStorageSpec(reactContext) {  override fun getName() = NAME  override fun setItem(value: String, key: String) {+   var shouldEmit = false+   if (getItem(key) != null) {+       shouldEmit = true+   }    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.putString(key, value)    editor.apply()+   if (shouldEmit == true) {+       val eventData = Arguments.createMap().apply {+           putString("key", key)+           putString("value", value)+       }+       emitOnKeyAdded(eventData)+   }  }  override fun getItem(key: String): String? {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val username = sharedPref.getString(key, null)    return username.toString()  }
```

First, you need to import a couple of types that you need to use to create the eventData that needs to be sent from Native to JS. These imports are:import com.facebook.react.bridge.Argumentsimport com.facebook.react.bridge.WritableMapSecondly, you need to implement the logic that actually emits the event to JS. In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a function that expects aReadableMapas a parameter. You can create theReadableMapby using theArguments.createMap()factory method, and use theapplyfunction to populate the map. It's your responsibility to make sure that the the keys you are using in the map are the same properties that are defined in the spec type in JS.

- import com.facebook.react.bridge.Arguments
- import com.facebook.react.bridge.WritableMap
Secondly, you need to implement the logic that actually emits the event to JS. In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a function that expects aReadableMapas a parameter. You can create theReadableMapby using theArguments.createMap()factory method, and use theapplyfunction to populate the map. It's your responsibility to make sure that the the keys you are using in the map are the same properties that are defined in the spec type in JS.

Assuming you followed the guide for iOS described in theNative Modules guide, what's left to do is to plug the code that emit the events in your app.To do so, you have to:Open theRCTNativeLocalStorage.hfile.Change the base class fromNSObjecttoNativeLocalStorageSpecBaseRCTNativeLocalStorage.h#import <Foundation/Foundation.h>#import <NativeLocalStorageSpec/NativeLocalStorageSpec.h>NS_ASSUME_NONNULL_BEGIN-@interface RCTNativeLocalStorage : NSObject <NativeLocalStorageSpec>+@interface RCTNativeLocalStorage : NativeLocalStorageSpecBase <NativeLocalStorageSpec>@endNS_ASSUME_NONNULL_ENDOpen theRCTNativeLocalStorage.mmfile.Modify it to emit the events when needed, for example:RCTNativeLocalStorage.mm- (void)setItem:(NSString *)value key:(NSString *)key {+BOOL shouldEmitEvent = NO;+if (![self getItem:key]) {+shouldEmitEvent = YES;+}[self.localStorage setObject:value forKey:key];+if (shouldEmitEvent) {+[self emitOnKeyAdded:@{@"key": key, @"value": value}];+}}TheNativeLocalStorageSpecBaseis a base class that provides theemitOnKeyAddedmethod and its basic implementation and boilerplate. Thanks to this class, you don't have to handle all the conversion between Objective-C and JSI that is required to send the event to JS.In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a generic dictionary that you can populate on the native side. It's your responsibility to make sure that the the keys you are using in the dictionary are the same properties that are defined in the spec type in JS.

To do so, you have to:Open theRCTNativeLocalStorage.hfile.Change the base class fromNSObjecttoNativeLocalStorageSpecBaseRCTNativeLocalStorage.h#import <Foundation/Foundation.h>#import <NativeLocalStorageSpec/NativeLocalStorageSpec.h>NS_ASSUME_NONNULL_BEGIN-@interface RCTNativeLocalStorage : NSObject <NativeLocalStorageSpec>+@interface RCTNativeLocalStorage : NativeLocalStorageSpecBase <NativeLocalStorageSpec>@endNS_ASSUME_NONNULL_ENDOpen theRCTNativeLocalStorage.mmfile.Modify it to emit the events when needed, for example:RCTNativeLocalStorage.mm- (void)setItem:(NSString *)value key:(NSString *)key {+BOOL shouldEmitEvent = NO;+if (![self getItem:key]) {+shouldEmitEvent = YES;+}[self.localStorage setObject:value forKey:key];+if (shouldEmitEvent) {+[self emitOnKeyAdded:@{@"key": key, @"value": value}];+}}TheNativeLocalStorageSpecBaseis a base class that provides theemitOnKeyAddedmethod and its basic implementation and boilerplate. Thanks to this class, you don't have to handle all the conversion between Objective-C and JSI that is required to send the event to JS.In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a generic dictionary that you can populate on the native side. It's your responsibility to make sure that the the keys you are using in the dictionary are the same properties that are defined in the spec type in JS.

- Open theRCTNativeLocalStorage.hfile.
- Change the base class fromNSObjecttoNativeLocalStorageSpecBase
```
#import <Foundation/Foundation.h>#import <NativeLocalStorageSpec/NativeLocalStorageSpec.h>NS_ASSUME_NONNULL_BEGIN-@interface RCTNativeLocalStorage : NSObject <NativeLocalStorageSpec>+@interface RCTNativeLocalStorage : NativeLocalStorageSpecBase <NativeLocalStorageSpec>@endNS_ASSUME_NONNULL_END
```

- Open theRCTNativeLocalStorage.mmfile.
- Modify it to emit the events when needed, for example:
```
 - (void)setItem:(NSString *)value key:(NSString *)key {+  BOOL shouldEmitEvent = NO;+  if (![self getItem:key]) {+    shouldEmitEvent = YES;+  }   [self.localStorage setObject:value forKey:key];+  if (shouldEmitEvent) {+    [self emitOnKeyAdded:@{@"key": key, @"value": value}];+  }}
```

TheNativeLocalStorageSpecBaseis a base class that provides theemitOnKeyAddedmethod and its basic implementation and boilerplate. Thanks to this class, you don't have to handle all the conversion between Objective-C and JSI that is required to send the event to JS.In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a generic dictionary that you can populate on the native side. It's your responsibility to make sure that the the keys you are using in the dictionary are the same properties that are defined in the spec type in JS.

In case of complex types, like theKeyValuePairdefined in the specs, Codegen will generate a generic dictionary that you can populate on the native side. It's your responsibility to make sure that the the keys you are using in the dictionary are the same properties that are defined in the spec type in JS.


## Step 5: Run Your App
If you now try to run your app, you should see this behavior.


================================================================================


# Native Modules Lifecycle
Source: https://reactnative.dev/docs/the-new-architecture/native-modules-lifecycle

In React Native, Native Modules are singleton. The Native Module infrastructure lazily creates a Native Module the first time it is accessed and it keeps it around whenever the app requires it. This is a performance optimization that allows us to avoid the overhead of creating Native Modules eagerly, at app start, and it ensure faster startup times.

In a pure React Native app, the Native Modules are created once and they are never destroyed. However, in more complex apps, there might be use cases where the Native Modules are destroyed and recreated. Imagine, for example, a brownfield app that mixes some native views with some React Native surfaces, as presented in theIntegrating with Existing App guide. In that case it might make sense to destroy a React Native instance when the user navigates away from a React Native surface and recreate it when the user navigates back to that surface.

When this happens, Native Modules that are stateless won't cause any issues. However, for stateful Native Modules it might be necessary to properly invalidate the Native Module to ensure that the state is reset and the resources released.

In this guide, you will explore how to initialize and invalidate a Native Module properly. This guide assumes that you are familiar with how to write a Native Modules and you are comfortable writing native code. If you are not familiar with Native Modules, please read theNative Modules guidefirst.


## Android
When it comes to Android, all the Native Modules already implements aTurboModuleinterface that defines two methods:initialize()andinvalidate().

Theinitialize()method is called by the Native Module infrastructure when the Native Module is created. This is the best place to put all the initialization code that needs access to the ReactApplicationContext, for example. These are some Native Modules from core that implements theinitialize()method:BlobModule,NetworkingModule.

Theinvalidate()method is called by the Native Module infrastructure when the Native Module is destroyed. This is the best place to put all the cleanup code, resetting the Native Module state and release resources that are no longer needed, such as memory and files. These are some Native Modules from core that implements theinvalidate()method:DeviceInfoModule,NetworkModule


## iOS
On iOS, Native Modules conforms to theRCTTurboModuleprotocol. However, this protocol does not expose theinitializeandinvalidatemethod that are exposed by the Android'sTurboModuleclass.

Instead, on iOS, there are two additional protocols:RCTInitializingandRCTInvalidating. These protocols are used to define theinitializeandinvalidatemethods, respectively.

If your module needs to run some initialization code, then you can conform to theRCTInitializingprotocol and implement theinitializemethod. To do so, you have to:

- Modify theNativeModule.hfile by adding the following lines:
```
+ #import <React/RCTInitializing.h>//...- @interface NativeModule : NSObject <NativeModuleSpec>+ @interface NativeModule : NSObject <NativeModuleSpec, RCTInitializing>//...@end
```

- Implement theinitializemethod in theNativeModule.mmfile:
```
// ...@implementation NativeModule+- (void)initialize {+ // add the initialization code here+}@end
```

These are some Native Modules from core that implements theinitializemethod:RCTBlobManager,RCTTiming.

If your module needs to run some cleanup code, then you can conform to theRCTInvalidatingprotocol and implement theinvalidatemethod. To do so, you have to:

- Moduify theNativeModule.hfile by adding the following lines:
```
+ #import <React/RCTInvalidating.h>//...- @interface NativeModule : NSObject <NativeModuleSpec>+ @interface NativeModule : NSObject <NativeModuleSpec, RCTInvalidating>//...@end
```

- Implement theinvalidatemethod in theNativeModule.mmfile:
```
// ...@implementation NativeModule+- (void)invalidate {+ // add the cleanup code here+}@end
```

These are some Native Modules from core that implements theinvalidatemethod:RCTAppearance,RCTDeviceInfo.


================================================================================


# Cross-Platform Native Modules (C++)
Source: https://reactnative.dev/docs/the-new-architecture/pure-cxx-modules

Writing a module in C++ is the best way to share platform-agnostic code between Android and iOS. With pure C++ modules, you can write your logic only once and reuse it right away from all the platforms, without the need of writing platform-specific code.

In this guide, we will go through the creation of a pure C++ Turbo Native Module:

- Create the JS specs
- Configure Codegen to generate the scaffolding
- Implement the Native logic
- Register the module in the Android and iOS application
- Test your changes in JS
The rest of this guide assumes that you have created your application running the command:

```
npx @react-native-community/cli@latest init SampleApp --version 0.83
```


## 1. Create the JS specs
Pure C++ Turbo Native Modules are Turbo Native Modules. They need a specification file (also called spec file) so that Codegen can create the scaffolding code for us. The specification file is also what we use to access the Turbo Native Module in JS.

Spec files need to be written in a typed JS dialect. React Native currently supports Flow or TypeScript.

- Inside the root folder of your app, create a new folder calledspecs.
- Create a new file calledNativeSampleModule.tswith the following code:
All Native Turbo Module spec files must have the prefixNative, otherwise Codegen will ignore them.

- TypeScriptFlow
- Flow
```
// @flowimport type {TurboModule} from 'react-native'import { TurboModuleRegistry } from "react-native";export interface Spec extends TurboModule {  +reverseString: (input: string) => string;}export default (TurboModuleRegistry.getEnforcing<Spec>(  "NativeSampleModule"): Spec);
```

```
import {TurboModule, TurboModuleRegistry} from 'react-native';export interface Spec extends TurboModule {  readonly reverseString: (input: string) => string;}export default TurboModuleRegistry.getEnforcing<Spec>(  'NativeSampleModule',);
```


## 2. Configure Codegen
The next step is to configureCodegenin yourpackage.json. Update the file to include:

```
     "start": "react-native start",     "test": "jest"   },   "codegenConfig": {     "name": "AppSpecs",     "type": "modules",     "jsSrcsDir": "specs",     "android": {       "javaPackageName": "com.sampleapp.specs"     }   },   "dependencies": {
```

This configuration tells Codegen to look for spec files in thespecsfolder. It also instructs Codegen to only generate code formodulesand to namespace the generated code asAppSpecs.


## 3. Write the Native Code
Writing a C++ Turbo Native Module allows you to share the code between Android and iOS. Therefore we will be writing the code once, and we will look into what changes we need to apply to the platforms so that the C++ code can be picked up.

- Create a folder namedsharedat the same level as theandroidandiosfolders.
Create a folder namedsharedat the same level as theandroidandiosfolders.

- Inside thesharedfolder, create a new file calledNativeSampleModule.h.shared/NativeSampleModule.h#pragmaonce#include<AppSpecsJSI.h>#include<memory>#include<string>namespacefacebook::react{classNativeSampleModule:publicNativeSampleModuleCxxSpec<NativeSampleModule>{public:NativeSampleModule(std::shared_ptr<CallInvoker>jsInvoker);std::stringreverseString(jsi::Runtime&rt,std::string input);};}// namespace facebook::react
Inside thesharedfolder, create a new file calledNativeSampleModule.h.

```
#pragma once#include <AppSpecsJSI.h>#include <memory>#include <string>namespace facebook::react {class NativeSampleModule : public NativeSampleModuleCxxSpec<NativeSampleModule> {public:  NativeSampleModule(std::shared_ptr<CallInvoker> jsInvoker);  std::string reverseString(jsi::Runtime& rt, std::string input);};} // namespace facebook::react
```

- Inside thesharedfolder, create a new file calledNativeSampleModule.cpp.shared/NativeSampleModule.cpp#include"NativeSampleModule.h"namespacefacebook::react{NativeSampleModule::NativeSampleModule(std::shared_ptr<CallInvoker>jsInvoker):NativeSampleModuleCxxSpec(std::move(jsInvoker)){}std::stringNativeSampleModule::reverseString(jsi::Runtime&rt,std::string input){returnstd::string(input.rbegin(),input.rend());}}// namespace facebook::react
Inside thesharedfolder, create a new file calledNativeSampleModule.cpp.

```
#include "NativeSampleModule.h"namespace facebook::react {NativeSampleModule::NativeSampleModule(std::shared_ptr<CallInvoker> jsInvoker)    : NativeSampleModuleCxxSpec(std::move(jsInvoker)) {}std::string NativeSampleModule::reverseString(jsi::Runtime& rt, std::string input) {  return std::string(input.rbegin(), input.rend());}} // namespace facebook::react
```

Let's have a look at the two files we created:

- TheNativeSampleModule.hfile is the header file for a Pure C++ TurboModule. Theincludestatements make sure that we include the specs that will be created by Codegen and that contains the interface and the base class we need to implement.
- The module lives in thefacebook::reactnamespace to have access to all the types that live in that namespace.
- The classNativeSampleModuleis the actual Turbo Native Module class and it extends theNativeSampleModuleCxxSpecclass which contains some glue code and boilerplate code to let this class behave as a Turbo Native Module.
- Finally, we have the constructor, that accepts a pointer to theCallInvoker, to communicate with JS if needed and the function's prototype we have to implement.
TheNativeSampleModule.cppfile is the actual implementation of our Turbo Native Module and implements the constructor and the method that we declared in the specs.


## 4. Register the Module in the platform
The next steps will let us register the module in the platform. This is the step that exposes the native code to JS so that the React Native application can finally call the native methods from the JS layer.

This is the only time when we will have to write some platform-specific code.


### Android
To make sure that the Android app can effectively build the C++ Turbo Native Module, we need to:

- Create aCMakeLists.txtto access our C++ code.
- Modifybuild.gradleto point to the newly createdCMakeLists.txtfile.
- Create anOnLoad.cppfile in our Android app to register the new Turbo Native Module.
Android uses CMake to build. CMake needs to access the files we defined in our shared folder to be able to build them.

- Create a new folderSampleApp/android/app/src/main/jni. Thejnifolder is where the C++ side of Android lives.
- Create aCMakeLists.txtfile and add this context:
```
cmake_minimum_required(VERSION 3.13)# Define the library name here.project(appmodules)# This file includes all the necessary to let you build your React Native applicationinclude(${REACT_ANDROID_DIR}/cmake-utils/ReactNative-application.cmake)# Define where the additional source code lives. We need to crawl back the jni, main, src, app, android folderstarget_sources(${CMAKE_PROJECT_NAME} PRIVATE ../../../../../shared/NativeSampleModule.cpp)# Define where CMake can find the additional header files. We need to crawl back the jni, main, src, app, android folderstarget_include_directories(${CMAKE_PROJECT_NAME} PUBLIC ../../../../../shared)
```

The CMake file does the following things:

- Defines theappmoduleslibrary, where all the app C++ code will be included.
- Loads the base React Native's CMake file.
- Adds the Module C++ source code that we need to build with thetarget_sourcesdirectives. By default React Native will already populate theappmoduleslibrary with default sources, here we include our custom one. You can see that we need to crawl back from thejnifolder to thesharedfolder where our C++ Turbo Module lives.
- Specifies where CMake can find the module header files. Also in this case we need to crawl back from thejnifolder.
Gradle is the tool that orchestrates the Android build. We need to tell it where it can find theCMakefiles to build the Turbo Native Module.

- Open theSampleApp/android/app/build.gradlefile.
- Add the following block into the Gradle file, within the existingandroidblock:
```
    buildTypes {        debug {            signingConfig signingConfigs.debug        }        release {            // Caution! In production, you need to generate your own keystore file.            // see https://reactnative.dev/docs/signed-apk-android.            signingConfig signingConfigs.debug            minifyEnabled enableProguardInReleaseBuilds            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"        }    }+   externalNativeBuild {+       cmake {+           path "src/main/jni/CMakeLists.txt"+       }+   }}
```

This block tells the Gradle file where to look for the CMake file. The path is relative to the folder where thebuild.gradlefile lives, so we need to add the path to theCMakeLists.txtfiles in thejnifolder.

The final step is to register the new C++ Turbo Native Module in the runtime, so that when JS requires the C++ Turbo Native Module, the app knows where to find it and can return it.

- From the folderSampleApp/android/app/src/main/jni, run the following command:
```
curl -O https://raw.githubusercontent.com/facebook/react-native/v0.83.0/packages/react-native/ReactAndroid/cmake-utils/default-app-setup/OnLoad.cpp
```

- Then, modify this file as follows:
```
#include <DefaultComponentsRegistry.h>#include <DefaultTurboModuleManagerDelegate.h>#include <autolinking.h>#include <fbjni/fbjni.h>#include <react/renderer/componentregistry/ComponentDescriptorProviderRegistry.h>#include <rncore.h>+ // Include the NativeSampleModule header+ #include <NativeSampleModule.h>//...std::shared_ptr<TurboModule> cxxModuleProvider(    const std::string& name,    const std::shared_ptr<CallInvoker>& jsInvoker) {  // Here you can provide your CXX Turbo Modules coming from  // either your application or from external libraries. The approach to follow  // is similar to the following (for a module called `NativeCxxModuleExample`):  //  // if (name == NativeCxxModuleExample::kModuleName) {  //   return std::make_shared<NativeCxxModuleExample>(jsInvoker);  // }+  // This code registers the module so that when the JS side asks for it, the app can return it+  if (name == NativeSampleModule::kModuleName) {+    return std::make_shared<NativeSampleModule>(jsInvoker);+  }  // And we fallback to the CXX module providers autolinked  return autolinking_cxxModuleProvider(name, jsInvoker);}// leave the rest of the file
```

These steps download the originalOnLoad.cppfile from React Native, so that we can safely override it to load the C++ Turbo Native Module in the app.

Once we downloaded the file, we can modify it by:

- Including the header file that points to our module
- Registering the Turbo Native Module so that when JS requires it, the app can return it.
Now, you can runyarn androidfrom the project root to see your app building successfully.


### iOS
To make sure that the iOS app can effectively build the C++ Turbo Native Module, we need to:

- Install pods and run Codegen.
- Add thesharedfolder to our iOS project.
- Register the C++ Turbo Native Module in the application.
The first step we need to run is the usual steps we run every time we have to prepare our iOS application. CocoaPods is the tool we use to setup and install React Native dependencies and, as part of the process, it will also run Codegen for us.

```
cd iosbundle installbundle exec pod install
```

This step adds thesharedfolder to the project to make it visible to Xcode.

- Open the CocoaPods generated Xcode Workspace.
```
cd iosopen SampleApp.xcworkspace
```

- Click on theSampleAppproject on the left and selectAdd files to "Sample App"....
- Select thesharedfolder and click onAdd.
If you did everything right, your project on the left should look like this:

To register a pure Cxx Turbo Native Module in your app, you need to:

- Create aModuleProviderfor the Native Module
- Configure thepackage.jsonto associate the JS module name with the ModuleProvider class.
The ModuleProvider is an Objective-C++ that glues together the Pure C++ module with the rest of your iOS App.

- From Xcode, select theSampleAppproject and press⌘+Nto create a new file.
- Select theCocoa Touch Classtemplate
- Add the nameNativeSampleModuleProvider(keep the other field asSubclass of: NSObjectandLanguage: Objective-C)
- Click Next to generate the files.
- Rename theNativeSampleModuleProvider.mtoNativeSampleModuleProvider.mm. Themmextension denotes an Objective-C++ file.
- Implement the content of theNativeSampleModuleProvider.hwith the following:
```
#import <Foundation/Foundation.h>#import <ReactCommon/RCTTurboModule.h>NS_ASSUME_NONNULL_BEGIN@interface NativeSampleModuleProvider : NSObject <RCTModuleProvider>@endNS_ASSUME_NONNULL_END
```

This declares aNativeSampleModuleProviderobject that conforms to theRCTModuleProviderprotocol.

- Implement the content of theNativeSampleModuleProvider.mmwith the following:
```
#import "NativeSampleModuleProvider.h"#import <ReactCommon/CallInvoker.h>#import <ReactCommon/TurboModule.h>#import "NativeSampleModule.h"@implementation NativeSampleModuleProvider- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:    (const facebook::react::ObjCTurboModule::InitParams &)params{  return std::make_shared<facebook::react::NativeSampleModule>(params.jsInvoker);}@end
```

This code implements theRCTModuleProviderprotocol by creating the pure C++NativeSampleModulewhen thegetTurboModule:method is called.

The last step consists in updating thepackage.jsonto tell React Native about the link between the JS specs of the Native Module and the concrete implementation of those spec in native code.

Modify thepackage.jsonas it follows:

```
     "start": "react-native start",     "test": "jest"   },   "codegenConfig": {     "name": "AppSpecs",     "type": "modules",     "jsSrcsDir": "specs",     "android": {       "javaPackageName": "com.sampleapp.specs"     },     "ios": {        "modulesProvider": {          "NativeSampleModule":  "NativeSampleModuleProvider"        }     }   },   "dependencies": {
```

At this point, you need to re-install the pods to make sure that codegen runs again to generate the new files:

```
# from the ios folderbundle exec pod installopen SampleApp.xcworkspace
```

If you now build your application from Xcode, you should be able to build successfully.


## 5. Testing your Code
It's now time to access our C++ Turbo Native Module from JS. To do so, we have to modify theApp.tsxfile to import the Turbo Native Module and to call it in our code.

- Open theApp.tsxfile.
- Replace the content of the template with the following code:
```
import React from 'react';import {  Button,  SafeAreaView,  StyleSheet,  Text,  TextInput,  View,} from 'react-native';import SampleTurboModule from './specs/NativeSampleModule';function App(): React.JSX.Element {  const [value, setValue] = React.useState('');  const [reversedValue, setReversedValue] = React.useState('');  const onPress = () => {    const revString = SampleTurboModule.reverseString(value);    setReversedValue(revString);  };  return (    <SafeAreaView style={styles.container}>      <View>        <Text style={styles.title}>          Welcome to C++ Turbo Native Module Example        </Text>        <Text>Write down here the text you want to reverse</Text>        <TextInput          style={styles.textInput}          placeholder="Write your text here"          onChangeText={setValue}          value={value}        />        <Button title="Reverse" onPress={onPress} />        <Text>Reversed text: {reversedValue}</Text>      </View>    </SafeAreaView>  );}const styles = StyleSheet.create({  container: {    flex: 1,    justifyContent: 'center',    alignItems: 'center',  },  title: {    fontSize: 18,    marginBottom: 20,  },  textInput: {    borderColor: 'black',    borderWidth: 1,    borderRadius: 5,    padding: 10,    marginTop: 10,  },});export default App;
```

The interesting lines in this app are:

- import SampleTurboModule from './specs/NativeSampleModule';: this line imports the Turbo Native Module in the app,
- const revString = SampleTurboModule.reverseString(value);in theonPresscallback: this is how you can use the Turbo Native Module in your app.
For the sake of this example and to keep it as short as possible, we directly imported the spec file in our app.
The best practice in this case is to create a separate file to wrap the specs and use that file into your application.
This allows you to prepare the input for the specs and gives you more control over them in JS.

Congratulations, you wrote your first C++ Turbo Native Module!


================================================================================


# iOS - Using Swift in Your Native Modules
Source: https://reactnative.dev/docs/the-new-architecture/turbo-modules-with-swift

Swift is the official and default language for developing native application on iOS.

In this guide, you will explore how you can write your Native Modules using Swift.

The core of React Native is mainly written in C++ and the interoperability between Swift and C++ is not great, despite theinteroperability layerdeveloped by Apple.Therefore, the module you are going to write in this guide won't be a pure Swift implementation due to the incompatibilities between the languages. You'll have to write some Objective-C++ glue code but the goal of the guide is to minimize the amount of Objective-C++ code that is needed. If you are migrating an existing Native Modules from the legacy architecture to the New Architecture, this approach should allow you to reuse most of the code.

Therefore, the module you are going to write in this guide won't be a pure Swift implementation due to the incompatibilities between the languages. You'll have to write some Objective-C++ glue code but the goal of the guide is to minimize the amount of Objective-C++ code that is needed. If you are migrating an existing Native Modules from the legacy architecture to the New Architecture, this approach should allow you to reuse most of the code.

This guide starts from the iOS implementation of theNative Moduleguide.
Make sure to be familiar with that guide before diving into this one, potentially implementing the example in the guide.


## The Adapter pattern
The goal is to implement all our business logic using a Swift module and have a thin glue layer in Objective-C++ that is able to connect the app with the Swift implementation.

You can achieve this by leveraging theAdapterdesign pattern, to connect the Swift Module with the Objective-C++ layer.

The Objective-C++ object is created by React Native and it keeps a reference to the Swift module, handling its lifecycle. The Objective-C++ object forwards to the all the methods invocation to Swift.


### Creating the Swift Module
The first step is to move the implementation from the Objective-C++ layer to the Swift Layer.

To achieve that, please follow these steps:

- Create a new empty file in the Xcode project, and call itNativeLocalStorage.swift
- Add the implementation in your Swift module like it follows:
```
import Foundation@objcMembers public class NativeLocalStorage: NSObject {  let userDefaults = UserDefaults(suiteName: "local-storage");  public func getItem(for key: String) -> String? {    return userDefaults?.string(forKey: key)  }  public func setItem(for key: String, value: String) {    userDefaults?.set(value, forKey: key)  }  public func removeItem(for key: String) {    userDefaults?.removeObject(forKey: key)  }  public func clear() {    userDefaults?.dictionaryRepresentation().keys.forEach { removeItem(for: $0) }  }}
```

Notice that you have to declare all the methods that you need to call from Objective-C aspublicand with the@objcannotation.
Remember also to make your class inherit fromNSObject, otherwise it would not be possible to use it from Objective-C.


### Update theRCTNativeLocalStoragefile
Then, you need to update the implementation of theRCTNativeLocalStorageto be able to create the Swift module and to call its methods.

- Open theRCTNativeLocalStorage.mmfile
- Update it as it follows:
```
//  RCTNativeLocalStorage.m//  TurboModuleExample#import "RCTNativeLocalStorage.h"+#import "SampleApp-Swift.h"- static NSString *const RCTNativeLocalStorageKey = @"local-storage";-@interface RCTNativeLocalStorage()-@property (strong, nonatomic) NSUserDefaults *localStorage;-@end-@implementation RCTNativeLocalStorage+@implementation RCTNativeLocalStorage {+    NativeLocalStorage *storage;+}-RCT_EXPORT_MODULE(NativeLocalStorage) - (id) init {   if (self = [super init]) {-    _localStorage = [[NSUserDefaults alloc] initWithSuiteName:RCTNativeLocalStorageKey];+    storage = [NativeLocalStorage new];   }   return self; } - (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {   return std::make_shared<facebook::react::NativeLocalStorageSpecJSI>(params); } - (NSString * _Nullable)getItem:(NSString *)key {-   return [self.localStorage stringForKey:key];+   return [storage getItemFor:key]; } - (void)setItem:(NSString *)value key:(NSString *)key {-   [self.localStorage setObject:value forKey:key];+   [storage setItemFor:key value:value]; } - (void)removeItem:(NSString *)key {-   [self.localStorage removeObjectForKey:key];+   [storage removeItemFor:key]; } - (void)clear {-   NSDictionary *keys = [self.localStorage dictionaryRepresentation];-   for (NSString *key in keys) {-     [self removeItem:key];-   }+  [storage clear]; }++ (NSString *)moduleName+{+  return @"NativeLocalStorage";+}@end
```

The code is not really changed. Instead of creating a reference to theNSUserDefaultsdirectly, you create a newNativeLocalStorageusing the swift implementation and, whenever a native module function is invoked, the invocation is forwarded to theNativeLocalStorageimplemented in Swift.

Remember to import the"SampleApp-Swift.h"header. This is a header automatically generated by Xcode which contains the public API of your Swift files, in a format that is consumable by Objective-C. TheSampleApppart of the header is actually your App name, so if you created the app with a name that isdifferentfromSampleApp, you'll have to change it.

Note also that theRCT_EXPORT_MODULEmacro is not required anymore, because native modules are registered using thepackage.jsonas describedhere.

This approach introduces a bit of code duplication in the interfaces, but it allows you to reuse the Swift code you may already have in your codebase, with little extra effort.


### Implementing the Bridging Header
If you are a library author, developing a native module that is going to be distributed as a separate library, this step is not required.

The last required step to connect the Swift code with the Objective-C++ counterpart is a bridging header.

A bridging header is an header where you can import all the Objective-C header files that needs to be visible by your swift code.

You might already have a bridging header in your codebase, but in case you haven't, you can create a new one by following these steps:

- In Xcode, create a new file and call it"SampleApp-Bridging-Header.h"
- Update the content of the"SampleApp-Bridging-Header.h"like this:
```
////  Use this file to import your target's public headers that you would like to expose to Swift.//+ #import <React-RCTAppDelegate/RCTDefaultReactNativeFactoryDelegate.h>
```

- Link the Bridging header in your project:In the project navigator, select your app name (SampleApp, on the left)Click onBuild SettingsFilter for"Bridging Header"Add the relative path to the "Bridging Header", in the example it isSampleApp-Bridging-Header.h
- In the project navigator, select your app name (SampleApp, on the left)
- Click onBuild Settings
- Filter for"Bridging Header"
- Add the relative path to the "Bridging Header", in the example it isSampleApp-Bridging-Header.h

## Build and Run Your App
Now you can follow the last step of theNative Module's guideand you should see your app running with a Native Module written in Swift.


================================================================================


# Using Codegen
Source: https://reactnative.dev/docs/the-new-architecture/using-codegen

This guide teaches how to:

- ConfigureCodegen.
- Invoke it manually for each platform.
It also describes the generated code.


## Prerequisites
You always need a React Native app to generate the code properly, even when invoking theCodegenmanually.

TheCodegenprocess is tightly coupled with the build of the app, and the scripts are located in thereact-nativeNPM package.

For the sake of this guide, create a project using the React Native CLI as follows:

```
npx @react-native-community/cli@latest init SampleApp --version 0.83
```

Codegenis used to generate the glue-code for your custom modules or components. See the guides for Turbo Native Modules and Fabric Native Components for more details on how to create them.


## ConfiguringCodegen
Codegencan be configured in your app by modifying thepackage.jsonfile.Codegenis controlled by a custom field calledcodegenConfig.

```
  "codegenConfig": {    "name": "<SpecName>",    "type": "<types>",    "jsSrcsDir": "<source_dir>",    "android": {      "javaPackageName": "<java.package.name>"    },    "ios": {      "modules": {        "TestModule": {          "className": "<iOS-class-implementing-the-RCTModuleProvider-protocol>",          "unstableRequiresMainQueueSetup": false,          "conformsToProtocols": ["RCTImageURLLoader", "RCTURLRequestHandler", "RCTImageDataDecoder"],        }      },      "components": {        "TestComponent": {          "className": "<iOS-class-implementing-the-component>"        }      }    }  },
```

You can add this snippet to your app and customize the various fields:

- name:Name of the codegen config. This will customize the codegen output: the filenames, and the code.
- type:modules:Only generate code for modules.components:Only generate code for components.all: Generate code for everything.
- modules:Only generate code for modules.
- components:Only generate code for components.
- all: Generate code for everything.
- jsSrcsDir: The root folder where all your specs live.
- android: Codegen configuration for Android (all optional):.javaPackageName: Configure the package name of the Android Java codegen output.
- .javaPackageName: Configure the package name of the Android Java codegen output.
- ios: Codegen configuration for iOS (all optional):.modules[moduleName]:.className: This module's ObjC class. Or, if it's aC++-only module, itsRCTModuleProviderclass..unstableRequiresMainQueueSetup: Initialize this module on the UI Thread, before running any JavaScript..conformsToProtocols: Annotate which of these protocols this module conforms to any of the following protocols:RCTImageURLLoader,RCTURLRequestHandler,RCTImageDataDecoder..components[componentName]:.className: This component's ObjC class (e.g:TextInput->RCTTextInput).
- .modules[moduleName]:.className: This module's ObjC class. Or, if it's aC++-only module, itsRCTModuleProviderclass..unstableRequiresMainQueueSetup: Initialize this module on the UI Thread, before running any JavaScript..conformsToProtocols: Annotate which of these protocols this module conforms to any of the following protocols:RCTImageURLLoader,RCTURLRequestHandler,RCTImageDataDecoder.
- .className: This module's ObjC class. Or, if it's aC++-only module, itsRCTModuleProviderclass.
- .unstableRequiresMainQueueSetup: Initialize this module on the UI Thread, before running any JavaScript.
- .conformsToProtocols: Annotate which of these protocols this module conforms to any of the following protocols:RCTImageURLLoader,RCTURLRequestHandler,RCTImageDataDecoder.
- .components[componentName]:.className: This component's ObjC class (e.g:TextInput->RCTTextInput).
- .className: This component's ObjC class (e.g:TextInput->RCTTextInput).
WhenCodegenruns, it searches among all the dependencies of the app, looking for JS files that respects some specific conventions, and it generates the required code:

- Turbo Native Modules require that the spec files are prefixed withNative. For example,NativeLocalStorage.tsis a valid name for a spec file.
- Native Fabric Components require that the spec files are suffixed withNativeComponent. For example,WebViewNativeComponent.tsis a valid name for a spec file.

## RunningCodegen
The rest of this guide assumes that you have a Native Turbo Module, a Native Fabric Component or both already set up in your project. We also assume that you have valid specification files in thejsSrcsDirspecified in thepackage.json.


### Android
Codegenfor Android is integrated with the React Native Gradle Plugin (RNGP). The RNGP contains a task that can be invoked that reads the configurations defined in thepackage.jsonfile and executeCodegen. To run the gradle task, first navigate inside theandroidfolder of your project. Then run:

```
./gradlew generateCodegenArtifactsFromSchema
```

This task invokes thegenerateCodegenArtifactsFromSchemacommand on all the imported projects of the app (the app and all the node modules which are linked to it). It generates the code in the correspondingnode_modules/<dependency>folder. For example, if you have a Fabric Native Component whose Node module is calledmy-fabric-component, the generated code is located in theSampleApp/node_modules/my-fabric-component/android/build/generated/source/codegenpath. For the app, the code is generated in theandroid/app/build/generated/source/codegenfolder.

After running the gradle command above, you will find the codegen code in theSampleApp/android/app/buildfolder. The structure will look like this:

```
build└── generated    └── source        └── codegen            ├── java            │   └── com            │       ├── facebook            │       │   └── react            │       │       └── viewmanagers            │       │           ├── <nativeComponent>ManagerDelegate.java            │       │           └── <nativeComponent>ManagerInterface.java            │       └── sampleapp            │           └── NativeLocalStorageSpec.java            ├── jni            │   ├── <codegenConfig.name>-generated.cpp            │   ├── <codegenConfig.name>.h            │   ├── CMakeLists.txt            │   └── react            │       └── renderer            │           └── components            │               └── <codegenConfig.name>            │                   ├── <codegenConfig.name>JSI-generated.cpp            │                   ├── <codegenConfig.name>.h            │                   ├── ComponentDescriptors.cpp            │                   ├── ComponentDescriptors.h            │                   ├── EventEmitters.cpp            │                   ├── EventEmitters.h            │                   ├── Props.cpp            │                   ├── Props.h            │                   ├── ShadowNodes.cpp            │                   ├── ShadowNodes.h            │                   ├── States.cpp            │                   └── States.h            └── schema.json
```

The generated code is split in two folders:

- javawhich contains the platform specific code
- jniwhich contains the C++ code required to let JS and Java interact correctly.
In thejavafolder, you can find the Fabric Native component generated code in thecom/facebook/viewmanagerssubfolder.

- the<nativeComponent>ManagerDelegate.javacontains the methods that theViewManagercan call on the custom Native Component
- the<nativeComponent>ManagerInterface.javacontains the interface of theViewManager.
In the folder whose name was set up in thecodegenConfig.android.javaPackageName, instead, you can find the abstract class that a Turbo Native Module has to implement to carry out its tasks.

In thejnifolder, finally, there is all the boilerplate code to connect JS to Android.

- <codegenConfig.name>.hthis contains the interface of your custom C++ Turbo Native Modules.
- <codegenConfig.name>-generated.cppthis contains the glue code of your custom C++ Turbo Native Modules.
- react/renderer/components/<codegenConfig.name>: this folder contains all the glue-code required by your custom component.
This structure has been generated by using the valueallfor thecodegenConfig.typefield. If you use the valuemodules, expect to see noreact/renderer/components/folder. If you use the valuecomponents, expect not to see any of the other files.


### iOS
Codegenfor iOS relies on some Node scripts that are invoked during the build process. The scripts are located in theSampleApp/node_modules/react-native/scripts/folder.

The main script is thegenerate-codegen-artifacts.jsscript. To invoke the script, you can run this command from the root folder of your app:

```
node node_modules/react-native/scripts/generate-codegen-artifacts.jsUsage: generate-codegen-artifacts.js -p [path to app] -t [target platform] -o [output path]Options:      --help            Show help                                      [boolean]      --version         Show version number                            [boolean]  -p, --path            Path to the React Native project root.        [required]  -t, --targetPlatform  Target platform. Supported values: "android", "ios",                        "all".                                        [required]  -o, --outputPath      Path where generated artifacts will be output to.
```

where:

- --pathis the path to the root folder of your app.
- --outputPathis the destination whereCodegenwill write the generated files.
- --targetPlatformis the platform you'd like to generate the code for.
Running the script with these arguments:

```
node node_modules/react-native/scripts/generate-codegen-artifacts.js \    --path . \    --outputPath ios/ \    --targetPlatform ios
```

Will generate these files in theios/buildfolder:

```
build└── generated    └── ios        ├── <codegenConfig.name>        │   ├── <codegenConfig.name>-generated.mm        │   └── <codegenConfig.name>.h        ├── <codegenConfig.name>JSI-generated.cpp        ├── <codegenConfig.name>JSI.h        ├── FBReactNativeSpec        │   ├── FBReactNativeSpec-generated.mm        │   └── FBReactNativeSpec.h        ├── FBReactNativeSpecJSI-generated.cpp        ├── FBReactNativeSpecJSI.h        ├── RCTModulesConformingToProtocolsProvider.h        ├── RCTModulesConformingToProtocolsProvider.mm        └── react            └── renderer                └── components                    └── <codegenConfig.name>                        ├── ComponentDescriptors.cpp                        ├── ComponentDescriptors.h                        ├── EventEmitters.cpp                        ├── EventEmitters.h                        ├── Props.cpp                        ├── Props.h                        ├── RCTComponentViewHelpers.h                        ├── ShadowNodes.cpp                        ├── ShadowNodes.h                        ├── States.cpp                        └── States.h
```

Part of these generated files are used by React Native in the Core. Then there is a set of files which contains the same name you specified in the package.jsoncodegenConfig.namefield.

- <codegenConfig.name>/<codegenConfig.name>.h: this contains the interface of your custom iOS Turbo Native Modules.
- <codegenConfig.name>/<codegenConfig.name>-generated.mm: this contains the glue code of your custom iOS Turbo Native Modules.
- <codegenConfig.name>JSI.h: this contains the interface of your custom C++ Turbo Native Modules.
- <codegenConfig.name>JSI-generated.h: this contains the glue code of your custom C++ Turbo Native Modules.
- react/renderer/components/<codegenConfig.name>: this folder contains all the glue-code required by your custom component.
This structure has been generated by using the valueallfor thecodegenConfig.typefield. If you use the valuemodules, expect to see noreact/renderer/components/folder. If you use the valuecomponents, expect not to see any of the other files.


================================================================================


# What is Codegen?
Source: https://reactnative.dev/docs/the-new-architecture/what-is-codegen

Codegenis a tool to avoid writing a lot of repetitive code. Using Codegenis not mandatory: you can write all the generated code manually. However, Codegen generates scaffolding code that could save you a lot of time.

React Native invokes Codegen automatically every time an iOS or Android app is built. Occasionally, you would like to manually run the Codegen scripts to know which types and files are actually generated: this is a common scenario when developingTurbo Native Modulesand Fabric Native Components.


## How Codegen Works
Codegenis a process that is tightly coupled with a React Native app. The Codegen scripts live inside thereact-nativeNPM package and the apps call those scripts at build time.

Codegen crawls the folders in your project, starting from a directory you specify in yourpackage.json, looking for some specific JS files that contain the specification (or specs) for your custom modules and components. Spec files are JS files written in a typed dialect: React Native currently supports Flow and TypeScript.

Every time Codegen finds a spec file, it generates boilerplate code associated with it. Codegen generates some C++ glue-code and then it generates platform-specific code, using Java for Android and Objective-C++ for iOS.


================================================================================


# ❌ TimePickerAndroid
Source: https://reactnative.dev/docs/timepickerandroid

Use one of thecommunity packagesinstead.


================================================================================


# Timers
Source: https://reactnative.dev/docs/timers

Timers are an important part of an application and React Native implements thebrowser timers.


## Timers
- setTimeoutandclearTimeout
- setIntervalandclearInterval
- setImmediateandclearImmediate
- requestAnimationFrameandcancelAnimationFrame
requestAnimationFrame(fn)is not the same assetTimeout(fn, 0)- the former will fire after all the frames have flushed, whereas the latter will fire as quickly as possible (over 1000x per second on a iPhone 5S).

setImmediateis executed at the end of the current JavaScript execution block, right before sending the batched response back to native. Note that if you callsetImmediatewithin asetImmediatecallback, it will be executed right away, it won't yield back to native in between.

ThePromiseimplementation usessetImmediateas its asynchronicity implementation.

When debugging on Android, if the times between the debugger and device have drifted; things such as animation, event behavior, etc., might not work properly or the results may not be accurate.
Please correct this by runningadb shell "date `date +%m%d%H%M%Y.%S%3N`"on your debugger machine. Root access is required for the use in real device.


## InteractionManager
TheInteractionManagerbehavior has been changed to be the same assetImmediate, which should be used instead.

One reason why well-built native apps feel so smooth is by avoiding expensive operations during interactions and animations. In React Native, we currently have a limitation that there is only a single JS execution thread, but you can useInteractionManagerto make sure long-running work is scheduled to start after any interactions/animations have completed.

Applications can schedule tasks to run after interactions with the following:

```
InteractionManager.runAfterInteractions(() => {  // ...long-running synchronous task...});
```

Compare this to other scheduling alternatives:

- requestAnimationFrame(): for code that animates a view over time.
- setImmediate/setTimeout/setInterval(): run code later, note this may delay animations.
- runAfterInteractions(): run code later, without delaying active animations.
The touch handling system considers one or more active touches to be an 'interaction' and will delayrunAfterInteractions()callbacks until all touches have ended or been cancelled.

InteractionManageralso allows applications to register animations by creating an interaction 'handle' on animation start, and clearing it upon completion:

```
const handle = InteractionManager.createInteractionHandle();// run animation... (`runAfterInteractions` tasks are queued)// later, on animation completion:InteractionManager.clearInteractionHandle(handle);// queued tasks run if all handles were cleared
```


================================================================================


# ToastAndroid
Source: https://reactnative.dev/docs/toastandroid

React Native's ToastAndroid API exposes the Android platform's ToastAndroid module as a JS module. It provides the methodshow(message, duration)which takes the following parameters:

- messageA string with the text to toast
- durationThe duration of the toast—eitherToastAndroid.SHORTorToastAndroid.LONG
You can alternatively useshowWithGravity(message, duration, gravity)to specify where the toast appears in the screen's layout. May beToastAndroid.TOP,ToastAndroid.BOTTOMorToastAndroid.CENTER.

TheshowWithGravityAndOffset(message, duration, gravity, xOffset, yOffset)method adds the ability to specify an offset with in pixels.

Starting with Android 11 (API level 30), setting the gravity has no effect on text toasts. Read about the changeshere.


## Methods

### show()
```
static show(message: string, duration: number);
```


### showWithGravity()
This property will only work on Android API 29 and below. For similar functionality on higher Android APIs, consider using snackbar or notification.

```
static showWithGravity(message: string, duration: number, gravity: number);
```


### showWithGravityAndOffset()
This property will only work on Android API 29 and below. For similar functionality on higher Android APIs, consider using snackbar or notification.

```
static showWithGravityAndOffset(  message: string,  duration: number,  gravity: number,  xOffset: number,  yOffset: number,);
```


## Properties

### SHORT
Indicates the duration on the screen.

```
static SHORT: number;
```


### LONG
Indicates the duration on the screen.

```
static LONG: number;
```


### TOP
Indicates the position on the screen.

```
static TOP: number;
```


### BOTTOM
Indicates the position on the screen.

```
static BOTTOM: number;
```


### CENTER
Indicates the position on the screen.

```
static CENTER: number;
```


================================================================================


# TouchableHighlight
Source: https://reactnative.dev/docs/touchablehighlight

If you're looking for a more extensive and future-proof way to handle touch-based input, check out thePressableAPI.

A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, which allows the underlay color to show through, darkening or tinting the view.

The underlay comes from wrapping the child in a new View, which can affect layout, and sometimes cause unwanted visual artifacts if not used correctly, for example if the backgroundColor of the wrapped view isn't explicitly set to an opaque color.

TouchableHighlight must have one child (not zero or more than one). If you wish to have several child components, wrap them in a View.

```
function MyComponent(props: MyComponentProps) {  return (    <View {...props} style={{flex: 1, backgroundColor: '#fff'}}>      <Text>My Component</Text>    </View>  );}<TouchableHighlight  activeOpacity={0.6}  underlayColor="#DDDDDD"  onPress={() => alert('Pressed!')}>  <MyComponent /></TouchableHighlight>;
```


## Example

## Props

### TouchableWithoutFeedback Props
InheritsTouchableWithoutFeedback Props.


### activeOpacity
Determines what the opacity of the wrapped view should be when touch is active. The value should be between 0 and 1. Defaults to 0.85. RequiresunderlayColorto be set.


### onHideUnderlay
Called immediately after the underlay is hidden.


### onShowUnderlay
Called immediately after the underlay is shown.


### ref
A ref setter that will be assigned anelement nodewhen mounted.


### style

### underlayColor
The color of the underlay that will show through when the touch is active.


### hasTVPreferredFocusiOS
(Apple TV only)TV preferred focus (see documentation for the View component).


### nextFocusDownAndroid
TV next focus down (see documentation for the View component).


### nextFocusForwardAndroid
TV next focus forward (see documentation for the View component).


### nextFocusLeftAndroid
TV next focus left (see documentation for the View component).


### nextFocusRightAndroid
TV next focus right (see documentation for the View component).


### nextFocusUpAndroid
TV next focus up (see documentation for the View component).


### testOnly_pressed
Handy for snapshot tests.


================================================================================


# TouchableNativeFeedback
Source: https://reactnative.dev/docs/touchablenativefeedback

If you're looking for a more extensive and future-proof way to handle touch-based input, check out thePressableAPI.

A wrapper for making views respond properly to touches (Android only). On Android this component uses native state drawable to display touch feedback.

At the moment it only supports having a single View instance as a child node, as it's implemented by replacing that View with another instance of RCTView node with some additional properties set.

Background drawable of native feedback touchable can be customized withbackgroundproperty.


## Example

## Props

### TouchableWithoutFeedback Props
InheritsTouchableWithoutFeedback Props.


### background
Determines the type of background drawable that's going to be used to display feedback. It takes an object withtypeproperty and extra data depending on thetype. It's recommended to use one of the static methods to generate that dictionary.


### useForeground
Set to true to add the ripple effect to the foreground of the view, instead of the background. This is useful if one of your child views has a background of its own, or you're e.g. displaying images, and you don't want the ripple to be covered by them.

Check TouchableNativeFeedback.canUseNativeForeground() first, as this is only available on Android 6.0 and above. If you try to use this on older versions you will get a warning and fallback to background.


### hasTVPreferredFocusAndroid
TV preferred focus (see documentation for the View component).


### nextFocusDownAndroid
TV next focus down (see documentation for the View component).


### nextFocusForwardAndroid
TV next focus forward (see documentation for the View component).


### nextFocusLeftAndroid
TV next focus left (see documentation for the View component).


### nextFocusRightAndroid
TV next focus right (see documentation for the View component).


### nextFocusUpAndroid
TV next focus up (see documentation for the View component).


## Methods

### SelectableBackground()
```
static SelectableBackground(  rippleRadius: number | null,): ThemeAttributeBackgroundPropType;
```

Creates an object that represents android theme's default background for selectable elements (?android:attr/selectableItemBackground).rippleRadiusparameter controls the radius of the ripple effect.


### SelectableBackgroundBorderless()
```
static SelectableBackgroundBorderless(  rippleRadius: number | null,): ThemeAttributeBackgroundPropType;
```

Creates an object that represent android theme's default background for borderless selectable elements (?android:attr/selectableItemBackgroundBorderless). Available on android API level 21+.rippleRadiusparameter controls the radius of the ripple effect.


### Ripple()
```
static Ripple(  color: ColorValue,  borderless: boolean,  rippleRadius?: number | null,): RippleBackgroundPropType;
```

Creates an object that represents ripple drawable with specified color (as a string). If propertyborderlessevaluates to true the ripple will render outside of the view bounds (see native actionbar buttons as an example of that behavior). This background type is available on Android API level 21+.

Parameters:


### canUseNativeForeground()
```
static canUseNativeForeground(): boolean;
```


================================================================================


# TouchableOpacity
Source: https://reactnative.dev/docs/touchableopacity

If you're looking for a more extensive and future-proof way to handle touch-based input, check out thePressableAPI.

A wrapper for making views respond properly to touches. On press down, the opacity of the wrapped view is decreased, dimming it.

Opacity is controlled by wrapping the children in anAnimated.View, which is added to the view hierarchy. Be aware that this can affect layout.


## Example

## Props

### TouchableWithoutFeedback Props
InheritsTouchableWithoutFeedback Props.


### style

### activeOpacity
Determines what the opacity of the wrapped view should be when touch is active. Defaults to0.2.


### hasTVPreferredFocusiOS
(Apple TV only)TV preferred focus (see documentation for the View component).


### nextFocusDownAndroid
TV next focus down (see documentation for the View component).


### nextFocusForwardAndroid
TV next focus forward (see documentation for the View component).


### nextFocusLeftAndroid
TV next focus left (see documentation for the View component).


### nextFocusRightAndroid
TV next focus right (see documentation for the View component).


### nextFocusUpAndroid
TV next focus up (see documentation for the View component).


### ref
A ref setter that will be assigned anelement nodewhen mounted.


================================================================================


# TouchableWithoutFeedback
Source: https://reactnative.dev/docs/touchablewithoutfeedback

If you're looking for a more extensive and future-proof way to handle touch-based input, check out thePressableAPI.

Do not use unless you have a very good reason. All elements that respond to press should have a visual feedback when touched.

TouchableWithoutFeedbacksupports only one child. If you wish to have several child components, wrap them in a View. Importantly,TouchableWithoutFeedbackworks by cloning its child and applying responder props to it. It is therefore required that any intermediary components pass through those props to the underlying React Native component.


## Usage Pattern
```
function MyComponent(props: MyComponentProps) {  return (    <View {...props} style={{flex: 1, backgroundColor: '#fff'}}>      <Text>My Component</Text>    </View>  );}<TouchableWithoutFeedback onPress={() => alert('Pressed!')}>  <MyComponent /></TouchableWithoutFeedback>;
```


## Example

## Props

### accessibilityIgnoresInvertColorsiOS
A value indicating this view should or should not be inverted when color inversion is turned on. A value oftruewill tell the view to not be inverted even if color inversion is turned on.

See theAccessibility guidefor more information.


### accessible
Whentrue, indicates that the view is an accessibility element. By default, all the touchable elements are accessible.


### accessibilityLabel
Overrides the text that's read by the screen reader when the user interacts with the element. By default, the label is constructed by traversing all the children and accumulating all theTextnodes separated by space.


### accessibilityLanguageiOS
A value indicating which language should be used by the screen reader when the user interacts with the element. It should follow theBCP 47 specification.

See theiOSaccessibilityLanguagedocfor more information.


### accessibilityHint
An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not clear from the accessibility label.


### accessibilityRole
accessibilityRolecommunicates the purpose of a component to the user of an assistive technology.

accessibilityRolecan be one of the following:

- 'none'- Used when the element has no role.
- 'button'- Used when the element should be treated as a button.
- 'link'- Used when the element should be treated as a link.
- 'search'- Used when the text field element should also be treated as a search field.
- 'image'- Used when the element should be treated as an image. Can be combined with button or link, for example.
- 'keyboardkey'- Used when the element acts as a keyboard key.
- 'text'- Used when the element should be treated as static text that cannot change.
- 'adjustable'- Used when an element can be "adjusted" (e.g. a slider).
- 'imagebutton'- Used when the element should be treated as a button and is also an image.
- 'header'- Used when an element acts as a header for a content section (e.g. the title of a navigation bar).
- 'summary'- Used when an element can be used to provide a quick summary of current conditions in the app when the app first launches.
- 'alert'- Used when an element contains important text to be presented to the user.
- 'checkbox'- Used when an element represents a checkbox which can be checked, unchecked, or have mixed checked state.
- 'combobox'- Used when an element represents a combo box, which allows the user to select among several choices.
- 'menu'- Used when the component is a menu of choices.
- 'menubar'- Used when a component is a container of multiple menus.
- 'menuitem'- Used to represent an item within a menu.
- 'progressbar'- Used to represent a component which indicates progress of a task.
- 'radio'- Used to represent a radio button.
- 'radiogroup'- Used to represent a group of radio buttons.
- 'scrollbar'- Used to represent a scroll bar.
- 'spinbutton'- Used to represent a button which opens a list of choices.
- 'switch'- Used to represent a switch which can be turned on and off.
- 'tab'- Used to represent a tab.
- 'tablist'- Used to represent a list of tabs.
- 'timer'- Used to represent a timer.
- 'toolbar'- Used to represent a tool bar (a container of action buttons or components).

### accessibilityState
Describes the current state of a component to the user of an assistive technology.

See theAccessibility guidefor more information.


### accessibilityActions
Accessibility actions allow an assistive technology to programmatically invoke the actions of a component. TheaccessibilityActionsproperty should contain a list of action objects. Each action object should contain the field name and label.

See theAccessibility guidefor more information.


### aria-busy
Indicates an element is being modified and that assistive technologies may want to wait until the changes are complete before informing the user about the update.


### aria-checked
Indicates the state of a checkable element. This field can either take a boolean or the "mixed" string to represent mixed checkboxes.


### aria-disabled
Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.


### aria-expanded
Indicates whether an expandable element is currently expanded or collapsed.


### aria-hidden
Indicates whether the element is hidden from assistive technologies.

For example, in a window that contains sibling viewsAandB, settingaria-hiddentotrueon viewBcauses VoiceOver to ignore theBelement and its children.


### aria-label
Defines a string value that labels an interactive element.


### aria-liveAndroid
Indicates that an element will be updated, and describes the types of updates the user agents, assistive technologies, and user can expect from the live region.

- offAccessibility services should not announce changes to this view.
- politeAccessibility services should announce changes to this view.
- assertiveAccessibility services should interrupt ongoing speech to immediately announce changes to this view.

### aria-modaliOS
Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver. Has precedence over theaccessibilityViewIsModalprop.


### aria-selected
Indicates whether a selectable element is currently selected or not.


### onAccessibilityAction
Invoked when the user performs the accessibility actions. The only argument to this function is an event containing the name of the action to perform.

See theAccessibility guidefor more information.


### accessibilityValue
Represents the current value of a component. It can be a textual description of a component's value, or for range-based components, such as sliders and progress bars, it contains range information (minimum, current, and maximum).

See theAccessibility guidefor more information.


### aria-valuemax
Represents the maximum value for range-based components, such as sliders and progress bars. Has precedence over themaxvalue in theaccessibilityValueprop.


### aria-valuemin
Represents the minimum value for range-based components, such as sliders and progress bars. Has precedence over theminvalue in theaccessibilityValueprop.


### aria-valuenow
Represents the current value for range-based components, such as sliders and progress bars. Has precedence over thenowvalue in theaccessibilityValueprop.


### aria-valuetext
Represents the textual description of the component. Has precedence over thetextvalue in theaccessibilityValueprop.


### delayLongPress
Duration (in milliseconds) fromonPressInbeforeonLongPressis called.


### delayPressIn
Duration (in milliseconds), from the start of the touch, beforeonPressInis called.


### delayPressOut
Duration (in milliseconds), from the release of the touch, beforeonPressOutis called.


### disabled
If true, disable all interactions for this component.


### hitSlop
This defines how far your touch can start away from the button. This is added topressRetentionOffsetwhen moving off of the button.

The touch area never extends past the parent view bounds and the Z-index of sibling views always takes precedence if a touch hits two overlapping views.


### id
Used to locate this view from native code. Has precedence overnativeIDprop.


### onBlur
Invoked when the item loses focus.


### onFocus
Invoked when the item receives focus.


### onLayout
Invoked on mount and on layout changes.


### onLongPress
Called if the time afteronPressInlasts longer than 370 milliseconds. This time period can be customized withdelayLongPress.


### onPress
Called when the touch is released, but not if cancelled (e.g. by a scroll that steals the responder lock). The first function argument is an event in form ofPressEvent.


### onPressIn
Called as soon as the touchable element is pressed and invoked even before onPress. This can be useful when making network requests. The first function argument is an event in form ofPressEvent.


### onPressOut
Called as soon as the touch is released even before onPress. The first function argument is an event in form ofPressEvent.


### pressRetentionOffset
When the scroll view is disabled, this defines how far your touch may move off of the button, before deactivating the button. Once deactivated, try moving it back and you'll see that the button is once again reactivated! Move it back and forth several times while the scroll view is disabled. Ensure you pass in a constant to reduce memory allocations.


### nativeID

### testID
Used to locate this view in end-to-end tests.


### touchSoundDisabledAndroid
If true, doesn't play a system sound on touch.


================================================================================


# Transforms
Source: https://reactnative.dev/docs/transforms

Transforms are style properties that will help you modify the appearance and position of your components using 2D or 3D transformations. However, once you apply transforms, the layouts remain the same around the transformed component hence it might overlap with the nearby components. You can apply margin to the transformed component, the nearby components or padding to the container to prevent such overlaps.


## Example

## Transform
transformaccepts an array of transformation objects or space-separated string values. Each object specifies the property that will be transformed as the key, and the value to use in the transformation. Objects should not be combined. Use a single key/value pair per object.

The rotate transformations require a string so that the transform may be expressed in degrees (deg) or radians (rad). For example:

```
{  transform: [{rotateX: '45deg'}, {rotateZ: '0.785398rad'}],}
```

The same could also be achieved using a space-separated string:

```
{  transform: 'rotateX(45deg) rotateZ(0.785398rad)',}
```

The skew transformations require a string so that the transform may be expressed in degrees (deg). For example:

```
{  transform: [{skewX: '45deg'}],}
```


### Matrix Transform
Thematrixtransform accepts a 4x4 transformation matrix as an array of 16 numbers. This allows you to apply complex transformations that combine translation, rotation, scaling, and skewing in a single operation.

The matrix is specified in column-major order:

```
{  transform: [    {      matrix: [        scaleX,        skewY,        0,        0,        skewX,        scaleY,        0,        0,        0,        0,        1,        0,        translateX,        translateY,        0,        1,      ],    },  ];}
```

For example, to apply a combination of scale and skew:

```
{  transform: [    {      matrix: [        1, 0.5, 0, 0, 0.5, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,      ],    },  ];}
```

Matrix transforms are useful when you need to apply pre-calculated transformation matrices, such as those from animation libraries or when building UI editor applications. For basic transformations, it's recommended to use the individual transform properties (scale, rotate, translate, etc.) as they are more readable.


### 🗑️decomposedMatrix,rotation,scaleX,scaleY,transformMatrix,translateX,translateY
Use thetransformprop instead.


## Transform Origin
ThetransformOriginproperty sets the origin for a view's transformations. The transform origin is the point around which a transformation is applied. By default, the origin of a transform iscenter.


### Values
Transform origin supportspx,percentageand keywordstop,left,right,bottom,centervalues.

ThetransformOriginproperty may be specified using one, two, or three values, where each value represents an offset.

- The value must be apx, apercentage, or one of the keywordsleft,center,right,top, andbottom.
```
{  transformOrigin: '20px',  transformOrigin: 'bottom',}
```

- First value (x-offset) must be apx, apercentage, or one of the keywordsleft,center, andright.
- The second value (y-offset) must be apx, apercentage, or one of the keywordstop,center, andbottom.
```
{  transformOrigin: '10px 2px',  transformOrigin: 'left top',  transformOrigin: 'top right',}
```

- The first two values are the same as for the two-value syntax.
- The third value (z-offset) must be apx. It always represents the Z offset.
```
{  transformOrigin: '2px 30% 10px',  transformOrigin: 'right bottom 20px',}
```

transformOriginalso supports an array syntax. It makes it convenient to use it with Animated APIs. It also avoids string parsing, so should be more efficient.

```
{  // Using numeric values  transformOrigin: [10, 30, 40],  // Mixing numeric and percentage values  transformOrigin: [10, '20%', 0],}
```

You may refer to MDN's guide onTransform originfor additional information.


================================================================================


# Troubleshooting
Source: https://reactnative.dev/docs/troubleshooting

These are some common issues you may run into while setting up React Native. If you encounter something that is not listed here, trysearching for the issue in GitHub.


### Port already in use
TheMetro bundlerruns on port 8081. If another process is already using that port, you can either terminate that process, or change the port that the bundler uses.

Run the following command to find the id for the process that is listening on port 8081:

```
sudo lsof -i :8081
```

Then run the following to terminate the process:

```
kill -9 <PID>
```

On Windows you can find the process using port 8081 usingResource Monitorand stop it using Task Manager.

You can configure the bundler to use a port other than 8081 by using theportparameter, from the root of your project run:

- npmYarn
- Yarn
```
npm start -- --port=8088
```

```
yarn start --port 8088
```

You will also need to update your applications to load the JavaScript bundle from the new port. If running on device from Xcode, you can do this by updating occurrences of8081to your chosen port in theios/__App_Name__.xcodeproj/project.pbxprojfile.


### NPM locking error
If you encounter an error such asnpm WARN locking Error: EACCESwhile using the React Native CLI, try running the following:

```
sudo chown -R $USER ~/.npmsudo chown -R $USER /usr/local/lib/node_modules
```


### Missing libraries for React
If you added React Native manually to your project, make sure you have included all the relevant dependencies that you are using, likeRCTText.xcodeproj,RCTImage.xcodeproj. Next, the binaries built by these dependencies have to be linked to your app binary. Use theLinked Frameworks and Binariessection in the Xcode project settings. More detailed steps are here:Linking Libraries.

If you are using CocoaPods, verify that you have added React along with the subspecs to thePodfile. For example, if you were using the<Text />,<Image />andfetch()APIs, you would need to add these in yourPodfile:

```
pod 'React', :path => '../node_modules/react-native', :subspecs => [  'RCTText',  'RCTImage',  'RCTNetwork',  'RCTWebSocket',]
```

Next, make sure you have runpod installand that aPods/directory has been created in your project with React installed. CocoaPods will instruct you to use the generated.xcworkspacefile henceforth to be able to use these installed dependencies.

There is a CocoaPods plugin calledcocoapods-fix-react-nativewhich handles any potential post-fixing of the source code due to differences when using a dependency manager.

In the project's build settings,User Search Header PathsandHeader Search Pathsare two configs that specify where Xcode should look for#importheader files specified in the code. For Pods, CocoaPods uses a default array of specific folders to look in. Verify that this particular config is not overwritten, and that none of the folders configured are too large. If one of the folders is a large folder, Xcode will attempt to recursively search the entire directory and throw above error at some point.

To revert theUser Search Header PathsandHeader Search Pathsbuild settings to their defaults set by CocoaPods - select the entry in the Build Settings panel, and hit delete. It will remove the custom override and return to the CocoaPod defaults.


### No transports available
React Native implements a polyfill for WebSockets. Thesepolyfillsare initialized as part of the react-native module that you include in your application throughimport React from 'react'. If you load another module that requires WebSockets, such asFirebase, be sure to load/require it after react-native:

```
import React from 'react';import Firebase from 'firebase';
```


## Shell Command Unresponsive Exception
If you encounter a ShellCommandUnresponsiveException exception such as:

```
Execution failed for task ':app:installDebug'.  com.android.builder.testing.api.DeviceException: com.android.ddmlib.ShellCommandUnresponsiveException
```

Restart the ADB server by running the following commands in your terminal:

```
adb kill-serveradb start-server
```


## Unable to start react-native package manager (on Linux)

### Case 1: Error "code":"ENOSPC","errno":"ENOSPC"
Issue caused by the number of directoriesinotify(used by watchman on Linux) can monitor. To solve it, run this command in your terminal window

```
echo fs.inotify.max_user_watches=582222 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p
```


### Error: spawnSync ./gradlew EACCES
If you run into issue where executingnpm run androidoryarn androidon macOS throws the above error, try to runsudo chmod +x android/gradlewcommand to makegradlewfiles into executable.


================================================================================


# Turbo Native Modules: Android
Source: https://reactnative.dev/docs/turbo-native-modules-android

Now it's time to write some Android platform code to make surelocalStoragesurvives after the application is closed.

The first step is to implement the generatedNativeLocalStorageSpecinterface:

- JavaKotlin
- Kotlin
```
package com.nativelocalstorage;import android.content.Context;import android.content.SharedPreferences;import com.nativelocalstorage.NativeLocalStorageSpec;import com.facebook.react.bridge.ReactApplicationContext;public class NativeLocalStorageModule extends NativeLocalStorageSpec {  public static final String NAME = "NativeLocalStorage";  public NativeLocalStorageModule(ReactApplicationContext reactContext) {    super(reactContext);  }  @Override  public String getName() {    return NAME;  }  @Override  public void setItem(String value, String key) {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    SharedPreferences.Editor editor = sharedPref.edit();    editor.putString(key, value);    editor.apply();  }  @Override  public String getItem(String key) {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    String username = sharedPref.getString(key, null);    return username;  }  @Override  public void removeItem(String key) {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    sharedPref.edit().remove(key).apply();  }  @Override  public void clear() {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    sharedPref.edit().clear().apply();  }}
```

```
package com.nativelocalstorageimport android.content.Contextimport android.content.SharedPreferencesimport com.nativelocalstorage.NativeLocalStorageSpecimport com.facebook.react.bridge.ReactApplicationContextclass NativeLocalStorageModule(reactContext: ReactApplicationContext) : NativeLocalStorageSpec(reactContext) {  override fun getName() = NAME  override fun setItem(value: String, key: String) {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.putString(key, value)    editor.apply()  }  override fun getItem(key: String): String? {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val username = sharedPref.getString(key, null)    return username.toString()  }  override fun removeItem(key: String) {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.remove(key)    editor.apply()  }  override fun clear() {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.clear()    editor.apply()  }  companion object {    const val NAME = "NativeLocalStorage"  }}
```

Next we need to createNativeLocalStoragePackage. It provides an object to register our Module in the React Native runtime, by wrapping it as a Base Native Package:

- JavaKotlin
- Kotlin
```
package com.nativelocalstorage;import com.facebook.react.BaseReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.model.ReactModuleInfo;import com.facebook.react.module.model.ReactModuleInfoProvider;import java.util.HashMap;import java.util.Map;public class NativeLocalStoragePackage extends BaseReactPackage {  @Override  public NativeModule getModule(String name, ReactApplicationContext reactContext) {    if (name.equals(NativeLocalStorageModule.NAME)) {      return new NativeLocalStorageModule(reactContext);    } else {      return null;    }  }  @Override  public ReactModuleInfoProvider getReactModuleInfoProvider() {    return new ReactModuleInfoProvider() {      @Override      public Map<String, ReactModuleInfo> getReactModuleInfos() {        Map<String, ReactModuleInfo> map = new HashMap<>();        map.put(NativeLocalStorageModule.NAME, new ReactModuleInfo(          NativeLocalStorageModule.NAME,       // name          NativeLocalStorageModule.NAME,       // className          false, // canOverrideExistingModule          false, // needsEagerInit          false, // isCXXModule          true   // isTurboModule        ));        return map;      }    };  }}
```

```
package com.nativelocalstorageimport com.facebook.react.BaseReactPackageimport com.facebook.react.bridge.NativeModuleimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.module.model.ReactModuleInfoimport com.facebook.react.module.model.ReactModuleInfoProviderclass NativeLocalStoragePackage : BaseReactPackage() {  override fun getModule(name: String, reactContext: ReactApplicationContext): NativeModule? =    if (name == NativeLocalStorageModule.NAME) {      NativeLocalStorageModule(reactContext)    } else {      null    }  override fun getReactModuleInfoProvider() = ReactModuleInfoProvider {    mapOf(      NativeLocalStorageModule.NAME to ReactModuleInfo(        name = NativeLocalStorageModule.NAME,        className = NativeLocalStorageModule.NAME,        canOverrideExistingModule = false,        needsEagerInit = false,        isCxxModule = false,        isTurboModule = true      )    )  }}
```

Finally, we need to tell the React Native in our main application how to find thisPackage. We call this "registering" the package in React Native.

In this case, you add it to be returned by thegetPackagesmethod.

Later you’ll learn how to distribute your Native Modules asnpm packages, which our build tooling will autolink for you.

- JavaKotlin
- Kotlin
```
package com.inappmodule;import android.app.Application;import com.facebook.react.PackageList;import com.facebook.react.ReactApplication;import com.facebook.react.ReactHost;import com.facebook.react.ReactNativeHost;import com.facebook.react.ReactPackage;import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;import com.facebook.react.defaults.DefaultReactHost;import com.facebook.react.defaults.DefaultReactNativeHost;import com.facebook.soloader.SoLoader;import com.nativelocalstorage.NativeLocalStoragePackage;import java.util.ArrayList;import java.util.List;public class MainApplication extends Application implements ReactApplication {  private final ReactNativeHost reactNativeHost = new DefaultReactNativeHost(this) {    @Override    public List<ReactPackage> getPackages() {      List<ReactPackage> packages = new PackageList(this).getPackages();      // Packages that cannot be autolinked yet can be added manually here, for example:      // packages.add(new MyReactNativePackage());      packages.add(new NativeLocalStoragePackage());      return packages;    }    @Override    public String getJSMainModuleName() {      return "index";    }    @Override    public boolean getUseDeveloperSupport() {      return BuildConfig.DEBUG;    }    @Override    public boolean isNewArchEnabled() {      return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;    }    @Override    public boolean isHermesEnabled() {      return BuildConfig.IS_HERMES_ENABLED;    }  };  @Override  public ReactHost getReactHost() {    return DefaultReactHost.getDefaultReactHost(getApplicationContext(), reactNativeHost);  }  @Override  public void onCreate() {    super.onCreate();    SoLoader.init(this, false);    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {      // If you opted-in for the New Architecture, we load the native entry point for this app.      DefaultNewArchitectureEntryPoint.load();    }  }}
```

```
package com.inappmoduleimport android.app.Applicationimport com.facebook.react.PackageListimport com.facebook.react.ReactApplicationimport com.facebook.react.ReactHostimport com.facebook.react.ReactNativeHostimport com.facebook.react.ReactPackageimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.loadimport com.facebook.react.defaults.DefaultReactHost.getDefaultReactHostimport com.facebook.react.defaults.DefaultReactNativeHostimport com.facebook.soloader.SoLoaderimport com.nativelocalstorage.NativeLocalStoragePackageclass MainApplication : Application(), ReactApplication {  override val reactNativeHost: ReactNativeHost =      object : DefaultReactNativeHost(this) {        override fun getPackages(): List<ReactPackage> =            PackageList(this).packages.apply {              // Packages that cannot be autolinked yet can be added manually here, for example:              // add(MyReactNativePackage())              add(NativeLocalStoragePackage())            }        override fun getJSMainModuleName(): String = "index"        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED      }  override val reactHost: ReactHost    get() = getDefaultReactHost(applicationContext, reactNativeHost)  override fun onCreate() {    super.onCreate()    SoLoader.init(this, false)    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {      // If you opted-in for the New Architecture, we load the native entry point for this app.      load()    }  }}
```

You can now build and run your code on an emulator:

- npmYarn
- Yarn
```
npm run android
```

```
yarn run android
```


================================================================================


# Native Modules
Source: https://reactnative.dev/docs/turbo-native-modules-introduction

Your React Native application code may need to interact with native platform APIs that aren't provided by React Native or an existing library. You can write the integration code yourself using aTurbo Native Module. This guide will show you how to write one.

The basic steps are:

- define a typed JavaScript specificationusing one of the most popular JavaScript type annotation languages: Flow or TypeScript;
- configure your dependency management system to run Codegen, which converts the specification into native language interfaces;
- write your application codeusing your specification; and
- write your native platform code using the generated interfacesto write and hook your native code into the React Native runtime environment.
Lets work through each of these steps by building an example Turbo Native Module. The rest of this guide assume that you have created your application running the command:

```
npx @react-native-community/cli@latest init TurboModuleExample --version 0.83
```


## Native Persistent Storage
This guide will show you how to write an implementation of theWeb Storage API:localStorage. The API is relatable to a React developer who might be writing application code on your project.

To make this work on mobile, we need to use Android and iOS APIs:

- Android:SharedPreferences, and
- iOS:NSUserDefaults.

### 1. Declare Typed Specification
React Native provides a tool calledCodegen, which takes a specification written in TypeScript or Flow and generates platform specific code for Android and iOS. The specification declares the methods and data types that will pass back and forth between your native code and the React Native JavaScript runtime. A Turbo Native Module is both your specification, the native code you write, and the Codegen interfaces generated from your specification.

To create a specs file:

- Inside the root folder of your app, create a new folder calledspecs.
- Create a new file calledNativeLocalStorage.ts.
You can see all of the types you can use in your specification and the native types that are generated in theAppendixdocumentation.

If you want to change the name of your module and the related specs file, make sure to always use 'Native' as prefix (e.g.NativeStorageorNativeUsersDefault).

Here is an implementation of thelocalStoragespecification:

- TypeScriptFlow
- Flow
```
import type {TurboModule} from 'react-native';import {TurboModuleRegistry} from 'react-native';export interface Spec extends TurboModule {  setItem(value: string, key: string): void;  getItem(key: string): string | null;  removeItem(key: string): void;  clear(): void;}export default TurboModuleRegistry.getEnforcing<Spec>(  'NativeLocalStorage',);
```

```
import type {TurboModule} from 'react-native';import {TurboModule, TurboModuleRegistry} from 'react-native';export interface Spec extends TurboModule {  setItem(value: string, key: string): void;  getItem(key: string): ?string;  removeItem(key: string): void;  clear(): void;}
```


### 2. Configure Codegen to run
The specification is used by the React Native Codegen tools to generate platform specific interfaces and boilerplate for us. To do this, Codegen needs to know where to find our specification and what to do with it. Update yourpackage.jsonto include:

```
     "start": "react-native start",     "test": "jest"   },   "codegenConfig": {     "name": "NativeLocalStorageSpec",     "type": "modules",     "jsSrcsDir": "specs",     "android": {       "javaPackageName": "com.nativelocalstorage"     }   },   "dependencies": {
```

With everything wired up for Codegen, we need to prepare our native code to hook into our generated code.

- AndroidiOS
- iOS
Codegen is executed through thegenerateCodegenArtifactsFromSchemaGradle task:bashcdandroid./gradlew generateCodegenArtifactsFromSchemaBUILD SUCCESSFULin837ms14actionable tasks:3executed,11up-to-dateThis is automatically run when you build your Android application.

```
cd android./gradlew generateCodegenArtifactsFromSchemaBUILD SUCCESSFUL in 837ms14 actionable tasks: 3 executed, 11 up-to-date
```

This is automatically run when you build your Android application.

Codegen is run as part of the script phases that's automatically added to the project generated by CocoaPods.bashcdiosbundleinstallbundleexecpodinstallThe output will look like this:shell...Framework buildtypeis static library[Codegen]Adding script_phases to ReactCodegen.[Codegen]Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen]Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen]Searchingforcodegen-enabled librariesinthe app.[Codegen]Found TurboModuleExample[Codegen]Searchingforcodegen-enabled librariesinthe project dependencies.[Codegen]Found react-native...

```
cd iosbundle installbundle exec pod install
```

The output will look like this:shell...Framework buildtypeis static library[Codegen]Adding script_phases to ReactCodegen.[Codegen]Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen]Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen]Searchingforcodegen-enabled librariesinthe app.[Codegen]Found TurboModuleExample[Codegen]Searchingforcodegen-enabled librariesinthe project dependencies.[Codegen]Found react-native...

```
...Framework build type is static library[Codegen] Adding script_phases to ReactCodegen.[Codegen] Generating ./build/generated/ios/ReactCodegen.podspec.json[Codegen] Analyzing /Users/me/src/TurboModuleExample/package.json[Codegen] Searching for codegen-enabled libraries in the app.[Codegen] Found TurboModuleExample[Codegen] Searching for codegen-enabled libraries in the project dependencies.[Codegen] Found react-native...
```


### 3. Write Application Code using the Turbo Native Module
UsingNativeLocalStorage, here’s a modifiedApp.tsxthat includes some text we want persisted, an input field and some buttons to update this value.

TheTurboModuleRegistrysupports 2 modes of retrieving a Turbo Native Module:

- get<T>(name: string): T | nullwhich will returnnullif the Turbo Native Module is unavailable.
- getEnforcing<T>(name: string): Twhich will throw an exception if the Turbo Native Module is unavailable. This assumes the module is always available.
```
import React from 'react';import {  SafeAreaView,  StyleSheet,  Text,  TextInput,  Button,} from 'react-native';import NativeLocalStorage from './specs/NativeLocalStorage';const EMPTY = '<empty>';function App(): React.JSX.Element {  const [value, setValue] = React.useState<string | null>(null);  const [editingValue, setEditingValue] = React.useState<    string | null  >(null);  React.useEffect(() => {    const storedValue = NativeLocalStorage?.getItem('myKey');    setValue(storedValue ?? '');  }, []);  function saveValue() {    NativeLocalStorage?.setItem(editingValue ?? EMPTY, 'myKey');    setValue(editingValue);  }  function clearAll() {    NativeLocalStorage?.clear();    setValue('');  }  function deleteValue() {    NativeLocalStorage?.removeItem('myKey');    setValue('');  }  return (    <SafeAreaView style={{flex: 1}}>      <Text style={styles.text}>        Current stored value is: {value ?? 'No Value'}      </Text>      <TextInput        placeholder="Enter the text you want to store"        style={styles.textInput}        onChangeText={setEditingValue}      />      <Button title="Save" onPress={saveValue} />      <Button title="Delete" onPress={deleteValue} />      <Button title="Clear" onPress={clearAll} />    </SafeAreaView>  );}const styles = StyleSheet.create({  text: {    margin: 10,    fontSize: 20,  },  textInput: {    margin: 10,    height: 40,    borderColor: 'black',    borderWidth: 1,    paddingLeft: 5,    paddingRight: 5,    borderRadius: 5,  },});export default App;
```


### 4. Write your Native Platform code
With everything prepared, we're going to start writing native platform code. We do this in 2 parts:

This guide shows you how to create a Turbo Native Module that only works with the New Architecture. If you need to support both the New Architecture and the Legacy Architecture, please refer to ourbackwards compatibility guide.

- AndroidiOS
- iOS
Now it's time to write some Android platform code to make surelocalStoragesurvives after the application is closed.

The first step is to implement the generatedNativeLocalStorageSpecinterface:

- JavaKotlin
- Kotlin
```
package com.nativelocalstorage;import android.content.Context;import android.content.SharedPreferences;import com.nativelocalstorage.NativeLocalStorageSpec;import com.facebook.react.bridge.ReactApplicationContext;public class NativeLocalStorageModule extends NativeLocalStorageSpec {  public static final String NAME = "NativeLocalStorage";  public NativeLocalStorageModule(ReactApplicationContext reactContext) {    super(reactContext);  }  @Override  public String getName() {    return NAME;  }  @Override  public void setItem(String value, String key) {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    SharedPreferences.Editor editor = sharedPref.edit();    editor.putString(key, value);    editor.apply();  }  @Override  public String getItem(String key) {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    String username = sharedPref.getString(key, null);    return username;  }  @Override  public void removeItem(String key) {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    sharedPref.edit().remove(key).apply();  }  @Override  public void clear() {    SharedPreferences sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE);    sharedPref.edit().clear().apply();  }}
```

```
package com.nativelocalstorageimport android.content.Contextimport android.content.SharedPreferencesimport com.nativelocalstorage.NativeLocalStorageSpecimport com.facebook.react.bridge.ReactApplicationContextclass NativeLocalStorageModule(reactContext: ReactApplicationContext) : NativeLocalStorageSpec(reactContext) {  override fun getName() = NAME  override fun setItem(value: String, key: String) {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.putString(key, value)    editor.apply()  }  override fun getItem(key: String): String? {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val username = sharedPref.getString(key, null)    return username.toString()  }  override fun removeItem(key: String) {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.remove(key)    editor.apply()  }  override fun clear() {    val sharedPref = getReactApplicationContext().getSharedPreferences("my_prefs", Context.MODE_PRIVATE)    val editor = sharedPref.edit()    editor.clear()    editor.apply()  }  companion object {    const val NAME = "NativeLocalStorage"  }}
```

Next we need to createNativeLocalStoragePackage. It provides an object to register our Module in the React Native runtime, by wrapping it as a Base Native Package:

- JavaKotlin
- Kotlin
```
package com.nativelocalstorage;import com.facebook.react.BaseReactPackage;import com.facebook.react.bridge.NativeModule;import com.facebook.react.bridge.ReactApplicationContext;import com.facebook.react.module.model.ReactModuleInfo;import com.facebook.react.module.model.ReactModuleInfoProvider;import java.util.HashMap;import java.util.Map;public class NativeLocalStoragePackage extends BaseReactPackage {  @Override  public NativeModule getModule(String name, ReactApplicationContext reactContext) {    if (name.equals(NativeLocalStorageModule.NAME)) {      return new NativeLocalStorageModule(reactContext);    } else {      return null;    }  }  @Override  public ReactModuleInfoProvider getReactModuleInfoProvider() {    return new ReactModuleInfoProvider() {      @Override      public Map<String, ReactModuleInfo> getReactModuleInfos() {        Map<String, ReactModuleInfo> map = new HashMap<>();        map.put(NativeLocalStorageModule.NAME, new ReactModuleInfo(          NativeLocalStorageModule.NAME,       // name          NativeLocalStorageModule.NAME,       // className          false, // canOverrideExistingModule          false, // needsEagerInit          false, // isCXXModule          true   // isTurboModule        ));        return map;      }    };  }}
```

```
package com.nativelocalstorageimport com.facebook.react.BaseReactPackageimport com.facebook.react.bridge.NativeModuleimport com.facebook.react.bridge.ReactApplicationContextimport com.facebook.react.module.model.ReactModuleInfoimport com.facebook.react.module.model.ReactModuleInfoProviderclass NativeLocalStoragePackage : BaseReactPackage() {  override fun getModule(name: String, reactContext: ReactApplicationContext): NativeModule? =    if (name == NativeLocalStorageModule.NAME) {      NativeLocalStorageModule(reactContext)    } else {      null    }  override fun getReactModuleInfoProvider() = ReactModuleInfoProvider {    mapOf(      NativeLocalStorageModule.NAME to ReactModuleInfo(        name = NativeLocalStorageModule.NAME,        className = NativeLocalStorageModule.NAME,        canOverrideExistingModule = false,        needsEagerInit = false,        isCxxModule = false,        isTurboModule = true      )    )  }}
```

Finally, we need to tell the React Native in our main application how to find thisPackage. We call this "registering" the package in React Native.

In this case, you add it to be returned by thegetPackagesmethod.

Later you’ll learn how to distribute your Native Modules asnpm packages, which our build tooling will autolink for you.

- JavaKotlin
- Kotlin
```
package com.inappmodule;import android.app.Application;import com.facebook.react.PackageList;import com.facebook.react.ReactApplication;import com.facebook.react.ReactHost;import com.facebook.react.ReactNativeHost;import com.facebook.react.ReactPackage;import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;import com.facebook.react.defaults.DefaultReactHost;import com.facebook.react.defaults.DefaultReactNativeHost;import com.facebook.soloader.SoLoader;import com.nativelocalstorage.NativeLocalStoragePackage;import java.util.ArrayList;import java.util.List;public class MainApplication extends Application implements ReactApplication {  private final ReactNativeHost reactNativeHost = new DefaultReactNativeHost(this) {    @Override    public List<ReactPackage> getPackages() {      List<ReactPackage> packages = new PackageList(this).getPackages();      // Packages that cannot be autolinked yet can be added manually here, for example:      // packages.add(new MyReactNativePackage());      packages.add(new NativeLocalStoragePackage());      return packages;    }    @Override    public String getJSMainModuleName() {      return "index";    }    @Override    public boolean getUseDeveloperSupport() {      return BuildConfig.DEBUG;    }    @Override    public boolean isNewArchEnabled() {      return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;    }    @Override    public boolean isHermesEnabled() {      return BuildConfig.IS_HERMES_ENABLED;    }  };  @Override  public ReactHost getReactHost() {    return DefaultReactHost.getDefaultReactHost(getApplicationContext(), reactNativeHost);  }  @Override  public void onCreate() {    super.onCreate();    SoLoader.init(this, false);    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {      // If you opted-in for the New Architecture, we load the native entry point for this app.      DefaultNewArchitectureEntryPoint.load();    }  }}
```

```
package com.inappmoduleimport android.app.Applicationimport com.facebook.react.PackageListimport com.facebook.react.ReactApplicationimport com.facebook.react.ReactHostimport com.facebook.react.ReactNativeHostimport com.facebook.react.ReactPackageimport com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.loadimport com.facebook.react.defaults.DefaultReactHost.getDefaultReactHostimport com.facebook.react.defaults.DefaultReactNativeHostimport com.facebook.soloader.SoLoaderimport com.nativelocalstorage.NativeLocalStoragePackageclass MainApplication : Application(), ReactApplication {  override val reactNativeHost: ReactNativeHost =      object : DefaultReactNativeHost(this) {        override fun getPackages(): List<ReactPackage> =            PackageList(this).packages.apply {              // Packages that cannot be autolinked yet can be added manually here, for example:              // add(MyReactNativePackage())              add(NativeLocalStoragePackage())            }        override fun getJSMainModuleName(): String = "index"        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED      }  override val reactHost: ReactHost    get() = getDefaultReactHost(applicationContext, reactNativeHost)  override fun onCreate() {    super.onCreate()    SoLoader.init(this, false)    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {      // If you opted-in for the New Architecture, we load the native entry point for this app.      load()    }  }}
```

You can now build and run your code on an emulator:

- npmYarn
- Yarn
```
npm run android
```

```
yarn run android
```

Now it's time to write some iOS platform code to make surelocalStoragesurvives after the application is closed.


## Prepare your Xcode Project
We need to prepare your iOS project using Xcode. After completing these6 stepsyou'll haveRCTNativeLocalStoragethat implements the generatedNativeLocalStorageSpecinterface.

- Open the CocoaPods generated Xcode Workspace:
```
cd iosopen TurboModuleExample.xcworkspace
```

- Right click on app and selectNew Group, call the new groupNativeLocalStorage.
- In theNativeLocalStoragegroup, createNew→File from Template.
- Use theCocoa Touch Class.
- Name the Cocoa Touch ClassRCTNativeLocalStoragewith theObjective-Clanguage.
- RenameRCTNativeLocalStorage.m→RCTNativeLocalStorage.mmmaking it an Objective-C++ file.

## Implement localStorage with NSUserDefaults
Start by updatingRCTNativeLocalStorage.h:

```
//  RCTNativeLocalStorage.h//  TurboModuleExample#import <Foundation/Foundation.h>#import <NativeLocalStorageSpec/NativeLocalStorageSpec.h>NS_ASSUME_NONNULL_BEGIN@interface RCTNativeLocalStorage : NSObject@interface RCTNativeLocalStorage : NSObject <NativeLocalStorageSpec>@end
```

Then update our implementation to useNSUserDefaultswith a customsuite name.

```
//  RCTNativeLocalStorage.m//  TurboModuleExample#import "RCTNativeLocalStorage.h"static NSString *const RCTNativeLocalStorageKey = @"local-storage";@interface RCTNativeLocalStorage()@property (strong, nonatomic) NSUserDefaults *localStorage;@end@implementation RCTNativeLocalStorage- (id) init {  if (self = [super init]) {    _localStorage = [[NSUserDefaults alloc] initWithSuiteName:RCTNativeLocalStorageKey];  }  return self;}- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {  return std::make_shared<facebook::react::NativeLocalStorageSpecJSI>(params);}- (NSString * _Nullable)getItem:(NSString *)key {  return [self.localStorage stringForKey:key];}- (void)setItem:(NSString *)value          key:(NSString *)key {  [self.localStorage setObject:value forKey:key];}- (void)removeItem:(NSString *)key {  [self.localStorage removeObjectForKey:key];}- (void)clear {  NSDictionary *keys = [self.localStorage dictionaryRepresentation];  for (NSString *key in keys) {    [self removeItem:key];  }}+ (NSString *)moduleName{  return @"NativeLocalStorage";}@end
```

Important things to note:

- You can use Xcode to jump to the Codegen@protocol NativeLocalStorageSpec. You can also use Xcode to generate stubs for you.

## Register the Native Module in your app
The last step consist in updating thepackage.jsonto tell React Native about the link between the JS specs of the Native Module and the concrete implementation of those specs in native code.

Modify thepackage.jsonas it follows:

```
     "start": "react-native start",     "test": "jest"   },   "codegenConfig": {     "name": "NativeLocalStorageSpec",     "type": "modules",     "jsSrcsDir": "specs",     "android": {       "javaPackageName": "com.sampleapp.specs"     },     "ios": {        "modulesProvider": {          "NativeLocalStorage": "RCTNativeLocalStorage"        }     }   },   "dependencies": {
```

At this point, you need to re-install the pods to make sure that codegen runs again to generate the new files:

```
# from the ios folderbundle exec pod installopen SampleApp.xcworkspace
```

If you now build your application from Xcode, you should be able to build successfully.


## Build and run your code on a Simulator
- npmYarn
- Yarn
```
npm run ios
```

```
yarn run ios
```


================================================================================


# Turbo Native Modules: iOS
Source: https://reactnative.dev/docs/turbo-native-modules-ios

Now it's time to write some iOS platform code to make surelocalStoragesurvives after the application is closed.


## Prepare your Xcode Project
We need to prepare your iOS project using Xcode. After completing these6 stepsyou'll haveRCTNativeLocalStoragethat implements the generatedNativeLocalStorageSpecinterface.

- Open the CocoaPods generated Xcode Workspace:
```
cd iosopen TurboModuleExample.xcworkspace
```

- Right click on app and selectNew Group, call the new groupNativeLocalStorage.
- In theNativeLocalStoragegroup, createNew→File from Template.
- Use theCocoa Touch Class.
- Name the Cocoa Touch ClassRCTNativeLocalStoragewith theObjective-Clanguage.
- RenameRCTNativeLocalStorage.m→RCTNativeLocalStorage.mmmaking it an Objective-C++ file.

## Implement localStorage with NSUserDefaults
Start by updatingRCTNativeLocalStorage.h:

```
//  RCTNativeLocalStorage.h//  TurboModuleExample#import <Foundation/Foundation.h>#import <NativeLocalStorageSpec/NativeLocalStorageSpec.h>NS_ASSUME_NONNULL_BEGIN@interface RCTNativeLocalStorage : NSObject@interface RCTNativeLocalStorage : NSObject <NativeLocalStorageSpec>@end
```

Then update our implementation to useNSUserDefaultswith a customsuite name.

```
//  RCTNativeLocalStorage.m//  TurboModuleExample#import "RCTNativeLocalStorage.h"static NSString *const RCTNativeLocalStorageKey = @"local-storage";@interface RCTNativeLocalStorage()@property (strong, nonatomic) NSUserDefaults *localStorage;@end@implementation RCTNativeLocalStorage- (id) init {  if (self = [super init]) {    _localStorage = [[NSUserDefaults alloc] initWithSuiteName:RCTNativeLocalStorageKey];  }  return self;}- (std::shared_ptr<facebook::react::TurboModule>)getTurboModule:(const facebook::react::ObjCTurboModule::InitParams &)params {  return std::make_shared<facebook::react::NativeLocalStorageSpecJSI>(params);}- (NSString * _Nullable)getItem:(NSString *)key {  return [self.localStorage stringForKey:key];}- (void)setItem:(NSString *)value          key:(NSString *)key {  [self.localStorage setObject:value forKey:key];}- (void)removeItem:(NSString *)key {  [self.localStorage removeObjectForKey:key];}- (void)clear {  NSDictionary *keys = [self.localStorage dictionaryRepresentation];  for (NSString *key in keys) {    [self removeItem:key];  }}+ (NSString *)moduleName{  return @"NativeLocalStorage";}@end
```

Important things to note:

- You can use Xcode to jump to the Codegen@protocol NativeLocalStorageSpec. You can also use Xcode to generate stubs for you.

## Register the Native Module in your app
The last step consist in updating thepackage.jsonto tell React Native about the link between the JS specs of the Native Module and the concrete implementation of those specs in native code.

Modify thepackage.jsonas it follows:

```
     "start": "react-native start",     "test": "jest"   },   "codegenConfig": {     "name": "NativeLocalStorageSpec",     "type": "modules",     "jsSrcsDir": "specs",     "android": {       "javaPackageName": "com.sampleapp.specs"     },     "ios": {        "modulesProvider": {          "NativeLocalStorage": "RCTNativeLocalStorage"        }     }   },   "dependencies": {
```

At this point, you need to re-install the pods to make sure that codegen runs again to generate the new files:

```
# from the ios folderbundle exec pod installopen SampleApp.xcworkspace
```

If you now build your application from Xcode, you should be able to build successfully.


## Build and run your code on a Simulator
- npmYarn
- Yarn
```
npm run ios
```

```
yarn run ios
```


================================================================================


# Learn the Basics
Source: https://reactnative.dev/docs/tutorial

React Native is like React, but it uses native components instead of web components as building blocks. So to understand the basic structure of a React Native app, you need to understand some of the basic React concepts, like JSX, components,state, andprops. If you already know React, you still need to learn some React Native specific stuff, like the native components. This tutorial is aimed at all audiences, whether you have React experience or not.

Let's do this thing.


## Hello World
In accordance with the ancient traditions of our people, we must first build an app that does nothing except say "Hello, world!". Here it is:

If you are feeling curious, you can play around with sample code directly in the web simulators. You can also paste it into yourApp.jsfile to create a real app on your local machine.


## What's going on here?
- First of all, we need to importReactto be able to useJSX, which will then be transformed to the native components of each platform.
- On line 2, we import theTextandViewcomponents fromreact-native
Then we define theHelloWorldAppfunction, which is afunction componentand behaves in the same way as in React for the web. This function returns aViewcomponent with some styles and aTextas its child.

TheTextcomponent allows us to render a text, while theViewcomponent renders a container. This container has several styles applied, let's analyze what each one is doing.

The first style that we find isflex: 1, theflexprop will define how your items are going to "fill" over the available space along your main axis. Since we only have one container, it will take all the available space of the parent component. In this case, it is the only component, so it will take all the available screen space.

The following style isjustifyContent: "center". This aligns children of a container in the center of the container's main axis. Finally, we havealignItems: "center", which aligns children of a container in the center of the container's cross axis.

Some of the things in here might not look like JavaScript to you. Don't panic.This is the future.

First of all, ES2015 (also known as ES6) is a set of improvements to JavaScript that is now part of the official standard, but not yet supported by all browsers, so often it isn't used yet in web development. React Native ships with ES2015 support, so you can use this stuff without worrying about compatibility.import,export,constandfromin the example above are all ES2015 features. If you aren't familiar with ES2015, you can probably pick it up by reading through sample code like this tutorial has. If you want,this pagehas a good overview of ES2015 features.

The other unusual thing in this code example is<View><Text>Hello world!</Text></View>. This is JSX - a syntax for embedding XML within JavaScript. Many frameworks use a specialized templating language which lets you embed code inside markup language. In React, this is reversed. JSX lets you write your markup language inside code. It looks like HTML on the web, except instead of web things like<div>or<span>, you use React components. In this case,<Text>is aCore Componentthat displays some text andViewis like the<div>or<span>.


## Components
So this code is definingHelloWorldApp, a newComponent. When you're building a React Native app, you'll be making new components a lot. Anything you see on the screen is some sort of component.


## Props
Most components can be customized when they are created, with different parameters. These creation parameters are called props.

Your own components can also useprops. This lets you make a single component that is used in many different places in your app, with slightly different properties in each place. Refer toprops.YOUR_PROP_NAMEin your functional components orthis.props.YOUR_PROP_NAMEin your class components. Here's an example:

- TypeScriptJavaScript
- JavaScript
Usingnameas a prop lets us customize theGreetingcomponent, so we can reuse that component for each of our greetings. This example also uses theGreetingcomponent in JSX. The power to do this is what makes React so cool.

The other new thing going on here is theViewcomponent. AViewis useful as a container for other components, to help control style and layout.

Withpropsand the basicText,Image, andViewcomponents, you can build a wide variety of static screens. To learn how to make your app change over time, you need tolearn about State.


## State
Unlike propsthat are read-onlyand should not be modified, thestateallows React components to change their output over time in response to user actions, network responses and anything else.

In a React component, the props are the variables that we pass from a parent component to a child component. Similarly, the state are also variables, with the difference that they are not passed as parameters, but rather that the component initializes and manages them internally.

```
// ReactJS Counter Example using Hooks!import React, {useState} from 'react';const App = () => {  const [count, setCount] = useState(0);  return (    <div className="container">      <p>You clicked {count} times</p>      <button        onClick={() => setCount(count + 1)}>        Click me!      </button>    </div>  );};// CSS.container {  display: flex;  justify-content: center;  align-items: center;}
```

```
// React Native Counter Example using Hooks!import React, {useState} from 'react';import {View, Text, Button, StyleSheet} from 'react-native';const App = () => {  const [count, setCount] = useState(0);  return (    <View style={styles.container}>      <Text>You clicked {count} times</Text>      <Button        onPress={() => setCount(count + 1)}        title="Click me!"      />    </View>  );};// React Native Stylesconst styles = StyleSheet.create({  container: {    flex: 1,    justifyContent: 'center',    alignItems: 'center',  },});
```

As shown above, there is no difference in handling thestatebetweenReactandReact Native. You can use the state of your components both in classes and in function components usinghooks!

In the following example we will show the same above counter example using classes.


================================================================================


# Using TypeScript
Source: https://reactnative.dev/docs/typescript

TypeScriptis a language which extends JavaScript by adding type definitions. New React Native projects target TypeScript by default, but also support JavaScript and Flow.


## Getting Started with TypeScript
New projects created by theReact Native CLIor popular templates likeIgnitewill use TypeScript by default.

TypeScript may also be used withExpo, which maintains TypeScript templates, or will prompt you to automatically install and configure TypeScript when a.tsor.tsxfile is added to your project.

```
npx create-expo-app --template
```


## Adding TypeScript to an Existing Project
- Add TypeScript, types, and ESLint plugins to your project.
- npmYarn
- Yarn
```
npm install -D typescript @react-native/typescript-config @types/jest @types/react @types/react-test-renderer
```

```
yarn add --dev typescript @react-native/typescript-config @types/jest @types/react @types/react-test-renderer
```

This command adds the latest version of every dependency. The versions may need to be changed to match the existing packages used by your project. You can use a tool likeReact Native Upgrade Helperto see the versions shipped by React Native.

- Add a TypeScript config file. Create atsconfig.jsonin the root of your project:
```
{  "extends": "@react-native/typescript-config"}
```

- Rename a JavaScript file to be*.tsx
You should leave the./index.jsentrypoint file as it is otherwise you may run into an issue when it comes to bundling a production build.

- Runtscto type-check your new TypeScript files.
- npmYarn
- Yarn
```
npx tsc
```

```
yarn tsc
```


## Using JavaScript Instead of TypeScript
React Native defaults new applications to TypeScript, but JavaScript may still be used. Files with a.jsxextension are treated as JavaScript instead of TypeScript, and will not be typechecked. JavaScript modules may still be imported by TypeScript modules, along with the reverse.


## How TypeScript and React Native works
Out of the box, TypeScript sources are transformed byBabelduring bundling. We recommend that you use the TypeScript compiler only for type checking. This is the default behavior oftscfor newly created applications. If you have existing TypeScript code being ported to React Native, there areone or two caveatsto using Babel instead of TypeScript.


## What does React Native + TypeScript look like
You can provide an interface for a React Component'sPropsandStateviaReact.Component<Props, State>which will provide type-checking and editor auto-completing when working with that component in JSX.

```
import {useState} from 'react';import {Button, StyleSheet, Text, View} from 'react-native';export type Props = {  name: string;  baseEnthusiasmLevel?: number;};function Hello({name, baseEnthusiasmLevel = 0}: Props) {  const [enthusiasmLevel, setEnthusiasmLevel] = useState(    baseEnthusiasmLevel,  );  const onIncrement = () =>    setEnthusiasmLevel(enthusiasmLevel + 1);  const onDecrement = () =>    setEnthusiasmLevel(      enthusiasmLevel > 0 ? enthusiasmLevel - 1 : 0,    );  const getExclamationMarks = (numChars: number) =>    numChars > 0 ? Array(numChars + 1).join('!') : '';  return (    <View style={styles.container}>      <Text style={styles.greeting}>        Hello {name}        {getExclamationMarks(enthusiasmLevel)}      </Text>      <View>        <Button          title="Increase enthusiasm"          accessibilityLabel="increment"          onPress={onIncrement}          color="blue"        />        <Button          title="Decrease enthusiasm"          accessibilityLabel="decrement"          onPress={onDecrement}          color="red"        />      </View>    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    alignItems: 'center',    justifyContent: 'center',  },  greeting: {    fontSize: 20,    fontWeight: 'bold',    margin: 16,  },});export default Hello;
```

You can explore the syntax more in theTypeScript playground.


## Where to Find Useful Advice
- TypeScript Handbook
- React's documentation on TypeScript
- React + TypeScript Cheatsheetshas a good overview on how to use React with TypeScript

## Using Custom Path Aliases with TypeScript
To use custom path aliases with TypeScript, you need to set the path aliases to work from both Babel and TypeScript. Here's how:

- Edit yourtsconfig.jsonto have yourcustom path mappings. Set anything in the root ofsrcto be available with no preceding path reference, and allow any test file to be accessed by usingtests/File.tsx:
```
{-  "extends": "@react-native/typescript-config"+  "extends": "@react-native/typescript-config",+  "compilerOptions": {+    "baseUrl": ".",+    "paths": {+      "*": ["src/*"],+      "tests": ["tests/*"],+      "@components/*": ["src/components/*"],+    },+  }}
```

- Addbabel-plugin-module-resolveras a development package to your project:
- npmYarn
- Yarn
```
npm install --save-dev babel-plugin-module-resolver
```

```
yarn add --dev babel-plugin-module-resolver
```

- Finally, configure yourbabel.config.js(note that the syntax for yourbabel.config.jsis different from yourtsconfig.json):
```
{   presets: ['module:metro-react-native-babel-preset'],+  plugins: [+    [+       'module-resolver',+       {+         root: ['./src'],+         extensions: ['.ios.js', '.android.js', '.js', '.ts', '.tsx', '.json'],+         alias: {+           tests: ['./tests/'],+           "@components": "./src/components",+         }+       }+    ]+  ]}
```


================================================================================


# Upgrading to new versions
Source: https://reactnative.dev/docs/upgrading

Upgrading to new versions of React Native will give you access to more APIs, views, developer tools and other goodies. Upgrading requires a small amount of effort, but we try to make it straightforward for you.


## Expo projects
Upgrading your Expo project to a new version of React Native requires updating thereact-native,react, andexpopackage versions in yourpackage.jsonfile. Expo recommends upgrading SDK versions incrementally, one at a time. Doing so will help you pinpoint breakages and issues that arise during the upgrade process. See theUpgrading Expo SDK Walkthroughfor up-to-date information about upgrading your project.


## React Native projects
Because typical React Native projects are essentially made up of an Android project, an iOS project, and a JavaScript project, upgrading can be rather tricky. TheUpgrade Helperis a web tool to help you out when upgrading your apps by providing the full set of changes happening between any two versions. It also shows comments on specific files to help understanding why that change is needed.


### 1. Select the versions
You first need to select from and to which version you wish to upgrade, by default the latest major versions are selected. After selecting you can click the button "Show me how to upgrade".

💡 Major updates will show a "useful content" section on the top with links to help you out when upgrading.


### 2. Upgrade dependencies
The first file that is shown is thepackage.json, it's good to update the dependencies that are showing in there. For example, ifreact-nativeandreactappears as changes then you can install it in your project by running following commands:

- npmYarn
- Yarn
```
# {{VERSION}} and {{REACT_VERSION}} are the release versions showing in the diffnpm install react-native@{{VERSION}}npm install react@{{REACT_VERSION}}
```

```
# {{VERSION}} and {{REACT_VERSION}} are the release versions showing in the diffyarn add react-native@{{VERSION}}yarn add react@{{REACT_VERSION}}
```


### 3. Upgrade your project files
The new release may contain updates to other files that are generated when you runnpx react-native init, those files are listed after thepackage.jsonin theUpgrade Helperpage. If there aren't other changes then you only need to rebuild the project to continue developing. In case there are changes you need to manually apply them into your project.


### Troubleshooting
These sort of errors are usually related to caching, it's recommended to installreact-native-clean-projectto clear all your project's cache and then you can run it again.


================================================================================


# useColorScheme
Source: https://reactnative.dev/docs/usecolorscheme

```
import {useColorScheme} from 'react-native';
```

TheuseColorSchemeReact hook provides and subscribes to color scheme updates from theAppearancemodule. The return value indicates the current user preferred color scheme. The value may be updated later, either through direct user action (e.g. theme selection in device settings) or on a schedule (e.g. light and dark themes that follow the day/night cycle).


### Supported color schemes
- "light": The user prefers a light color theme.
- "dark": The user prefers a dark color theme.
- null: The user has not indicated a preferred color theme.

## Example
You can find a complete example that demonstrates the use of this hook alongside a React context to add support for light and dark themes to your application inAppearanceExample.js.


================================================================================


# useWindowDimensions
Source: https://reactnative.dev/docs/usewindowdimensions

```
import {useWindowDimensions} from 'react-native';
```

useWindowDimensionsautomatically updates all of its values when screen size or font scale changes. You can get your application window's width and height like so:

```
const {height, width} = useWindowDimensions();
```


## Example

## Properties

### fontScale
```
useWindowDimensions().fontScale;
```

The scale of the font currently used. Some operating systems allow users to scale their font sizes larger or smaller for reading comfort. This property will let you know what is in effect.


### height
```
useWindowDimensions().height;
```

The height in pixels of the window or screen your app occupies.


### scale
```
useWindowDimensions().scale;
```

The pixel ratio of the device your app is running on. The values can be:

- 1which indicates that one point equals one pixel (usually PPI/DPI of 96, 76 on some platforms).
- 2or3which indicates a Retina or high DPI display.

### width
```
useWindowDimensions().width;
```

The width in pixels of the window or screen your app occupies.


================================================================================


# Using List Views
Source: https://reactnative.dev/docs/using-a-listview

React Native provides a suite of components for presenting lists of data. Generally, you'll want to use eitherFlatListorSectionList.

TheFlatListcomponent displays a scrolling list of changing, but similarly structured, data.FlatListworks well for long lists of data, where the number of items might change over time. Unlike the more genericScrollView, theFlatListonly renders elements that are currently showing on the screen, not all the elements at once.

TheFlatListcomponent requires two props:dataandrenderItem.datais the source of information for the list.renderItemtakes one item from the source and returns a formatted component to render.

This example creates a basicFlatListof hardcoded data. Each item in thedataprops is rendered as aTextcomponent. TheFlatListBasicscomponent then renders theFlatListand allTextcomponents.

If you want to render a set of data broken into logical sections, maybe with section headers, similar toUITableViewon iOS, then aSectionListis the way to go.

One of the most common uses for a list view is displaying data that you fetch from a server. To do that, you will need tolearn about networking in React Native.


================================================================================


# Using a ScrollView
Source: https://reactnative.dev/docs/using-a-scrollview

TheScrollViewis a generic scrolling container that can contain multiple components and views. The scrollable items can be heterogeneous, and you can scroll both vertically and horizontally (by setting thehorizontalproperty).

This example creates a verticalScrollViewwith both images and text mixed together.

ScrollViews can be configured to allow paging through views using swiping gestures by using thepagingEnabledprops. Swiping horizontally between views can also be implemented on Android using theViewPagercomponent.

On iOS a ScrollView with a single item can be used to allow the user to zoom content. Set up themaximumZoomScaleandminimumZoomScaleprops and your user will be able to use pinch and expand gestures to zoom in and out.

The ScrollView works best to present a small number of things of a limited size. All the elements and views of aScrollVieware rendered, even if they are not currently shown on the screen. If you have a long list of items which cannot fit on the screen, you should use aFlatListinstead. So let'slearn about list viewsnext.


================================================================================


# Vibration
Source: https://reactnative.dev/docs/vibration

Vibrates the device.


## Example
Android apps should request theandroid.permission.VIBRATEpermission by adding<uses-permission android:name="android.permission.VIBRATE"/>toAndroidManifest.xml.

The Vibration API is implemented as aAudioServicesPlaySystemSound(kSystemSoundID_Vibrate)call on iOS.


## Methods

### cancel()
```
static cancel();
```

Call this to stop vibrating after having invokedvibrate()with repetition enabled.


### vibrate()
```
static vibrate(  pattern?: number | number[],  repeat?: boolean);
```

Triggers a vibration with a fixed duration.

On Android,the vibration duration defaults to 400 milliseconds, and an arbitrary vibration duration can be specified by passing a number as the value for thepatternargument.On iOS,the vibration duration is fixed at roughly 400 milliseconds.

Thevibrate()method can take apatternargument with an array of numbers that represent time in milliseconds. You may setrepeatto true to run through the vibration pattern in a loop untilcancel()is called.

On Android,the odd indices of thepatternarray represent the vibration duration, while the even ones represent the separation time.On iOS,the numbers in thepatternarray represent the separation time, as the vibration duration is fixed.

Parameters:


================================================================================


# View
Source: https://reactnative.dev/docs/view

The most fundamental component for building a UI,Viewis a container that supports layout withflexbox,style,some touch handling, andaccessibilitycontrols.Viewmaps directly to the native view equivalent on whatever platform React Native is running on, whether that is aUIView,<div>,android.view, etc.

Viewis designed to be nested inside other views and can have 0 to many children of any type.

This example creates aViewthat wraps two boxes with color and a text component in a row with padding.

Views are designed to be used withStyleSheetfor clarity and performance, although inline styles are also supported.


### Synthetic Touch Events
ForViewresponder props (e.g.,onResponderMove), the synthetic touch event passed to them are in form ofPressEvent.


## Props

### accessibilityActions
Accessibility actions allow an assistive technology to programmatically invoke the actions of a component. TheaccessibilityActionsproperty should contain a list of action objects. Each action object should contain the field name and label.

See theAccessibility guidefor more information.


### accessibilityElementsHiddeniOS
A boolean value indicating whether the given accessibility element, and any accessibility elements it contains, are hidden. Default isfalse.

See theAccessibility guidefor more information.


### accessibilityHint
An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not clear from the accessibility label.


### accessibilityLanguageiOS
A value indicating which language should be used by the screen reader when the user interacts with the element. It should follow theBCP 47 specification.

See theiOSaccessibilityLanguagedocfor more information.


### accessibilityIgnoresInvertColorsiOS
A value indicating this view should or should not be inverted when color inversion is turned on. A value oftruewill tell the view to not be inverted even if color inversion is turned on.

See theAccessibility guidefor more information.


### accessibilityLabel
Overrides the text that's read by the screen reader when the user interacts with the element. By default, the label is constructed by traversing all the children and accumulating all theTextnodes separated by space.


### accessibilityLiveRegionAndroid
Indicates to accessibility services whether the user should be notified when this view changes. Works for Android API >= 19 only. Possible values:

- 'none'- Accessibility services should not announce changes to this view.
- 'polite'- Accessibility services should announce changes to this view.
- 'assertive'- Accessibility services should interrupt ongoing speech to immediately announce changes to this view.
See theAndroidViewdocsfor reference.


### accessibilityRole
accessibilityRolecommunicates the purpose of a component to the user of an assistive technology.

accessibilityRolecan be one of the following:

- 'none'- Used when the element has no role.
- 'button'- Used when the element should be treated as a button.
- 'link'- Used when the element should be treated as a link.
- 'search'- Used when the text field element should also be treated as a search field.
- 'image'- Used when the element should be treated as an image. Can be combined with button or link, for example.
- 'keyboardkey'- Used when the element acts as a keyboard key.
- 'text'- Used when the element should be treated as static text that cannot change.
- 'adjustable'- Used when an element can be "adjusted" (e.g. a slider).
- 'imagebutton'- Used when the element should be treated as a button and is also an image.
- 'header'- Used when an element acts as a header for a content section (e.g. the title of a navigation bar).
- 'summary'- Used when an element can be used to provide a quick summary of current conditions in the app when the app first launches.
- 'alert'- Used when an element contains important text to be presented to the user.
- 'checkbox'- Used when an element represents a checkbox which can be checked, unchecked, or have mixed checked state.
- 'combobox'- Used when an element represents a combo box, which allows the user to select among several choices.
- 'menu'- Used when the component is a menu of choices.
- 'menubar'- Used when a component is a container of multiple menus.
- 'menuitem'- Used to represent an item within a menu.
- 'progressbar'- Used to represent a component which indicates progress of a task.
- 'radio'- Used to represent a radio button.
- 'radiogroup'- Used to represent a group of radio buttons.
- 'scrollbar'- Used to represent a scroll bar.
- 'spinbutton'- Used to represent a button which opens a list of choices.
- 'switch'- Used to represent a switch which can be turned on and off.
- 'tab'- Used to represent a tab.
- 'tablist'- Used to represent a list of tabs.
- 'timer'- Used to represent a timer.
- 'toolbar'- Used to represent a tool bar (a container of action buttons or components).
- 'grid'- Used with ScrollView, VirtualizedList, FlatList, or SectionList to represent a grid. Adds the in/out of grid announcements to the android GridView.

### accessibilityState
Describes the current state of a component to the user of an assistive technology.

See theAccessibility guidefor more information.


### accessibilityValue
Represents the current value of a component. It can be a textual description of a component's value, or for range-based components, such as sliders and progress bars, it contains range information (minimum, current, and maximum).

See theAccessibility guidefor more information.


### accessibilityViewIsModaliOS
A value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver. Default isfalse.

See theAccessibility guidefor more information.


### accessible
Whentrue, indicates that the view is an accessibility element and discoverable by assistive technologies such as screen readers and hardware keyboards. By default, all the touchable elements are accessible.

See theAccessibility guidefor more information.


### aria-busy
Indicates an element is being modified and that assistive technologies may want to wait until the changes are complete before informing the user about the update.


### aria-checked
Indicates the state of a checkable element. This field can either take a boolean or the "mixed" string to represent mixed checkboxes.


### aria-disabled
Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.


### aria-expanded
Indicates whether an expandable element is currently expanded or collapsed.


### aria-hidden
Indicates whether the element is hidden from assistive technologies.

For example, in a window that contains sibling viewsAandB, settingaria-hiddentotrueon viewBcauses VoiceOver to ignore theBelement and its children.


### aria-label
Defines a string value that labels an interactive element.


### aria-labelledbyAndroid
Identifies the element that labels the element it is applied to. The value ofaria-labelledbyshould match thenativeIDof the related element:

```
<View>  <Text nativeID="formLabel">Label for Input Field</Text>  <TextInput aria-label="input" aria-labelledby="formLabel" /></View>
```


### aria-liveAndroid
Indicates that an element will be updated, and describes the types of updates the user agents, assistive technologies, and user can expect from the live region.

- offAccessibility services should not announce changes to this view.
- politeAccessibility services should announce changes to this view.
- assertiveAccessibility services should interrupt ongoing speech to immediately announce changes to this view.

### aria-modaliOS
Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver. Has precedence over theaccessibilityViewIsModalprop.


### aria-selected
Indicates whether a selectable element is currently selected or not.


### aria-valuemax
Represents the maximum value for range-based components, such as sliders and progress bars. Has precedence over themaxvalue in theaccessibilityValueprop.


### aria-valuemin
Represents the minimum value for range-based components, such as sliders and progress bars. Has precedence over theminvalue in theaccessibilityValueprop.


### aria-valuenow
Represents the current value for range-based components, such as sliders and progress bars. Has precedence over thenowvalue in theaccessibilityValueprop.


### aria-valuetext
Represents the textual description of the component. Has precedence over thetextvalue in theaccessibilityValueprop.


### collapsable
Views that are only used to layout their children or otherwise don't draw anything may be automatically removed from the native hierarchy as an optimization. Set this property tofalseto disable this optimization and ensure that thisViewexists in the native view hierarchy.


### collapsableChildren
Setting to false prevents direct children of the view from being removed from the native view hierarchy, similar to the effect of settingcollapsable={false}on each child.


### experimental_accessibilityOrder
This API is experimental.Experimental APIs may contain bugs and are likely to change in a future version of React Native. Don't use them in production.

experimental_accessibilityOrderindicates the order in which an assistive technology focuses descendants of thisView. This prop takes an array of strings where each string is anativeIDof some descendant component whose order is being defined. This prop does not enable accessibility itself, each referenced component still needs to be accessible by settingaccessibleto true. This prop is bothnestableandexhaustivemeaning

- Ifexperimental_accessibilityOrdercontains a reference to some non-accessible component, it will focus the descendants of that component in the default order. Additionally, it can also contain a reference to other components that also have anexperimental_accessibilityOrder.
- If some component that is otherwise accessible is not directly referenced inexperimental_accessibilityOrder, or nested within some container directly referenced inexperimental_accessibilityOrder, then it will not be accessible.
See theaccessibility guidefor more information.


### focusableAndroid
Whether thisViewshould be focusable with a non-touch input device, eg. receive focus with a hardware keyboard.


### hitSlop
This defines how far a touch event can start away from the view. Typical interface guidelines recommend touch targets that are at least 30 - 40 points/density-independent pixels.

For example, if a touchable view has a height of 20 the touchable height can be extended to 40 withhitSlop={{top: 10, bottom: 10, left: 0, right: 0}}

The touch area never extends past the parent view bounds, and the Z-index of sibling views always takes precedence if a touch hits two overlapping views.


### id
Used to locate this view from native classes. Has precedence overnativeIDprop.

This disables the 'layout-only view removal' optimization for this view!


### importantForAccessibilityAndroid
Controls how view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen. Works for Android only.

Possible values:

- 'auto'- The system determines whether the view is important for accessibility - default (recommended).
- 'yes'- The view is important for accessibility.
- 'no'- The view is not important for accessibility.
- 'no-hide-descendants'- The view is not important for accessibility, nor are any of its descendant views.
See theAndroidimportantForAccessibilitydocsfor reference.


### nativeID
Used to locate this view from native classes.

This disables the 'layout-only view removal' optimization for this view!


### needsOffscreenAlphaCompositing
Whether thisViewneeds to rendered offscreen and composited with an alpha in order to preserve 100% correct colors and blending behavior. The default (false) falls back to drawing the component and its children with an alpha applied to the paint used to draw each element instead of rendering the full component offscreen and compositing it back with an alpha value. This default may be noticeable and undesired in the case where theViewyou are setting an opacity on has multiple overlapping elements (e.g. multiple overlappingViews, or text and a background).

Rendering offscreen to preserve correct alpha behavior is extremely expensive and hard to debug for non-native developers, which is why it is not turned on by default. If you do need to enable this property for an animation, consider combining it with renderToHardwareTextureAndroid if the viewcontentsare static (i.e. it doesn't need to be redrawn each frame). If that property is enabled, this View will be rendered off-screen once, saved in a hardware texture, and then composited onto the screen with an alpha each frame without having to switch rendering targets on the GPU.


### nextFocusDownAndroid
Designates the next view to receive focus when the user navigates down. See theAndroid documentation.


### nextFocusForwardAndroid
Designates the next view to receive focus when the user navigates forward. See theAndroid documentation.


### nextFocusLeftAndroid
Designates the next view to receive focus when the user navigates left. See theAndroid documentation.


### nextFocusRightAndroid
Designates the next view to receive focus when the user navigates right. See theAndroid documentation.


### nextFocusUpAndroid
Designates the next view to receive focus when the user navigates up. See theAndroid documentation.


### onAccessibilityAction
Invoked when the user performs the accessibility actions. The only argument to this function is an event containing the name of the action to perform.

See theAccessibility guidefor more information.


### onAccessibilityEscapeiOS
Whenaccessibleistrue, the system will invoke this function when the user performs the escape gesture.


### onAccessibilityTapiOS
Whenaccessibleis true, the system will try to invoke this function when the user performs accessibility tap gesture.


### onLayout
Invoked on mount and on layout changes.

This event is fired immediately once the layout has been calculated, but the new layout may not yet be reflected on the screen at the time the event is received, especially if a layout animation is in progress.


### onMagicTapiOS
Whenaccessibleistrue, the system will invoke this function when the user performs the magic tap gesture.


### onMoveShouldSetResponder
Does this view want to "claim" touch responsiveness? This is called for every touch move on theViewwhen it is not the responder.


### onMoveShouldSetResponderCapture
If a parentViewwants to prevent a childViewfrom becoming responder on a move, it should have this handler which returnstrue.


### onResponderGrant
The View is now responding for touch events. This is the time to highlight and show the user what is happening.

On Android, return true from this callback to prevent any other native components from becoming responder until this responder terminates.


### onResponderMove
The user is moving their finger.


### onResponderReject
Another responder is already active and will not release it to thatViewasking to be the responder.


### onResponderRelease
Fired at the end of the touch.


### onResponderTerminate
The responder has been taken from theView. Might be taken by other views after a call toonResponderTerminationRequest, or might be taken by the OS without asking (e.g., happens with control center/ notification center on iOS)


### onResponderTerminationRequest
Some otherViewwants to become responder and is asking thisViewto release its responder. Returningtrueallows its release.


### onStartShouldSetResponder
Does this view want to become responder on the start of a touch?


### onStartShouldSetResponderCapture
If a parentViewwants to prevent a childViewfrom becoming responder on a touch start, it should have this handler which returnstrue.


### pointerEvents
Controls whether theViewcan be the target of touch events.

- 'auto': The View can be the target of touch events.
- 'none': The View is never the target of touch events.
- 'box-none': The View is never the target of touch events but its subviews can be. It behaves like if the view had the following classes in CSS:
```
.box-none {  pointer-events: none;}.box-none * {  pointer-events: auto;}
```

- 'box-only': The view can be the target of touch events but its subviews cannot be. It behaves like if the view had the following classes in CSS:
```
.box-only {  pointer-events: auto;}.box-only * {  pointer-events: none;}
```


### ref
A ref setter that will be assigned anelement nodewhen mounted.


### removeClippedSubviews
This is a reserved performance property exposed byRCTViewand is useful for scrolling content when there are many subviews, most of which are offscreen. For this property to be effective, it must be applied to a view that contains many subviews that extend outside its bound. The subviews must also haveoverflow: hidden, as should the containing view (or one of its superviews).


### renderToHardwareTextureAndroidAndroid
Whether thisViewshould render itself (and all of its children) into a single hardware texture on the GPU.

On Android, this is useful for animations and interactions that only modify opacity, rotation, translation, and/or scale: in those cases, the view doesn't have to be redrawn and display lists don't need to be re-executed. The texture can be re-used and re-composited with different parameters. The downside is that this can use up limited video memory, so this prop should be set back to false at the end of the interaction/animation.


### role
rolecommunicates the purpose of a component to the user of an assistive technology. Has precedence over theaccessibilityRoleprop.


### shouldRasterizeIOSiOS
Whether thisViewshould be rendered as a bitmap before compositing.

On iOS, this is useful for animations and interactions that do not modify this component's dimensions nor its children; for example, when translating the position of a static view, rasterization allows the renderer to reuse a cached bitmap of a static view and quickly composite it during each frame.

Rasterization incurs an off-screen drawing pass and the bitmap consumes memory. Test and measure when using this property.


### style

### tabIndexAndroid
Whether thisViewshould be focusable with a non-touch input device, eg. receive focus with a hardware keyboard.
Supports the following values:

- 0- View is focusable
- -1- View is not focusable

### testID
Used to locate this view in end-to-end tests.

This disables the 'layout-only view removal' optimization for this view!


================================================================================


# View Style Props
Source: https://reactnative.dev/docs/view-style-props


### Example

## Props

### backfaceVisibility

### backgroundColor

### borderBottomColor

### borderBlockColor

### borderBlockEndColor

### borderBlockStartColor

### borderBottomEndRadius

### borderBottomLeftRadius

### borderBottomRightRadius

### borderBottomStartRadius

### borderStartEndRadius

### borderStartStartRadius

### borderEndEndRadius

### borderEndStartRadius

### borderBottomWidth

### borderColor

### borderCurveiOS
On iOS 13+, it is possible to change the corner curve of borders.


### borderEndColor

### borderLeftColor

### borderLeftWidth

### borderRadius
If the rounded border is not visible, try applyingoverflow: 'hidden'as well.


### borderRightColor

### borderRightWidth

### borderStartColor

### borderStyle

### borderTopColor

### borderTopEndRadius

### borderTopLeftRadius

### borderTopRightRadius

### borderTopStartRadius

### borderTopWidth

### borderWidth

### boxShadow
boxShadowis only available on theNew Architecture. Outset shadows are only supported onAndroid 9+. Inset shadows are only supported onAndroid 10+.

Adds a shadow effect to an element, with the ability to control the position, color, size, and blurriness of the shadow. This shadow either appears around the outside or inside of the border box of the element, depending on whether or not the shadow isinset. This is a spec-compliant implementation of theweb style prop of the same name. Read more about all the arguments available in theBoxShadowValuedocumentation.

These shadows can be composed together so that a singleboxShadowcan be comprised of multiple different shadows.

boxShadowtakes either a string which mimics theweb syntaxor an array ofBoxShadowValueobjects.


### cursoriOS
On iOS 17+, Setting topointerallows hover effects when a pointer (such as a trackpad or stylus on iOS, or the users' gaze on visionOS) is over the view.


### elevationAndroid
Sets the elevation of a view, using Android's underlyingelevation API. This adds a drop shadow to the item and affects z-order for overlapping views. Only supported on Android 5.0+, has no effect on earlier versions.


### filter
filteris only available on theNew Architecture

Adds a graphical filter to theView. This filter is comprised of any number offilter functions, which each represent some atomic change to the graphical composition of theView. The complete list of valid filter functions is defined below.filterwill apply to descendants of theViewas well as theViewitself.filterimpliesoverflow: hidden, so descendants will be clipped to fit the bounds of theView.

The following filter functions work across all platforms:

- brightness: Changes the brightness of theView. Takes a non-negative number or percentage.
- opacity: Changes the opacity, or alpha, of theView. Takes a non-negative number or percentage.
Due to issues with performance and spec compliance, these are the only two filter functions available on iOS. There are plans to explore some potential workarounds using SwiftUI instead of UIKit for this implementation.

The following filter functions work on Android only:

- blur: Blurs theViewwith aGaussian blur, where the specified length represents the radius used in the blurring algorithm. Any non-negative DIP value is valid (no percents). The larger the value, the blurrier the result.
- contrast: Changes the contrast of theView. Takes a non-negative number or percentage.
- dropShadow: Adds a shadow around the alpha mask of theView(only non-zero alpha pixels in theViewwill cast a shadow). Takes an optional color representing the shadow color, and 2 or 3 lengths. If 2 lengths are specified they are interpreted asoffsetXandoffsetYwhich will translate the shadow in the X and Y dimensions respectfully. If a 3rd length is given it is interpreted as the standard deviation of the Gaussian blur used on the shadow - so a larger value will blur the shadow more. Read more about the arguments inDropShadowValue.
- grayscale: Converts theViewtograyscaleby the specified amount. Takes a non-negative number or percentage, where1or100%represents complete grayscale.
- hueRotate: Changes thehueof the View. The argument of this function defines the angle of a color wheel around which the hue will be rotated, so e.g.,360degwould have no effect. This angle can have eitherdegorradunits.
- invert: Inverts the colors in theView. Takes a non-negative number or percentage, where1or100%represents complete inversion.
- sepia: Converts theViewtosepia. Takes a non-negative number or percentage, where1or100%represents complete sepia.
- saturate: Changes thesaturationof theView. Takes a non-negative number or percentage.
bluranddropShadoware only supported onAndroid 12+

filtertakes either an array of objects comprising of the above filter functions or a string which mimics theweb syntax.


### mixBlendMode
mixBlendModeis only available on theNew Architecture

Controls how theViewblends its colors with the other elements in itsstacking context. Check out theMDN documentationfor a full overview of each blending function.

For more granular control over what should be blending together seeisolation.

- normal: The element is drawn on top of its background without blending.
- multiply: The source color is multiplied by the destination color and replaces the destination.
- screen: Multiplies the complements of the backdrop and source color values, then complements the result.
- overlay: Multiplies or screens the colors, depending on the backdrop color value.
- darken: Selects the darker of the backdrop and source colors.
- lighten: Selects the lighter of the backdrop and source colors.
- color-dodge: Brightens the backdrop color to reflect the source color. Painting with black produces no changes.
- color-burn: Darkens the backdrop color to reflect the source color. Painting with white produces no change.
- hard-light: Multiplies or screens the colors, depending on the source color value. The effect is similar to shining a harsh spotlight on the backdrop.
- soft-light: Darkens or lightens the colors, depending on the source color value. The effect is similar to shining a diffused spotlight on the backdrop.
- difference: Subtracts the darker of the two constituent colors from the lighter color.
- exclusion: Produces an effect similar to that of the Difference mode but lower in contrast.
- hue: Creates a color with the hue of the source color and the saturation and luminosity of the backdrop color.
- saturation: Creates a color with the saturation of the source color and the hue and luminosity of the backdrop color.
- color: Creates a color with the hue and saturation of the source color and the luminosity of the backdrop color. This preserves the gray levels of the backdrop and is useful for coloring monochrome images or tinting color images.
- luminosity: Creates a color with the luminosity of the source color and the hue and saturation of the backdrop color. This produces an inverse effect to that of the Color mode.

### opacity

### outlineColor
outlineColoris only available on theNew Architecture

Sets the color of an element's outline. Seeweb documentationfor more details.


### outlineOffset
outlineOffsetis only available on theNew Architecture

Sets the amount of space between an outline and the bounds of an element. Does not affect layout. Seeweb documentationfor more details.


### outlineStyle
outlineStyleis only available on theNew Architecture

Sets the style of an element's outline. Seeweb documentationfor more details.


### outlineWidth
outlineWidthis only available on theNew Architecture

The width of an outline which is drawn around an element, outside the border. Does not affect layout. Seeweb documentationfor more details.


### pointerEvents
Controls whether theViewcan be the target of touch events.

- 'auto': The View can be the target of touch events.
- 'none': The View is never the target of touch events.
- 'box-none': The View is never the target of touch events but its subviews can be.
- 'box-only': The view can be the target of touch events but its subviews cannot be.

================================================================================


# ViewToken Object Type
Source: https://reactnative.dev/docs/viewtoken

ViewTokenobject is returned as one of the properties in theonViewableItemsChangedcallback (for example, in theFlatListcomponent). It is exported byViewabilityHelper.js.


## Example
```
{  item: {key: "key-12"},  key: "key-12",  index: 11,  isViewable: true}
```


## Keys and values

### index
Unique numeric identifier assigned to the data element.


### isViewable
Specifies if at least some part of list element is visible in the viewport.


### item
Item data


### key
Key identifier assigned to the data element extracted to the top level.


### section
Item section data when used withSectionList.


## Used by
- FlatList
- SectionList
- VirtualizedList

================================================================================


# VirtualizedList
Source: https://reactnative.dev/docs/virtualizedlist

Base implementation for the more convenient<FlatList>and<SectionList>components, which are also better documented. In general, this should only really be used if you need more flexibility thanFlatListprovides, e.g. for use with immutable data instead of plain arrays.

Virtualization massively improves memory consumption and performance of large lists by maintaining a finite render window of active items and replacing all items outside of the render window with appropriately sized blank space. The window adapts to scrolling behavior, and items are rendered incrementally with low-pri (after any running interactions) if they are far from the visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.


## Example
- TypeScriptJavaScript
- JavaScript
Some caveats:

- Internal state is not preserved when content scrolls out of the render window. Make sure all your data is captured in the item data or external stores like Flux, Redux, or Relay.
- This is aPureComponentwhich means that it will not re-render ifpropsare shallow-equal. Make sure that everything yourrenderItemfunction depends on is passed as a prop (e.g.extraData) that is not===after updates, otherwise your UI may not update on changes. This includes thedataprop and parent component state.
- In order to constrain memory and enable smooth scrolling, content is rendered asynchronously offscreen. This means it's possible to scroll faster than the fill rate and momentarily see blank content. This is a tradeoff that can be adjusted to suit the needs of each application, and we are working on improving it behind the scenes.
- By default, the list looks for akeyprop on each item and uses that for the React key. Alternatively, you can provide a customkeyExtractorprop.

## Props

### ScrollView Props
InheritsScrollView Props.


### data
Opaque data type passed togetItemandgetItemCountto retrieve items.


### RequiredgetItem
```
(data: any, index: number) => any;
```

A generic accessor for extracting an item from any sort of data blob.


### RequiredgetItemCount
```
(data: any) => number;
```

Determines how many items are in the data blob.


### RequiredrenderItem
```
(info: any) => ?React.Element<any>
```

Takes an item fromdataand renders it into the list


### CellRendererComponent
CellRendererComponent allows customizing how cells rendered byrenderItem/ListItemComponentare wrapped when placed into the underlying ScrollView. This component must accept event handlers which notify VirtualizedList of changes within the cell.


### ItemSeparatorComponent
Rendered in between each item, but not at the top or bottom. By default,highlightedandleadingItemprops are provided.renderItemprovidesseparators.highlight/unhighlightwhich will update thehighlightedprop, but you can also add custom props withseparators.updateProps. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListEmptyComponent
Rendered when the list is empty. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListItemComponent
Each data item is rendered using this element. Can be a React Component Class, or a render function.


### ListFooterComponent
Rendered at the bottom of all the items. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListFooterComponentStyle
Styling for internal View forListFooterComponent.


### ListHeaderComponent
Rendered at the top of all the items. Can be a React Component (e.g.SomeComponent), or a React element (e.g.<SomeComponent />).


### ListHeaderComponentStyle
Styling for internal View forListHeaderComponent.


### debug
debugwill turn on extra logging and visual overlays to aid with debugging both usage and implementation, but with a significant perf hit.


### 🗑️disableVirtualization
Virtualization provides significant performance and memory optimizations, but fully unmounts react instances that are outside of the render window. You should only need to disable this for debugging purposes.


### extraData
A marker property for telling the list to re-render (since it implementsPureComponent). If any of yourrenderItem, Header, Footer, etc. functions depend on anything outside of thedataprop, stick it here and treat it immutably.


### getItemLayout
```
(  data: any,  index: number,) => {length: number, offset: number, index: number}
```


### horizontal
Iftrue, renders items next to each other horizontally instead of stacked vertically.


### initialNumToRender
How many items to render in the initial batch. This should be enough to fill the screen but not much more. Note these items will never be unmounted as part of the windowed rendering in order to improve perceived performance of scroll-to-top actions.


### initialScrollIndex
Instead of starting at the top with the first item, start atinitialScrollIndex. This disables the "scroll to top" optimization that keeps the firstinitialNumToRenderitems always rendered and immediately renders the items starting at this initial index. RequiresgetItemLayoutto be implemented.


### inverted
Reverses the direction of scroll. Uses scale transforms of-1.


### keyExtractor
```
(item: any, index: number) => string;
```

Used to extract a unique key for a given item at the specified index. Key is used for caching and as the react key to track item re-ordering. The default extractor checksitem.key, thenitem.id, and then falls back to using the index, like React does.


### maxToRenderPerBatch
The maximum number of items to render in each incremental render batch. The more rendered at once, the better the fill rate, but responsiveness may suffer because rendering content may interfere with responding to button taps or other interactions.


### onEndReached
Called once when the scroll position gets withinonEndReachedThresholdfrom the logical end of the list.


### onEndReachedThreshold
How far from the end (in units of visible length of the list) the trailing edge of the list must be from the end of the content to trigger theonEndReachedcallback. Thus, a value of 0.5 will triggeronEndReachedwhen the end of the content is within half the visible length of the list.


### onRefresh
```
() => void;
```

If provided, a standardRefreshControlwill be added for "Pull to Refresh" functionality. Make sure to also set therefreshingprop correctly.


### onScrollToIndexFailed
```
(info: {  index: number,  highestMeasuredFrameIndex: number,  averageItemLength: number,}) => void;
```

Used to handle failures when scrolling to an index that has not been measured yet. Recommended action is to either compute your own offset andscrollToit, or scroll as far as possible and then try again after more items have been rendered.


### onStartReached
Called once when the scroll position gets withinonStartReachedThresholdfrom the logical start of the list.


### onStartReachedThreshold
How far from the start (in units of visible length of the list) the leading edge of the list must be from the start of the content to trigger theonStartReachedcallback. Thus, a value of 0.5 will triggeronStartReachedwhen the start of the content is within half the visible length of the list.


### onViewableItemsChanged
Called when the viewability of rows changes, as defined by theviewabilityConfigprop.


### persistentScrollbar

### progressViewOffset
Set this when offset is needed for the loading indicator to show correctly.


### refreshControl
A custom refresh control element. When set, it overrides the default<RefreshControl>component built internally. The onRefresh and refreshing props are also ignored. Only works for vertical VirtualizedList.


### refreshing
Set this true while waiting for new data from a refresh.


### removeClippedSubviews
Using this property may lead to bugs (missing content) in some circumstances - use at your own risk.

Whentrue, offscreen child views are removed from their native backing superview when offscreen. This may improve scroll performance for large lists. On Android the default value istrue.


### renderScrollComponent
```
(props: object) => element;
```

Render a custom scroll component, e.g. with a differently styledRefreshControl.


### viewabilityConfig
SeeViewabilityHelper.jsfor flow type and further documentation.


### viewabilityConfigCallbackPairs
List ofViewabilityConfig/onViewableItemsChangedpairs. A specificonViewableItemsChangedwill be called when its correspondingViewabilityConfig's conditions are met. SeeViewabilityHelper.jsfor flow type and further documentation.


### updateCellsBatchingPeriod
Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off screen. Similar fill rate/responsiveness tradeoff asmaxToRenderPerBatch.


### windowSize
Determines the maximum number of items rendered outside of the visible area, in units of visible lengths. So if your list fills the screen, thenwindowSize={21}(the default) will render the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing this number will reduce memory consumption and may improve performance, but will increase the chance that fast scrolling may reveal momentary blank areas of unrendered content.


## Methods

### flashScrollIndicators()
```
flashScrollIndicators();
```


### getScrollableNode()
```
getScrollableNode(): any;
```


### getScrollRef()
```
getScrollRef():  | React.ElementRef<typeof ScrollView>  | React.ElementRef<typeof View>  | null;
```


### getScrollResponder()
```
getScrollResponder () => ScrollResponderMixin | null;
```

Provides a handle to the underlying scroll responder. Note thatthis._scrollRefmight not be aScrollView, so we need to check that it responds togetScrollResponderbefore calling it.


### scrollToEnd()
```
scrollToEnd(params?: {animated?: boolean});
```

Scrolls to the end of the content. May be janky withoutgetItemLayoutprop.

Parameters:

Validparamskeys are:

- 'animated'(boolean) - Whether the list should do an animation while scrolling. Defaults totrue.

### scrollToIndex()
```
scrollToIndex(params: {  index: number;  animated?: boolean;  viewOffset?: number;  viewPosition?: number;});
```

Validparamsconsist of:

- 'index' (number). Required.
- 'animated' (boolean). Optional.
- 'viewOffset' (number). Optional.
- 'viewPosition' (number). Optional.

### scrollToItem()
```
scrollToItem(params: {  item: ItemT;  animated?: boolean;  viewOffset?: number;  viewPosition?: number;);
```

Validparamsconsist of:

- 'item' (Item). Required.
- 'animated' (boolean). Optional.
- 'viewOffset' (number). Optional.
- 'viewPosition' (number). Optional.

### scrollToOffset()
```
scrollToOffset(params: {  offset: number;  animated?: boolean;});
```

Scroll to a specific content pixel offset in the list.

Paramoffsetexpects the offset to scroll to. In case ofhorizontalis true, the offset is the x-value, in any other case the offset is the y-value.

Paramanimated(trueby default) defines whether the list should do an animation while scrolling.


================================================================================


# VirtualView 🧪
Source: https://reactnative.dev/docs/virtualview

This API is experimental.Experimental APIs may contain bugs and are likely to change in a future version of React Native. Don't use them in production.

VirtualViewis a core component that behaves similar toView.

When it is the descendent of aScrollView, it gains additional virtualization capabilities to reduce its memory footprint when obscured by the scroll viewport.

```
<ScrollView>  <VirtualView>    <Text>Hello world!</Text>  </VirtualView></ScrollView>
```

AVirtualViewwithout an ancestorScrollViewdoes not have any virtualization capabilities.


## Virtualization
When aVirtualViewleaves the visible region of aScrollView, it becomes hidden. When hidden, aVirtualViewwill cache its most recent layout and may unmount its children — a process called virtualization.

When aVirtualViewreturns to the visible region of aScrollView, it becomes visible. When visible, its children areguaranteedto be rendered. This guarantee is maintained by blocking the main thread from rendering the next frame that would reveal theVirtualViewuntil its children can be rendered.

In future developments, a hiddenVirtualViewmay instead render its children in an<Activity mode="hidden">to preserve state for as long as possible while balancing memory overhead.


### Blocking the Main Thread
This is the first time in React Native’s feature set where rendering a React component can block the main thread. This is a new capability enabled by theNew Architecture!

Blocking the main thread can provide a better user experience by preventing flashes of blank frames that sometimes occur when using components likeFlatList. It can also enable better performance by using main thread priority, which is also typically run on higher performance cores.

However, blocking the main thread also comes with tradeoffs. If an update operation, such as mounting the children of aVirtualView, takes too long to finish, it can now drop frames. Dropping more than a couple frames can lead to a worse user experience by making the app feel sluggish and non-responsive. Dropping too many frames may cause the operating system to display a modal indicating the app is not responsive, or it may even terminate your app!

DevTools does not currently support debugging JavaScript on the main thread. This means if you are using breakpoints to debug code called fromonModeChange, that is executed on the main thread, your debugger may freeze.Debugging all other parts of your JavaScript code should work as expected. We are working on closing this gap before releasingVirtualViewto stable channels of React Native.

Debugging all other parts of your JavaScript code should work as expected. We are working on closing this gap before releasingVirtualViewto stable channels of React Native.


### Prerendering
VirtualViewenables you to benefit from main thread rendering while mitigating the disadvantages of dropped frames by rendering earlier before it is needed. This is called “prerendering”.

By default, eachVirtualViewwill prerender its children when it approaches the visible region of aScrollView. When this happens, its children will be rendered on a background thread at a lower priority (using atransition). This ensures that the main thread and React are available to handle other critical user interactions at a higher priority.

VirtualView's prerender logic is not currently configurable. The algorithm for determining this is undergoing active design iteration and is likely to change in a future release.


## Props

### children
Content to render inside thisVirtualView.


### onModeChange
Invoked when theVirtualViewchanges how it renders its children.

If a callback is supplied, it may be invoked from different threads and priorities depending on the internal state change. This can be detected by checking themodeproperty on the event:

- IfmodeisVirtualViewMode.Visible, the callback is being invoked from the main thread with immediate priority.
- IfmodeisVirtualViewMode.PrerenderorVirtualViewMode.Hidden, the callback is being invoked from a background thread with transition priority.
The callback will never be invoked consecutively with the samemodevalue. However, there are few guarantees about sequencing of events. Also, the callback may never be invoked withVirtualViewMode.Visibleeven if it becomes visible, if the children were successfully prerendered.


### nativeID
An identifier for locating this view from native classes.


### style

## Type Definitions

### ModeChangeEvent
Argument supplied toonModeChange.

Properties:

For example, if aVirtualViewenters the visible region of aScrollView...modewould beVirtualViewMode.VisiblethresholdRectwould describe the visible viewport of the nearest ancestorScrollViewtargetRectwould be the layout oftargetthat overlaps withthresholdRect(i.e. it is within the visible region of theScrollView)

- modewould beVirtualViewMode.Visible
- thresholdRectwould describe the visible viewport of the nearest ancestorScrollView
- targetRectwould be the layout oftargetthat overlaps withthresholdRect(i.e. it is within the visible region of theScrollView)

### VirtualViewMode
Possible modes of aVirtualView.


## Static Methods

### createHiddenVirtualView()
```
static createHiddenVirtualView(height: number): typeof VirtualView;
```

VirtualViewinitially renders its children as visible, even if it is initially obscured by an ancestorScrollView. This is because when a component is initially rendered, the presence of an ancestorScrollView— let alone its size and scroll position — are unknown.

For advanced use cases,createHiddenVirtualView()creates a component that renders an initially hiddenVirtualViewwith the supplied estimated layout.

```
const HiddenVirtualView = createHiddenVirtualView(100);<ScrollView>  <HiddenVirtualView>    <Text>Hello world!</Text>  </HiddenVirtualView></ScrollView>;
```

Parameters:


================================================================================
